[{"filePath":"D:\\src\\Edison\\src\\services\\adaptive-stop-loss.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'calculateStopLoss' has a complexity of 12. Maximum allowed is 10.","line":87,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":155,"endColumn":4},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentPrice' is defined but never used. Allowed unused args must match /^_/u.","line":91,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":122,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":122,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4244,4250],"text":"result != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":170,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":170,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6116,6141],"text":"(structure.liquidityZones == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":181,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":181,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6608,6623],"text":"(zone.sweepCount != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6608,6623],"text":"(zone.sweepCount ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6608,6623],"text":"(Boolean(zone.sweepCount))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":217,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":217,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7643,7665],"text":"(structure.orderBlocks == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.0.","line":236,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":236,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":263,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":263,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9022,9044],"text":"(structure.swingPoints == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 86400000.","line":275,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":275,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.0.","line":293,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":293,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":319,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":319,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10849,10877],"text":"(structure.supportResistance == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":329,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":329,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.0.","line":349,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":349,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":375,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":375,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12688,12702],"text":"(structure.atr == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12689,12702],"text":"(structure.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12688,12702],"text":"(!Boolean(structure.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":380,"column":72,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":75},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":388,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":388,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":422,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":422,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14293,14297],"text":"(atr == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14294,14297],"text":"(atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14293,14297],"text":"(!Boolean(atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Adaptive Stop Loss Service (Phase 3)\r\n *\r\n * Multi-factor stop loss placement based on market structure.\r\n * Priority order: SWEEP > ORDER_BLOCK > SWING > LEVEL > ATR > PERCENT\r\n *\r\n * Why adaptive SL is better:\r\n * - Structure-based SL (sweeps, OBs, swings) respects market mechanics\r\n * - Prevents tight SL that gets swept by MM algos\r\n * - Reduces \"fake-out\" stop-outs on local wicks\r\n * - Better R/R ratio (wider but smarter placement)\r\n *\r\n * Example:\r\n * Entry: 1.2000 LONG\r\n * - Swing low: 1.1950 (recent swing)\r\n * - ATR SL: 1.1920 (1.5x ATR)\r\n * - Result: SL @ 1.1945 (swing - 0.3 ATR buffer) âœ…\r\n * - Why: Respects structure + small buffer for noise\r\n */\r\n\r\nimport {\r\n  AdaptiveStopLossConfig,\r\n  StopLossCalculation,\r\n  StopLossType,\r\n  LoggerService,\r\n  SignalDirection,\r\n  SwingPoint,\r\n  SwingPointType,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BUFFER_MIN = 0.0001; // Minimum buffer (0.01%)\r\nconst BUFFER_MAX = 0.005; // Maximum buffer (0.5%)\r\n\r\n// ============================================================================\r\n// INTERFACES\r\n// ============================================================================\r\n\r\ninterface MarketStructure {\r\n  swingPoints?: SwingPoint[];\r\n  liquidityZones?: Array<{\r\n    price: number;\r\n    type: 'BUY_SIDE' | 'SELL_SIDE';\r\n    timestamp: number;\r\n    sweepCount?: number;\r\n  }>;\r\n  orderBlocks?: Array<{ price: number; strength: number }>;\r\n  supportResistance?: Array<{ price: number; strength: number; touches: number }>;\r\n  atr?: number;\r\n}\r\n\r\n// ============================================================================\r\n// ADAPTIVE STOP LOSS SERVICE\r\n// ============================================================================\r\n\r\nexport class AdaptiveStopLossService {\r\n  constructor(\r\n    private config: AdaptiveStopLossConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('AdaptiveStopLossService initialized', {\r\n      enabled: config.enabled,\r\n      priorityOrder: config.priorityOrder,\r\n      bufferMultiplier: config.bufferMultiplier,\r\n      minDistance: `${config.minDistancePercent}%`,\r\n      maxDistance: `${config.maxDistancePercent}%`,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate optimal stop loss based on market structure\r\n   *\r\n   * @param entryPrice Entry price\r\n   * @param direction Trade direction (LONG/SHORT)\r\n   * @param structure Market structure data (swings, zones, levels, etc)\r\n   * @param currentPrice Current market price (for validation)\r\n   * @returns Stop loss calculation with reasoning\r\n   */\r\n  calculateStopLoss(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n    currentPrice: number,\r\n  ): StopLossCalculation {\r\n    if (!this.config.enabled) {\r\n      return this.fallbackPercentSL(entryPrice, direction, 'Adaptive SL disabled');\r\n    }\r\n\r\n    // Try each method in priority order\r\n    for (const type of this.config.priorityOrder) {\r\n      let result: StopLossCalculation | null = null;\r\n\r\n      switch (type) {\r\n      case StopLossType.SWEEP:\r\n        result = this.calculateSweepBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.ORDER_BLOCK:\r\n        result = this.calculateOrderBlockBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.SWING:\r\n        result = this.calculateSwingBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.LEVEL:\r\n        result = this.calculateLevelBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.ATR:\r\n        result = this.calculateATRBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.PERCENT:\r\n        result = this.fallbackPercentSL(entryPrice, direction, 'Fallback to fixed percent');\r\n        break;\r\n      }\r\n\r\n      if (result) {\r\n        // Validate distance\r\n        const distancePercent = Math.abs((result.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n\r\n        if (distancePercent < this.config.minDistancePercent) {\r\n          this.logger.debug(`${type} SL too tight: ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}%`, {\r\n            minRequired: this.config.minDistancePercent,\r\n          });\r\n          continue; // Try next method\r\n        }\r\n\r\n        if (distancePercent > this.config.maxDistancePercent) {\r\n          this.logger.debug(`${type} SL too wide: ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}%`, {\r\n            maxAllowed: this.config.maxDistancePercent,\r\n          });\r\n          continue; // Try next method\r\n        }\r\n\r\n        // Valid SL found\r\n        result.distancePercent = distancePercent;\r\n        this.logger.info(`âœ… Adaptive SL selected: ${type}`, {\r\n          slPrice: result.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          distance: `${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n          reason: result.reason,\r\n        });\r\n\r\n        return result;\r\n      }\r\n    }\r\n\r\n    // All methods failed - use emergency fallback\r\n    this.logger.warn('âš ï¸ All adaptive SL methods failed - using emergency fallback');\r\n    return this.fallbackPercentSL(entryPrice, direction, 'Emergency fallback (all methods failed)');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: SL CALCULATION METHODS (Priority Order)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * 1. SWEEP-BASED SL (Highest Priority)\r\n   * Place SL beyond recent liquidity sweep to avoid re-sweep\r\n   */\r\n  private calculateSweepBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.liquidityZones || structure.liquidityZones.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Find recent sweep zone on opposite side\r\n    const recentSweeps = structure.liquidityZones\r\n      .filter((zone) => {\r\n        const isOpposite = isLong ? zone.type === 'SELL_SIDE' : zone.type === 'BUY_SIDE';\r\n        const isRecent = Date.now() - zone.timestamp < TIME_UNITS.HOUR; // Last 1 hour\r\n        const hasBeenSwept = zone.sweepCount && zone.sweepCount > 0;\r\n        return isOpposite && isRecent && hasBeenSwept;\r\n      })\r\n      .sort((a, b) => b.timestamp - a.timestamp);\r\n\r\n    if (recentSweeps.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const sweepZone = recentSweeps[0];\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n\r\n    // Place SL beyond sweep with buffer\r\n    const slPrice = isLong\r\n      ? sweepZone.price - buffer\r\n      : sweepZone.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.SWEEP,\r\n      price: slPrice,\r\n      distancePercent: 0, // Will be calculated in main method\r\n      reason: `Beyond liquidity sweep @ ${sweepZone.price.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      structurePrice: sweepZone.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 2. ORDER BLOCK-BASED SL\r\n   * Place SL beyond order block that caused reversal\r\n   */\r\n  private calculateOrderBlockBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.orderBlocks || structure.orderBlocks.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Find strongest OB below/above entry\r\n    const relevantOBs = structure.orderBlocks\r\n      .filter((ob) => (isLong ? ob.price < entryPrice : ob.price > entryPrice))\r\n      .sort((a, b) => b.strength - a.strength);\r\n\r\n    if (relevantOBs.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const ob = relevantOBs[0];\r\n\r\n    // OB should be within reasonable distance\r\n    const obDistance = Math.abs((ob.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n    if (obDistance > 3.0) {\r\n      // OB too far\r\n      return null;\r\n    }\r\n\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n    const slPrice = isLong ? ob.price - buffer : ob.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.ORDER_BLOCK,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `Beyond order block @ ${ob.price.toFixed(DECIMAL_PLACES.PRICE)} (strength: ${ob.strength.toFixed(DECIMAL_PLACES.PERCENT)})`,\r\n      structurePrice: ob.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 3. SWING-BASED SL\r\n   * Place SL beyond recent swing low/high\r\n   */\r\n  private calculateSwingBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.swingPoints || structure.swingPoints.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const targetType = isLong ? SwingPointType.LOW : SwingPointType.HIGH;\r\n\r\n    // Find nearest swing point of correct type\r\n    const relevantSwings = structure.swingPoints\r\n      .filter((sp) => {\r\n        const correctType = sp.type === targetType;\r\n        const correctSide = isLong ? sp.price < entryPrice : sp.price > entryPrice;\r\n        const notTooOld = Date.now() - sp.timestamp < 86400000; // Last 24h\r\n        return correctType && correctSide && notTooOld;\r\n      })\r\n      .sort((a, b) => {\r\n        // Prefer closer swing points\r\n        const distA = Math.abs(a.price - entryPrice);\r\n        const distB = Math.abs(b.price - entryPrice);\r\n        return distA - distB;\r\n      });\r\n\r\n    if (relevantSwings.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const swing = relevantSwings[0];\r\n\r\n    // Swing should be within reasonable distance\r\n    const swingDistance = Math.abs((swing.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n    if (swingDistance > 4.0) {\r\n      return null;\r\n    }\r\n\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n    const slPrice = isLong ? swing.price - buffer : swing.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.SWING,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `Beyond swing ${targetType.toLowerCase()} @ ${swing.price.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      structurePrice: swing.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 4. LEVEL-BASED SL\r\n   * Place SL beyond support/resistance level\r\n   */\r\n  private calculateLevelBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.supportResistance || structure.supportResistance.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Find nearest strong level on correct side\r\n    const relevantLevels = structure.supportResistance\r\n      .filter((level) => {\r\n        const correctSide = isLong ? level.price < entryPrice : level.price > entryPrice;\r\n        const strongEnough = level.touches >= 2 && level.strength >= MULTIPLIERS.HALF;\r\n        return correctSide && strongEnough;\r\n      })\r\n      .sort((a, b) => {\r\n        // Prefer closer + stronger\r\n        const distA = Math.abs(a.price - entryPrice);\r\n        const distB = Math.abs(b.price - entryPrice);\r\n        const scoreA = a.strength / distA;\r\n        const scoreB = b.strength / distB;\r\n        return scoreB - scoreA;\r\n      });\r\n\r\n    if (relevantLevels.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const level = relevantLevels[0];\r\n\r\n    // Level should be within reasonable distance\r\n    const levelDistance = Math.abs((level.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n    if (levelDistance > 3.0) {\r\n      return null;\r\n    }\r\n\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n    const slPrice = isLong ? level.price - buffer : level.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.LEVEL,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `Beyond ${isLong ? 'support' : 'resistance'} @ ${level.price.toFixed(DECIMAL_PLACES.PRICE)} (${level.touches} touches)`,\r\n      structurePrice: level.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 5. ATR-BASED SL (Fallback)\r\n   * Standard ATR-based stop loss\r\n   */\r\n  private calculateATRBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.atr || structure.atr <= 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const atrDistance = structure.atr * this.config.bufferMultiplier * 1.5; // 1.5x ATR default\r\n\r\n    const slPrice = isLong ? entryPrice - atrDistance : entryPrice + atrDistance;\r\n\r\n    return {\r\n      type: StopLossType.ATR,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `ATR-based (${this.config.bufferMultiplier * 1.5}x ATR = ${atrDistance.toFixed(DECIMAL_PLACES.PRICE)})`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 6. PERCENT-BASED SL (Emergency Fallback)\r\n   * Fixed percentage stop loss when all else fails\r\n   */\r\n  private fallbackPercentSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    reason: string,\r\n  ): StopLossCalculation {\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const distance = (this.config.fallbackPercent / PERCENT_MULTIPLIER) * entryPrice;\r\n    const slPrice = isLong ? entryPrice - distance : entryPrice + distance;\r\n\r\n    return {\r\n      type: StopLossType.PERCENT,\r\n      price: slPrice,\r\n      distancePercent: this.config.fallbackPercent,\r\n      reason: `Fixed ${this.config.fallbackPercent}% (${reason})`,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate buffer size based on ATR\r\n   * Buffer prevents SL from being exactly at structure (prone to false triggers)\r\n   */\r\n  private calculateBuffer(atr?: number): number {\r\n    if (!atr || atr <= 0) {\r\n      return BUFFER_MIN;\r\n    }\r\n\r\n    const buffer = atr * this.config.bufferMultiplier;\r\n\r\n    // Clamp to min/max\r\n    return Math.max(BUFFER_MIN, Math.min(BUFFER_MAX, buffer));\r\n  }\r\n\r\n  /**\r\n   * Get config (for testing/monitoring)\r\n   */\r\n  getConfig(): AdaptiveStopLossConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\adaptive-tp3.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'checkExtension' has a complexity of 11. Maximum allowed is 10.","line":102,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":183,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":114,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":114,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3834,3840],"text":"state == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":154,"column":22,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":154,"endColumn":46,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[5309,5315],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":194,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":194,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6669,6675],"text":"state == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":228,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":228,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7784,7790],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":245,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":245,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8392,8397],"text":"(state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":260,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":260,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[8735,8752],"text":"((state?.maxReached) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[8735,8752],"text":"((state?.maxReached) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":260,"column":30,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":260,"endColumn":32,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8753,8755],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":268,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":268,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8914,8919],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Adaptive TP3 Service (Phase 3)\r\n *\r\n * Dynamically extends TP3 when strong momentum continues after TP2.\r\n * Base TP3: 2.0%\r\n * Extension: +0.5% per tick (max 3 ticks = +1.5%)\r\n * Max TP3: 3.5%\r\n *\r\n * Why adaptive TP3 is better:\r\n * - Captures more profit on strong trends (don't leave money on table)\r\n * - Only extends when momentum confirmed (volume + EMA + no reversal)\r\n * - Protects with trailing stop (if TP3 not hit, trailing captures)\r\n *\r\n * Example:\r\n * TP2 hit @ +1.0%, momentum strong:\r\n * - Tick 1: TP3 @ +2.0% â†’ +2.5% (not hit, continue)\r\n * - Tick 2: TP3 @ +2.5% â†’ +3.0% (not hit, continue)\r\n * - Tick 3: TP3 @ +3.0% â†’ +3.5% (MAX, no more extension)\r\n * - Result: TP3 hit @ +3.2% instead of +2.0% = +60% more profit! âœ…\r\n */\r\n\r\nimport {\r\n  AdaptiveTP3Config,\r\n  LoggerService,\r\n  Position,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// INTERFACES\r\n// ============================================================================\r\n\r\ninterface TP3State {\r\n  baseTp3Percent: number; // Original TP3 target\r\n  currentTp3Percent: number; // Current TP3 target (extended)\r\n  ticksApplied: number; // How many extension ticks applied\r\n  lastExtensionTime: number; // Timestamp of last extension\r\n  maxReached: boolean; // Max ticks reached\r\n}\r\n\r\n// ============================================================================\r\n// ADAPTIVE TP3 SERVICE\r\n// ============================================================================\r\n\r\nexport class AdaptiveTP3Service {\r\n  private states: Map<string, TP3State> = new Map();\r\n\r\n  constructor(\r\n    private config: AdaptiveTP3Config,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('AdaptiveTP3Service initialized', {\r\n      enabled: config.enabled,\r\n      baseTP3: config.baseTP3Percent + '%',\r\n      tickSize: config.tickSizePercent + '%',\r\n      maxTicks: config.maxTicks,\r\n      maxExtension: (config.tickSizePercent * config.maxTicks).toFixed(1) + '%',\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Initialize TP3 state after TP2 hit\r\n   *\r\n   * @param positionId Position ID\r\n   * @param baseTP3Percent Base TP3 target (e.g., 2.0%)\r\n   */\r\n  initialize(positionId: string, baseTP3Percent: number): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.states.set(positionId, {\r\n      baseTp3Percent: baseTP3Percent,\r\n      currentTp3Percent: baseTP3Percent,\r\n      ticksApplied: 0,\r\n      lastExtensionTime: Date.now(),\r\n      maxReached: false,\r\n    });\r\n\r\n    this.logger.info('ðŸ“Š Adaptive TP3 initialized', {\r\n      positionId,\r\n      baseTP3: baseTP3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      maxPossible: (baseTP3Percent + this.config.tickSizePercent * this.config.maxTicks).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if should extend TP3 (call this on candle close)\r\n   *\r\n   * Conditions for extension:\r\n   * 1. TP3 not hit yet (price hasn't reached current TP3)\r\n   * 2. Strong momentum continues (volume + EMA angle)\r\n   * 3. No reversal signals (price still trending)\r\n   * 4. Max ticks not reached\r\n   *\r\n   * @returns { shouldExtend, newTP3Percent, reason }\r\n   */\r\n  checkExtension(\r\n    position: Position,\r\n    currentPrice: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number, // EMA slope in degrees\r\n  ): { shouldExtend: boolean; newTP3Percent?: number; reason: string } {\r\n    if (!this.config.enabled) {\r\n      return { shouldExtend: false, reason: 'Adaptive TP3 disabled' };\r\n    }\r\n\r\n    const state = this.states.get(position.id);\r\n    if (!state) {\r\n      return { shouldExtend: false, reason: 'Not initialized' };\r\n    }\r\n\r\n    // Check if max ticks reached\r\n    if (state.maxReached || state.ticksApplied >= this.config.maxTicks) {\r\n      state.maxReached = true;\r\n      return { shouldExtend: false, reason: 'Max ticks reached' };\r\n    }\r\n\r\n    // Calculate current profit percent\r\n    const profitPercent = this.calculateProfitPercent(position, currentPrice);\r\n\r\n    // Check if TP3 already hit\r\n    if (profitPercent >= state.currentTp3Percent) {\r\n      return { shouldExtend: false, reason: 'TP3 already hit' };\r\n    }\r\n\r\n    // Check momentum conditions\r\n\r\n    // 1. Volume elevated\r\n    const volumeRatio = currentVolume / avgVolume;\r\n    if (volumeRatio < this.config.momentumThreshold.volumeMultiplier) {\r\n      return {\r\n        shouldExtend: false,\r\n        reason: `Volume too low: ${volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x < ${this.config.momentumThreshold.volumeMultiplier}x`,\r\n      };\r\n    }\r\n\r\n    // 2. EMA angle steep (momentum)\r\n    const absAngle = Math.abs(emaAngle);\r\n    if (absAngle < this.config.momentumThreshold.emaAngle) {\r\n      return {\r\n        shouldExtend: false,\r\n        reason: `EMA angle too flat: ${absAngle.toFixed(DECIMAL_PLACES.PERCENT)}Â° < ${this.config.momentumThreshold.emaAngle}Â°`,\r\n      };\r\n    }\r\n\r\n    // 3. No reversal (price still trending in correct direction)\r\n    if (this.config.momentumThreshold.noReversal) {\r\n      const isLong = position.side === 'LONG';\r\n      const profitDirection = profitPercent > 0;\r\n      const expectedDirection = isLong;\r\n\r\n      if (profitDirection !== expectedDirection) {\r\n        return {\r\n          shouldExtend: false,\r\n          reason: 'Price reversed direction',\r\n        };\r\n      }\r\n\r\n      // Check if profit is increasing (not stalling)\r\n      const minProfitForExtension = state.currentTp3Percent - this.config.tickSizePercent;\r\n      if (profitPercent < minProfitForExtension) {\r\n        return {\r\n          shouldExtend: false,\r\n          reason: `Profit stalling: ${profitPercent.toFixed(DECIMAL_PLACES.PERCENT)}% < ${minProfitForExtension.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // All checks passed - extend TP3!\r\n    const newTP3Percent = state.currentTp3Percent + this.config.tickSizePercent;\r\n\r\n    return {\r\n      shouldExtend: true,\r\n      newTP3Percent,\r\n      reason: `Momentum strong: ${volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x vol, ${absAngle.toFixed(DECIMAL_PLACES.PERCENT)}Â° EMA`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extend TP3 by one tick\r\n   *\r\n   * @param positionId Position ID\r\n   * @param newTP3Price New TP3 price (from exchange/position manager)\r\n   * @returns Updated TP3 percent\r\n   */\r\n  extendTP3(positionId: string, newTP3Price: number): number | null {\r\n    const state = this.states.get(positionId);\r\n    if (!state) {\r\n      return null;\r\n    }\r\n\r\n    const newPercent = state.currentTp3Percent + this.config.tickSizePercent;\r\n\r\n    state.currentTp3Percent = newPercent;\r\n    state.ticksApplied++;\r\n    state.lastExtensionTime = Date.now();\r\n\r\n    if (state.ticksApplied >= this.config.maxTicks) {\r\n      state.maxReached = true;\r\n    }\r\n\r\n    this.logger.info('ðŸ“ˆ TP3 extended!', {\r\n      positionId,\r\n      oldTP3: (state.currentTp3Percent - this.config.tickSizePercent).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      newTP3: newPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      ticksApplied: state.ticksApplied,\r\n      maxTicks: this.config.maxTicks,\r\n      newPrice: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    return newPercent;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate current profit percent\r\n   */\r\n  private calculateProfitPercent(position: Position, currentPrice: number): number {\r\n    const isLong = position.side === 'LONG';\r\n    if (isLong) {\r\n      return ((currentPrice - position.entryPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    } else {\r\n      return ((position.entryPrice - currentPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC: STATE MANAGEMENT\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get current TP3 target\r\n   */\r\n  getCurrentTP3Percent(positionId: string): number | null {\r\n    const state = this.states.get(positionId);\r\n    return state ? state.currentTp3Percent : null;\r\n  }\r\n\r\n  /**\r\n   * Get TP3 state\r\n   */\r\n  getState(positionId: string): TP3State | undefined {\r\n    return this.states.get(positionId);\r\n  }\r\n\r\n  /**\r\n   * Check if max extension reached\r\n   */\r\n  isMaxReached(positionId: string): boolean {\r\n    const state = this.states.get(positionId);\r\n    return state?.maxReached || false;\r\n  }\r\n\r\n  /**\r\n   * Reset state (position closed)\r\n   */\r\n  reset(positionId: string): void {\r\n    const state = this.states.get(positionId);\r\n    if (state) {\r\n      this.logger.debug('Resetting TP3 state', {\r\n        positionId,\r\n        finalTP3: state.currentTp3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        ticksApplied: state.ticksApplied,\r\n      });\r\n    }\r\n    this.states.delete(positionId);\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): AdaptiveTP3Config {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\auxiliary-data-logger.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":37,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":37,"endColumn":39,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1240,1270],"text":"(this.config.orderBook?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1240,1270],"text":"(this.config.orderBook?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":46,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":46,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1511,1538],"text":"(this.config.volume?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1511,1538],"text":"(this.config.volume?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":63,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":63,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2020,2043],"text":"(this.orderBookAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":63,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":63,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2047,2067],"text":"(this.volumeAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":69,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":69,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2152,2174],"text":"(this.orderBookAnalyzer != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":69,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":69,"endColumn":58,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2178,2199],"text":"(this.config.orderBook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":78,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":78,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2390,2409],"text":"(this.volumeAnalyzer != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":78,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":78,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2413,2431],"text":"(this.config.volume != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":100,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":100,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2998,3021],"text":"(this.orderBookAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":100,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":100,"endColumn":58,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3025,3047],"text":"(this.config.orderBook == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":143,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":143,"endColumn":12},{"ruleId":"complexity","severity":1,"message":"Async method 'logVolume' has a complexity of 12. Maximum allowed is 10.","line":165,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":236,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":169,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":169,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5278,5298],"text":"(this.volumeAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":169,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":169,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5302,5321],"text":"(this.config.volume == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":179,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":179,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6059,6077],"text":"(volumeAnalysis.poc != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":205,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":205,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":224,"column":83,"nodeType":"Literal","messageId":"noMagic","endLine":224,"endColumn":86}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Auxiliary Data Logger Service\r\n *\r\n * Logs OrderBook and Volume data for informational purposes.\r\n * Does NOT affect signal generation decisions - logging only!\r\n *\r\n * Extracted from SignalGeneratorService for better testability.\r\n */\r\n\r\nimport {\r\n  SignalDirection,\r\n  Config,\r\n  TimeframeRole,\r\n  LoggerService,\r\n} from '../types';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { VolumeAnalyzer } from '../analyzers/volume.analyzer';\r\nimport { BybitService } from './bybit';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\n\r\n// ============================================================================\r\n// AUXILIARY DATA LOGGER SERVICE\r\n// ============================================================================\r\n\r\nexport class AuxiliaryDataLogger {\r\n  private orderBookAnalyzer: OrderBookAnalyzer | null = null;\r\n  private volumeAnalyzer: VolumeAnalyzer | null = null;\r\n\r\n  constructor(\r\n    private bybitService: BybitService,\r\n    private candleProvider: CandleProvider,\r\n    private config: Config,\r\n    private logger: LoggerService,\r\n  ) {\r\n    // Initialize OrderBook analyzer if enabled\r\n    if (this.config.orderBook?.enabled) {\r\n      this.orderBookAnalyzer = new OrderBookAnalyzer(\r\n        this.config.orderBook,\r\n        this.logger,\r\n      );\r\n      this.logger.info('OrderBook logging enabled');\r\n    }\r\n\r\n    // Initialize Volume analyzer if enabled\r\n    if (this.config.volume?.enabled) {\r\n      this.volumeAnalyzer = new VolumeAnalyzer(\r\n        this.config.volume,\r\n        this.logger,\r\n      );\r\n      this.logger.info('Volume logging enabled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log OrderBook and Volume analysis (non-blocking)\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction\r\n   */\r\n  async logAnalysis(currentPrice: number, direction: SignalDirection): Promise<void> {\r\n    // Skip if both analyzers disabled\r\n    if (!this.orderBookAnalyzer && !this.volumeAnalyzer) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Log OrderBook if enabled\r\n      if (this.orderBookAnalyzer && this.config.orderBook) {\r\n        await this.logOrderBook(\r\n          this.config.exchange.symbol,\r\n          currentPrice,\r\n          direction,\r\n        );\r\n      }\r\n\r\n      // Log Volume if enabled\r\n      if (this.volumeAnalyzer && this.config.volume) {\r\n        await this.logVolume(currentPrice, direction);\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to log auxiliary data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log OrderBook analysis\r\n   *\r\n   * @param symbol - Trading symbol\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction\r\n   */\r\n  private async logOrderBook(\r\n    symbol: string,\r\n    currentPrice: number,\r\n    direction: SignalDirection,\r\n  ): Promise<void> {\r\n    if (!this.orderBookAnalyzer || !this.config.orderBook) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.debug('Fetching order book...');\r\n\r\n      const orderBookData = await this.bybitService.getOrderBook(\r\n        symbol,\r\n        this.config.orderBook.depth,\r\n      );\r\n\r\n      const orderBookAnalysis = this.orderBookAnalyzer.analyze(\r\n        {\r\n          bids: orderBookData.bids,\r\n          asks: orderBookData.asks,\r\n          timestamp: orderBookData.timestamp,\r\n        },\r\n        currentPrice,\r\n      );\r\n\r\n      // Log summary\r\n      const summary = this.orderBookAnalyzer.getSummary(orderBookAnalysis);\r\n      this.logger.info('ðŸ“Š OrderBook Analysis', { summary });\r\n\r\n      // Log detailed analysis\r\n      this.logger.debug('OrderBook details', {\r\n        imbalance: {\r\n          direction: orderBookAnalysis.imbalance.direction,\r\n          ratio: orderBookAnalysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n          strength: `${(orderBookAnalysis.imbalance.strength * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          bidVolume: orderBookAnalysis.imbalance.bidVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n          askVolume: orderBookAnalysis.imbalance.askVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n        },\r\n        walls: orderBookAnalysis.walls.length,\r\n        spread: `${orderBookAnalysis.spread.toFixed(DECIMAL_PLACES.PRICE)}%`,\r\n        depth: `${orderBookAnalysis.depth.bid} bids / ${orderBookAnalysis.depth.ask} asks`,\r\n      });\r\n\r\n      // Check for blocking walls (info only)\r\n      const hasWall = this.orderBookAnalyzer.hasBlockingWall(\r\n        orderBookAnalysis,\r\n        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',\r\n        2.0,\r\n      );\r\n\r\n      if (hasWall) {\r\n        this.logger.info('âš ï¸ OrderBook wall detected in path', {\r\n          direction,\r\n          distance: '< 2%',\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to log OrderBook', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log Volume analysis\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction\r\n   */\r\n  private async logVolume(\r\n    currentPrice: number,\r\n    direction: SignalDirection,\r\n  ): Promise<void> {\r\n    if (!this.volumeAnalyzer || !this.config.volume) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.debug('Analyzing volume profile...');\r\n\r\n      // Get PRIMARY candles for volume analysis\r\n      const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n\r\n      if (!primaryCandles || primaryCandles.length === 0) {\r\n        this.logger.warn('No candles available for volume analysis');\r\n        return;\r\n      }\r\n\r\n      const volumeAnalysis = this.volumeAnalyzer.analyze(primaryCandles, currentPrice);\r\n\r\n      // Log summary\r\n      const summary = this.volumeAnalyzer.getSummary(volumeAnalysis);\r\n      this.logger.info('ðŸ“ˆ Volume Analysis', { summary });\r\n\r\n      // Log detailed analysis\r\n      this.logger.debug('Volume details', {\r\n        poc: volumeAnalysis.poc\r\n          ? `${volumeAnalysis.poc.price.toFixed(DECIMAL_PLACES.PERCENT)} (${volumeAnalysis.poc.volume.toFixed(0)})`\r\n          : 'N/A',\r\n        hvns: volumeAnalysis.hvns.length,\r\n        lvns: volumeAnalysis.lvns.length,\r\n        totalVolume: volumeAnalysis.totalVolume.toFixed(0),\r\n        avgVolume: volumeAnalysis.avgVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Check for blocking HVNs (info only)\r\n      const hasHVN = this.volumeAnalyzer.hasBlockingHVN(\r\n        volumeAnalysis,\r\n        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',\r\n        2.0,\r\n      );\r\n\r\n      if (hasHVN) {\r\n        this.logger.info('âš ï¸ High Volume Node detected in path', {\r\n          direction,\r\n          distance: '< 2%',\r\n        });\r\n      }\r\n\r\n      // Check if in LVN (weak zone)\r\n      const inLVN = this.volumeAnalyzer.isInLVN(volumeAnalysis, currentPrice);\r\n      if (inLVN) {\r\n        this.logger.info('ðŸ“ Current price is in Low Volume Node (weak zone)', {\r\n          price: currentPrice,\r\n        });\r\n      }\r\n\r\n      // Check if near POC\r\n      const nearPOC = this.volumeAnalyzer.isNearPOC(volumeAnalysis, currentPrice, 0.5);\r\n      if (nearPOC) {\r\n        this.logger.info('ðŸ“ Current price is near Point of Control', {\r\n          price: currentPrice,\r\n          poc: volumeAnalysis.poc?.price.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to log Volume', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\blocking-rules.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MAX_DISTANCE_TO_EMA_PERCENT' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":28,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'COOLDOWN_PERIOD_MS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES_5M' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES_30M' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES_1H' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'VOLUME_MIN_MULTIPLIER_TREND' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'VOLUME_MIN_MULTIPLIER_LEVEL' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_DROP_FROM_ATH_FOR_LONG' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":37,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":33},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'checkBlockingRules' has no 'await' expression.","line":93,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":93,"endColumn":27},{"ruleId":"complexity","severity":1,"message":"Async method 'checkBlockingRules' has a complexity of 13. Maximum allowed is 10.","line":93,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":156,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":239,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":239,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":267,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":267,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -3.","line":272,"column":41,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":272,"endColumn":43}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Blocking Rules Service\r\n *\r\n * Centralized blocking rules for all strategies.\r\n * Philosophy: \"Better to miss a good trade than take a bad trade\"\r\n *\r\n * Global Blocks (apply to ALL strategies):\r\n * - GLOBAL_1: Insufficient data\r\n * - GLOBAL_2: EMA distance > 5.5% (falling knife / blow-off top)\r\n * - GLOBAL_3: Active positions limit (max 1)\r\n * - GLOBAL_4: Cooldown period (10 sec between signals)\r\n *\r\n * Additional Blocks:\r\n * - Volume blocks (low liquidity)\r\n * - Wick blocks (rejection candles)\r\n * - ATH protection (buying tops)\r\n */\r\n\r\nimport { SignalDirection, Candle, LoggerService } from '../types';\r\nimport { VolumeCalculator } from '../analyzers/volume.calculator';\r\nimport { WickAnalyzer } from '../analyzers/wick.analyzer';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_DISTANCE_TO_EMA_PERCENT = 5.5; // GLOBAL_2\r\nconst COOLDOWN_PERIOD_MS = 10000; // GLOBAL_4: 10 seconds\r\nconst MIN_CANDLES_5M = 100; // GLOBAL_1\r\nconst MIN_CANDLES_30M = CONFIDENCE_THRESHOLDS.MODERATE; // GLOBAL_1\r\nconst MIN_CANDLES_1H = CONFIDENCE_THRESHOLDS.MODERATE; // GLOBAL_1\r\n\r\nconst VOLUME_MIN_MULTIPLIER_TREND = MULTIPLIERS.HALF; // Trend-Following\r\nconst VOLUME_MIN_MULTIPLIER_LEVEL = 0.3; // Level-Based\r\n\r\nconst MIN_DROP_FROM_ATH_FOR_LONG = 0.2; // ATH protection (%)\r\nconst CANDLES_FOR_24H_HIGH = 288; // 24h at 5m intervals\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface BlockingRulesConfig {\r\n  maxDistanceToEmaPercent: number; // GLOBAL_2\r\n  cooldownPeriodMs: number; // GLOBAL_4\r\n  minCandles5m: number; // GLOBAL_1\r\n  volumeMinMultiplierTrend: number;\r\n  volumeMinMultiplierLevel: number;\r\n  minDropFromAthForLong: number; // ATH protection\r\n  enableAthProtection: boolean; // ATH protection toggle\r\n  enableVolumeChecks: boolean; // Volume checks toggle\r\n  enableWickChecks: boolean; // Wick checks toggle\r\n}\r\n\r\nexport interface BlockingContext {\r\n  direction: SignalDirection;\r\n  strategy: 'TrendFollowing' | 'LevelBased' | 'CounterTrend';\r\n  candles: Candle[];\r\n  currentPrice: number;\r\n  ema50: number;\r\n  rsi?: number;\r\n  hasActivePosition: boolean;\r\n  lastSignalTime: number;\r\n}\r\n\r\nexport interface BlockingResult {\r\n  blocked: boolean;\r\n  reason?: string;\r\n  blockId?: string;\r\n}\r\n\r\n// ============================================================================\r\n// BLOCKING RULES SERVICE\r\n// ============================================================================\r\n\r\nexport class BlockingRulesService {\r\n  private volumeCalculator: VolumeCalculator;\r\n  private wickAnalyzer: WickAnalyzer;\r\n\r\n  constructor(\r\n    private config: BlockingRulesConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.volumeCalculator = new VolumeCalculator(logger);\r\n    this.wickAnalyzer = new WickAnalyzer(logger);\r\n  }\r\n\r\n  /**\r\n   * Check all blocking rules for a signal\r\n   * Returns blocked=true if ANY rule blocks the signal\r\n   */\r\n  async checkBlockingRules(context: BlockingContext): Promise<BlockingResult> {\r\n    // ========================================================================\r\n    // GLOBAL BLOCKS (apply to ALL strategies)\r\n    // ========================================================================\r\n\r\n    // GLOBAL_1: Insufficient data\r\n    const insufficientDataBlock = this.checkInsufficientData(context.candles);\r\n    if (insufficientDataBlock.blocked) {\r\n      return insufficientDataBlock;\r\n    }\r\n\r\n    // GLOBAL_2: EMA distance > 5.5%\r\n    const emaDistanceBlock = this.checkEmaDistance(context.currentPrice, context.ema50);\r\n    if (emaDistanceBlock.blocked) {\r\n      return emaDistanceBlock;\r\n    }\r\n\r\n    // GLOBAL_3: Active positions limit\r\n    const activePositionBlock = this.checkActivePositionLimit(context.hasActivePosition);\r\n    if (activePositionBlock.blocked) {\r\n      return activePositionBlock;\r\n    }\r\n\r\n    // GLOBAL_4: Cooldown period\r\n    const cooldownBlock = this.checkCooldownPeriod(context.lastSignalTime);\r\n    if (cooldownBlock.blocked) {\r\n      return cooldownBlock;\r\n    }\r\n\r\n    // ========================================================================\r\n    // STRATEGY-SPECIFIC BLOCKS\r\n    // ========================================================================\r\n\r\n    // Volume checks (if enabled)\r\n    if (this.config.enableVolumeChecks) {\r\n      const volumeBlock = this.checkVolume(context.candles, context.strategy);\r\n      if (volumeBlock.blocked) {\r\n        return volumeBlock;\r\n      }\r\n    }\r\n\r\n    // Wick checks (if enabled)\r\n    if (this.config.enableWickChecks) {\r\n      const wickBlock = this.checkWicks(context.candles, context.direction);\r\n      if (wickBlock.blocked) {\r\n        return wickBlock;\r\n      }\r\n    }\r\n\r\n    // ATH protection (if enabled, LONG only, Trend-Following only)\r\n    if (\r\n      this.config.enableAthProtection &&\r\n      context.direction === SignalDirection.LONG &&\r\n      context.strategy === 'TrendFollowing'\r\n    ) {\r\n      const athBlock = this.checkAthProtection(context.candles, context.currentPrice);\r\n      if (athBlock.blocked) {\r\n        return athBlock;\r\n      }\r\n    }\r\n\r\n    // No blocks triggered\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_1: Check for insufficient data\r\n   */\r\n  private checkInsufficientData(candles: Candle[]): BlockingResult {\r\n    if (candles.length < this.config.minCandles5m) {\r\n      this.logger.warn('[BlockingRules] GLOBAL_1: Insufficient data', {\r\n        candles: candles.length,\r\n        required: this.config.minCandles5m,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_1',\r\n        reason: `Insufficient data: ${candles.length} < ${this.config.minCandles5m} candles`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_2: Check EMA distance > 5.5%\r\n   * Most effective blocking rule (prevented 15+ losses in backtests)\r\n   */\r\n  private checkEmaDistance(price: number, ema50: number): BlockingResult {\r\n    const distancePercent = Math.abs((price - ema50) / ema50) * PERCENT_MULTIPLIER;\r\n\r\n    if (distancePercent > this.config.maxDistanceToEmaPercent) {\r\n      this.logger.warn('[BlockingRules] GLOBAL_2: EMA distance too far', {\r\n        distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        max: this.config.maxDistanceToEmaPercent,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_2',\r\n        reason: `EMA distance ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}% > ${this.config.maxDistanceToEmaPercent}% (falling knife / blow-off top)`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_3: Check active positions limit (max 1)\r\n   */\r\n  private checkActivePositionLimit(hasActivePosition: boolean): BlockingResult {\r\n    if (hasActivePosition) {\r\n      this.logger.warn('[BlockingRules] GLOBAL_3: Active position exists');\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_3',\r\n        reason: 'Active position exists (max 1 position limit)',\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_4: Check cooldown period (10 sec between signals)\r\n   */\r\n  private checkCooldownPeriod(lastSignalTime: number): BlockingResult {\r\n    const now = Date.now();\r\n    const timeSinceLastSignal = now - lastSignalTime;\r\n\r\n    if (timeSinceLastSignal < this.config.cooldownPeriodMs) {\r\n      this.logger.debug('[BlockingRules] GLOBAL_4: Cooldown period active', {\r\n        timeSince: timeSinceLastSignal,\r\n        required: this.config.cooldownPeriodMs,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_4',\r\n        reason: `Cooldown period active (${timeSinceLastSignal}ms < ${this.config.cooldownPeriodMs}ms)`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * VOL_TREND_1 / VOL_LEVEL_1: Check volume\r\n   */\r\n  private checkVolume(candles: Candle[], strategy: string): BlockingResult {\r\n    const volumeAnalysis = this.volumeCalculator.calculate(candles);\r\n\r\n    if (!volumeAnalysis || volumeAnalysis.avgVolume === 0) {\r\n      return { blocked: false }; // No volume data, skip check\r\n    }\r\n\r\n    const threshold =\r\n      strategy === 'LevelBased'\r\n        ? this.config.volumeMinMultiplierLevel\r\n        : this.config.volumeMinMultiplierTrend;\r\n\r\n    if (volumeAnalysis.isLowVolume && volumeAnalysis.volumeRatio < threshold) {\r\n      this.logger.warn('[BlockingRules] VOL: Low volume', {\r\n        strategy,\r\n        ratio: volumeAnalysis.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        threshold,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: strategy === 'LevelBased' ? 'VOL_LEVEL_1' : 'VOL_TREND_1',\r\n        reason: `Low volume: ${volumeAnalysis.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x < ${threshold}x (low liquidity risk)`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * WICK_LONG / WICK_SHORT: Check for large wicks (rejection candles)\r\n   */\r\n  private checkWicks(candles: Candle[], direction: SignalDirection): BlockingResult {\r\n    if (candles.length < 3) {\r\n      return { blocked: false }; // Not enough candles to check\r\n    }\r\n\r\n    // Check last 3 candles\r\n    const recentCandles = candles.slice(-3);\r\n\r\n    for (const candle of recentCandles) {\r\n      const wickAnalysis = this.wickAnalyzer.analyze(candle);\r\n\r\n      if (wickAnalysis.hasLargeWick) {\r\n        const blocks = this.wickAnalyzer.blocksSignal(wickAnalysis, direction);\r\n        if (blocks) {\r\n          this.logger.warn('[BlockingRules] WICK: Large wick detected', {\r\n            direction,\r\n            wickDirection: wickAnalysis.wickDirection,\r\n          });\r\n          return {\r\n            blocked: true,\r\n            blockId: direction === SignalDirection.LONG ? 'WICK_LONG' : 'WICK_SHORT',\r\n            reason: `Large ${wickAnalysis.wickDirection} wick detected (rejection candle)`,\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * ATH_LONG: Check ATH protection (avoid buying tops)\r\n   * Only for LONG signals in Trend-Following strategy\r\n   */\r\n  private checkAthProtection(candles: Candle[], currentPrice: number): BlockingResult {\r\n    if (candles.length < CANDLES_FOR_24H_HIGH) {\r\n      return { blocked: false }; // Not enough data for 24h high\r\n    }\r\n\r\n    // Get 24h high (last 288 candles at 5m)\r\n    const last24hCandles = candles.slice(-CANDLES_FOR_24H_HIGH);\r\n    const high24h = Math.max(...last24hCandles.map((c) => c.high));\r\n\r\n    // Calculate drop from high\r\n    const dropFromHighPercent = ((high24h - currentPrice) / high24h) * PERCENT_MULTIPLIER;\r\n\r\n    if (dropFromHighPercent < this.config.minDropFromAthForLong) {\r\n      this.logger.warn('[BlockingRules] ATH_LONG: Too close to ATH', {\r\n        dropFromHigh: dropFromHighPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        min: this.config.minDropFromAthForLong,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'ATH_LONG',\r\n        reason: `Too close to ATH: drop ${dropFromHighPercent.toFixed(DECIMAL_PLACES.PERCENT)}% < ${this.config.minDropFromAthForLong}% (buying the top risk)`,\r\n      };\r\n    }\r\n\r\n    return { blocked: false };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\bybit\\bybit-base.partial.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":82,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":82,"endColumn":81},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":93,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":93,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":96,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":96,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":131,"column":55,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":131,"endColumn":76},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":136,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":136,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[4978,5011],"text":"((instrument.lotSizeFilter?.qtyStep).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[4978,5011],"text":"((instrument.lotSizeFilter?.qtyStep) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4978,5011],"text":"(Boolean((instrument.lotSizeFilter?.qtyStep)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":137,"column":24,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":137,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[5047,5079],"text":"((instrument.priceFilter?.tickSize).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[5047,5079],"text":"((instrument.priceFilter?.tickSize) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5047,5079],"text":"(Boolean((instrument.priceFilter?.tickSize)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":138,"column":27,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":138,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[5120,5157],"text":"((instrument.lotSizeFilter?.minOrderQty).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[5120,5157],"text":"((instrument.lotSizeFilter?.minOrderQty) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5120,5157],"text":"(Boolean((instrument.lotSizeFilter?.minOrderQty)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":159,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":159,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5571,5584],"text":"(this.qtyStep == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5572,5584],"text":"(this.qtyStep ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5571,5584],"text":"(!Boolean(this.qtyStep))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":159,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":159,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5588,5602],"text":"(this.tickSize == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5589,5602],"text":"(this.tickSize ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5588,5602],"text":"(!Boolean(this.tickSize))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":159,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":159,"endColumn":61,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5606,5623],"text":"(this.minOrderQty == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5607,5623],"text":"(this.minOrderQty ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5606,5623],"text":"(!Boolean(this.minOrderQty))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":214,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":214,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7428,7440],"text":"(this.qtyStep != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7428,7440],"text":"(this.qtyStep ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7428,7440],"text":"(Boolean(this.qtyStep))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":214,"column":31,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":214,"endColumn":33,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7441,7443],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":219,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":219,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[7637,7655],"text":"(step.split('.')[1].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[7637,7655],"text":"(step.split('.')[1] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7637,7655],"text":"(Boolean(step.split('.')[1]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":245,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":245,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8405,8418],"text":"(this.tickSize != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8405,8418],"text":"(this.tickSize ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8405,8418],"text":"(Boolean(this.tickSize))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":245,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":245,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8419,8421],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":250,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":250,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[8595,8613],"text":"(tick.split('.')[1].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[8595,8613],"text":"(tick.split('.')[1] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8595,8613],"text":"(Boolean(tick.split('.')[1]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Bybit Base Partial - Shared Utilities\r\n *\r\n * Provides common functionality used by all Bybit partial classes:\r\n * - Symbol precision management (qtyStep, tickSize)\r\n * - Retry logic with exponential backoff\r\n * - Rounding utilities (quantity, price)\r\n * - Error handling\r\n * - Constants\r\n */\r\n\r\nimport { RestClientV5 } from 'bybit-api';\r\nimport { LoggerService } from '../../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nexport const RECV_WINDOW = 20000; // Increased from 5000 to handle clock drift\r\nexport const MAX_RETRIES = 3;\r\nexport const RETRY_DELAY_MS = 1000;\r\nexport const RETRY_BACKOFF_MULTIPLIER = 2;\r\nexport const DEFAULT_CANDLE_LIMIT = 200;\r\nexport const POSITION_SIZE_ZERO = 0;\r\nexport const BYBIT_SUCCESS_CODE = 0;\r\nexport const BYBIT_NOT_MODIFIED_CODE = 34039; // \"order not modified\" - price already at target\r\nexport const BYBIT_ORDER_STATUS_CODE = 34040; // \"order does not exist or status does not support modification\"\r\nexport const BYBIT_ORDER_NOT_EXISTS_CODE = 110001; // \"order not exists or too late to cancel\"\r\nexport const BYBIT_ZERO_POSITION_CODE = 10001; // \"can not set tp/sl/ts for zero position\"\r\nexport const POSITION_IDX_ONE_WAY = 0;\r\nexport const PERCENT_TO_DECIMAL = 100;\r\n\r\n// ============================================================================\r\n// BYBIT BASE PARTIAL\r\n// ============================================================================\r\n\r\nexport class BybitBase {\r\n  protected readonly restClient: RestClientV5;\r\n  protected readonly symbol: string;\r\n  protected readonly timeframe: string;\r\n  protected readonly logger: LoggerService;\r\n  protected readonly demo: boolean;\r\n\r\n  // Symbol precision parameters (loaded from exchange)\r\n  protected qtyStep: string | null = null;\r\n  protected tickSize: string | null = null;\r\n  protected minOrderQty: string | null = null;\r\n\r\n  // Time synchronization (stored offset: local - server)\r\n  protected timeOffsetMs: number = 0;\r\n\r\n  constructor(\r\n    restClient: RestClientV5,\r\n    symbol: string,\r\n    timeframe: string,\r\n    logger: LoggerService,\r\n    demo: boolean,\r\n  ) {\r\n    this.restClient = restClient;\r\n    this.symbol = symbol;\r\n    this.timeframe = timeframe;\r\n    this.logger = logger;\r\n    this.demo = demo;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // INITIALIZATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Initialize service - load symbol precision parameters\r\n   * Must be called after construction, before trading\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.logger.info('Initializing BybitService - loading symbol info...');\r\n\r\n    // Sync time with Bybit server to prevent timestamp errors\r\n    this.logger.info('Synchronizing time with exchange...');\r\n    try {\r\n      const serverTimeResponse = await this.restClient.getServerTime();\r\n      if (serverTimeResponse.retCode === BYBIT_SUCCESS_CODE) {\r\n        const serverTime = parseInt(serverTimeResponse.result.timeSecond) * 1000;\r\n        const localTime = Date.now();\r\n        const timeDrift = localTime - serverTime;\r\n\r\n        // Store time offset (positive = local clock is ahead)\r\n        this.timeOffsetMs = timeDrift;\r\n\r\n        this.logger.info('Time synchronized with Bybit server', {\r\n          serverTime,\r\n          localTime,\r\n          offsetMs: this.timeOffsetMs,\r\n          offsetOk: Math.abs(this.timeOffsetMs) < 500,\r\n        });\r\n\r\n        if (Math.abs(this.timeOffsetMs) > 500) {\r\n          this.logger.warn('âš ï¸ Clock drift detected - applying offset correction', {\r\n            offsetMs: this.timeOffsetMs,\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to sync time, continuing without sync', {\r\n        error: String(error),\r\n      });\r\n    }\r\n\r\n    const symbolInfo = await this.getSymbolInfo();\r\n    this.qtyStep = symbolInfo.qtyStep;\r\n    this.tickSize = symbolInfo.tickSize;\r\n    this.minOrderQty = symbolInfo.minOrderQty;\r\n\r\n    this.logger.info('Symbol precision loaded', {\r\n      symbol: this.symbol,\r\n      qtyStep: this.qtyStep,\r\n      tickSize: this.tickSize,\r\n      minOrderQty: this.minOrderQty,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get symbol trading parameters from exchange\r\n   */\r\n  private async getSymbolInfo(): Promise<{ qtyStep: string; tickSize: string; minOrderQty: string }> {\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getInstrumentsInfo({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE || !response.result?.list || response.result.list.length === 0) {\r\n        throw new Error(`Failed to get symbol info for ${this.symbol}: ${response.retMsg}`);\r\n      }\r\n\r\n      const instrument = response.result.list[0];\r\n      const qtyStep = instrument.lotSizeFilter?.qtyStep || '0.01';\r\n      const tickSize = instrument.priceFilter?.tickSize || '0.0001';\r\n      const minOrderQty = instrument.lotSizeFilter?.minOrderQty || '0.01';\r\n\r\n      this.logger.debug('Symbol info received', {\r\n        symbol: this.symbol,\r\n        qtyStep,\r\n        tickSize,\r\n        minOrderQty,\r\n      });\r\n\r\n      return { qtyStep, tickSize, minOrderQty };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get exchange limits for position calculations\r\n   */\r\n  getExchangeLimits(): {\r\n    qtyStep: string;\r\n    tickSize: string;\r\n    minOrderQty: string;\r\n    } {\r\n    if (!this.qtyStep || !this.tickSize || !this.minOrderQty) {\r\n      throw new Error('Exchange limits not initialized - call initialize() first');\r\n    }\r\n\r\n    return {\r\n      qtyStep: this.qtyStep,\r\n      tickSize: this.tickSize,\r\n      minOrderQty: this.minOrderQty,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set precision parameters (for sharing between instances)\r\n   * Used by BybitService to share precision data from base instance to partial instances\r\n   */\r\n  setPrecision(qtyStep: string, tickSize: string, minOrderQty: string): void {\r\n    this.qtyStep = qtyStep;\r\n    this.tickSize = tickSize;\r\n    this.minOrderQty = minOrderQty;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC GETTERS (for external services)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get RestClient instance\r\n   * Made public for LimitOrderExecutorService (Phase 2)\r\n   */\r\n  public getRestClient(): RestClientV5 {\r\n    return this.restClient;\r\n  }\r\n\r\n  /**\r\n   * Get trading symbol\r\n   * Made public for LimitOrderExecutorService (Phase 2)\r\n   */\r\n  public getSymbol(): string {\r\n    return this.symbol;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ROUNDING UTILITIES\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Round quantity to qtyStep precision\r\n   * Example: qty=99.8901, qtyStep=0.01 => 99.89\r\n   *\r\n   * NOTE: This method is DEPRECATED - use PositionCalculatorService instead!\r\n   * Kept only for backward compatibility with existing code (BybitOrders, BybitPositions).\r\n   * Made public for LimitOrderExecutorService (Phase 2).\r\n   */\r\n  public roundQuantity(qty: number): string {\r\n    // Fallback for backward compatibility (e.g., emergency protection calls)\r\n    const step = this.qtyStep || '0.1';\r\n    const stepNum = parseFloat(step);\r\n    const rounded = Math.floor(qty / stepNum) * stepNum;\r\n\r\n    // Format to match step precision (count decimals in step)\r\n    const decimals = (step.split('.')[1] || '').length;\r\n    const result = rounded.toFixed(decimals);\r\n\r\n    this.logger.debug('ðŸ”¢ roundQuantity (DEPRECATED)', {\r\n      input: qty,\r\n      qtyStep: step,\r\n      stepNum,\r\n      rounded,\r\n      decimals,\r\n      result,\r\n      qtyStepLoaded: this.qtyStep !== null,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Round price to tickSize precision\r\n   * Example: price=1.00249, tickSize=0.0001 => 1.0024\r\n   *\r\n   * NOTE: This method is DEPRECATED - use PositionCalculatorService instead!\r\n   * Kept only for backward compatibility with existing code (BybitOrders).\r\n   * Made public for LimitOrderExecutorService (Phase 2).\r\n   */\r\n  public roundPrice(price: number): string {\r\n    // Fallback for backward compatibility\r\n    const tick = this.tickSize || '0.0001';\r\n    const tickNum = parseFloat(tick);\r\n    const rounded = Math.floor(price / tickNum) * tickNum;\r\n\r\n    // Format to match tick precision\r\n    const decimals = (tick.split('.')[1] || '').length;\r\n    return rounded.toFixed(decimals);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // BALANCE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get USDT balance\r\n   */\r\n  async getBalance(): Promise<number> {\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getWalletBalance({\r\n        accountType: 'UNIFIED',\r\n        coin: 'USDT',\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const coins = response.result.list[0]?.coin;\r\n      if (coins === undefined || coins.length === 0) {\r\n        throw new Error('USDT balance not found');\r\n      }\r\n\r\n      const usdtCoin = coins.find((c) => c.coin === 'USDT');\r\n      if (usdtCoin === undefined) {\r\n        throw new Error('USDT not found in wallet');\r\n      }\r\n\r\n      return parseFloat(usdtCoin.walletBalance);\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // RETRY LOGIC\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Retry logic with exponential backoff\r\n   */\r\n  protected async retry<T>(fn: () => Promise<T>): Promise<T> {\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\r\n      try {\r\n        return await fn();\r\n      } catch (error) {\r\n        lastError = this.handleError(error);\r\n\r\n        // Don't retry on auth errors\r\n        if (lastError.message.includes('auth') || lastError.message.includes('API key')) {\r\n          throw lastError;\r\n        }\r\n\r\n        // Wait before retry (exponential backoff)\r\n        if (attempt < MAX_RETRIES - 1) {\r\n          const delay = RETRY_DELAY_MS * Math.pow(RETRY_BACKOFF_MULTIPLIER, attempt);\r\n          this.logger.warn(`Retry attempt ${attempt + 1}/${MAX_RETRIES}`, { delay, error: lastError.message });\r\n          await this.sleep(delay);\r\n        }\r\n      }\r\n    }\r\n\r\n    throw new Error(`Failed after ${MAX_RETRIES} retries: ${lastError?.message ?? 'Unknown error'}`);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ERROR HANDLING\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Handle and format errors\r\n   */\r\n  protected handleError(error: unknown): Error {\r\n    if (error instanceof Error) {\r\n      return error;\r\n    }\r\n\r\n    return new Error(`Unknown error: ${String(error)}`);\r\n  }\r\n\r\n  /**\r\n   * Get corrected timestamp for Bybit API requests\r\n   * Applies time offset to prevent timestamp errors\r\n   */\r\n  protected getCorrectedTimestamp(): number {\r\n    return Date.now() - this.timeOffsetMs;\r\n  }\r\n\r\n  /**\r\n   * Sleep helper\r\n   */\r\n  protected sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\bybit\\bybit-market-data.partial.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":48,"column":19,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":48,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1709,1717],"text":"(interval != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1709,1717],"text":"(interval ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1709,1717],"text":"(Boolean(interval))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":48,"column":28,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":48,"endColumn":30,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1718,1720],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":49,"column":21,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":49,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1758,1763],"text":"(limit != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1758,1763],"text":"(limit ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1758,1763],"text":"(Boolean(limit))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":49,"column":27,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":49,"endColumn":29,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1764,1766],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":75,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":75,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":76,"column":26,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":76,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":86,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":97,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":97,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":98,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":98,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":99,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":99,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":106,"column":26,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":106,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[3778,3792],"text":"((klines[0]?.[0]).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[3778,3792],"text":"((klines[0]?.[0]) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3778,3792],"text":"(Boolean((klines[0]?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":107,"column":25,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":107,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[3876,3906],"text":"((klines[klines.length - 1]?.[0]).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[3876,3906],"text":"((klines[klines.length - 1]?.[0]) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3876,3906],"text":"(Boolean((klines[klines.length - 1]?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":203,"column":26,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":203,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7082,7088],"text":"(symbol != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7082,7088],"text":"(symbol ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7082,7088],"text":"(Boolean(symbol))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":203,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":203,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7089,7091],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":217,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":217,"endColumn":23},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":217,"column":28,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":217,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":255,"column":26,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":255,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8651,8657],"text":"(symbol != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8651,8657],"text":"(symbol ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8651,8657],"text":"(Boolean(symbol))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":255,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":255,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8658,8660],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":269,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":269,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 8.","line":281,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":281,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":281,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":281,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":281,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":281,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":281,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":281,"endColumn":71},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `never`.","line":282,"column":13,"nodeType":"MemberExpression","messageId":"invalid","endLine":282,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 8.","line":282,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":282,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":282,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":282,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":282,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":282,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":282,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":282,"endColumn":61}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Bybit Market Data Partial\r\n *\r\n * Handles public market data operations (no authentication required):\r\n * - Historical candles (OHLCV)\r\n * - Current price\r\n * - Server time\r\n * - Order book depth\r\n */\r\n\r\nimport type { KlineIntervalV3 } from 'bybit-api';\r\nimport { Candle, CONFIDENCE_THRESHOLDS } from '../../types';\r\nimport { BybitBase, BYBIT_SUCCESS_CODE, DEFAULT_CANDLE_LIMIT } from './bybit-base.partial';\r\n\r\n// ============================================================================\r\n// BYBIT MARKET DATA PARTIAL\r\n// ============================================================================\r\n\r\nexport class BybitMarketData extends BybitBase {\r\n  // ==========================================================================\r\n  // CANDLES\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get historical candles (OHLCV data)\r\n   * @param symbolOrLimit - Symbol name OR limit number (for backward compatibility)\r\n   * @param interval - Interval (e.g., \"1\", \"5\", \"60\")\r\n   * @param limit - Number of candles to fetch\r\n   */\r\n  async getCandles(\r\n    symbolOrLimit: string | number = DEFAULT_CANDLE_LIMIT,\r\n    interval?: string,\r\n    limit?: number,\r\n  ): Promise<Candle[]> {\r\n    // Backward compatibility: if first arg is number, use old behavior\r\n    let symbol: string;\r\n    let timeframe: string;\r\n    let candleLimit: number;\r\n\r\n    if (typeof symbolOrLimit === 'number') {\r\n      // Old behavior: getCandles(limit)\r\n      symbol = this.symbol;\r\n      timeframe = this.timeframe;\r\n      candleLimit = symbolOrLimit;\r\n    } else {\r\n      // New behavior: getCandles(symbol, interval, limit)\r\n      symbol = symbolOrLimit;\r\n      timeframe = interval || this.timeframe;\r\n      candleLimit = limit || DEFAULT_CANDLE_LIMIT;\r\n    }\r\n\r\n    return await this.retry(async () => {\r\n      this.logger.info('ðŸ•¯ï¸ Requesting candles from Bybit', {\r\n        symbol,\r\n        interval: timeframe,\r\n        limit: candleLimit,\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n\r\n      const requestParams = {\r\n        category: 'linear' as const,\r\n        symbol,\r\n        interval: timeframe as KlineIntervalV3,\r\n        limit: candleLimit,\r\n      };\r\n\r\n      this.logger.debug('ðŸ“¤ API Request params', requestParams);\r\n\r\n      const response = await this.restClient.getKline(requestParams);\r\n\r\n      // Detailed response logging\r\n      this.logger.info('ðŸ“¥ Bybit API response received', {\r\n        retCode: response.retCode,\r\n        retMsg: response.retMsg,\r\n        hasResult: !!response.result,\r\n        hasResultList: !!response.result?.list,\r\n        listLength: response.result?.list?.length ?? 0,\r\n        category: response.result?.category,\r\n        symbol: response.result?.symbol,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        this.logger.error('âŒ Bybit API error', {\r\n          retCode: response.retCode,\r\n          retMsg: response.retMsg,\r\n          fullResponse: JSON.stringify(response, null, 2),\r\n        });\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const klines = response.result?.list;\r\n      if (klines === undefined || klines === null || klines.length === 0) {\r\n        this.logger.error('âŒ Empty candles response', {\r\n          symbol: this.symbol,\r\n          interval: this.timeframe,\r\n          limit,\r\n          resultExists: !!response.result,\r\n          resultKeys: response.result ? Object.keys(response.result) : [],\r\n          fullResult: JSON.stringify(response.result, null, 2),\r\n        });\r\n        throw new Error('No candles received from exchange');\r\n      }\r\n\r\n      this.logger.info('âœ… Candles fetched successfully', {\r\n        count: klines.length,\r\n        firstCandleTime: klines[0]?.[0] ? new Date(parseInt(klines[0][0])).toISOString() : 'N/A',\r\n        lastCandleTime: klines[klines.length - 1]?.[0] ? new Date(parseInt(klines[klines.length - 1][0])).toISOString() : 'N/A',\r\n      });\r\n\r\n      // Bybit returns newest first, reverse to oldest first\r\n      const reversedKlines = klines.reverse();\r\n\r\n      const candles = reversedKlines.map((k) => ({\r\n        timestamp: parseInt(k[0]),\r\n        open: parseFloat(k[1]),\r\n        high: parseFloat(k[2]),\r\n        low: parseFloat(k[3]),\r\n        close: parseFloat(k[4]),\r\n        volume: parseFloat(k[5]),\r\n      }));\r\n\r\n      this.logger.debug('ðŸ“Š First candle', {\r\n        timestamp: new Date(candles[0].timestamp).toISOString(),\r\n        open: candles[0].open,\r\n        close: candles[0].close,\r\n      });\r\n\r\n      this.logger.debug('ðŸ“Š Last candle', {\r\n        timestamp: new Date(candles[candles.length - 1].timestamp).toISOString(),\r\n        open: candles[candles.length - 1].open,\r\n        close: candles[candles.length - 1].close,\r\n      });\r\n\r\n      return candles;\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRICE & TIME\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get current market price\r\n   */\r\n  async getCurrentPrice(): Promise<number> {\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getTickers({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const ticker = response.result.list[0];\r\n      if (ticker === undefined || ticker === null) {\r\n        throw new Error(`No ticker data for ${this.symbol}`);\r\n      }\r\n\r\n      return parseFloat(ticker.lastPrice);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get server time (for time synchronization)\r\n   */\r\n  async getServerTime(): Promise<number> {\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getServerTime();\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const timeSeconds = response.result.timeSecond;\r\n      if (timeSeconds === undefined || timeSeconds === null) {\r\n        throw new Error('Server time not received');\r\n      }\r\n\r\n      // Convert seconds to milliseconds\r\n      const MILLISECONDS_IN_SECOND = 1000;\r\n      return Number(timeSeconds) * MILLISECONDS_IN_SECOND;\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ORDER BOOK\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get order book (market depth)\r\n   *\r\n   * @param symbol - Trading symbol (default: this.symbol)\r\n   * @param limit - Number of levels to fetch (default: 50, max: 500)\r\n   * @returns Order book data with bids and asks\r\n   */\r\n  async getOrderBook(symbol?: string, limit: number = CONFIDENCE_THRESHOLDS.MODERATE): Promise<{\r\n    bids: Array<{ price: number; size: number }>;\r\n    asks: Array<{ price: number; size: number }>;\r\n    timestamp: number;\r\n  }> {\r\n    const targetSymbol = symbol || this.symbol;\r\n\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getOrderbook({\r\n        category: 'linear',\r\n        symbol: targetSymbol,\r\n        limit,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const orderbook = response.result;\r\n      if (!orderbook.b || !orderbook.a) {\r\n        throw new Error('Invalid order book data');\r\n      }\r\n\r\n      // Parse bids and asks (use 'size' to match OrderbookLevel interface)\r\n      const bids = orderbook.b.map((level: string[]) => ({\r\n        price: parseFloat(level[0]),\r\n        size: parseFloat(level[1]),\r\n      }));\r\n\r\n      const asks = orderbook.a.map((level: string[]) => ({\r\n        price: parseFloat(level[0]),\r\n        size: parseFloat(level[1]),\r\n      }));\r\n\r\n      return {\r\n        bids,\r\n        asks,\r\n        timestamp: typeof orderbook.ts === 'string' ? parseInt(orderbook.ts) : orderbook.ts,\r\n      };\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // FUNDING RATE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get current funding rate and next funding time\r\n   *\r\n   * @param symbol - Symbol (e.g., \"APEXUSDT\")\r\n   * @returns Funding rate data\r\n   */\r\n  async getFundingRate(symbol?: string): Promise<{\r\n    fundingRate: number;\r\n    timestamp: number;\r\n    nextFundingTime: number;\r\n  }> {\r\n    const targetSymbol = symbol || this.symbol;\r\n\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getFundingRateHistory({\r\n        category: 'linear',\r\n        symbol: targetSymbol,\r\n        limit: 1, // Get only latest funding rate\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const fundingHistory = response.result?.list;\r\n      if (!fundingHistory || fundingHistory.length === 0) {\r\n        throw new Error('No funding rate data available');\r\n      }\r\n\r\n      const latest = fundingHistory[0];\r\n\r\n      return {\r\n        fundingRate: parseFloat(latest.fundingRate),\r\n        timestamp: typeof latest.fundingRateTimestamp === 'string'\r\n          ? parseInt(latest.fundingRateTimestamp)\r\n          : latest.fundingRateTimestamp,\r\n        nextFundingTime: typeof latest.fundingRateTimestamp === 'string'\r\n          ? parseInt(latest.fundingRateTimestamp) + 8 * 60 * 60 * 1000 // +8 hours\r\n          : latest.fundingRateTimestamp + 8 * 60 * 60 * 1000,\r\n      };\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\bybit\\bybit-orders.partial.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Async method 'verifyProtectionSet' has a complexity of 17. Maximum allowed is 10.","line":363,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":466,"endColumn":4},{"ruleId":"max-len","severity":1,"message":"This line has a length of 132. Maximum allowed is 120.","line":434,"column":1,"nodeType":"Program","messageId":"max","endLine":434,"endColumn":133},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":434,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":434,"endColumn":41},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":434,"column":24,"nodeType":null,"messageId":"preferOptionalChain","endLine":434,"endColumn":75,"fix":{"range":[15621,15672],"text":"stopLossOrders[0]?.triggerPrice"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":434,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":434,"endColumn":75,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15642,15672],"text":"(stopLossOrders[0].triggerPrice != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[15642,15672],"text":"(stopLossOrders[0].triggerPrice ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15642,15672],"text":"(Boolean(stopLossOrders[0].triggerPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (422). Maximum allowed is 300.","line":449,"column":1,"nodeType":null,"messageId":"exceed","endLine":618,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":494,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":494,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":529,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":529,"endColumn":44},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":588,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":599,"endColumn":12}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENTAGE_THRESHOLDS } from '../../constants';\r\n/**\r\n * Bybit Orders Partial\r\n *\r\n * Handles order management operations:\r\n * - Take-profit levels (TP1, TP2, TP3)\r\n * - Stop-loss orders\r\n * - Trailing stops\r\n * - Order cancellation\r\n * - Conditional orders cleanup\r\n */\r\n\r\nimport { PositionSide, TakeProfit, ProtectionVerification, BybitOrder, isStopLossOrder, isTakeProfitOrder } from '../../types';\r\nimport { BybitBase, BYBIT_SUCCESS_CODE, BYBIT_NOT_MODIFIED_CODE, BYBIT_ORDER_NOT_EXISTS_CODE, BYBIT_ZERO_POSITION_CODE, POSITION_IDX_ONE_WAY, PERCENT_TO_DECIMAL } from './bybit-base.partial';\r\n\r\n// ============================================================================\r\n// BYBIT ORDERS PARTIAL\r\n// ============================================================================\r\n\r\nexport class BybitOrders extends BybitBase {\r\n  // ==========================================================================\r\n  // TAKE PROFIT\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Place multiple take-profit levels\r\n   */\r\n  async placeTakeProfitLevels(params: {\r\n    side: PositionSide;\r\n    entryPrice: number;\r\n    totalQuantity: number;\r\n    levels: TakeProfit[];\r\n  }): Promise<(string | undefined)[]> {\r\n    return await this.retry(async () => {\r\n      const { side, entryPrice, totalQuantity, levels } = params;\r\n      const orderIds: (string | undefined)[] = [];\r\n\r\n      const orderSide = side === PositionSide.LONG ? 'Sell' : 'Buy';\r\n\r\n      for (const level of levels) {\r\n        const tpPrice =\r\n          side === PositionSide.LONG\r\n            ? entryPrice * (1 + level.percent / PERCENT_TO_DECIMAL)\r\n            : entryPrice * (1 - level.percent / PERCENT_TO_DECIMAL);\r\n\r\n        const quantity = (totalQuantity * level.sizePercent) / PERCENT_TO_DECIMAL;\r\n\r\n        // Round quantity and price to exchange precision\r\n        const orderQty = this.roundQuantity(quantity);\r\n        const orderPrice = this.roundPrice(tpPrice);\r\n\r\n        this.logger.debug('Placing TP level', {\r\n          level: level.level,\r\n          percent: level.percent,\r\n          price: tpPrice,\r\n          priceRounded: orderPrice,\r\n          quantity,\r\n          quantityRounded: orderQty,\r\n        });\r\n\r\n        try {\r\n          const response = await this.restClient.submitOrder({\r\n            category: 'linear',\r\n            symbol: this.symbol,\r\n            side: orderSide,\r\n            orderType: 'Limit',\r\n            qty: orderQty,\r\n            price: orderPrice,\r\n            reduceOnly: true,\r\n            timeInForce: 'GTC',\r\n          });\r\n\r\n          if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n            this.logger.warn(`Failed to place TP level ${level.level}`, { error: response.retMsg });\r\n            orderIds.push(undefined); // Push undefined to maintain array index alignment\r\n          } else {\r\n            orderIds.push(response.result.orderId);\r\n            this.logger.info(`TP level ${level.level} placed`, {\r\n              orderId: response.result.orderId,\r\n              price: tpPrice,\r\n              quantity,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          this.logger.error(`Exception placing TP level ${level.level}`, { error });\r\n          orderIds.push(undefined); // Push undefined to maintain array index alignment\r\n        }\r\n      }\r\n\r\n      return orderIds;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cancel take-profit order\r\n   *\r\n   * Gracefully handles cases where order doesn't exist (already filled/cancelled).\r\n   * This is expected behavior when TP hits before cancellation.\r\n   */\r\n  async cancelTakeProfit(orderId: string): Promise<void> {\r\n    return await this.retry(async () => {\r\n      this.logger.debug('Cancelling take-profit', { orderId });\r\n\r\n      const response = await this.restClient.cancelOrder({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        orderId,\r\n      });\r\n\r\n      // Order not exists or too late to cancel - this is OK!\r\n      // It means the order was already filled or cancelled by exchange\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        if (response.retMsg.includes('not exists') || response.retMsg.includes('too late')) {\r\n          this.logger.warn('Take-profit already cancelled or filled', {\r\n            orderId,\r\n            reason: response.retMsg,\r\n          });\r\n          return; // Success - nothing to cancel\r\n        }\r\n\r\n        throw new Error(`Failed to cancel take-profit: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('Take-profit cancelled', { orderId });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update take-profit order price\r\n   *\r\n   * Used for smart TP3 movement - moving TP3 by ticks as price moves favorably.\r\n   */\r\n  async updateTakeProfit(orderId: string, newPrice: number): Promise<void> {\r\n    return await this.retry(async () => {\r\n      this.logger.debug('Updating take-profit price', { orderId, newPrice });\r\n\r\n      const response = await this.restClient.amendOrder({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        orderId,\r\n        price: newPrice.toString(), // Use 'price' for Limit orders (TP), not 'triggerPrice'\r\n      });\r\n\r\n      // Allow \"not modified\" error - price is already correct\r\n      if (response.retCode === BYBIT_NOT_MODIFIED_CODE) {\r\n        this.logger.debug('Take-profit already at target price', { orderId, newPrice });\r\n        return; // Success - no modification needed\r\n      }\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Failed to update take-profit: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('Take-profit price updated', { orderId, newPrice });\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // STOP LOSS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Place stop-loss order\r\n   */\r\n  async placeStopLoss(params: {\r\n    side: PositionSide;\r\n    quantity: number;\r\n    stopPrice: number;\r\n  }): Promise<string> {\r\n    return await this.retry(async () => {\r\n      const { side, quantity, stopPrice } = params;\r\n\r\n      const orderSide = side === PositionSide.LONG ? 'Sell' : 'Buy';\r\n      const TRIGGER_DIRECTION_RISE = 1;\r\n      const TRIGGER_DIRECTION_FALL = 2;\r\n      const triggerDirection = side === PositionSide.LONG\r\n        ? TRIGGER_DIRECTION_FALL\r\n        : TRIGGER_DIRECTION_RISE;\r\n\r\n      // Round quantity and price to exchange precision\r\n      const orderQty = this.roundQuantity(quantity);\r\n      const orderPrice = this.roundPrice(stopPrice);\r\n\r\n      this.logger.debug('Placing stop-loss', {\r\n        side,\r\n        stopPrice,\r\n        stopPriceRounded: orderPrice,\r\n        quantity,\r\n        quantityRounded: orderQty,\r\n      });\r\n\r\n      const response = await this.restClient.submitOrder({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        side: orderSide,\r\n        orderType: 'Market',\r\n        qty: orderQty,\r\n        triggerPrice: orderPrice,\r\n        triggerDirection,\r\n        triggerBy: 'LastPrice',\r\n        reduceOnly: true,\r\n        closeOnTrigger: true,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Failed to place stop-loss: ${response.retMsg}`);\r\n      }\r\n\r\n      const orderId = response.result.orderId;\r\n      this.logger.info('Stop-loss placed', { orderId, stopPrice });\r\n\r\n      return orderId;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update stop-loss price for existing position\r\n   * Uses setTradingStop API (NOT amendOrder) to update position SL\r\n   */\r\n  async updateStopLoss(newStopPrice: number): Promise<void> {\r\n    return await this.retry(async () => {\r\n      const roundedPrice = this.roundPrice(newStopPrice);\r\n\r\n      this.logger.info('ðŸ”„ Updating stop-loss for position', {\r\n        newStopPrice,\r\n        roundedPrice,\r\n        symbol: this.symbol,\r\n      });\r\n\r\n      const response = await this.restClient.setTradingStop({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        stopLoss: roundedPrice.toString(),\r\n        positionIdx: POSITION_IDX_ONE_WAY, // One-Way mode\r\n        tpslMode: 'Full',\r\n      });\r\n\r\n      this.logger.info('ðŸ“‹ setTradingStop response', {\r\n        retCode: response.retCode,\r\n        retMsg: response.retMsg,\r\n        result: response.result,\r\n      });\r\n\r\n      // Code 10001 means \"zero position\" - position already closed (race condition), which is OK\r\n      if (response.retCode === BYBIT_ZERO_POSITION_CODE) {\r\n        this.logger.info('â„¹ï¸ Position already closed, skipping SL update (race condition)', {\r\n          newStopPrice: roundedPrice,\r\n          retCode: response.retCode,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Code 34040 means \"not modified\" - SL is already at this price, which is OK\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE && response.retCode !== BYBIT_NOT_MODIFIED_CODE) {\r\n        throw new Error(`Failed to update stop-loss: ${response.retMsg}`);\r\n      }\r\n\r\n      if (response.retCode === BYBIT_NOT_MODIFIED_CODE) {\r\n        this.logger.info('â„¹ï¸ Stop-loss already at target price (not modified)', { newStopPrice: roundedPrice });\r\n      } else {\r\n        this.logger.info('âœ… Stop-loss updated successfully', { newStopPrice: roundedPrice });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cancel stop-loss order\r\n   */\r\n  async cancelStopLoss(orderId: string): Promise<void> {\r\n    return await this.retry(async () => {\r\n      this.logger.debug('Cancelling stop-loss', { orderId });\r\n\r\n      const response = await this.restClient.cancelOrder({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        orderId,\r\n      });\r\n\r\n      // Code 110001 means \"order not exists\" - SL already cancelled, which is OK\r\n      if (response.retCode === BYBIT_ORDER_NOT_EXISTS_CODE) {\r\n        this.logger.info('â„¹ï¸ Stop-loss already cancelled (order not exists)', { orderId });\r\n        return;\r\n      }\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Failed to cancel stop-loss: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('Stop-loss cancelled', { orderId });\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // TRAILING STOP\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Activate server-side trailing stop\r\n   */\r\n  async setTrailingStop(params: {\r\n    side: PositionSide;\r\n    activationPrice: number;\r\n    trailingPercent: number;\r\n  }): Promise<void> {\r\n    return await this.retry(async () => {\r\n      const { activationPrice, trailingPercent } = params;\r\n\r\n      const trailingStopAmount = activationPrice * (trailingPercent / PERCENT_TO_DECIMAL);\r\n\r\n      this.logger.debug('Setting trailing stop', {\r\n        activationPrice,\r\n        trailingPercent,\r\n        trailingStopAmount,\r\n      });\r\n\r\n      const response = await this.restClient.setTradingStop({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        trailingStop: trailingStopAmount.toFixed(DECIMAL_PLACES.PRICE),\r\n        positionIdx: POSITION_IDX_ONE_WAY,\r\n        tpslMode: 'Full',\r\n      });\r\n\r\n      // Code 10001 means \"zero position\" - position already closed (race condition), which is OK\r\n      if (response.retCode === BYBIT_ZERO_POSITION_CODE) {\r\n        this.logger.info('â„¹ï¸ Position already closed, skipping trailing stop (race condition)', {\r\n          trailingPercent,\r\n          retCode: response.retCode,\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Code 34040 means \"not modified\" - trailing stop already set, which is OK\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE && response.retCode !== BYBIT_NOT_MODIFIED_CODE) {\r\n        throw new Error(`Failed to set trailing stop: ${response.retMsg}`);\r\n      }\r\n\r\n      if (response.retCode === BYBIT_NOT_MODIFIED_CODE) {\r\n        this.logger.info('â„¹ï¸ Trailing stop already set (not modified)', {\r\n          trailingPercent: `${trailingPercent}%`,\r\n        });\r\n      } else {\r\n        this.logger.info('Trailing stop activated', {\r\n          activationPrice,\r\n          trailingPercent: `${trailingPercent}%`,\r\n          trailingStopAmount,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PROTECTION VERIFICATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Verify that TP/SL protection is actually set on exchange\r\n   * CRITICAL: Prevents positions without protection\r\n   *\r\n   * @param side - Position side (LONG or SHORT)\r\n   * @returns ProtectionVerification with detailed status\r\n   */\r\n  async verifyProtectionSet(side: PositionSide): Promise<ProtectionVerification> {\r\n    try {\r\n      // 1. Get active orders (SL/TP orders)\r\n      const orders = await this.getActiveOrders();\r\n\r\n      // Find SL orders (trigger orders that close position)\r\n      const stopLossOrders = orders.filter((order: BybitOrder): boolean => {\r\n        const isSLOrder = isStopLossOrder(order);\r\n\r\n        // For LONG: SL is Sell order below entry\r\n        // For SHORT: SL is Buy order above entry\r\n        const correctSide = side === PositionSide.LONG\r\n          ? order.side === 'Sell'\r\n          : order.side === 'Buy';\r\n\r\n        return isSLOrder && correctSide;\r\n      });\r\n\r\n      // Find TP orders (limit reduce-only orders)\r\n      const takeProfitOrders = orders.filter((order: BybitOrder): boolean => {\r\n        const isTPOrder = isTakeProfitOrder(order);\r\n\r\n        // For LONG: TP is Sell order above entry\r\n        // For SHORT: TP is Buy order below entry\r\n        const correctSide = side === PositionSide.LONG\r\n          ? order.side === 'Sell'\r\n          : order.side === 'Buy';\r\n\r\n        return isTPOrder && correctSide;\r\n      });\r\n\r\n      const hasStopLoss = stopLossOrders.length > 0;\r\n      const hasTakeProfit = takeProfitOrders.length > 0;\r\n\r\n      // 2. Check for trailing stop via getPositionInfo\r\n      let hasTrailingStop = false;\r\n      try {\r\n        const positionResponse = await this.restClient.getPositionInfo({\r\n          category: 'linear',\r\n          symbol: this.symbol,\r\n        });\r\n\r\n        if (positionResponse.retCode === BYBIT_SUCCESS_CODE && positionResponse.result?.list?.length > 0) {\r\n          const position = positionResponse.result.list[0];\r\n          // Trailing stop is set if trailingStop field is not empty/zero\r\n          const trailingStopValue = position.trailingStop;\r\n          hasTrailingStop = trailingStopValue !== undefined &&\r\n                           trailingStopValue !== null &&\r\n                           trailingStopValue !== '' &&\r\n                           parseFloat(trailingStopValue) > 0;\r\n\r\n          this.logger.debug('Trailing stop check', {\r\n            trailingStopValue,\r\n            hasTrailingStop,\r\n          });\r\n        }\r\n      } catch (posError) {\r\n        this.logger.warn('Failed to check trailing stop, assuming none', {\r\n          error: posError instanceof Error ? posError.message : String(posError),\r\n        });\r\n      }\r\n\r\n      // 3. Build verification result\r\n      // Position is protected if:\r\n      // - (hasStopLoss OR hasTrailingStop) AND (hasTakeProfit OR hasTrailingStop)\r\n      // When trailing is active, we don't need TP anymore\r\n      const isProtected = (hasStopLoss || hasTrailingStop) && (hasTakeProfit || hasTrailingStop);\r\n\r\n      const verification: ProtectionVerification = {\r\n        hasStopLoss: hasStopLoss || hasTrailingStop, // Trailing stop counts as SL\r\n        hasTakeProfit: hasTakeProfit || hasTrailingStop, // Trailing stop replaces TP\r\n        stopLossPrice: stopLossOrders[0] && stopLossOrders[0].triggerPrice ? parseFloat(stopLossOrders[0].triggerPrice) : undefined,\r\n        takeProfitPrices: takeProfitOrders.map((o: BybitOrder): number => parseFloat(o.price)),\r\n        activeOrders: orders.length,\r\n        verified: isProtected,\r\n        hasTrailingStop,\r\n      };\r\n\r\n      this.logger.debug('Protection verification complete', {\r\n        side,\r\n        verification,\r\n        totalOrders: orders.length,\r\n        slOrders: stopLossOrders.length,\r\n        tpOrders: takeProfitOrders.length,\r\n        hasTrailingStop,\r\n        isProtected,\r\n      });\r\n\r\n      return verification;\r\n    } catch (error) {\r\n      this.logger.error('Failed to verify protection', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      // Return conservative result (assume no protection on error)\r\n      return {\r\n        hasStopLoss: false,\r\n        hasTakeProfit: false,\r\n        activeOrders: 0,\r\n        verified: false,\r\n        hasTrailingStop: false,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ACTIVE ORDERS & CLEANUP\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get all active orders for the symbol\r\n   * @returns Array of active orders with proper typing\r\n   */\r\n  async getActiveOrders(): Promise<BybitOrder[]> {\r\n    return await this.retry(async () => {\r\n      this.logger.debug('Fetching active orders', { symbol: this.symbol });\r\n\r\n      const response = await this.restClient.getActiveOrders({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        settleCoin: 'USDT',\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        this.logger.warn('Failed to get active orders', {\r\n          error: response.retMsg,\r\n          code: response.retCode,\r\n        });\r\n        return [];\r\n      }\r\n\r\n      const orders = (response.result?.list || []) as unknown as BybitOrder[];\r\n\r\n      this.logger.debug('Active orders fetched', {\r\n        count: orders.length,\r\n        orderIds: orders.map((o: BybitOrder): string => o.orderId),\r\n      });\r\n\r\n      return orders;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get order history (filled/cancelled orders)\r\n   * Used by Safety Monitor to determine exitType when WebSocket event was missed\r\n   * @param limit - Maximum number of orders to fetch (default: 20)\r\n   * @returns Array of historical orders with proper typing\r\n   */\r\n  async getOrderHistory(limit: number = PERCENTAGE_THRESHOLDS.LOW_MODERATE): Promise<BybitOrder[]> {\r\n    return await this.retry(async () => {\r\n      this.logger.debug('Fetching order history', { symbol: this.symbol, limit });\r\n\r\n      const response = await this.restClient.getHistoricOrders({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        limit,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        this.logger.warn('Failed to get order history', {\r\n          error: response.retMsg,\r\n          code: response.retCode,\r\n        });\r\n        return [];\r\n      }\r\n\r\n      const orders = (response.result?.list || []) as unknown as BybitOrder[];\r\n\r\n      this.logger.debug('Order history fetched', {\r\n        count: orders.length,\r\n        orderStatuses: orders.map((o: BybitOrder): object => {\r\n          return { id: o.orderId, status: o.orderStatus };\r\n        }),\r\n      });\r\n\r\n      return orders;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cancel all conditional orders (SL/TP) for the symbol\r\n   * Used to cleanup hanging orders when no position exists\r\n   * Logs errors instead of throwing to ensure cleanup continues\r\n   */\r\n  async cancelAllConditionalOrders(): Promise<void> {\r\n    try {\r\n      const orders = await this.getActiveOrders();\r\n\r\n      if (orders.length === 0) {\r\n        this.logger.debug('No active orders to cancel');\r\n        return;\r\n      }\r\n\r\n      // Filter for conditional orders (reduce-only orders that are SL/TP)\r\n      const conditionalOrders = orders.filter((order: BybitOrder): boolean => {\r\n        // Conditional orders are typically:\r\n        // 1. Reduce-only orders (reduceOnly = true)\r\n        // 2. Or orders with trigger price (stopOrderType exists)\r\n        return order.reduceOnly === true ||\r\n               order.stopOrderType !== undefined ||\r\n               order.triggerPrice !== undefined;\r\n      });\r\n\r\n      this.logger.info('Found conditional orders to cleanup', {\r\n        total: orders.length,\r\n        conditional: conditionalOrders.length,\r\n        conditionalIds: conditionalOrders.map((o: BybitOrder): string => o.orderId),\r\n      });\r\n\r\n      // Cancel each conditional order\r\n      for (const order of conditionalOrders) {\r\n        try {\r\n          this.logger.debug('Cancelling conditional order', {\r\n            orderId: order.orderId,\r\n            orderType: order.orderType,\r\n            side: order.side,\r\n            triggerPrice: order.triggerPrice,\r\n          });\r\n\r\n          const response = await this.restClient.cancelOrder({\r\n            category: 'linear',\r\n            symbol: this.symbol,\r\n            orderId: order.orderId,\r\n          });\r\n\r\n          if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n            this.logger.warn('Failed to cancel conditional order, continuing...', {\r\n              orderId: order.orderId,\r\n              error: response.retMsg,\r\n              code: response.retCode,\r\n            });\r\n          } else {\r\n            this.logger.info('âœ… Cancelled hanging conditional order', {\r\n              orderId: order.orderId,\r\n              orderType: order.orderType,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Error cancelling conditional order, continuing...', {\r\n            orderId: order.orderId,\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n      }\r\n\r\n      this.logger.info('Conditional orders cleanup completed', {\r\n        processed: conditionalOrders.length,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Error in cancelAllConditionalOrders', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\bybit\\bybit-positions.partial.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 110026.","line":50,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":40},{"ruleId":"complexity","severity":1,"message":"Async arrow function has a complexity of 11. Maximum allowed is 10.","line":147,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":193,"endColumn":6}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Bybit Positions Partial\r\n *\r\n * Handles position management operations:\r\n * - Open positions (LONG/SHORT)\r\n * - Close positions\r\n * - Get position info\r\n * - Set leverage\r\n * - Set margin mode\r\n */\r\n\r\nimport { Position, PositionSide } from '../../types';\r\nimport { BybitBase, BYBIT_SUCCESS_CODE, POSITION_SIZE_ZERO, POSITION_IDX_ONE_WAY } from './bybit-base.partial';\r\n\r\n// ============================================================================\r\n// BYBIT POSITIONS PARTIAL\r\n// ============================================================================\r\n\r\nexport class BybitPositions extends BybitBase {\r\n  // ==========================================================================\r\n  // MARGIN & LEVERAGE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Set margin mode to isolated\r\n   * NOTE: Not supported on demo trading - skipped for demo accounts\r\n   */\r\n  async setMarginMode(): Promise<void> {\r\n    // Skip for demo trading (not supported)\r\n    if (this.demo) {\r\n      this.logger.debug('Skipping setMarginMode (not supported on demo trading)');\r\n      return;\r\n    }\r\n\r\n    return await this.retry(async () => {\r\n      this.logger.debug('Setting margin mode to ISOLATED');\r\n\r\n      const response = await this.restClient.switchIsolatedMargin({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        tradeMode: 1, // 1 = Isolated margin\r\n        buyLeverage: '10',\r\n        sellLeverage: '10',\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        // Ignore if already in isolated mode\r\n        if (response.retMsg?.includes('margin mode not modified') ||\r\n            response.retMsg?.includes('already') ||\r\n            response.retCode === 110026) { // Already in isolated mode\r\n          this.logger.debug('Margin mode already set to ISOLATED');\r\n          return;\r\n        }\r\n        this.logger.warn('Failed to set margin mode (non-critical)', {\r\n          error: response.retMsg,\r\n          code: response.retCode,\r\n        });\r\n        return; // Continue anyway - margin mode is not critical\r\n      }\r\n\r\n      this.logger.info('Margin mode set to ISOLATED', { symbol: this.symbol });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set leverage for symbol\r\n   */\r\n  async setLeverage(leverage: number): Promise<void> {\r\n    return await this.retry(async () => {\r\n      // First ensure we're in isolated margin mode\r\n      await this.setMarginMode();\r\n\r\n      const response = await this.restClient.setLeverage({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        buyLeverage: leverage.toString(),\r\n        sellLeverage: leverage.toString(),\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        // Ignore \"leverage not modified\" error\r\n        if (response.retMsg?.includes('leverage not modified')) {\r\n          this.logger.debug('Leverage already set', { leverage });\r\n          return;\r\n        }\r\n        throw new Error(`Failed to set leverage: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('Leverage set', { symbol: this.symbol, leverage });\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // POSITION MANAGEMENT\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Open futures position with limit order\r\n   */\r\n  async openPosition(params: {\r\n    side: PositionSide;\r\n    quantity: number;\r\n    leverage: number;\r\n  }): Promise<string> {\r\n    return await this.retry(async () => {\r\n      const { side, quantity, leverage } = params;\r\n\r\n      // Set leverage first\r\n      await this.setLeverage(leverage);\r\n\r\n      // Round quantity to exchange precision\r\n      const orderQty = this.roundQuantity(quantity);\r\n\r\n      this.logger.info('ðŸ“¤ Submitting MARKET order to Bybit', {\r\n        side,\r\n        quantity,\r\n        quantityString: orderQty,\r\n        symbol: this.symbol,\r\n        leverage,\r\n      });\r\n\r\n      // Place MARKET order for immediate execution\r\n      const response = await this.restClient.submitOrder({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        side: side === PositionSide.LONG ? 'Buy' : 'Sell',\r\n        orderType: 'Market',\r\n        qty: orderQty,\r\n        positionIdx: POSITION_IDX_ONE_WAY,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Failed to open position: ${response.retMsg}`);\r\n      }\r\n\r\n      const orderId = response.result.orderId;\r\n      this.logger.info('Position MARKET order placed', { orderId, side, quantity: orderQty });\r\n\r\n      return orderId;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current open position\r\n   */\r\n  async getPosition(): Promise<Position | null> {\r\n    return await this.retry(async () => {\r\n      const response = await this.restClient.getPositionInfo({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Bybit API error: ${response.retMsg} (code: ${response.retCode})`);\r\n      }\r\n\r\n      const positions = response.result.list;\r\n      if (positions === undefined || positions.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      const pos = positions[0];\r\n      const size = parseFloat(pos.size ?? '0');\r\n\r\n      // No position if size is 0\r\n      if (size === POSITION_SIZE_ZERO) {\r\n        return null;\r\n      }\r\n\r\n      // Map to Position type\r\n      return {\r\n        id: `${this.symbol}_${pos.side}`,\r\n        symbol: this.symbol,\r\n        side: pos.side === 'Buy' ? PositionSide.LONG : PositionSide.SHORT,\r\n        quantity: size,\r\n        entryPrice: parseFloat(pos.avgPrice ?? '0'),\r\n        leverage: parseFloat(pos.leverage ?? '1'),\r\n        marginUsed: parseFloat(pos.positionIM ?? '0'), // Initial margin\r\n        stopLoss: {\r\n          price: 0,\r\n          initialPrice: 0,\r\n          isBreakeven: false,\r\n          isTrailing: false,\r\n          updatedAt: Date.now(),\r\n        },\r\n        takeProfits: [],\r\n        openedAt: Date.now(),\r\n        unrealizedPnL: parseFloat(pos.unrealisedPnl ?? '0'),\r\n        orderId: '',\r\n        reason: 'Existing position from API',\r\n        status: 'OPEN', // Position restored from exchange is OPEN\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Close position completely\r\n   */\r\n  async closePosition(side: PositionSide, quantity: number): Promise<void> {\r\n    return await this.retry(async () => {\r\n      const closeSide = side === PositionSide.LONG ? 'Sell' : 'Buy';\r\n\r\n      const response = await this.restClient.submitOrder({\r\n        category: 'linear',\r\n        symbol: this.symbol,\r\n        side: closeSide,\r\n        orderType: 'Market',\r\n        qty: quantity.toString(),\r\n        positionIdx: POSITION_IDX_ONE_WAY,\r\n        reduceOnly: true,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        throw new Error(`Failed to close position: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('Position closed', { side, quantity, orderId: response.result.orderId });\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\bybit\\bybit.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":106,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":106,"endColumn":87,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[4195,4258],"text":"((this.base as unknown as { timeOffsetMs: number }).timeOffsetMs !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[4195,4258],"text":"(!Number.isNaN((this.base as unknown as { timeOffsetMs: number }).timeOffsetMs))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4195,4258],"text":"(Boolean((this.base as unknown as { timeOffsetMs: number }).timeOffsetMs))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":131,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":131,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":132,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":132,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5245,5325],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":140,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":140,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":140,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":140,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":144,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":144,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":144,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":144,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":148,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":148,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":148,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":148,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":152,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":152,"endColumn":21},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":152,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":152,"endColumn":21},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":156,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":156,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":156,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":156,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":164,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":164,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":164,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":164,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":168,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":168,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":168,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":168,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":172,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":172,"endColumn":21},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":172,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":172,"endColumn":21},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":176,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":176,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":176,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":176,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":180,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":180,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":180,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":180,"endColumn":22},{"ruleId":"max-len","severity":1,"message":"This line has a length of 128. Maximum allowed is 120.","line":188,"column":1,"nodeType":"Program","messageId":"max","endLine":188,"endColumn":129},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":188,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":188,"endColumn":30},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":188,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":188,"endColumn":30},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":192,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":192,"endColumn":25},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":192,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":192,"endColumn":25},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":196,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":196,"endColumn":25},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":196,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":196,"endColumn":25},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":200,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":200,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":200,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":200,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":204,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":204,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":204,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":204,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":208,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":208,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":208,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":208,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":212,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":212,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":212,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":212,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":216,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":216,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":216,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":216,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":220,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":220,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":220,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":220,"endColumn":24},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":224,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":224,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":224,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":224,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":228,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":228,"endColumn":35},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":228,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":228,"endColumn":35},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":236,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":236,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":236,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":236,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":240,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":240,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":240,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":240,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":253,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":253,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":253,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":253,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":261,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":261,"endColumn":12},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":261,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":261,"endColumn":12},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":269,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":269,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":269,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":269,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":277,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":277,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":277,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":277,"endColumn":13}],"suppressedMessages":[],"errorCount":56,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Bybit API Service - Main Orchestrator\r\n *\r\n * Composed from modular partial classes:\r\n * - BybitBase: Shared utilities (retry, rounding, balance)\r\n * - BybitMarketData: Public API (candles, price, time, orderbook)\r\n * - BybitPositions: Position management (open, close, leverage)\r\n * - BybitOrders: Order management (TP, SL, trailing stop)\r\n *\r\n * Uses official Bybit SDK (RestClientV5) for futures trading.\r\n * Supports Demo/Testnet/Production environments.\r\n */\r\n\r\nimport { RestClientV5 } from 'bybit-api';\r\nimport {\r\n  ExchangeConfig,\r\n  LoggerService,\r\n  PositionSide,\r\n  TakeProfit,\r\n} from '../../types';\r\nimport { BybitBase, RECV_WINDOW } from './bybit-base.partial';\r\nimport { BybitMarketData } from './bybit-market-data.partial';\r\nimport { BybitPositions } from './bybit-positions.partial';\r\nimport { BybitOrders } from './bybit-orders.partial';\r\n\r\n// ============================================================================\r\n// BYBIT SERVICE (MAIN ORCHESTRATOR)\r\n// ============================================================================\r\n\r\nexport class BybitService {\r\n  // Partial class instances (composition pattern)\r\n  private readonly base: BybitBase;\r\n  private readonly marketData: BybitMarketData;\r\n  private readonly positions: BybitPositions;\r\n  private readonly orders: BybitOrders;\r\n\r\n  // Expose symbol and timeframe for backward compatibility\r\n  private readonly symbol: string;\r\n  private readonly timeframe: string;\r\n\r\n  private originalDateNow = Date.now;\r\n  private timeOffsetMs: number = 0;\r\n\r\n  constructor(config: ExchangeConfig, logger: LoggerService) {\r\n    this.symbol = config.symbol;\r\n    this.timeframe = config.timeframe;\r\n\r\n    // Initialize RestClientV5\r\n    const clientConfig: {\r\n      key: string;\r\n      secret: string;\r\n      testnet?: boolean;\r\n      baseUrl?: string;\r\n      recv_window?: number;\r\n      sync_time_api?: boolean; // Enable Bybit SDK time sync\r\n    } = {\r\n      key: config.apiKey,\r\n      secret: config.apiSecret,\r\n      recv_window: RECV_WINDOW,\r\n      sync_time_api: false, // SDK sync doesn't work - we'll do manual offset\r\n    };\r\n\r\n    // Select environment\r\n    if (config.demo) {\r\n      clientConfig.testnet = false;\r\n      clientConfig.baseUrl = 'https://api-demo.bybit.com';\r\n      logger.info('Bybit Demo API initialized', { baseUrl: clientConfig.baseUrl });\r\n    } else if (config.testnet) {\r\n      clientConfig.testnet = true;\r\n      logger.info('Bybit Testnet API initialized');\r\n    } else {\r\n      clientConfig.testnet = false;\r\n      logger.info('Bybit Production API initialized');\r\n    }\r\n\r\n    const restClient = new RestClientV5(clientConfig);\r\n\r\n    // Instantiate partial classes\r\n    this.base = new BybitBase(restClient, config.symbol, config.timeframe, logger, config.demo);\r\n    this.marketData = new BybitMarketData(restClient, config.symbol, config.timeframe, logger, config.demo);\r\n    this.positions = new BybitPositions(restClient, config.symbol, config.timeframe, logger, config.demo);\r\n    this.orders = new BybitOrders(restClient, config.symbol, config.timeframe, logger, config.demo);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // INITIALIZATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Initialize service - load symbol precision parameters\r\n   * Must be called after construction, before trading\r\n   */\r\n  async initialize(): Promise<void> {\r\n    await this.base.initialize();\r\n\r\n    // CRITICAL: Share precision data with all partial instances\r\n    // Only base.initialize() makes the API call - other instances reuse the data\r\n    const limits = this.base.getExchangeLimits();\r\n    this.orders.setPrecision(limits.qtyStep, limits.tickSize, limits.minOrderQty);\r\n    this.positions.setPrecision(limits.qtyStep, limits.tickSize, limits.minOrderQty);\r\n    this.marketData.setPrecision(limits.qtyStep, limits.tickSize, limits.minOrderQty);\r\n\r\n    // CRITICAL: Apply time offset correction after initialization\r\n    // BybitBase.initialize() calculates timeOffsetMs from server\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n    const baseOffset = (this.base as unknown as { timeOffsetMs: number }).timeOffsetMs || 0;\r\n    this.applyTimeOffset(baseOffset);\r\n  }\r\n\r\n  /**\r\n   * Apply time offset correction via Date.now() monkey-patch\r\n   * CRITICAL: Prevents timestamp errors when local clock is ahead\r\n   *\r\n   * IMPORTANT: ALWAYS apply monkey-patch, even for small offsets!\r\n   * Reason: Drift grows over time (e.g., 50ms â†’ 1500ms in hours)\r\n   * and we have NO periodic sync to update it.\r\n   */\r\n  private applyTimeOffset(offsetMs: number): void {\r\n    this.timeOffsetMs = offsetMs;\r\n\r\n    // ALWAYS monkey-patch Date.now() - drift grows over time!\r\n    const correctedDateNow = (): number => {\r\n      return this.originalDateNow() - this.timeOffsetMs;\r\n    };\r\n\r\n    // Apply global monkey-patch (affects Bybit SDK internal timestamp generation)\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n    (Date as unknown as { now: () => number }).now = correctedDateNow;\r\n\r\n    // Log only significant offsets to reduce noise\r\n    if (Math.abs(offsetMs) > 100) {\r\n      console.log(`â° Time offset applied: ${offsetMs}ms (Date.now() monkey-patched)`);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MARKET DATA (delegate to BybitMarketData partial)\r\n  // ==========================================================================\r\n\r\n  async getCandles(symbolOrLimit?: string | number, interval?: string, limit?: number) {\r\n    return this.marketData.getCandles(symbolOrLimit, interval, limit);\r\n  }\r\n\r\n  async getCurrentPrice() {\r\n    return this.marketData.getCurrentPrice();\r\n  }\r\n\r\n  async getServerTime() {\r\n    return this.marketData.getServerTime();\r\n  }\r\n\r\n  async getOrderBook(symbol?: string, limit?: number) {\r\n    return this.marketData.getOrderBook(symbol, limit);\r\n  }\r\n\r\n  async getFundingRate(symbol?: string) {\r\n    return this.marketData.getFundingRate(symbol);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // POSITIONS (delegate to BybitPositions partial)\r\n  // ==========================================================================\r\n\r\n  async setMarginMode() {\r\n    return this.positions.setMarginMode();\r\n  }\r\n\r\n  async setLeverage(leverage: number) {\r\n    return this.positions.setLeverage(leverage);\r\n  }\r\n\r\n  async openPosition(params: { side: PositionSide; quantity: number; leverage: number }) {\r\n    return this.positions.openPosition(params);\r\n  }\r\n\r\n  async getPosition() {\r\n    return this.positions.getPosition();\r\n  }\r\n\r\n  async closePosition(side: PositionSide, quantity: number) {\r\n    return this.positions.closePosition(side, quantity);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ORDERS (delegate to BybitOrders partial)\r\n  // ==========================================================================\r\n\r\n  async placeTakeProfitLevels(params: { side: PositionSide; entryPrice: number; totalQuantity: number; levels: TakeProfit[] }) {\r\n    return this.orders.placeTakeProfitLevels(params);\r\n  }\r\n\r\n  async cancelTakeProfit(orderId: string) {\r\n    return this.orders.cancelTakeProfit(orderId);\r\n  }\r\n\r\n  async updateTakeProfit(orderId: string, newPrice: number) {\r\n    return this.orders.updateTakeProfit(orderId, newPrice);\r\n  }\r\n\r\n  async placeStopLoss(params: { side: PositionSide; quantity: number; stopPrice: number }) {\r\n    return this.orders.placeStopLoss(params);\r\n  }\r\n\r\n  async updateStopLoss(newStopPrice: number) {\r\n    return this.orders.updateStopLoss(newStopPrice);\r\n  }\r\n\r\n  async cancelStopLoss(orderId: string) {\r\n    return this.orders.cancelStopLoss(orderId);\r\n  }\r\n\r\n  async setTrailingStop(params: { side: PositionSide; activationPrice: number; trailingPercent: number }) {\r\n    return this.orders.setTrailingStop(params);\r\n  }\r\n\r\n  async getActiveOrders() {\r\n    return this.orders.getActiveOrders();\r\n  }\r\n\r\n  async getOrderHistory(limit?: number) {\r\n    return this.orders.getOrderHistory(limit);\r\n  }\r\n\r\n  async verifyProtectionSet(side: PositionSide) {\r\n    return this.orders.verifyProtectionSet(side);\r\n  }\r\n\r\n  async cancelAllConditionalOrders() {\r\n    return this.orders.cancelAllConditionalOrders();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // BALANCE (delegate to BybitBase partial)\r\n  // ==========================================================================\r\n\r\n  async getBalance() {\r\n    return this.base.getBalance();\r\n  }\r\n\r\n  getExchangeLimits() {\r\n    return this.base.getExchangeLimits();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS (delegate to BybitBase partial)\r\n  // Phase 2: Made public for LimitOrderExecutorService\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get RestClient instance\r\n   * Delegates to BybitBase.getRestClient()\r\n   */\r\n  getRestClient() {\r\n    return this.base.getRestClient();\r\n  }\r\n\r\n  /**\r\n   * Get trading symbol\r\n   * Delegates to BybitBase.getSymbol()\r\n   */\r\n  getSymbol() {\r\n    return this.base.getSymbol();\r\n  }\r\n\r\n  /**\r\n   * Round quantity to exchange precision\r\n   * Delegates to BybitBase.roundQuantity()\r\n   */\r\n  roundQuantity(qty: number) {\r\n    return this.base.roundQuantity(qty);\r\n  }\r\n\r\n  /**\r\n   * Round price to exchange precision\r\n   * Delegates to BybitBase.roundPrice()\r\n   */\r\n  roundPrice(price: number) {\r\n    return this.base.roundPrice(price);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\bybit\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\circuit-breaker.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEFAULT_ERROR_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEFAULT_COOLDOWN_MS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":25,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":25,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":25,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":25,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":88,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":88,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3181,3194],"text":"(this.tripTime != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3181,3194],"text":"(this.tripTime ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3181,3194],"text":"(Boolean(this.tripTime))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":226,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":226,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6852,6865],"text":"(this.tripTime != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6852,6865],"text":"(this.tripTime ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6852,6865],"text":"(Boolean(this.tripTime))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Circuit Breaker Service\r\n *\r\n * Protects the system from API failures by tracking consecutive errors.\r\n * When error threshold is reached, the circuit \"trips\" and pauses operations.\r\n *\r\n * States:\r\n * - CLOSED: Normal operation (no errors or below threshold)\r\n * - OPEN: Circuit tripped (pause operations for cooldown period)\r\n * - HALF_OPEN: Testing if service recovered (allow one request)\r\n *\r\n * Configuration:\r\n * - errorThreshold: Number of consecutive errors before trip (default: 5)\r\n * - cooldownMs: How long to wait before testing recovery (default: 5 min)\r\n * - autoReset: Automatically close circuit after successful call (default: true)\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_ERROR_THRESHOLD = 5; // Trip after 5 consecutive errors\r\nconst DEFAULT_COOLDOWN_MS = 5 * 60 * 1000; // 5 minutes\r\nconst MAX_ERROR_HISTORY = 100; // Keep last 100 errors for analysis\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum CircuitState {\r\n  CLOSED = 'CLOSED', // Normal operation\r\n  OPEN = 'OPEN', // Circuit tripped\r\n  HALF_OPEN = 'HALF_OPEN', // Testing recovery\r\n}\r\n\r\nexport interface CircuitBreakerConfig {\r\n  errorThreshold: number; // Consecutive errors before trip\r\n  cooldownMs: number; // Cooldown period when open\r\n  autoReset: boolean; // Auto-close on success\r\n}\r\n\r\nexport interface CircuitBreakerStats {\r\n  state: CircuitState;\r\n  consecutiveErrors: number;\r\n  totalErrors: number;\r\n  totalSuccesses: number;\r\n  lastErrorTime: number | null;\r\n  lastSuccessTime: number | null;\r\n  tripCount: number; // How many times circuit tripped\r\n  tripTime: number | null; // When circuit last tripped\r\n}\r\n\r\n// ============================================================================\r\n// CIRCUIT BREAKER SERVICE\r\n// ============================================================================\r\n\r\nexport class CircuitBreakerService {\r\n  private state: CircuitState = CircuitState.CLOSED;\r\n  private consecutiveErrors: number = 0;\r\n  private totalErrors: number = 0;\r\n  private totalSuccesses: number = 0;\r\n  private lastErrorTime: number | null = null;\r\n  private lastSuccessTime: number | null = null;\r\n  private tripCount: number = 0;\r\n  private tripTime: number | null = null;\r\n  private errorHistory: { timestamp: number; error: string }[] = [];\r\n\r\n  constructor(\r\n    private config: CircuitBreakerConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('[CircuitBreaker] Initialized', {\r\n      errorThreshold: config.errorThreshold,\r\n      cooldownMs: config.cooldownMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if circuit allows operations\r\n   * @returns true if operations are allowed (CLOSED or HALF_OPEN)\r\n   */\r\n  isOpen(): boolean {\r\n    // If circuit is OPEN, check if cooldown period has passed\r\n    if (this.state === CircuitState.OPEN) {\r\n      const now = Date.now();\r\n      const timeSinceTrip = this.tripTime ? now - this.tripTime : 0;\r\n\r\n      if (timeSinceTrip >= this.config.cooldownMs) {\r\n        // Cooldown period passed, move to HALF_OPEN\r\n        this.logger.info('[CircuitBreaker] Moving to HALF_OPEN state', {\r\n          timeSinceTrip,\r\n        });\r\n        this.state = CircuitState.HALF_OPEN;\r\n        return false; // HALF_OPEN still blocks (will allow one test)\r\n      }\r\n\r\n      return true; // Still OPEN\r\n    }\r\n\r\n    return false; // CLOSED or HALF_OPEN\r\n  }\r\n\r\n  /**\r\n   * Record a successful operation\r\n   */\r\n  recordSuccess(): void {\r\n    this.totalSuccesses++;\r\n    this.lastSuccessTime = Date.now();\r\n    this.consecutiveErrors = 0; // Reset consecutive error count\r\n\r\n    if (this.state === CircuitState.HALF_OPEN && this.config.autoReset) {\r\n      // Successful call in HALF_OPEN state â†’ close circuit\r\n      this.logger.info('[CircuitBreaker] Recovery successful, closing circuit', {\r\n        totalSuccesses: this.totalSuccesses,\r\n      });\r\n      this.state = CircuitState.CLOSED;\r\n    } else if (this.state === CircuitState.CLOSED) {\r\n      this.logger.debug('[CircuitBreaker] Success recorded', {\r\n        totalSuccesses: this.totalSuccesses,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record a failed operation\r\n   */\r\n  recordError(error: string | Error): void {\r\n    this.totalErrors++;\r\n    this.consecutiveErrors++;\r\n    this.lastErrorTime = Date.now();\r\n\r\n    const errorMessage = error instanceof Error ? error.message : error;\r\n\r\n    // Add to error history\r\n    this.errorHistory.push({\r\n      timestamp: Date.now(),\r\n      error: errorMessage,\r\n    });\r\n\r\n    // Limit error history size\r\n    if (this.errorHistory.length > MAX_ERROR_HISTORY) {\r\n      this.errorHistory.shift();\r\n    }\r\n\r\n    this.logger.warn('[CircuitBreaker] Error recorded', {\r\n      consecutiveErrors: this.consecutiveErrors,\r\n      error: errorMessage,\r\n    });\r\n\r\n    // Check if threshold reached\r\n    if (this.consecutiveErrors >= this.config.errorThreshold) {\r\n      this.trip();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trip the circuit (move to OPEN state)\r\n   */\r\n  private trip(): void {\r\n    if (this.state === CircuitState.OPEN) {\r\n      return; // Already open\r\n    }\r\n\r\n    this.state = CircuitState.OPEN;\r\n    this.tripCount++;\r\n    this.tripTime = Date.now();\r\n\r\n    this.logger.error('[CircuitBreaker] âš ï¸ CIRCUIT TRIPPED - Operations paused', {\r\n      consecutiveErrors: this.consecutiveErrors,\r\n      tripCount: this.tripCount,\r\n      cooldownMs: this.config.cooldownMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Manually close the circuit (reset)\r\n   */\r\n  reset(): void {\r\n    this.logger.info('[CircuitBreaker] Manual reset');\r\n    this.state = CircuitState.CLOSED;\r\n    this.consecutiveErrors = 0;\r\n    this.tripTime = null;\r\n  }\r\n\r\n  /**\r\n   * Get current circuit breaker statistics\r\n   */\r\n  getStats(): CircuitBreakerStats {\r\n    return {\r\n      state: this.state,\r\n      consecutiveErrors: this.consecutiveErrors,\r\n      totalErrors: this.totalErrors,\r\n      totalSuccesses: this.totalSuccesses,\r\n      lastErrorTime: this.lastErrorTime,\r\n      lastSuccessTime: this.lastSuccessTime,\r\n      tripCount: this.tripCount,\r\n      tripTime: this.tripTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get error history\r\n   */\r\n  getErrorHistory(): { timestamp: number; error: string }[] {\r\n    return [...this.errorHistory];\r\n  }\r\n\r\n  /**\r\n   * Get circuit state\r\n   */\r\n  getState(): CircuitState {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Check if cooldown period has passed (circuit can move to HALF_OPEN)\r\n   */\r\n  canAttemptRecovery(): boolean {\r\n    if (this.state !== CircuitState.OPEN) {\r\n      return false;\r\n    }\r\n\r\n    const now = Date.now();\r\n    const timeSinceTrip = this.tripTime ? now - this.tripTime : 0;\r\n    return timeSinceTrip >= this.config.cooldownMs;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\compound-interest-calculator.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.1.","line":162,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":166,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":166,"endColumn":77}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Compound Interest Calculator Service\r\n *\r\n * Calculates position sizes using compound interest logic to automatically\r\n * scale positions based on account profit while protecting base deposit.\r\n *\r\n * Features:\r\n * - Automatic position scaling based on profit\r\n * - Base deposit protection (never fully risked)\r\n * - Profit locking (portion of profit is protected)\r\n * - Configurable reinvestment percentage\r\n * - Risk limits per trade\r\n *\r\n * Example Usage:\r\n * ```typescript\r\n * const calculator = new CompoundInterestCalculatorService(config, logger, bybitService);\r\n * const result = await calculator.calculatePositionSize();\r\n * console.log(`Position size: ${result.positionSize} USDT`);\r\n * ```\r\n */\r\n\r\nimport { CompoundInterestConfig, LoggerService } from '../types';\r\nimport {\r\n  calculateCompoundPositionSize,\r\n  validateCompoundConfig,\r\n  CompoundCalculationResult,\r\n} from '../utils/compound-interest.helpers';\r\n\r\nexport class CompoundInterestCalculatorService {\r\n  constructor(\r\n    private config: CompoundInterestConfig,\r\n    private logger: LoggerService,\r\n    private getBalance: () => Promise<number>, // Function to get current balance from exchange\r\n  ) {\r\n    // Validate config on initialization\r\n    try {\r\n      validateCompoundConfig(config);\r\n      this.logger.info('âœ… CompoundInterestCalculator initialized', {\r\n        enabled: config.enabled,\r\n        baseDeposit: config.baseDeposit,\r\n        reinvestmentPercent: config.reinvestmentPercent,\r\n        profitLockPercent: config.profitLockPercent,\r\n        minSize: config.minPositionSize,\r\n        maxSize: config.maxPositionSize,\r\n      });\r\n    } catch (error: unknown) {\r\n      this.logger.error('âŒ Invalid CompoundInterest config', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate position size based on current balance and compound interest rules\r\n   *\r\n   * @returns Calculation result with position size and breakdown\r\n   */\r\n  async calculatePositionSize(): Promise<CompoundCalculationResult> {\r\n    try {\r\n      // Get current balance from exchange\r\n      const currentBalance = await this.getBalance();\r\n\r\n      this.logger.debug('Calculating compound position size', {\r\n        currentBalance,\r\n        baseDeposit: this.config.baseDeposit,\r\n      });\r\n\r\n      // Calculate using helpers\r\n      const result = calculateCompoundPositionSize(currentBalance, this.config);\r\n\r\n      // Log result\r\n      this.logCalculationResult(result);\r\n\r\n      return result;\r\n    } catch (error: unknown) {\r\n      this.logger.error('Error calculating compound position size', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  getConfig(): CompoundInterestConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update configuration (useful for dynamic adjustments)\r\n   *\r\n   * @param newConfig - New configuration\r\n   */\r\n  updateConfig(newConfig: Partial<CompoundInterestConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n\r\n    try {\r\n      validateCompoundConfig(this.config);\r\n      this.logger.info('âœ… CompoundInterest config updated', {\r\n        enabled: this.config.enabled,\r\n        reinvestmentPercent: this.config.reinvestmentPercent,\r\n      });\r\n    } catch (error: unknown) {\r\n      this.logger.error('âŒ Invalid config update', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if compound interest is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get position size without making API call (for testing/simulation)\r\n   *\r\n   * @param currentBalance - Balance to use for calculation\r\n   * @returns Calculation result\r\n   */\r\n  calculatePositionSizeSync(currentBalance: number): CompoundCalculationResult {\r\n    return calculateCompoundPositionSize(currentBalance, this.config);\r\n  }\r\n\r\n  /**\r\n   * Estimate future position size after a profit/loss\r\n   *\r\n   * @param currentBalance - Current balance\r\n   * @param estimatedPnL - Expected profit or loss\r\n   * @returns Estimated position size after PnL\r\n   */\r\n  estimateFuturePositionSize(currentBalance: number, estimatedPnL: number): number {\r\n    const futureBalance = currentBalance + estimatedPnL;\r\n    const result = calculateCompoundPositionSize(futureBalance, this.config);\r\n    return result.positionSize;\r\n  }\r\n\r\n  /**\r\n   * Calculate potential growth from current position\r\n   *\r\n   * @param currentBalance - Current balance\r\n   * @returns Growth metrics\r\n   */\r\n  calculateGrowthMetrics(currentBalance: number): {\r\n    currentSize: number;\r\n    profitToNextLevel: number; // How much profit needed to increase position by 10%\r\n    maxPossibleSize: number;\r\n    growthFactor: number; // Current size / min size\r\n  } {\r\n    const currentResult = calculateCompoundPositionSize(currentBalance, this.config);\r\n\r\n    // Calculate profit needed for 10% position increase\r\n    const targetSize = currentResult.positionSize * 1.1;\r\n    let profitNeeded = 0;\r\n\r\n    // Binary search for required profit\r\n    for (let profit = 0; profit < this.config.maxPositionSize; profit += 0.1) {\r\n      const testBalance = currentBalance + profit;\r\n      const testResult = calculateCompoundPositionSize(testBalance, this.config);\r\n      if (testResult.positionSize >= targetSize) {\r\n        profitNeeded = profit;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return {\r\n      currentSize: currentResult.positionSize,\r\n      profitToNextLevel: profitNeeded,\r\n      maxPossibleSize: this.config.maxPositionSize,\r\n      growthFactor: currentResult.positionSize / this.config.minPositionSize,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Log calculation result with appropriate level\r\n   */\r\n  private logCalculationResult(result: CompoundCalculationResult): void {\r\n    const {\r\n      positionSize,\r\n      currentBalance,\r\n      totalProfit,\r\n      lockedProfit,\r\n      protectionActive,\r\n      limitApplied,\r\n    } = result;\r\n\r\n    const logData = {\r\n      positionSize: positionSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n      currentBalance: currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      totalProfit: totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\r\n      lockedProfit: lockedProfit.toFixed(DECIMAL_PLACES.PERCENT),\r\n      protectionActive,\r\n      limitApplied,\r\n      growthFactor: (positionSize / this.config.minPositionSize).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n    };\r\n\r\n    if (protectionActive) {\r\n      this.logger.warn('ðŸ›¡ï¸ Deposit protection ACTIVE', logData);\r\n    } else if (limitApplied !== 'none') {\r\n      this.logger.info(`âš ï¸ Position limit applied: ${limitApplied}`, logData);\r\n    } else {\r\n      this.logger.debug('ðŸ’° Compound position calculated', logData);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\confirmation-filter.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":38,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":38,"endColumn":54,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1054,1099],"text":"(this.config.strategy.btcConfirmation?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1054,1099],"text":"(this.config.strategy.btcConfirmation?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":62,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":62,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1841,1858],"text":"(this.btcAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":62,"column":31,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":62,"endColumn":76,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1863,1908],"text":"((this.config.strategy.btcConfirmation?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[1862,1908],"text":"((this.config.strategy.btcConfirmation?.enabled) === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":73,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":73,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2141,2153],"text":"btcAnalysis == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":128,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":128,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3926,3943],"text":"(this.btcAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":128,"column":31,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":128,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3947,3984],"text":"(this.config.strategy.btcConfirmation == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":148,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":148,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":155,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":155,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4724,4748],"text":"btcConfig.useCorrelation ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4724,4748],"text":"btcConfig.useCorrelation === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":157,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":157,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4804,4831],"text":"(btcConfig.correlationPeriod != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4804,4831],"text":"(btcConfig.correlationPeriod ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4804,4831],"text":"(Boolean(btcConfig.correlationPeriod))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":157,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":157,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4832,4834],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":157,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":157,"endColumn":70}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Confirmation Filter Service\r\n *\r\n * Filters signals based on BTC confirmation:\r\n * - Fetches BTC candles\r\n * - Analyzes BTC direction/momentum\r\n * - Checks alignment with signal direction\r\n * - Returns confirmation result\r\n *\r\n * Extracted from SignalGeneratorService for better testability.\r\n */\r\n\r\nimport {\r\n  SignalDirection,\r\n  Config,\r\n  Candle,\r\n  LoggerService,\r\n  ConfirmationResult,\r\n  BTCAnalysis,\r\n} from '../types';\r\nimport { BTCAnalyzer } from '../analyzers/btc.analyzer';\r\nimport { BybitService } from './bybit';\r\n\r\n// ============================================================================\r\n// CONFIRMATION FILTER SERVICE\r\n// ============================================================================\r\n\r\nexport class ConfirmationFilter {\r\n  private btcAnalyzer: BTCAnalyzer | null = null;\r\n\r\n  constructor(\r\n    private bybitService: BybitService,\r\n    private config: Config,\r\n    private logger: LoggerService,\r\n  ) {\r\n    // Initialize BTC analyzer if enabled\r\n    if (this.config.strategy.btcConfirmation?.enabled) {\r\n      this.btcAnalyzer = new BTCAnalyzer(\r\n        this.config.strategy.btcConfirmation,\r\n        this.logger,\r\n      );\r\n      this.logger.info('BTC confirmation filter enabled', {\r\n        symbol: this.config.strategy.btcConfirmation.symbol,\r\n        timeframe: this.config.strategy.btcConfirmation.timeframe,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Confirm signal based on BTC analysis\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param altSymbol - Altcoin symbol for correlation\r\n   * @returns Confirmation result with BTC analysis\r\n   */\r\n  async confirm(\r\n    direction: SignalDirection,\r\n    altSymbol: string,\r\n  ): Promise<ConfirmationResult> {\r\n    // If BTC confirmation disabled, always confirm\r\n    if (!this.btcAnalyzer || !this.config.strategy.btcConfirmation?.enabled) {\r\n      return {\r\n        shouldConfirm: true,\r\n        reason: 'BTC confirmation disabled',\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Analyze BTC\r\n      const btcAnalysis = await this.analyzeBTC(direction, altSymbol);\r\n\r\n      if (!btcAnalysis) {\r\n        // If BTC analysis fails, fail-open (allow signal)\r\n        this.logger.warn('BTC analysis failed, allowing signal (fail-open)');\r\n        return {\r\n          shouldConfirm: true,\r\n          reason: 'BTC analysis failed (fail-open)',\r\n        };\r\n      }\r\n\r\n      // Check if BTC confirms the signal\r\n      const shouldConfirm = this.btcAnalyzer.shouldConfirm(btcAnalysis);\r\n\r\n      if (shouldConfirm) {\r\n        this.logger.info('âœ… BTC confirmation PASSED', {\r\n          direction,\r\n          btcDirection: btcAnalysis.direction,\r\n          btcMomentum: `${(btcAnalysis.momentum * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          isAligned: btcAnalysis.isAligned,\r\n        });\r\n      } else {\r\n        this.logger.info('âŒ BTC confirmation FAILED - signal blocked', {\r\n          direction,\r\n          btcDirection: btcAnalysis.direction,\r\n          btcMomentum: `${(btcAnalysis.momentum * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          isAligned: btcAnalysis.isAligned,\r\n          reason: btcAnalysis.reason,\r\n        });\r\n      }\r\n\r\n      return {\r\n        shouldConfirm,\r\n        btcAnalysis,\r\n        reason: btcAnalysis.reason,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error in confirmation filter', { error });\r\n      // Fail-open on error\r\n      return {\r\n        shouldConfirm: true,\r\n        reason: 'Error in BTC confirmation (fail-open)',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze BTC movement for signal confirmation\r\n   *\r\n   * @param signalDirection - Direction of the altcoin signal\r\n   * @param altSymbol - Altcoin symbol for correlation\r\n   * @returns BTC analysis or null if failed\r\n   */\r\n  private async analyzeBTC(\r\n    signalDirection: SignalDirection,\r\n    altSymbol: string,\r\n  ): Promise<BTCAnalysis | null> {\r\n    if (!this.btcAnalyzer || !this.config.strategy.btcConfirmation) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const btcConfig = this.config.strategy.btcConfirmation;\r\n\r\n      // Fetch BTC candles\r\n      this.logger.debug('Fetching BTC candles', {\r\n        symbol: btcConfig.symbol,\r\n        timeframe: btcConfig.timeframe,\r\n        limit: btcConfig.candleLimit,\r\n      });\r\n\r\n      const btcCandles = await this.bybitService.getCandles(\r\n        btcConfig.symbol,\r\n        btcConfig.timeframe,\r\n        btcConfig.candleLimit,\r\n      );\r\n\r\n      if (!btcCandles || btcCandles.length === 0) {\r\n        this.logger.warn('Failed to fetch BTC candles');\r\n        return null;\r\n      }\r\n\r\n      // Fetch altcoin candles for correlation (if enabled)\r\n      let altCandles: Candle[] | undefined;\r\n      if (btcConfig.useCorrelation) {\r\n        try {\r\n          const correlationPeriod = btcConfig.correlationPeriod || 50;\r\n          altCandles = await this.bybitService.getCandles(\r\n            altSymbol,\r\n            btcConfig.timeframe,\r\n            correlationPeriod,\r\n          );\r\n        } catch (error) {\r\n          this.logger.warn('Failed to fetch altcoin candles for correlation', { error });\r\n        }\r\n      }\r\n\r\n      // Analyze BTC\r\n      const analysis = this.btcAnalyzer.analyze(btcCandles, signalDirection, altCandles);\r\n\r\n      return analysis;\r\n    } catch (error) {\r\n      this.logger.error('Error analyzing BTC', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\daily-limits.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":69,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":69,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2124,2157],"text":"(this.config.maxDailyProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2124,2157],"text":"(this.config.maxDailyProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2124,2157],"text":"(Boolean(this.config.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":129,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":129,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4052,4085],"text":"(this.config.maxDailyProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4052,4085],"text":"(this.config.maxDailyProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4052,4085],"text":"(Boolean(this.config.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":165,"column":36,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":165,"endColumn":69,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5355,5388],"text":"(this.config.maxDailyProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5355,5388],"text":"(this.config.maxDailyProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5355,5388],"text":"(Boolean(this.config.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Daily Limits Service (PHASE 5)\r\n *\r\n * Protects capital by stopping trading after hitting daily loss limit or profit target.\r\n *\r\n * Features:\r\n * - Daily loss limit (e.g., -5% of starting balance)\r\n * - Daily profit target (optional, e.g., +5% of starting balance)\r\n * - Automatic reset at specified UTC time\r\n * - Emergency stop option (completely halt bot)\r\n *\r\n * Usage:\r\n * 1. Initialize with starting balance at bot startup\r\n * 2. Call onTradeClose() after each trade closes\r\n * 3. Check canTrade() before opening new positions\r\n * 4. System automatically resets stats on new day\r\n */\r\n\r\nimport { DailyLimitsConfig, DailyStats, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// DAILY LIMITS SERVICE\r\n// ============================================================================\r\n\r\nexport class DailyLimitsService {\r\n  private stats: DailyStats;\r\n\r\n  constructor(\r\n    private config: DailyLimitsConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.stats = this.initStats();\r\n  }\r\n\r\n  /**\r\n   * Initialize daily stats\r\n   * @returns New DailyStats object for today\r\n   */\r\n  private initStats(): DailyStats {\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    return {\r\n      date: today,\r\n      startingBalance: 0, // Will be set via setStartingBalance()\r\n      currentBalance: 0,\r\n      realizedPnL: 0,\r\n      maxLossHit: false,\r\n      maxProfitHit: false,\r\n      tradesCount: 0,\r\n      lastResetTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set starting balance for the day\r\n   * Should be called once at bot startup\r\n   *\r\n   * @param balance - Current account balance\r\n   */\r\n  setStartingBalance(balance: number): void {\r\n    this.stats.startingBalance = balance;\r\n    this.stats.currentBalance = balance;\r\n\r\n    this.logger.info('ðŸ“Š Daily limits initialized (PHASE 5)', {\r\n      date: this.stats.date,\r\n      startingBalance: balance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      maxLoss: `-${this.config.maxDailyLossPercent}%`,\r\n      maxProfit: this.config.maxDailyProfitPercent\r\n        ? `+${this.config.maxDailyProfitPercent}%`\r\n        : 'disabled',\r\n      emergencyStop: this.config.emergencyStopOnLimit,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update stats after trade close\r\n   * Call this after each position closes\r\n   *\r\n   * @param pnl - Realized PnL from the trade\r\n   * @param newBalance - New account balance after trade\r\n   */\r\n  onTradeClose(pnl: number, newBalance: number): void {\r\n    this.stats.currentBalance = newBalance;\r\n    this.stats.realizedPnL += pnl;\r\n    this.stats.tradesCount++;\r\n\r\n    this.logger.debug('Daily limits updated', {\r\n      pnl: pnl.toFixed(DECIMAL_PLACES.PERCENT),\r\n      totalPnL: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n      balance: newBalance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      tradesCount: this.stats.tradesCount,\r\n    });\r\n\r\n    this.checkLimits();\r\n  }\r\n\r\n  /**\r\n   * Check if daily limits exceeded\r\n   * Triggers emergency stop if configured\r\n   */\r\n  private checkLimits(): void {\r\n    if (this.stats.startingBalance === 0) {\r\n      this.logger.warn('Starting balance not set - cannot check limits');\r\n      return;\r\n    }\r\n\r\n    const pnlPercent = (this.stats.realizedPnL / this.stats.startingBalance) * PERCENT_MULTIPLIER;\r\n\r\n    // Check loss limit\r\n    if (pnlPercent <= -this.config.maxDailyLossPercent) {\r\n      this.stats.maxLossHit = true;\r\n\r\n      this.logger.error('ðŸ›‘ DAILY LOSS LIMIT HIT! (PHASE 5)', {\r\n        pnl: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        limit: `-${this.config.maxDailyLossPercent}%`,\r\n        tradesCount: this.stats.tradesCount,\r\n      });\r\n\r\n      if (this.config.emergencyStopOnLimit) {\r\n        this.logger.error('â›” EMERGENCY STOP - Bot shutting down to protect capital');\r\n        process.exit(1); // Stop bot\r\n      }\r\n    }\r\n\r\n    // Check profit target\r\n    if (\r\n      this.config.maxDailyProfitPercent &&\r\n      pnlPercent >= this.config.maxDailyProfitPercent\r\n    ) {\r\n      this.stats.maxProfitHit = true;\r\n\r\n      this.logger.info('âœ… DAILY PROFIT TARGET HIT! (PHASE 5)', {\r\n        pnl: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        target: `+${this.config.maxDailyProfitPercent}%`,\r\n        tradesCount: this.stats.tradesCount,\r\n      });\r\n\r\n      if (this.config.emergencyStopOnLimit) {\r\n        this.logger.info('ðŸŽ¯ Profit target reached - Bot shutting down (success)');\r\n        process.exit(0); // Stop bot (success)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if trading allowed\r\n   * Call before opening new positions\r\n   *\r\n   * @returns Object with allowed flag and optional reason for blocking\r\n   */\r\n  canTrade(): { allowed: boolean; reason?: string } {\r\n    // Check if need reset (new day)\r\n    this.checkReset();\r\n\r\n    if (this.stats.maxLossHit) {\r\n      return {\r\n        allowed: false,\r\n        reason: `Daily loss limit hit (${this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT)} USDT, ${((this.stats.realizedPnL / this.stats.startingBalance) * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT)}%)`,\r\n      };\r\n    }\r\n\r\n    if (this.stats.maxProfitHit && this.config.maxDailyProfitPercent) {\r\n      return {\r\n        allowed: false,\r\n        reason: `Daily profit target hit (+${this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT)} USDT, +${((this.stats.realizedPnL / this.stats.startingBalance) * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT)}%)`,\r\n      };\r\n    }\r\n\r\n    return { allowed: true };\r\n  }\r\n\r\n  /**\r\n   * Check if need to reset stats (new day)\r\n   * Automatically called in canTrade()\r\n   */\r\n  private checkReset(): void {\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    if (this.stats.date !== today) {\r\n      this.logger.info('ðŸ”„ Daily limits reset (new day) (PHASE 5)', {\r\n        previousDate: this.stats.date,\r\n        previousPnL: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        trades: this.stats.tradesCount,\r\n        maxLossHit: this.stats.maxLossHit,\r\n        maxProfitHit: this.stats.maxProfitHit,\r\n      });\r\n\r\n      this.stats = this.initStats();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current daily stats\r\n   * @returns Copy of current stats\r\n   */\r\n  getStats(): DailyStats {\r\n    return { ...this.stats };\r\n  }\r\n\r\n  /**\r\n   * Manually reset stats (for testing)\r\n   * Should not be used in production\r\n   */\r\n  reset(): void {\r\n    this.logger.warn('âš ï¸ Daily limits manually reset');\r\n    this.stats = this.initStats();\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\data-collector.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ParsedMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RECONNECT_DELAY_MS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":113,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":113,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3777,3785],"text":"this.db == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":183,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":183,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5937,5956],"text":"this.databaseWriter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":203,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":203,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6415,6437],"text":"this.orderbookInterval != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":209,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":209,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6600,6619],"text":"this.databaseWriter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":219,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":219,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":222,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":222,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7019,7026],"text":"this.ws != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":228,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":228,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7118,7125],"text":"this.db != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":255,"column":26,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":267,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":264,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":264,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8001,8008],"text":"this.ws != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":2,"message":"'data' may evaluate to '[object Object]' when stringified.","line":271,"column":37,"nodeType":"Identifier","messageId":"baseToString","endLine":271,"endColumn":41},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":278,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":287,"endColumn":8},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'subscribeToStreams' has no 'await' expression.","line":300,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":300,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":301,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":301,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9091,9099],"text":"(this.ws == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'handleWebSocketMessage' has a complexity of 13. Maximum allowed is 10.","line":344,"column":33,"nodeType":"FunctionExpression","messageId":"complex","endLine":413,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":348,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":348,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10508,10515],"text":"parsed == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":368,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":368,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10986,10993],"text":"this.ws != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":445,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":445,"endColumn":34},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (356). Maximum allowed is 300.","line":448,"column":1,"nodeType":null,"messageId":"exceed","endLine":525,"endColumn":1},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'scheduleReconnect' has no 'await' expression.","line":453,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":453,"endColumn":34},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":470,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":470,"endColumn":31,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[13921,13921],"text":"void "},"desc":"Add void operator to ignore."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":486,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":486,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[14290,14304],"text":"(map[timeframe].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[14290,14304],"text":"(map[timeframe] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14290,14304],"text":"(Boolean(map[timeframe]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":497,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":497,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14500,14508],"text":"this.db == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":501,"column":26,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":503,"endColumn":18,"fix":{"range":[14659,14708],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":504,"column":28,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":506,"endColumn":18,"fix":{"range":[14810,14859],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":507,"column":25,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":509,"endColumn":18,"fix":{"range":[14950,14999],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":512,"column":16,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":512,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15033,15052],"text":"((candlesCount?.count) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15033,15052],"text":"((candlesCount?.count) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15033,15052],"text":"(Boolean((candlesCount?.count)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":512,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":512,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15053,15055],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":513,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":513,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15087,15108],"text":"((orderbookCount?.count) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15087,15108],"text":"((orderbookCount?.count) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15087,15108],"text":"(Boolean((orderbookCount?.count)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":513,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":513,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15109,15111],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":514,"column":20,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":514,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15135,15153],"text":"((tradesCount?.count) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15135,15153],"text":"((tradesCount?.count) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15135,15153],"text":"(Boolean((tradesCount?.count)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":514,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":514,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15154,15156],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":31,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\r\n * Data Collector Service (Refactored)\r\n *\r\n * Standalone service for collecting real-time market data for backtesting.\r\n * Collects: candles (multiple timeframes), orderbook snapshots, trade ticks.\r\n *\r\n * REFACTORED: Decomposed into separate components to prevent blocking.\r\n * - WebSocketReceiver: Parse messages (NO AWAIT)\r\n * - DataQueue: In-memory queues with memory limits\r\n * - DatabaseWriter: Batch INSERT operations\r\n * - PingPongHandler: Ping/pong handling\r\n *\r\n * NO TRADING LOGIC - data collection only!\r\n */\r\n\r\nimport sqlite3 from 'sqlite3';\r\nimport { open, Database } from 'sqlite';\r\nimport WebSocket from 'ws';\r\nimport {\r\n  DataCollectionConfig,\r\n  OrderbookSnapshot,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// Import decomposed components\r\nimport { PingPongHandler } from './data-collector/ping-pong.handler';\r\nimport { DataQueue } from './data-collector/data-queue';\r\nimport { DatabaseWriter } from './data-collector/database-writer';\r\nimport { WebSocketReceiver, ParsedMessage } from './data-collector/websocket-receiver';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BYBIT_WS_PUBLIC = 'wss://stream.bybit.com/v5/public/linear';\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst ORDERBOOK_SNAPSHOT_INTERVAL_MS = 5000; // 5s instead of 1s (reduce load)\r\n\r\n// ============================================================================\r\n// SERVICE\r\n// ============================================================================\r\n\r\nexport class DataCollectorService {\r\n  private db: Database | null = null;\r\n  private ws: WebSocket | null = null;\r\n  private orderbookInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts = 0;\r\n  private isConnecting = false;\r\n  private isStopping = false;\r\n\r\n  // Latest orderbook snapshots (in memory)\r\n  private latestOrderbooks: Map<string, { bids: Array<[string, string]>; asks: Array<[string, string]> }> =\r\n    new Map();\r\n\r\n  // Decomposed components\r\n  private pingPongHandler: PingPongHandler;\r\n  private dataQueue: DataQueue;\r\n  private databaseWriter: DatabaseWriter | null = null;\r\n  private receiver: WebSocketReceiver;\r\n\r\n  constructor(\r\n    private config: DataCollectionConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    // Initialize components\r\n    this.pingPongHandler = new PingPongHandler(logger);\r\n    this.dataQueue = new DataQueue(logger);\r\n    this.receiver = new WebSocketReceiver(logger);\r\n  }\r\n\r\n  /**\r\n   * Initialize database and create tables\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      this.logger.info('Initializing Data Collector (Multi-Symbol)', {\r\n        symbols: this.config.symbols,\r\n        symbolCount: this.config.symbols.length,\r\n        timeframes: this.config.timeframes,\r\n        orderbookInterval: this.config.orderbookInterval + 's',\r\n        compression: this.config.database.compression,\r\n      });\r\n\r\n      // Open SQLite database\r\n      this.db = await open({\r\n        filename: this.config.database.path,\r\n        driver: sqlite3.Database,\r\n      });\r\n\r\n      // Create tables\r\n      await this.createTables();\r\n\r\n      // Initialize DatabaseWriter\r\n      this.databaseWriter = new DatabaseWriter(\r\n        this.db,\r\n        this.logger,\r\n        this.config.database.compression,\r\n      );\r\n\r\n      this.logger.info('Database initialized', { path: this.config.database.path });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize database', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create database tables with indexes\r\n   */\r\n  private async createTables(): Promise<void> {\r\n    if (!this.db) {\r\n      throw new Error('Database not initialized');\r\n    }\r\n\r\n    // Candles table\r\n    await this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS candles (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        symbol TEXT NOT NULL,\r\n        timeframe TEXT NOT NULL,\r\n        timestamp INTEGER NOT NULL,\r\n        open REAL NOT NULL,\r\n        high REAL NOT NULL,\r\n        low REAL NOT NULL,\r\n        close REAL NOT NULL,\r\n        volume REAL NOT NULL,\r\n        createdAt INTEGER NOT NULL\r\n      );\r\n      CREATE INDEX IF NOT EXISTS idx_candles_symbol_timeframe_timestamp\r\n        ON candles(symbol, timeframe, timestamp);\r\n      CREATE UNIQUE INDEX IF NOT EXISTS idx_candles_unique\r\n        ON candles(symbol, timeframe, timestamp);\r\n    `);\r\n\r\n    // Orderbook snapshots table (with compression)\r\n    await this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS orderbook_snapshots (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        symbol TEXT NOT NULL,\r\n        timestamp INTEGER NOT NULL,\r\n        bids BLOB NOT NULL,\r\n        asks BLOB NOT NULL,\r\n        createdAt INTEGER NOT NULL\r\n      );\r\n      CREATE INDEX IF NOT EXISTS idx_orderbook_symbol_timestamp\r\n        ON orderbook_snapshots(symbol, timestamp);\r\n    `);\r\n\r\n    // Trade ticks table\r\n    await this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS trade_ticks (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        symbol TEXT NOT NULL,\r\n        timestamp INTEGER NOT NULL,\r\n        price REAL NOT NULL,\r\n        size REAL NOT NULL,\r\n        side TEXT NOT NULL,\r\n        createdAt INTEGER NOT NULL\r\n      );\r\n      CREATE INDEX IF NOT EXISTS idx_trade_ticks_symbol_timestamp\r\n        ON trade_ticks(symbol, timestamp);\r\n    `);\r\n\r\n    this.logger.info('Database tables created');\r\n  }\r\n\r\n  /**\r\n   * Start collecting data (connect WebSocket + start intervals)\r\n   */\r\n  async start(): Promise<void> {\r\n    this.logger.info('Starting Data Collector...');\r\n\r\n    await this.connectWebSocket();\r\n\r\n    // Start orderbook snapshot interval (if enabled)\r\n    if (this.config.collectOrderbook) {\r\n      this.startOrderbookSnapshotInterval();\r\n    }\r\n\r\n    // Start database writer\r\n    if (this.databaseWriter) {\r\n      this.databaseWriter.start(\r\n        () => this.dataQueue.drainCandles(),\r\n        () => this.dataQueue.drainOrderbooks(),\r\n        () => this.dataQueue.drainTicks(),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop collecting data\r\n   */\r\n  async stop(): Promise<void> {\r\n    this.logger.info('Stopping Data Collector...');\r\n    this.isStopping = true;\r\n\r\n    // Stop ping/pong\r\n    this.pingPongHandler.stop();\r\n\r\n    // Stop orderbook interval\r\n    if (this.orderbookInterval) {\r\n      clearInterval(this.orderbookInterval);\r\n      this.orderbookInterval = null;\r\n    }\r\n\r\n    // Stop database writer (will flush remaining data)\r\n    if (this.databaseWriter) {\r\n      await this.databaseWriter.stop(\r\n        () => this.dataQueue.drainCandles(),\r\n        () => this.dataQueue.drainOrderbooks(),\r\n        () => this.dataQueue.drainTicks(),\r\n      );\r\n    }\r\n\r\n    // Wait for any pending operations\r\n    this.logger.info('Waiting for pending operations...');\r\n    await new Promise((resolve) => setTimeout(resolve, 1000));\r\n\r\n    // Close WebSocket\r\n    if (this.ws) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n\r\n    // Close database\r\n    if (this.db) {\r\n      await this.db.close();\r\n      this.db = null;\r\n    }\r\n\r\n    // Clear queues\r\n    this.dataQueue.clear();\r\n\r\n    this.logger.info('Data Collector stopped');\r\n  }\r\n\r\n  /**\r\n   * Connect to Bybit WebSocket and subscribe to streams\r\n   */\r\n  private async connectWebSocket(): Promise<void> {\r\n    if (this.isConnecting) {\r\n      return;\r\n    }\r\n    this.isConnecting = true;\r\n\r\n    try {\r\n      this.logger.info('Connecting to Bybit WebSocket...', { url: BYBIT_WS_PUBLIC });\r\n\r\n      this.ws = new WebSocket(BYBIT_WS_PUBLIC, {\r\n        handshakeTimeout: 10000,\r\n      });\r\n\r\n      this.ws.on('open', async () => {\r\n        this.logger.info('WebSocket connected');\r\n        this.reconnectAttempts = 0;\r\n        this.isConnecting = false;\r\n\r\n        // Subscribe to all streams\r\n        await this.subscribeToStreams();\r\n\r\n        // Start ping/pong handler\r\n        if (this.ws) {\r\n          this.pingPongHandler.start(this.ws);\r\n        }\r\n      });\r\n\r\n      // CRITICAL FIX: Remove await from message handler (fire-and-forget)\r\n      this.ws.on('message', (data: WebSocket.Data) => {\r\n        this.handleWebSocketMessage(data.toString()); // NO AWAIT!\r\n      });\r\n\r\n      this.ws.on('error', (error) => {\r\n        this.logger.error('WebSocket error', { error: error.message });\r\n      });\r\n\r\n      this.ws.on('close', async () => {\r\n        this.logger.warn('WebSocket closed');\r\n        this.isConnecting = false;\r\n\r\n        // Stop ping/pong\r\n        this.pingPongHandler.stop();\r\n\r\n        // Reconnect\r\n        await this.scheduleReconnect();\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to connect WebSocket', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      this.isConnecting = false;\r\n      await this.scheduleReconnect();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to all configured streams (candles, orderbook, trades)\r\n   */\r\n  private async subscribeToStreams(): Promise<void> {\r\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    const subscriptions: string[] = [];\r\n\r\n    // Subscribe to all symbols\r\n    for (const symbol of this.config.symbols) {\r\n      // Subscribe to candles (kline) for all timeframes\r\n      for (const timeframe of this.config.timeframes) {\r\n        const numericInterval = this.toNumericInterval(timeframe);\r\n        subscriptions.push(`kline.${numericInterval}.${symbol}`);\r\n      }\r\n\r\n      // Subscribe to orderbook (50 levels)\r\n      if (this.config.collectOrderbook) {\r\n        subscriptions.push(`orderbook.50.${symbol}`);\r\n      }\r\n\r\n      // Subscribe to trade ticks\r\n      if (this.config.collectTradeTicks) {\r\n        subscriptions.push(`publicTrade.${symbol}`);\r\n      }\r\n    }\r\n\r\n    // Send subscription message\r\n    const subscribeMsg = {\r\n      op: 'subscribe',\r\n      args: subscriptions,\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeMsg));\r\n\r\n    this.logger.info('Subscribed to streams', {\r\n      symbols: this.config.symbols,\r\n      totalSubscriptions: subscriptions.length,\r\n      subscriptionsPerSymbol: subscriptions.length / this.config.symbols.length,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle WebSocket message (NO AWAIT - fire-and-forget)\r\n   */\r\n  private handleWebSocketMessage(data: string): void {\r\n    // Parse message (synchronous operation)\r\n    const parsed = this.receiver.parseMessage(data);\r\n\r\n    if (!parsed) {\r\n      return;\r\n    }\r\n\r\n    // Handle different message types\r\n    switch (parsed.type) {\r\n    case 'subscription':\r\n      if (parsed.success) {\r\n        this.logger.info('âœ… Subscription confirmed', {\r\n          conn_id: parsed.conn_id,\r\n        });\r\n      } else {\r\n        this.logger.error('âŒ Subscription failed', {\r\n          ret_msg: parsed.ret_msg,\r\n          conn_id: parsed.conn_id,\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'server-ping':\r\n      if (this.ws) {\r\n        this.pingPongHandler.handleServerPing(this.ws, { op: 'ping', args: parsed.args });\r\n      }\r\n      break;\r\n\r\n    case 'pong':\r\n      this.pingPongHandler.handlePong({ op: parsed.op });\r\n      break;\r\n\r\n    case 'candle':\r\n      // Add to queue (NO AWAIT!)\r\n      this.dataQueue.addCandle(parsed.candle);\r\n\r\n      // Log 1m candles for monitoring\r\n      if (parsed.candle.timeframe === '1m') {\r\n        this.logger.info('ðŸ• 1m Candle received', {\r\n          symbol: parsed.candle.symbol,\r\n          timestamp: new Date(parsed.candle.timestamp).toISOString(),\r\n          close: parsed.candle.close,\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'orderbook':\r\n      // Store latest orderbook in memory (will be saved by interval)\r\n      this.latestOrderbooks.set(parsed.symbol, {\r\n        bids: parsed.bids,\r\n        asks: parsed.asks,\r\n      });\r\n      break;\r\n\r\n    case 'trade-ticks':\r\n      // Add ticks to queue (NO AWAIT!)\r\n      for (const tick of parsed.ticks) {\r\n        this.dataQueue.addTick(tick);\r\n      }\r\n      break;\r\n\r\n    case 'unhandled':\r\n      this.logger.warn('âš ï¸ Unhandled message', {\r\n        op: parsed.op,\r\n        keys: parsed.keys,\r\n      });\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start orderbook snapshot interval (save every N seconds)\r\n   */\r\n  private startOrderbookSnapshotInterval(): void {\r\n    const intervalMs = ORDERBOOK_SNAPSHOT_INTERVAL_MS;\r\n\r\n    this.orderbookInterval = setInterval(() => {\r\n      // Add orderbook snapshots to queue (NO AWAIT!)\r\n      for (const [symbol, orderbook] of this.latestOrderbooks) {\r\n        const snapshot: OrderbookSnapshot = {\r\n          symbol: symbol,\r\n          timestamp: Date.now(),\r\n          bids: JSON.stringify(orderbook.bids),\r\n          asks: JSON.stringify(orderbook.asks),\r\n          createdAt: Date.now(),\r\n        };\r\n\r\n        this.dataQueue.addOrderbook(snapshot);\r\n      }\r\n\r\n      // Log stats\r\n      if (this.latestOrderbooks.size > 0) {\r\n        this.logger.debug('Orderbook snapshots queued', {\r\n          symbols: Array.from(this.latestOrderbooks.keys()),\r\n          count: this.latestOrderbooks.size,\r\n        });\r\n      }\r\n    }, intervalMs);\r\n\r\n    this.logger.info('Orderbook snapshot interval started', {\r\n      interval: intervalMs / 1000 + 's',\r\n      symbols: this.config.symbols,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Schedule reconnect with exponential backoff\r\n   */\r\n  private async scheduleReconnect(): Promise<void> {\r\n    if (this.reconnectAttempts >= this.config.websocket.maxReconnectAttempts) {\r\n      this.logger.error('Max reconnect attempts reached', {\r\n        attempts: this.reconnectAttempts,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.reconnectAttempts++;\r\n    const delay = this.config.websocket.reconnectDelay * this.reconnectAttempts;\r\n\r\n    this.logger.info('Scheduling reconnect', {\r\n      attempt: this.reconnectAttempts,\r\n      delay: delay + 'ms',\r\n    });\r\n\r\n    setTimeout(() => {\r\n      this.connectWebSocket();\r\n    }, delay);\r\n  }\r\n\r\n  /**\r\n   * Convert timeframe to numeric interval for Bybit v5 subscriptions\r\n   */\r\n  private toNumericInterval(timeframe: string): string {\r\n    const map: Record<string, string> = {\r\n      '1m': '1',\r\n      '5m': '5',\r\n      '15m': '15',\r\n      '30m': '30',\r\n      '1h': '60',\r\n      '4h': '240',\r\n    };\r\n    return map[timeframe] || timeframe;\r\n  }\r\n\r\n  /**\r\n   * Get database statistics\r\n   */\r\n  async getStats(): Promise<{\r\n    candles: number;\r\n    orderbook_snapshots: number;\r\n    trade_ticks: number;\r\n  }> {\r\n    if (!this.db) {\r\n      throw new Error('Database not initialized');\r\n    }\r\n\r\n    const candlesCount = (await this.db.get('SELECT COUNT(*) as count FROM candles')) as\r\n      | { count: number }\r\n      | undefined;\r\n    const orderbookCount = (await this.db.get('SELECT COUNT(*) as count FROM orderbook_snapshots')) as\r\n      | { count: number }\r\n      | undefined;\r\n    const tradesCount = (await this.db.get('SELECT COUNT(*) as count FROM trade_ticks')) as\r\n      | { count: number }\r\n      | undefined;\r\n\r\n    return {\r\n      candles: candlesCount?.count || 0,\r\n      orderbook_snapshots: orderbookCount?.count || 0,\r\n      trade_ticks: tradesCount?.count || 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get queue sizes (for monitoring)\r\n   */\r\n  getQueueSizes(): { candles: number; orderbooks: number; ticks: number } {\r\n    return this.dataQueue.getSizes();\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\data-collector\\data-queue.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":41,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":41,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":53,"column":83,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":87},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":67,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":67,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":78,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":78,"endColumn":93},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":92,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":92,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":103,"column":79,"nodeType":"Literal","messageId":"noMagic","endLine":103,"endColumn":83}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DataQueue\r\n *\r\n * In-memory queues for candles, orderbook, and trade ticks.\r\n * Implements memory limits to prevent memory leaks.\r\n */\r\n\r\nimport { CandleRecord, OrderbookSnapshot, TradeTickRecord, LoggerService } from '../../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_QUEUE_SIZE = 10000; // Max items per queue (prevent memory leaks)\r\nconst WARN_QUEUE_SIZE = 5000; // Warn when queue grows too large\r\n\r\n// ============================================================================\r\n// QUEUE\r\n// ============================================================================\r\n\r\nexport class DataQueue {\r\n  private candlesQueue: CandleRecord[] = [];\r\n  private orderbooksQueue: OrderbookSnapshot[] = [];\r\n  private ticksQueue: TradeTickRecord[] = [];\r\n\r\n  private droppedCandles = 0;\r\n  private droppedOrderbooks = 0;\r\n  private droppedTicks = 0;\r\n\r\n  constructor(\r\n    private logger: LoggerService,\r\n    private maxQueueSize: number = MAX_QUEUE_SIZE,\r\n  ) {}\r\n\r\n  /**\r\n   * Add candle to queue (with memory limit)\r\n   */\r\n  addCandle(candle: CandleRecord): void {\r\n    if (this.candlesQueue.length >= this.maxQueueSize) {\r\n      this.droppedCandles++;\r\n      if (this.droppedCandles % 100 === 1) {\r\n        this.logger.warn('âš ï¸ Candles queue full - dropping data', {\r\n          queueSize: this.candlesQueue.length,\r\n          dropped: this.droppedCandles,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.candlesQueue.push(candle);\r\n\r\n    // Warn if queue is growing too large\r\n    if (this.candlesQueue.length >= WARN_QUEUE_SIZE && this.candlesQueue.length % 1000 === 0) {\r\n      this.logger.warn('âš ï¸ Candles queue is growing', {\r\n        queueSize: this.candlesQueue.length,\r\n        maxSize: this.maxQueueSize,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add orderbook snapshot to queue (with memory limit)\r\n   */\r\n  addOrderbook(orderbook: OrderbookSnapshot): void {\r\n    if (this.orderbooksQueue.length >= this.maxQueueSize) {\r\n      this.droppedOrderbooks++;\r\n      if (this.droppedOrderbooks % 100 === 1) {\r\n        this.logger.warn('âš ï¸ Orderbooks queue full - dropping data', {\r\n          queueSize: this.orderbooksQueue.length,\r\n          dropped: this.droppedOrderbooks,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.orderbooksQueue.push(orderbook);\r\n\r\n    if (this.orderbooksQueue.length >= WARN_QUEUE_SIZE && this.orderbooksQueue.length % 1000 === 0) {\r\n      this.logger.warn('âš ï¸ Orderbooks queue is growing', {\r\n        queueSize: this.orderbooksQueue.length,\r\n        maxSize: this.maxQueueSize,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add trade tick to queue (with memory limit)\r\n   */\r\n  addTick(tick: TradeTickRecord): void {\r\n    if (this.ticksQueue.length >= this.maxQueueSize) {\r\n      this.droppedTicks++;\r\n      if (this.droppedTicks % 100 === 1) {\r\n        this.logger.warn('âš ï¸ Ticks queue full - dropping data', {\r\n          queueSize: this.ticksQueue.length,\r\n          dropped: this.droppedTicks,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    this.ticksQueue.push(tick);\r\n\r\n    if (this.ticksQueue.length >= WARN_QUEUE_SIZE && this.ticksQueue.length % 1000 === 0) {\r\n      this.logger.warn('âš ï¸ Ticks queue is growing', {\r\n        queueSize: this.ticksQueue.length,\r\n        maxSize: this.maxQueueSize,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Drain candles queue (return all and clear)\r\n   */\r\n  drainCandles(): CandleRecord[] {\r\n    const candles = this.candlesQueue;\r\n    this.candlesQueue = [];\r\n    return candles;\r\n  }\r\n\r\n  /**\r\n   * Drain orderbooks queue (return all and clear)\r\n   */\r\n  drainOrderbooks(): OrderbookSnapshot[] {\r\n    const orderbooks = this.orderbooksQueue;\r\n    this.orderbooksQueue = [];\r\n    return orderbooks;\r\n  }\r\n\r\n  /**\r\n   * Drain ticks queue (return all and clear)\r\n   */\r\n  drainTicks(): TradeTickRecord[] {\r\n    const ticks = this.ticksQueue;\r\n    this.ticksQueue = [];\r\n    return ticks;\r\n  }\r\n\r\n  /**\r\n   * Get queue sizes\r\n   */\r\n  getSizes(): { candles: number; orderbooks: number; ticks: number } {\r\n    return {\r\n      candles: this.candlesQueue.length,\r\n      orderbooks: this.orderbooksQueue.length,\r\n      ticks: this.ticksQueue.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get dropped counts (memory overflow protection)\r\n   */\r\n  getDroppedCounts(): { candles: number; orderbooks: number; ticks: number } {\r\n    return {\r\n      candles: this.droppedCandles,\r\n      orderbooks: this.droppedOrderbooks,\r\n      ticks: this.droppedTicks,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all queues (for shutdown)\r\n   */\r\n  clear(): void {\r\n    this.candlesQueue = [];\r\n    this.orderbooksQueue = [];\r\n    this.ticksQueue = [];\r\n    this.logger.info('All queues cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\data-collector\\database-writer.ts","messages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":45,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":80,"endColumn":6},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":95,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":95,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2839,2857],"text":"this.writeInterval != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * DatabaseWriter\r\n *\r\n * Batch INSERT operations for SQLite database.\r\n * Writes data in batches to avoid blocking WebSocket message processing.\r\n */\r\n\r\nimport { Database } from 'sqlite';\r\nimport * as zlib from 'zlib';\r\nimport { promisify } from 'util';\r\nimport { CandleRecord, OrderbookSnapshot, TradeTickRecord, LoggerService } from '../../types';\r\n\r\nconst gzip = promisify(zlib.gzip);\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BATCH_WRITE_INTERVAL_MS = 5000; // Write every 5 seconds\r\nconst MAX_BATCH_SIZE = 1000; // Max items per batch INSERT\r\n\r\n// ============================================================================\r\n// WRITER\r\n// ============================================================================\r\n\r\nexport class DatabaseWriter {\r\n  private writeInterval: NodeJS.Timeout | null = null;\r\n  private isStopping = false;\r\n\r\n  constructor(\r\n    private db: Database,\r\n    private logger: LoggerService,\r\n    private compression: boolean = true,\r\n    private batchIntervalMs: number = BATCH_WRITE_INTERVAL_MS,\r\n  ) {}\r\n\r\n  /**\r\n   * Start batch writing interval\r\n   */\r\n  start(\r\n    drainCandles: () => CandleRecord[],\r\n    drainOrderbooks: () => OrderbookSnapshot[],\r\n    drainTicks: () => TradeTickRecord[],\r\n  ): void {\r\n    this.writeInterval = setInterval(async () => {\r\n      if (this.isStopping) {\r\n        return;\r\n      }\r\n\r\n      try {\r\n        // Drain queues\r\n        const candles = drainCandles();\r\n        const orderbooks = drainOrderbooks();\r\n        const ticks = drainTicks();\r\n\r\n        // Write batches\r\n        if (candles.length > 0) {\r\n          await this.writeCandlesBatch(candles);\r\n        }\r\n        if (orderbooks.length > 0) {\r\n          await this.writeOrderbooksBatch(orderbooks);\r\n        }\r\n        if (ticks.length > 0) {\r\n          await this.writeTicksBatch(ticks);\r\n        }\r\n\r\n        // Log stats\r\n        if (candles.length > 0 || orderbooks.length > 0 || ticks.length > 0) {\r\n          this.logger.debug('âœ… Batch written to DB', {\r\n            candles: candles.length,\r\n            orderbooks: orderbooks.length,\r\n            ticks: ticks.length,\r\n          });\r\n        }\r\n      } catch (error) {\r\n        this.logger.error('Failed to write batch', {\r\n          error: error instanceof Error ? error.message : String(error),\r\n        });\r\n      }\r\n    }, this.batchIntervalMs);\r\n\r\n    this.logger.info('Database writer started', { intervalMs: this.batchIntervalMs });\r\n  }\r\n\r\n  /**\r\n   * Stop batch writing\r\n   */\r\n  async stop(\r\n    drainCandles: () => CandleRecord[],\r\n    drainOrderbooks: () => OrderbookSnapshot[],\r\n    drainTicks: () => TradeTickRecord[],\r\n  ): Promise<void> {\r\n    this.isStopping = true;\r\n\r\n    if (this.writeInterval) {\r\n      clearInterval(this.writeInterval);\r\n      this.writeInterval = null;\r\n    }\r\n\r\n    // Final write - drain remaining data\r\n    this.logger.info('Writing remaining data before shutdown...');\r\n    try {\r\n      const candles = drainCandles();\r\n      const orderbooks = drainOrderbooks();\r\n      const ticks = drainTicks();\r\n\r\n      if (candles.length > 0) {\r\n        await this.writeCandlesBatch(candles);\r\n      }\r\n      if (orderbooks.length > 0) {\r\n        await this.writeOrderbooksBatch(orderbooks);\r\n      }\r\n      if (ticks.length > 0) {\r\n        await this.writeTicksBatch(ticks);\r\n      }\r\n\r\n      this.logger.info('âœ… Final batch written', {\r\n        candles: candles.length,\r\n        orderbooks: orderbooks.length,\r\n        ticks: ticks.length,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to write final batch', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write candles batch to database\r\n   */\r\n  private async writeCandlesBatch(candles: CandleRecord[]): Promise<void> {\r\n    if (candles.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Split into chunks if too large\r\n    const chunks = this.chunkArray(candles, MAX_BATCH_SIZE);\r\n\r\n    for (const chunk of chunks) {\r\n      try {\r\n        // Build batch INSERT query\r\n        const placeholders = chunk.map(() => '(?, ?, ?, ?, ?, ?, ?, ?, ?)').join(', ');\r\n        const values = chunk.flatMap((c) => [\r\n          c.symbol,\r\n          c.timeframe,\r\n          c.timestamp,\r\n          c.open,\r\n          c.high,\r\n          c.low,\r\n          c.close,\r\n          c.volume,\r\n          c.createdAt,\r\n        ]);\r\n\r\n        await this.db.run(\r\n          `INSERT OR IGNORE INTO candles (symbol, timeframe, timestamp, open, high, low, close, volume, createdAt)\r\n           VALUES ${placeholders}`,\r\n          values,\r\n        );\r\n      } catch (error) {\r\n        this.logger.error('Failed to write candles batch', {\r\n          error: error instanceof Error ? error.message : String(error),\r\n          chunkSize: chunk.length,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write orderbooks batch to database\r\n   */\r\n  private async writeOrderbooksBatch(orderbooks: OrderbookSnapshot[]): Promise<void> {\r\n    if (orderbooks.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Split into chunks if too large\r\n    const chunks = this.chunkArray(orderbooks, MAX_BATCH_SIZE);\r\n\r\n    for (const chunk of chunks) {\r\n      try {\r\n        // Compress and prepare values\r\n        const valuesPromises = chunk.map(async (ob) => {\r\n          const bidsBuffer = this.compression\r\n            ? await gzip(ob.bids)\r\n            : Buffer.from(ob.bids);\r\n          const asksBuffer = this.compression\r\n            ? await gzip(ob.asks)\r\n            : Buffer.from(ob.asks);\r\n          return [ob.symbol, ob.timestamp, bidsBuffer, asksBuffer, ob.createdAt];\r\n        });\r\n\r\n        const values = await Promise.all(valuesPromises);\r\n\r\n        // Build batch INSERT query\r\n        const placeholders = values.map(() => '(?, ?, ?, ?, ?)').join(', ');\r\n        const flatValues = values.flat();\r\n\r\n        await this.db.run(\r\n          `INSERT INTO orderbook_snapshots (symbol, timestamp, bids, asks, createdAt)\r\n           VALUES ${placeholders}`,\r\n          flatValues,\r\n        );\r\n      } catch (error) {\r\n        this.logger.error('Failed to write orderbooks batch', {\r\n          error: error instanceof Error ? error.message : String(error),\r\n          chunkSize: chunk.length,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write ticks batch to database\r\n   */\r\n  private async writeTicksBatch(ticks: TradeTickRecord[]): Promise<void> {\r\n    if (ticks.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Split into chunks if too large\r\n    const chunks = this.chunkArray(ticks, MAX_BATCH_SIZE);\r\n\r\n    for (const chunk of chunks) {\r\n      try {\r\n        // Build batch INSERT query\r\n        const placeholders = chunk.map(() => '(?, ?, ?, ?, ?, ?)').join(', ');\r\n        const values = chunk.flatMap((t) => [\r\n          t.symbol,\r\n          t.timestamp,\r\n          t.price,\r\n          t.size,\r\n          t.side,\r\n          t.createdAt,\r\n        ]);\r\n\r\n        await this.db.run(\r\n          `INSERT INTO trade_ticks (symbol, timestamp, price, size, side, createdAt)\r\n           VALUES ${placeholders}`,\r\n          values,\r\n        );\r\n      } catch (error) {\r\n        this.logger.error('Failed to write ticks batch', {\r\n          error: error instanceof Error ? error.message : String(error),\r\n          chunkSize: chunk.length,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Split array into chunks\r\n   */\r\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\r\n    const chunks: T[][] = [];\r\n    for (let i = 0; i < array.length; i += chunkSize) {\r\n      chunks.push(array.slice(i, i + chunkSize));\r\n    }\r\n    return chunks;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\data-collector\\ping-pong.handler.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":36,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":36,"endColumn":13},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":43,"column":23,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":43,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":55,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":55,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1647,1664],"text":"this.pingInterval != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":69,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":69,"endColumn":13}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TIME_UNITS } from '../../constants';\r\n/**\r\n * PingPongHandler\r\n *\r\n * Handles WebSocket ping/pong to keep connection alive.\r\n * Separate component to avoid blocking main message processing.\r\n */\r\n\r\nimport WebSocket from 'ws';\r\nimport { LoggerService } from '../../types';\r\nimport { BybitWebSocketMessage } from '../../types/events.types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PING_INTERVAL_MS = 20000;\r\n\r\n// ============================================================================\r\n// HANDLER\r\n// ============================================================================\r\n\r\nexport class PingPongHandler {\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private lastPongTime: number = Date.now();\r\n\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Start ping interval\r\n   */\r\n  start(ws: WebSocket): void {\r\n    this.lastPongTime = Date.now();\r\n\r\n    this.pingInterval = setInterval(() => {\r\n      if (ws && ws.readyState === WebSocket.OPEN) {\r\n        // Bybit V5 requires JSON ping: {\"op\": \"ping\"}\r\n        ws.send(JSON.stringify({ op: 'ping' }));\r\n        this.logger.info('ðŸ“ Sent ping to server');\r\n      } else {\r\n        this.logger.debug('Ping skipped - WebSocket not open', {\r\n          readyState: ws?.readyState,\r\n          wsExists: !!ws,\r\n        });\r\n      }\r\n    }, PING_INTERVAL_MS);\r\n\r\n    this.logger.info('Ping interval started', { intervalMs: PING_INTERVAL_MS });\r\n  }\r\n\r\n  /**\r\n   * Stop ping interval\r\n   */\r\n  stop(): void {\r\n    if (this.pingInterval) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n      this.logger.info('Ping interval stopped');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle server-initiated ping (Bybit V5 format)\r\n   * Server sends: {\"op\": \"ping\", \"args\": [\"timestamp\"]}\r\n   * We must respond: {\"op\": \"pong\", \"args\": [\"timestamp\"]}\r\n   */\r\n  handleServerPing(ws: WebSocket, message: BybitWebSocketMessage): void {\r\n    if (message.op === 'ping' && Array.isArray(message.args)) {\r\n      if (ws && ws.readyState === WebSocket.OPEN) {\r\n        ws.send(JSON.stringify({ op: 'pong', args: message.args }));\r\n        this.logger.info('â†©ï¸ Server ping received, sent pong', { args: message.args });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pong from server (response to our client-initiated ping)\r\n   * Linear/Inverse: {\"success\": true, \"ret_msg\": \"pong\", \"op\": \"ping\"}\r\n   * Private: {\"op\": \"pong\", \"args\": [...]}\r\n   */\r\n  handlePong(message: BybitWebSocketMessage): void {\r\n    if (message.op === 'pong' || (message.op === 'ping' && message.ret_msg === 'pong')) {\r\n      this.lastPongTime = Date.now();\r\n      this.logger.info('âœ… Pong received from server', { op: message.op });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if connection is alive (received pong recently)\r\n   */\r\n  isConnectionAlive(maxSilenceMs: number = TIME_UNITS.MINUTE): boolean {\r\n    const silenceMs = Date.now() - this.lastPongTime;\r\n    return silenceMs < maxSilenceMs;\r\n  }\r\n\r\n  /**\r\n   * Get last pong time\r\n   */\r\n  getLastPongTime(): number {\r\n    return this.lastPongTime;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\data-collector\\websocket-receiver.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ServerPingMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'BybitWebSocketMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":50},{"ruleId":"complexity","severity":1,"message":"Method 'parseMessage' has a complexity of 15. Maximum allowed is 10.","line":73,"column":15,"nodeType":"FunctionExpression","messageId":"complex","endLine":127,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":88,"column":36,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":88,"endColumn":48,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2331,2343],"text":"(Boolean(message.args))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of type any[] to a variable of type string[].","line":91,"column":11,"nodeType":"Property","messageId":"unsafeAssignment","endLine":91,"endColumn":64},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":104,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":104,"endColumn":24,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2744,2757],"text":"Boolean(message.topic)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":123,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":123,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":227,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":227,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[6269,6283],"text":"(map[timeframe].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[6269,6283],"text":"(map[timeframe] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6269,6283],"text":"(Boolean(map[timeframe]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WebSocketReceiver\r\n *\r\n * Receives and parses WebSocket messages from Bybit.\r\n * NO AWAIT operations - fire-and-forget to prevent blocking.\r\n */\r\n\r\nimport { CandleRecord, TradeTickRecord, LoggerService } from '../../types';\r\nimport { ServerPingMessage, BybitWebSocketMessage } from '../../types/events.types';\r\n\r\n// ============================================================================\r\n// INTERFACES (Bybit V5 format)\r\n// ============================================================================\r\n\r\ninterface BybitKlineData {\r\n  topic: string;\r\n  type: string;\r\n  data: Array<{\r\n    start: number;\r\n    end: number;\r\n    interval: string;\r\n    open: string;\r\n    close: string;\r\n    high: string;\r\n    low: string;\r\n    volume: string;\r\n    turnover: string;\r\n    confirm: boolean;\r\n    timestamp: number;\r\n  }>;\r\n  ts: number;\r\n}\r\n\r\ninterface BybitOrderbookData {\r\n  topic: string;\r\n  type: string;\r\n  data: {\r\n    s: string; // symbol\r\n    b: Array<[string, string]>; // bids [[price, size], ...]\r\n    a: Array<[string, string]>; // asks [[price, size], ...]\r\n    u: number; // update id\r\n    seq: number;\r\n  };\r\n  ts: number;\r\n}\r\n\r\ninterface BybitTradeData {\r\n  topic: string;\r\n  type: string;\r\n  data: Array<{\r\n    T: number; // timestamp\r\n    s: string; // symbol\r\n    S: 'Buy' | 'Sell'; // side\r\n    v: string; // volume\r\n    p: string; // price\r\n    L: string; // trade direction\r\n    i: string; // trade id\r\n    BT: boolean;\r\n  }>;\r\n  ts: number;\r\n}\r\n\r\n// ============================================================================\r\n// RECEIVER\r\n// ============================================================================\r\n\r\nexport class WebSocketReceiver {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Parse WebSocket message (NO AWAIT - returns data synchronously)\r\n   */\r\n  parseMessage(data: string): ParsedMessage | null {\r\n    try {\r\n      const message = JSON.parse(data) as Record<string, unknown>;\r\n\r\n      // Subscription response\r\n      if (message.op === 'subscribe') {\r\n        return {\r\n          type: 'subscription',\r\n          success: message.success === true,\r\n          conn_id: String(message.conn_id ?? ''),\r\n          ret_msg: message.ret_msg as string | undefined,\r\n        };\r\n      }\r\n\r\n      // Server-initiated ping\r\n      if (message.op === 'ping' && message.args) {\r\n        return {\r\n          type: 'server-ping',\r\n          args: Array.isArray(message.args) ? message.args : [],\r\n        };\r\n      }\r\n\r\n      // Pong from server\r\n      if (message.op === 'pong' || (message.op === 'ping' && message.ret_msg === 'pong')) {\r\n        return {\r\n          type: 'pong',\r\n          op: message.op as string,\r\n        };\r\n      }\r\n\r\n      // Data messages\r\n      if (message.topic) {\r\n        if ((message.topic as string).startsWith('kline.')) {\r\n          return this.parseKlineData(message as unknown as BybitKlineData);\r\n        } else if ((message.topic as string).startsWith('orderbook.')) {\r\n          return this.parseOrderbookData(message as unknown as BybitOrderbookData);\r\n        } else if ((message.topic as string).startsWith('publicTrade.')) {\r\n          return this.parseTradeData(message as unknown as BybitTradeData);\r\n        }\r\n      }\r\n\r\n      // Unhandled message\r\n      return {\r\n        type: 'unhandled',\r\n        op: message.op as string | undefined,\r\n        keys: Object.keys(message).join(','),\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse WebSocket message', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n        data: data.substring(0, 200),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse kline (candle) data\r\n   */\r\n  private parseKlineData(data: BybitKlineData): ParsedMessage | null {\r\n    try {\r\n      const kline = data.data[0];\r\n      const topicParts = data.topic.split('.'); // \"kline.1.APEXUSDT\"\r\n      const timeframe = this.normalizeTimeframe(topicParts[1]);\r\n      const symbol = topicParts[2];\r\n\r\n      // Only save confirmed candles (closed candles)\r\n      if (!kline.confirm) {\r\n        return null;\r\n      }\r\n\r\n      const candle: CandleRecord = {\r\n        symbol: symbol,\r\n        timeframe: timeframe,\r\n        timestamp: kline.end, // Use candle CLOSE time\r\n        open: parseFloat(kline.open),\r\n        high: parseFloat(kline.high),\r\n        low: parseFloat(kline.low),\r\n        close: parseFloat(kline.close),\r\n        volume: parseFloat(kline.volume),\r\n        createdAt: Date.now(),\r\n      };\r\n\r\n      return {\r\n        type: 'candle',\r\n        candle: candle,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse kline data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse orderbook data\r\n   */\r\n  private parseOrderbookData(data: BybitOrderbookData): ParsedMessage | null {\r\n    try {\r\n      const symbol = data.data.s;\r\n\r\n      return {\r\n        type: 'orderbook',\r\n        symbol: symbol,\r\n        bids: data.data.b,\r\n        asks: data.data.a,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse orderbook data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse trade tick data\r\n   */\r\n  private parseTradeData(data: BybitTradeData): ParsedMessage | null {\r\n    try {\r\n      const ticks: TradeTickRecord[] = data.data.map((trade) => ({\r\n        symbol: trade.s,\r\n        timestamp: trade.T,\r\n        price: parseFloat(trade.p),\r\n        size: parseFloat(trade.v),\r\n        side: trade.S,\r\n        createdAt: Date.now(),\r\n      }));\r\n\r\n      return {\r\n        type: 'trade-ticks',\r\n        ticks: ticks,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse trade data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize timeframe format (Bybit uses \"1\" for 1m, we use \"1m\")\r\n   */\r\n  private normalizeTimeframe(timeframe: string): string {\r\n    const map: Record<string, string> = {\r\n      '1': '1m',\r\n      '5': '5m',\r\n      '15': '15m',\r\n      '30': '30m',\r\n      '60': '1h',\r\n      '240': '4h',\r\n    };\r\n    return map[timeframe] || timeframe;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport type ParsedMessage =\r\n  | { type: 'subscription'; success: boolean; conn_id: string; ret_msg?: string }\r\n  | { type: 'server-ping'; args: string[] }\r\n  | { type: 'pong'; op: string }\r\n  | { type: 'candle'; candle: CandleRecord }\r\n  | { type: 'orderbook'; symbol: string; bids: Array<[string, string]>; asks: Array<[string, string]> }\r\n  | { type: 'trade-ticks'; ticks: TradeTickRecord[] }\r\n  | { type: 'unhandled'; op?: string; keys: string };\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\delta-analyzer.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DECIMAL_PLACES' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":108,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":108,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":142,"column":8,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":142,"endColumn":35,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[3940,3946],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":143,"column":8,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":143,"endColumn":36,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[4012,4019],"text":"SignalDirection.SHORT"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Delta Analyzer Service\r\n *\r\n * Analyzes buy/sell pressure from tick-by-tick trades.\r\n *\r\n * Delta = Cumulative Buy Volume - Cumulative Sell Volume\r\n *\r\n * Use Cases:\r\n * - Entry confirmation (delta matches signal direction)\r\n * - Divergence detection (price up, delta down = weak rally)\r\n * - Reversal signals (delta flip)\r\n *\r\n * Data Source: Bybit publicTrade WebSocket stream\r\n * - Aggressor side (Buy/Sell) identifies taker direction\r\n * - Buy = aggressive buyer taking ask liquidity (bullish)\r\n * - Sell = aggressive seller hitting bid liquidity (bearish)\r\n */\r\n\r\nimport { DeltaConfig, DeltaTick, DeltaAnalysis, Signal, LoggerService } from '../types';\r\n\r\nexport class DeltaAnalyzerService {\r\n  private ticks: DeltaTick[] = [];\r\n\r\n  constructor(\r\n    private config: DeltaConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('DeltaAnalyzerService initialized', {\r\n      enabled: config.enabled,\r\n      windowMs: config.windowSizeMs,\r\n      threshold: config.minDeltaThreshold,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add trade tick from WebSocket publicTrade stream\r\n   *\r\n   * @param tick - Trade tick with aggressor side (BUY/SELL)\r\n   */\r\n  addTick(tick: DeltaTick): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.ticks.push(tick);\r\n\r\n    // Remove old ticks outside rolling window\r\n    const cutoff = Date.now() - this.config.windowSizeMs;\r\n    this.ticks = this.ticks.filter((t) => t.timestamp >= cutoff);\r\n\r\n    // this.logger.debug('Delta tick added', {\r\n    //   side: tick.side,\r\n    //   qty: tick.quantity.toFixed(DECIMAL_PLACES.PERCENT),\r\n    //   price: tick.price.toFixed(DECIMAL_PLACES.PRICE),\r\n    //   ticksCount: this.ticks.length,\r\n    // });\r\n  }\r\n\r\n  /**\r\n   * Analyze current delta from recent ticks\r\n   *\r\n   * @returns Delta analysis with trend and strength\r\n   */\r\n  analyze(): DeltaAnalysis {\r\n    const cutoff = Date.now() - this.config.windowSizeMs;\r\n    const recentTicks = this.ticks.filter((t) => t.timestamp >= cutoff);\r\n\r\n    if (recentTicks.length === 0) {\r\n      // No data - return neutral\r\n      return {\r\n        timestamp: Date.now(),\r\n        buyVolume: 0,\r\n        sellVolume: 0,\r\n        delta: 0,\r\n        deltaPercent: 0,\r\n        trend: 'NEUTRAL',\r\n        strength: 0,\r\n      };\r\n    }\r\n\r\n    let buyVolume = 0;\r\n    let sellVolume = 0;\r\n\r\n    for (const tick of recentTicks) {\r\n      if (tick.side === 'BUY') {\r\n        buyVolume += tick.quantity;\r\n      } else {\r\n        sellVolume += tick.quantity;\r\n      }\r\n    }\r\n\r\n    const totalVolume = buyVolume + sellVolume;\r\n    const delta = buyVolume - sellVolume;\r\n    const deltaPercent = totalVolume > 0 ? (delta / totalVolume) * PERCENT_MULTIPLIER : 0;\r\n\r\n    // Trend determination\r\n    let trend: 'BULLISH' | 'BEARISH' | 'NEUTRAL';\r\n    if (Math.abs(delta) < this.config.minDeltaThreshold) {\r\n      trend = 'NEUTRAL';\r\n    } else if (delta > 0) {\r\n      trend = 'BULLISH';\r\n    } else {\r\n      trend = 'BEARISH';\r\n    }\r\n\r\n    // Strength (0-100) based on delta percentage\r\n    const strength = Math.min(Math.abs(deltaPercent), 100);\r\n\r\n    const analysis: DeltaAnalysis = {\r\n      timestamp: Date.now(),\r\n      buyVolume,\r\n      sellVolume,\r\n      delta,\r\n      deltaPercent,\r\n      trend,\r\n      strength,\r\n    };\r\n\r\n    this.logger.debug('Delta analyzed', {\r\n      buyVol: buyVolume.toFixed(0),\r\n      sellVol: sellVolume.toFixed(0),\r\n      delta: delta.toFixed(0),\r\n      deltaPercent: deltaPercent.toFixed(1) + '%',\r\n      trend,\r\n      strength: strength.toFixed(0),\r\n    });\r\n\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * Check if delta confirms signal direction\r\n   *\r\n   * @param signal - Trading signal to confirm\r\n   * @returns True if delta trend matches signal direction\r\n   */\r\n  confirmSignal(signal: Signal): boolean {\r\n    const analysis = this.analyze();\r\n\r\n    const confirms =\r\n      (signal.direction === 'LONG' && analysis.trend === 'BULLISH') ||\r\n      (signal.direction === 'SHORT' && analysis.trend === 'BEARISH');\r\n\r\n    if (confirms) {\r\n      this.logger.info('âœ… Delta confirms signal', {\r\n        direction: signal.direction,\r\n        delta: analysis.delta.toFixed(0),\r\n        deltaPercent: analysis.deltaPercent.toFixed(1) + '%',\r\n        strength: analysis.strength.toFixed(0),\r\n      });\r\n    } else {\r\n      this.logger.warn('âš ï¸ Delta contradicts signal', {\r\n        direction: signal.direction,\r\n        deltaTrend: analysis.trend,\r\n        delta: analysis.delta.toFixed(0),\r\n      });\r\n    }\r\n\r\n    return confirms;\r\n  }\r\n\r\n  /**\r\n   * Get current tick count in window\r\n   */\r\n  getTickCount(): number {\r\n    const cutoff = Date.now() - this.config.windowSizeMs;\r\n    return this.ticks.filter((t) => t.timestamp >= cutoff).length;\r\n  }\r\n\r\n  /**\r\n   * Clear all ticks (for testing)\r\n   */\r\n  reset(): void {\r\n    this.ticks = [];\r\n    this.logger.debug('Delta analyzer reset');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\entry-confirmation.service.ts","messages":[{"ruleId":"max-len","severity":1,"message":"This line has a length of 130. Maximum allowed is 120.","line":40,"column":1,"nodeType":"Program","messageId":"max","endLine":40,"endColumn":131},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":79,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":79,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":129,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":129,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4324,4332],"text":"pending == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":163,"column":118,"nodeType":"Literal","messageId":"noMagic","endLine":163,"endColumn":119},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":201,"column":121,"nodeType":"Literal","messageId":"noMagic","endLine":201,"endColumn":122},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":257,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":257,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":272,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":272,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9034,9041],"text":"pending != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":327,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":327,"endColumn":21}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Entry Confirmation Manager\r\n *\r\n * Prevents premature entries by waiting for next candle close confirmation.\r\n *\r\n * LONG Flow:\r\n * 1. Strategy detects potential LONG at support level\r\n * 2. Instead of entering immediately, save as \"pending\"\r\n * 3. Wait for next 1m candle to close\r\n * 4. If candle closes ABOVE support â†’ confirm entry (bounce confirmed)\r\n * 5. If candle closes BELOW support â†’ cancel (falling knife)\r\n *\r\n * SHORT Flow:\r\n * 1. Strategy detects potential SHORT at resistance level\r\n * 2. Instead of entering immediately, save as \"pending\"\r\n * 3. Wait for next 1m candle to close\r\n * 4. If candle closes BELOW resistance â†’ confirm entry (rejection confirmed)\r\n * 5. If candle closes ABOVE resistance â†’ cancel (pump continues)\r\n *\r\n * Benefits:\r\n * - Reduces quick stop-outs (< 5min holds)\r\n * - Confirms price rejection/bounce before entry\r\n * - Configurable per direction (LONG/SHORT)\r\n */\r\n\r\nimport { LoggerService, SignalDirection, EntryConfirmationConfig } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface PendingEntry {\r\n  id: string; // Unique ID for tracking\r\n  symbol: string;\r\n  direction: SignalDirection; // LONG or SHORT\r\n  keyLevel: number; // Support (LONG) or Resistance (SHORT) price level\r\n  detectedAt: number; // Timestamp when signal detected\r\n  expiresAt: number; // Timestamp when signal expires\r\n  signalData: Record<string, unknown>; // Original signal data to use if confirmed (flexible type for different signal structures)\r\n}\r\n\r\nexport interface ConfirmationResult {\r\n  confirmed: boolean;\r\n  reason: string;\r\n  closePrice?: number;\r\n  keyLevel?: number;\r\n}\r\n\r\n// ============================================================================\r\n// ENTRY CONFIRMATION MANAGER\r\n// ============================================================================\r\n\r\nexport class EntryConfirmationManager {\r\n  private pendingEntries: Map<string, PendingEntry> = new Map();\r\n\r\n  constructor(\r\n    private config: EntryConfirmationConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Check if confirmation is enabled for direction\r\n   */\r\n  isEnabled(direction: SignalDirection): boolean {\r\n    return direction === SignalDirection.LONG\r\n      ? this.config.long.enabled\r\n      : this.config.short.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get expiry time in milliseconds for direction\r\n   */\r\n  private getExpiryMs(direction: SignalDirection): number {\r\n    const seconds =\r\n      direction === SignalDirection.LONG\r\n        ? this.config.long.expirySeconds\r\n        : this.config.short.expirySeconds;\r\n    return seconds * 1000;\r\n  }\r\n\r\n  /**\r\n   * Add pending entry waiting for confirmation\r\n   *\r\n   * @param entry - Pending entry details\r\n   * @returns Pending entry ID\r\n   */\r\n  addPending(entry: Omit<PendingEntry, 'id' | 'expiresAt'>): string {\r\n    const id = `${entry.symbol}_${entry.direction}_${Date.now()}`;\r\n    const expiryMs = this.getExpiryMs(entry.direction);\r\n    const expiresAt = Date.now() + expiryMs;\r\n\r\n    const pendingEntry: PendingEntry = {\r\n      id,\r\n      expiresAt,\r\n      ...entry,\r\n    };\r\n\r\n    this.pendingEntries.set(id, pendingEntry);\r\n\r\n    const levelType = entry.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n    const confirmCondition =\r\n      entry.direction === SignalDirection.LONG\r\n        ? 'candle close above support'\r\n        : 'candle close below resistance';\r\n\r\n    this.logger.info(`â³ ${entry.direction} entry pending confirmation`, {\r\n      id,\r\n      symbol: entry.symbol,\r\n      direction: entry.direction,\r\n      [`${levelType}Level`]: entry.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n      waitingFor: `Next 1m ${confirmCondition}`,\r\n      expiresIn: `${expiryMs / TIME_UNITS.MINUTE}min`,\r\n    });\r\n\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Check if pending entry should be confirmed\r\n   *\r\n   * @param id - Pending entry ID\r\n   * @param currentCandleClose - Current 1m candle close price\r\n   * @returns Confirmation result\r\n   */\r\n  checkConfirmation(id: string, currentCandleClose: number): ConfirmationResult {\r\n    const pending = this.pendingEntries.get(id);\r\n\r\n    if (!pending) {\r\n      return {\r\n        confirmed: false,\r\n        reason: 'Pending entry not found',\r\n      };\r\n    }\r\n\r\n    // Check expiry\r\n    if (Date.now() > pending.expiresAt) {\r\n      const levelType = pending.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n      this.logger.info(`â±ï¸ ${pending.direction} entry EXPIRED`, {\r\n        id,\r\n        symbol: pending.symbol,\r\n        direction: pending.direction,\r\n        [`${levelType}Level`]: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n        reason: 'Confirmation timeout',\r\n      });\r\n\r\n      this.pendingEntries.delete(id);\r\n      return {\r\n        confirmed: false,\r\n        reason: 'Confirmation timeout - signal expired',\r\n      };\r\n    }\r\n\r\n    // LONG confirmation: candle closed ABOVE support\r\n    if (pending.direction === SignalDirection.LONG) {\r\n      if (currentCandleClose > pending.keyLevel) {\r\n        this.logger.info('âœ… LONG entry CONFIRMED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          supportLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          bouncePercent: (((currentCandleClose - pending.keyLevel) / pending.keyLevel) * PERCENT_MULTIPLIER).toFixed(3) + '%',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: true,\r\n          reason: 'Candle closed above support - bounce confirmed',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      } else {\r\n        // Candle closed BELOW/AT support - falling knife!\r\n        this.logger.info('âŒ LONG entry REJECTED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          supportLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          reason: 'Candle closed below support - falling knife',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: false,\r\n          reason: 'Candle closed below support - no bounce',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      }\r\n    }\r\n\r\n    // SHORT confirmation: candle closed BELOW resistance\r\n    if (pending.direction === SignalDirection.SHORT) {\r\n      if (currentCandleClose < pending.keyLevel) {\r\n        this.logger.info('âœ… SHORT entry CONFIRMED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          resistanceLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          rejectionPercent: (((pending.keyLevel - currentCandleClose) / pending.keyLevel) * PERCENT_MULTIPLIER).toFixed(3) + '%',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: true,\r\n          reason: 'Candle closed below resistance - rejection confirmed',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      } else {\r\n        // Candle closed ABOVE/AT resistance - pump continues!\r\n        this.logger.info('âŒ SHORT entry REJECTED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          resistanceLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          reason: 'Candle closed above resistance - pump continues',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: false,\r\n          reason: 'Candle closed above resistance - no rejection',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      }\r\n    }\r\n\r\n    // Should never reach here\r\n    return {\r\n      confirmed: false,\r\n      reason: 'Unknown direction',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get pending entry data\r\n   *\r\n   * @param id - Pending entry ID\r\n   * @returns Pending entry or undefined\r\n   */\r\n  getPending(id: string): PendingEntry | undefined {\r\n    return this.pendingEntries.get(id);\r\n  }\r\n\r\n  /**\r\n   * Get all pending entries\r\n   *\r\n   * @param direction - Optional: filter by direction\r\n   * @returns Array of pending entries\r\n   */\r\n  getAllPending(direction?: SignalDirection): PendingEntry[] {\r\n    const allEntries = Array.from(this.pendingEntries.values());\r\n\r\n    if (direction != null) {\r\n      return allEntries.filter((entry) => entry.direction === direction);\r\n    }\r\n\r\n    return allEntries;\r\n  }\r\n\r\n  /**\r\n   * Cancel pending entry\r\n   *\r\n   * @param id - Pending entry ID\r\n   * @returns true if cancelled, false if not found\r\n   */\r\n  cancel(id: string): boolean {\r\n    const pending = this.pendingEntries.get(id);\r\n    if (pending) {\r\n      const levelType = pending.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n      this.logger.info(`ðŸš« ${pending.direction} entry CANCELLED`, {\r\n        id,\r\n        symbol: pending.symbol,\r\n        direction: pending.direction,\r\n        [`${levelType}Level`]: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n\r\n      this.pendingEntries.delete(id);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries\r\n   *\r\n   * @returns Number of expired entries removed\r\n   */\r\n  cleanupExpired(): number {\r\n    const now = Date.now();\r\n    let count = 0;\r\n\r\n    for (const [id, entry] of this.pendingEntries.entries()) {\r\n      if (now > entry.expiresAt) {\r\n        this.logger.debug(`Removing expired pending ${entry.direction}`, {\r\n          id,\r\n          symbol: entry.symbol,\r\n          direction: entry.direction,\r\n        });\r\n        this.pendingEntries.delete(id);\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Clear all pending entries\r\n   */\r\n  clear(): void {\r\n    this.pendingEntries.clear();\r\n  }\r\n\r\n  /**\r\n   * Get count of pending entries\r\n   *\r\n   * @param direction - Optional: filter by direction\r\n   * @returns Count of pending entries\r\n   */\r\n  getPendingCount(direction?: SignalDirection): number {\r\n    if (direction != null) {\r\n      return this.getAllPending(direction).length;\r\n    }\r\n    return this.pendingEntries.size;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\fast-entry.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'checkFastTrigger' has a complexity of 11. Maximum allowed is 10.","line":46,"column":19,"nodeType":"FunctionExpression","messageId":"complex","endLine":122,"endColumn":4},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":78,"column":28,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":78,"endColumn":55,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[2414,2420],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":101,"column":23,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":101,"endColumn":50,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[3231,3237],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":189,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":189,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5891,5899],"text":"partial == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":239,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":239,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7524,7532],"text":"partial == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Fast Entry Service\r\n *\r\n * Allows partial entry before candle close to reduce late entry slippage.\r\n *\r\n * Flow:\r\n * 1. Signal generated\r\n * 2. Check fast trigger conditions (candle body, volume, senior TF)\r\n * 3. If TRUE: Execute partial entry (40% size)\r\n * 4. Schedule confirmation check on candle close\r\n * 5. On close: Add remaining 60% if confirmed, else close partial\r\n *\r\n * Benefits:\r\n * - Better entry price (0.3-0.5% improvement)\r\n * - Reduced stop-outs from late entries\r\n * - Partial position = lower risk if signal invalidates\r\n */\r\n\r\nimport { FastEntryConfig, PartialPosition, Signal, Candle, LoggerService } from '../types';\r\n\r\nexport class FastEntryService {\r\n  private partialPositions: Map<string, PartialPosition> = new Map();\r\n\r\n  constructor(\r\n    private config: FastEntryConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('FastEntryService initialized', {\r\n      enabled: config.enabled,\r\n      partialSize: `${config.partialSizePercent}%`,\r\n      minBody: `${config.minBodyPercent}%`,\r\n      volumeMultiplier: config.volumeMultiplier,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if fast entry conditions met\r\n   *\r\n   * Conditions:\r\n   * 1. Candle body â‰¥ 50% of range\r\n   * 2. Body direction matches signal\r\n   * 3. Volume > SMA(20) Ã— multiplier\r\n   * 4. Senior TF aligned (optional)\r\n   */\r\n  checkFastTrigger(\r\n    signal: Signal,\r\n    currentCandle: Candle,\r\n    volume: number,\r\n    volumeSMA: number,\r\n    seniorTFTrend: 'UP' | 'DOWN' | 'NEUTRAL',\r\n  ): boolean {\r\n    if (!this.config.enabled) {\r\n      return false;\r\n    }\r\n\r\n    // 1. Check candle body percentage\r\n    const range = currentCandle.high - currentCandle.low;\r\n\r\n    if (range === 0) {\r\n      this.logger.debug('Fast trigger: no range (doji candle)');\r\n      return false;\r\n    }\r\n\r\n    const body = Math.abs(currentCandle.close - currentCandle.open);\r\n    const bodyPercent = (body / range) * PERCENT_MULTIPLIER;\r\n\r\n    if (bodyPercent < this.config.minBodyPercent) {\r\n      this.logger.debug('Fast trigger: body too small', {\r\n        bodyPercent: bodyPercent.toFixed(1),\r\n        required: this.config.minBodyPercent,\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // 2. Check body direction matches signal\r\n    const isBullishCandle = currentCandle.close > currentCandle.open;\r\n    const directionMatch = signal.direction === 'LONG' ? isBullishCandle : !isBullishCandle;\r\n\r\n    if (!directionMatch) {\r\n      this.logger.debug('Fast trigger: direction mismatch', {\r\n        signalDirection: signal.direction,\r\n        candleDirection: isBullishCandle ? 'BULLISH' : 'BEARISH',\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // 3. Check volume\r\n    const volumeThreshold = volumeSMA * this.config.volumeMultiplier;\r\n    if (volume < volumeThreshold) {\r\n      this.logger.debug('Fast trigger: volume too low', {\r\n        volume: volume.toFixed(0),\r\n        threshold: volumeThreshold.toFixed(0),\r\n        ratio: (volume / volumeSMA).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // 4. Check senior TF alignment (optional)\r\n    if (this.config.requireSeniorTFAlignment) {\r\n      const aligned = signal.direction === 'LONG'\r\n        ? seniorTFTrend === 'UP'\r\n        : seniorTFTrend === 'DOWN';\r\n\r\n      if (!aligned) {\r\n        this.logger.debug('Fast trigger: senior TF not aligned', {\r\n          signalDirection: signal.direction,\r\n          seniorTFTrend,\r\n        });\r\n        return false;\r\n      }\r\n    }\r\n\r\n    this.logger.info('âœ… Fast trigger conditions met!', {\r\n      bodyPercent: bodyPercent.toFixed(1) + '%',\r\n      volume: volume.toFixed(0),\r\n      volumeRatio: (volume / volumeSMA).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n      seniorTF: seniorTFTrend,\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Execute partial entry (40% of position size)\r\n   */\r\n  async executePartialEntry(\r\n    symbol: string,\r\n    signal: Signal,\r\n    fullPositionSize: number,\r\n    openPositionFn: (qty: number) => Promise<{ orderId: string; avgPrice: number }>,\r\n  ): Promise<PartialPosition | null> {\r\n    const partialSize = fullPositionSize * (this.config.partialSizePercent / PERCENT_MULTIPLIER);\r\n\r\n    try {\r\n      this.logger.info('ðŸš€ Executing partial entry...', {\r\n        symbol,\r\n        direction: signal.direction,\r\n        fullSize: fullPositionSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        partialSize: partialSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        percent: this.config.partialSizePercent + '%',\r\n      });\r\n\r\n      // Open partial position\r\n      const order = await openPositionFn(partialSize);\r\n\r\n      const partial: PartialPosition = {\r\n        orderId: order.orderId,\r\n        symbol,\r\n        side: signal.direction,\r\n        qty: partialSize,\r\n        entryPrice: order.avgPrice,\r\n        timestamp: Date.now(),\r\n        signal,\r\n        confirmScheduled: false,\r\n      };\r\n\r\n      this.partialPositions.set(symbol, partial);\r\n\r\n      this.logger.info('âœ… Partial entry executed', {\r\n        orderId: order.orderId,\r\n        size: partialSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        price: order.avgPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        percent: this.config.partialSizePercent + '%',\r\n      });\r\n\r\n      return partial;\r\n\r\n    } catch (error: unknown) {\r\n      this.logger.error('âŒ Failed to execute partial entry', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Confirm entry - add remaining position (60%)\r\n   */\r\n  async confirmEntry(\r\n    symbol: string,\r\n    remainingSize: number,\r\n    addToPositionFn: (qty: number) => Promise<{ orderId: string; avgPrice: number }>,\r\n  ): Promise<boolean> {\r\n    const partial = this.partialPositions.get(symbol);\r\n\r\n    if (!partial) {\r\n      this.logger.warn('No partial position found for confirmation', { symbol });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      this.logger.info('âœ… Confirming entry - adding remaining position...', {\r\n        symbol,\r\n        partialQty: partial.qty.toFixed(DECIMAL_PLACES.PERCENT),\r\n        remainingQty: remainingSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        totalQty: (partial.qty + remainingSize).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Add remaining position\r\n      const order = await addToPositionFn(remainingSize);\r\n\r\n      this.logger.info('âœ… Entry confirmed - position completed', {\r\n        orderId: order.orderId,\r\n        addedQty: remainingSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        addedPrice: order.avgPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalQty: (partial.qty + remainingSize).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      this.partialPositions.delete(symbol);\r\n      return true;\r\n\r\n    } catch (error: unknown) {\r\n      this.logger.error('âŒ Failed to confirm entry', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel partial entry - close partial position\r\n   *\r\n   * Called when:\r\n   * - Candle closes against signal direction\r\n   * - Confirmation timeout exceeded\r\n   * - Signal invalidated\r\n   */\r\n  async cancelPartialEntry(\r\n    symbol: string,\r\n    closePositionFn: () => Promise<void>,\r\n  ): Promise<void> {\r\n    const partial = this.partialPositions.get(symbol);\r\n\r\n    if (!partial) {\r\n      this.logger.debug('No partial position to cancel', { symbol });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.warn('âŒ Cancelling partial entry...', {\r\n        symbol,\r\n        qty: partial.qty.toFixed(DECIMAL_PLACES.PERCENT),\r\n        entryPrice: partial.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        reason: 'Signal not confirmed',\r\n      });\r\n\r\n      await closePositionFn();\r\n\r\n      this.logger.info('âŒ Partial entry cancelled', {\r\n        symbol,\r\n        orderId: partial.orderId,\r\n      });\r\n\r\n      this.partialPositions.delete(symbol);\r\n\r\n    } catch (error: unknown) {\r\n      this.logger.error('âŒ Failed to cancel partial entry', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get partial position by symbol\r\n   */\r\n  getPartialPosition(symbol: string): PartialPosition | undefined {\r\n    return this.partialPositions.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Check if partial position exists\r\n   */\r\n  hasPartialPosition(symbol: string): boolean {\r\n    return this.partialPositions.has(symbol);\r\n  }\r\n\r\n  /**\r\n   * Get all partial positions\r\n   */\r\n  getAllPartialPositions(): PartialPosition[] {\r\n    return Array.from(this.partialPositions.values());\r\n  }\r\n\r\n  /**\r\n   * Clear partial position (without closing)\r\n   * Use when position closed externally\r\n   */\r\n  clearPartialPosition(symbol: string): void {\r\n    this.partialPositions.delete(symbol);\r\n    this.logger.debug('Partial position cleared', { symbol });\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): FastEntryConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\funding-rate-filter.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":131,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":131,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4869,4891],"text":"(this.cachedFundingRate != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":136,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":136,"endColumn":63}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Funding Rate Filter Service\r\n *\r\n * Filters trading signals based on funding rate to avoid overheated positions.\r\n *\r\n * Logic:\r\n * - Positive funding rate = longs pay shorts â†’ too many longs â†’ risky to LONG\r\n * - Negative funding rate = shorts pay longs â†’ too many shorts â†’ risky to SHORT\r\n *\r\n * Example:\r\n * - Funding rate = +0.1% â†’ block LONG signals (market too bullish, risk of reversal)\r\n * - Funding rate = -0.1% â†’ block SHORT signals (market too bearish, risk of reversal)\r\n */\r\n\r\nimport { LoggerService, SignalDirection, FundingRateFilterConfig } from '../types';\r\n\r\n// ============================================================================\r\n// INTERFACES\r\n// ============================================================================\r\n\r\nexport interface FundingRateData {\r\n  fundingRate: number; // Current funding rate (e.g., 0.0001 = 0.01%)\r\n  timestamp: number; // Timestamp of funding rate\r\n  nextFundingTime: number; // Next funding timestamp\r\n}\r\n\r\nexport interface FilterResult {\r\n  allowed: boolean; // Whether signal is allowed\r\n  reason?: string; // Reason for blocking (if blocked)\r\n  fundingRate?: number; // Current funding rate\r\n}\r\n\r\n// ============================================================================\r\n// SERVICE\r\n// ============================================================================\r\n\r\nexport class FundingRateFilterService {\r\n  private cachedFundingRate: FundingRateData | null = null;\r\n  private lastFetchTime: number = 0;\r\n\r\n  constructor(\r\n    private config: FundingRateFilterConfig,\r\n    private getFundingRate: () => Promise<FundingRateData>, // Injected Bybit API call\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Check if signal is allowed based on funding rate\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns FilterResult with allowed flag and reason\r\n   */\r\n  async checkSignal(direction: SignalDirection): Promise<FilterResult> {\r\n    // Check if filter is enabled\r\n    if (!this.config.enabled) {\r\n      return { allowed: true };\r\n    }\r\n\r\n    // Skip if direction is HOLD\r\n    if (direction === SignalDirection.HOLD) {\r\n      return { allowed: true };\r\n    }\r\n\r\n    try {\r\n      // Get current funding rate (from cache or API)\r\n      const fundingData = await this.getCurrentFundingRate();\r\n      const fundingRate = fundingData.fundingRate;\r\n\r\n      // Check LONG signal\r\n      if (direction === SignalDirection.LONG) {\r\n        if (fundingRate > this.config.blockLongThreshold) {\r\n          this.logger.warn('ðŸš« Funding Rate Filter: LONG blocked', {\r\n            fundingRate: (fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            threshold: (this.config.blockLongThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            reason: 'Funding too high (too many longs)',\r\n          });\r\n\r\n          return {\r\n            allowed: false,\r\n            reason: `Funding rate too high: ${(fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}% (threshold: ${(this.config.blockLongThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}%)`,\r\n            fundingRate,\r\n          };\r\n        }\r\n      }\r\n\r\n      // Check SHORT signal\r\n      if (direction === SignalDirection.SHORT) {\r\n        if (fundingRate < this.config.blockShortThreshold) {\r\n          this.logger.warn('ðŸš« Funding Rate Filter: SHORT blocked', {\r\n            fundingRate: (fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            threshold: (this.config.blockShortThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            reason: 'Funding too low (too many shorts)',\r\n          });\r\n\r\n          return {\r\n            allowed: false,\r\n            reason: `Funding rate too low: ${(fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}% (threshold: ${(this.config.blockShortThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}%)`,\r\n            fundingRate,\r\n          };\r\n        }\r\n      }\r\n\r\n      // Signal allowed\r\n      this.logger.debug('âœ… Funding Rate Filter: Signal allowed', {\r\n        direction,\r\n        fundingRate: (fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n      });\r\n\r\n      return {\r\n        allowed: true,\r\n        fundingRate,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error checking funding rate filter', { error });\r\n      // Allow signal if filter fails (fail-safe)\r\n      return { allowed: true, reason: 'Filter error (allowed by default)' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current funding rate (from cache or API)\r\n   *\r\n   * @returns FundingRateData\r\n   */\r\n  private async getCurrentFundingRate(): Promise<FundingRateData> {\r\n    const now = Date.now();\r\n\r\n    // Check if cache is valid\r\n    if (\r\n      this.cachedFundingRate &&\r\n      now - this.lastFetchTime < this.config.cacheTimeMs\r\n    ) {\r\n      this.logger.debug('ðŸ“¦ Using cached funding rate', {\r\n        fundingRate: (this.cachedFundingRate.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n        cacheAge: Math.floor((now - this.lastFetchTime) / 1000) + 's',\r\n      });\r\n      return this.cachedFundingRate;\r\n    }\r\n\r\n    // Fetch from API\r\n    this.logger.debug('ðŸ”„ Fetching funding rate from API');\r\n    const fundingData = await this.getFundingRate();\r\n\r\n    // Update cache\r\n    this.cachedFundingRate = fundingData;\r\n    this.lastFetchTime = now;\r\n\r\n    this.logger.info('ðŸ“Š Funding rate updated', {\r\n      fundingRate: (fundingData.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n      nextFundingTime: new Date(fundingData.nextFundingTime).toISOString(),\r\n    });\r\n\r\n    return fundingData;\r\n  }\r\n\r\n  /**\r\n   * Clear cache (for testing)\r\n   */\r\n  clearCache(): void {\r\n    this.cachedFundingRate = null;\r\n    this.lastFetchTime = 0;\r\n    this.logger.debug('ðŸ—‘ï¸ Funding rate cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get current cached funding rate (if available)\r\n   */\r\n  getCachedFundingRate(): FundingRateData | null {\r\n    return this.cachedFundingRate;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\ladder-tp-manager.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":164,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":325,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":325,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":325,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":325,"endColumn":39}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Ladder TP Manager Service (Phase 3)\r\n *\r\n * Manages multi-level take profit execution for scalping strategies.\r\n *\r\n * Features:\r\n * - 3 TP levels with partial closes (e.g., 0.08%, 0.15%, 0.25%)\r\n * - Position closes: 33%, 33%, 34%\r\n * - Move SL to breakeven after TP1\r\n * - Trailing SL after TP2\r\n * - R/R Ratio: ~1.26:1 (weighted average)\r\n *\r\n * Example:\r\n * Entry: 1.0000 LONG\r\n * TP1: 1.0008 (33% close) â†’ Move SL to 1.0000 (breakeven)\r\n * TP2: 1.0015 (33% close) â†’ Trailing SL activated\r\n * TP3: 1.0025 (34% close) â†’ Full exit\r\n */\r\n\r\nimport {\r\n  LoggerService,\r\n  SignalDirection,\r\n  PositionSide,\r\n  LadderTpManagerConfig,\r\n  LadderTpLevel,\r\n  Position,\r\n} from '../types';\r\nimport { BybitService } from './bybit/bybit.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_PARTIAL_CLOSE_PERCENT = 10; // Min % to close (avoid too small closes)\r\nconst MAX_PARTIAL_CLOSE_PERCENT = 90; // Max % to close (avoid closing full position)\r\nconst PRICE_TOLERANCE_PERCENT = 0.01; // 0.01% tolerance for TP hit detection\r\n\r\n// ============================================================================\r\n// LADDER TP MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class LadderTpManagerService {\r\n  constructor(\r\n    private config: LadderTpManagerConfig,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('LadderTpManagerService initialized', {\r\n      levels: config.levels.length,\r\n      moveToBreakeven: config.moveToBreakevenAfterTP1,\r\n      trailing: config.trailingAfterTP2,\r\n      trailingDistance: config.trailingDistancePercent,\r\n    });\r\n\r\n    // Validate config\r\n    this.validateConfig();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Create ladder TP levels for position\r\n   *\r\n   * Calculates TP prices based on entry price and direction\r\n   *\r\n   * @param entry - Entry price\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns Array of ladder TP levels\r\n   */\r\n  createLadderLevels(entry: number, direction: SignalDirection): LadderTpLevel[] {\r\n    this.logger.debug('Creating ladder TP levels', {\r\n      entry,\r\n      direction,\r\n      levelsCount: this.config.levels.length,\r\n    });\r\n\r\n    const levels: LadderTpLevel[] = this.config.levels.map((levelConfig, index) => {\r\n      // Calculate target price\r\n      let targetPrice: number;\r\n      if (direction === SignalDirection.LONG) {\r\n        // LONG: TP above entry\r\n        targetPrice = entry * (1 + levelConfig.pricePercent / PERCENT_MULTIPLIER);\r\n      } else {\r\n        // SHORT: TP below entry\r\n        targetPrice = entry * (1 - levelConfig.pricePercent / PERCENT_MULTIPLIER);\r\n      }\r\n\r\n      return {\r\n        level: index + 1,\r\n        pricePercent: levelConfig.pricePercent,\r\n        closePercent: levelConfig.closePercent,\r\n        targetPrice,\r\n        hit: false,\r\n      };\r\n    });\r\n\r\n    this.logger.info('âœ… Ladder TP levels created', {\r\n      direction,\r\n      levels: levels.map((l) => ({\r\n        level: l.level,\r\n        price: l.targetPrice,\r\n        closePercent: l.closePercent,\r\n      })),\r\n    });\r\n\r\n    return levels;\r\n  }\r\n\r\n  /**\r\n   * Check if TP level was hit\r\n   *\r\n   * Compares current price with TP target price\r\n   *\r\n   * @param level - TP level to check\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns True if TP was hit\r\n   */\r\n  checkTpHit(level: LadderTpLevel, currentPrice: number, direction: SignalDirection): boolean {\r\n    if (level.hit) {\r\n      return false; // Already hit\r\n    }\r\n\r\n    // Calculate tolerance\r\n    const tolerance = level.targetPrice * (PRICE_TOLERANCE_PERCENT / PERCENT_MULTIPLIER);\r\n\r\n    let isHit: boolean;\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: current price >= target price\r\n      isHit = currentPrice >= level.targetPrice - tolerance;\r\n    } else {\r\n      // SHORT: current price <= target price\r\n      isHit = currentPrice <= level.targetPrice + tolerance;\r\n    }\r\n\r\n    if (isHit) {\r\n      this.logger.info(`ðŸŽ¯ TP${level.level} HIT!`, {\r\n        targetPrice: level.targetPrice,\r\n        currentPrice,\r\n        closePercent: level.closePercent,\r\n      });\r\n    }\r\n\r\n    return isHit;\r\n  }\r\n\r\n  /**\r\n   * Execute partial close for TP level\r\n   *\r\n   * Closes specified % of position via Bybit API\r\n   *\r\n   * @param level - TP level to execute\r\n   * @param position - Current position\r\n   * @returns True if close successful\r\n   */\r\n  async executePartialClose(level: LadderTpLevel, position: Position): Promise<boolean> {\r\n    try {\r\n      // Calculate quantity to close\r\n      const closeQty = position.quantity * (level.closePercent / PERCENT_MULTIPLIER);\r\n\r\n      if (closeQty < 0.01) {\r\n        this.logger.warn('Close quantity too small, skipping partial close', {\r\n          level: level.level,\r\n          closeQty,\r\n          minQty: 0.01,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      this.logger.info(`ðŸ’° Executing TP${level.level} partial close`, {\r\n        level: level.level,\r\n        closePercent: level.closePercent,\r\n        closeQty,\r\n        targetPrice: level.targetPrice,\r\n      });\r\n\r\n      // Execute partial close via Bybit\r\n      await this.bybitService.closePosition(position.side, closeQty);\r\n\r\n      this.logger.info(`âœ… TP${level.level} partial close executed`, {\r\n        level: level.level,\r\n        closedQty: closeQty,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Failed to execute TP${level.level} partial close`, {\r\n        level: level.level,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move SL to breakeven (entry price)\r\n   *\r\n   * Called after TP1 hit to protect position\r\n   *\r\n   * @param position - Current position\r\n   * @returns True if SL moved successfully\r\n   */\r\n  async moveToBreakeven(position: Position): Promise<boolean> {\r\n    if (!this.config.moveToBreakevenAfterTP1) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const breakeven = position.entryPrice;\r\n\r\n      this.logger.info('âš–ï¸ Moving SL to breakeven after TP1', {\r\n        oldSl: position.stopLoss,\r\n        newSl: breakeven,\r\n        entry: position.entryPrice,\r\n      });\r\n\r\n      // Update SL via Bybit API\r\n      await this.bybitService.updateStopLoss(breakeven);\r\n\r\n      this.logger.info('âœ… SL moved to breakeven', {\r\n        slPrice: breakeven,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Failed to move SL to breakeven', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move SL to trailing price\r\n   *\r\n   * Called after TP2 hit to maximize profits\r\n   *\r\n   * @param position - Current position\r\n   * @param currentPrice - Current market price\r\n   * @returns True if SL moved successfully\r\n   */\r\n  async moveTrailing(position: Position, currentPrice: number): Promise<boolean> {\r\n    if (!this.config.trailingAfterTP2) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // Calculate trailing SL price\r\n      let newSlPrice: number;\r\n      if (position.side === PositionSide.LONG) {\r\n        // LONG: SL below current price\r\n        newSlPrice = currentPrice * (1 - this.config.trailingDistancePercent / PERCENT_MULTIPLIER);\r\n      } else {\r\n        // SHORT: SL above current price\r\n        newSlPrice = currentPrice * (1 + this.config.trailingDistancePercent / PERCENT_MULTIPLIER);\r\n      }\r\n\r\n      // Only move SL if it improves current SL\r\n      const shouldMove =\r\n        position.side === PositionSide.LONG\r\n          ? newSlPrice > position.stopLoss.price // LONG: move SL up\r\n          : newSlPrice < position.stopLoss.price; // SHORT: move SL down\r\n\r\n      if (!shouldMove) {\r\n        this.logger.debug('Trailing SL not better than current SL, skipping', {\r\n          currentSl: position.stopLoss.price,\r\n          newSl: newSlPrice,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      this.logger.info('ðŸ“ˆ Moving SL to trailing price after TP2', {\r\n        oldSl: position.stopLoss.price,\r\n        newSl: newSlPrice,\r\n        currentPrice,\r\n        trailingDistance: this.config.trailingDistancePercent,\r\n      });\r\n\r\n      // Update SL via Bybit API\r\n      await this.bybitService.updateStopLoss(newSlPrice);\r\n\r\n      this.logger.info('âœ… Trailing SL updated', {\r\n        slPrice: newSlPrice,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Failed to move trailing SL', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Validate configuration\r\n   */\r\n  private validateConfig(): void {\r\n    if (this.config.levels.length === 0) {\r\n      throw new Error('LadderTpManagerConfig must have at least 1 level');\r\n    }\r\n\r\n    // Validate each level\r\n    for (const level of this.config.levels) {\r\n      if (level.pricePercent <= 0) {\r\n        throw new Error(`Invalid pricePercent: ${level.pricePercent} (must be > 0)`);\r\n      }\r\n\r\n      if (level.closePercent < MIN_PARTIAL_CLOSE_PERCENT || level.closePercent > MAX_PARTIAL_CLOSE_PERCENT) {\r\n        throw new Error(\r\n          `Invalid closePercent: ${level.closePercent} (must be ${MIN_PARTIAL_CLOSE_PERCENT}-${MAX_PARTIAL_CLOSE_PERCENT}%)`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Validate total closePercent ~= 100%\r\n    const totalClose = this.config.levels.reduce((sum, level) => sum + level.closePercent, 0);\r\n    if (Math.abs(totalClose - 100) > 5) {\r\n      this.logger.warn('Total closePercent is not ~100%, some position may remain', {\r\n        totalClose,\r\n      });\r\n    }\r\n\r\n    if (this.config.trailingAfterTP2 && this.config.trailingDistancePercent <= 0) {\r\n      throw new Error(`Invalid trailingDistancePercent: ${this.config.trailingDistancePercent} (must be > 0)`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get config for external access\r\n   */\r\n  getConfig(): LadderTpManagerConfig {\r\n    return this.config;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\limit-order-executor.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":164,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":31},{"ruleId":"complexity","severity":1,"message":"Async method 'waitForFill' has a complexity of 11. Maximum allowed is 10.","line":184,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":260,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":211,"column":24,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":211,"endColumn":45},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":222,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":237,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":223,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":223,"endColumn":64},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":224,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":236,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":346,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":346,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[11293,11307],"text":"(order.avgPrice.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[11293,11307],"text":"(order.avgPrice !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11293,11307],"text":"(Boolean(order.avgPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (312). Maximum allowed is 300.","line":465,"column":1,"nodeType":null,"messageId":"exceed","endLine":488,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Limit Order Executor Service (Phase 2)\r\n *\r\n * Executes trades using limit orders instead of market orders\r\n * for fee savings (0.01% maker vs 0.06% taker = 0.05% savings).\r\n *\r\n * Features:\r\n * - Place limit orders at bid/ask with minimal slippage\r\n * - Wait for fill with configurable timeout\r\n * - Automatic fallback to market order if not filled\r\n * - Retry logic with max attempts\r\n * - Detailed execution statistics\r\n */\r\n\r\nimport {\r\n  LoggerService,\r\n  SignalDirection,\r\n  PositionSide,\r\n  LimitOrderExecutorConfig,\r\n  LimitOrderResult,\r\n  MarketOrderResult,\r\n} from '../types';\r\nimport { BybitService } from './bybit/bybit.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAKER_FEE_PERCENT = 0.01; // Maker fee (limit order filled)\r\nconst TAKER_FEE_PERCENT = 0.06; // Taker fee (market order)\r\nconst ORDER_CHECK_INTERVAL_MS = 200; // Check order status every 200ms\r\nconst BYBIT_SUCCESS_CODE = 0;\r\nconst POSITION_IDX_ONE_WAY = 0;\r\n\r\n// ============================================================================\r\n// LIMIT ORDER EXECUTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class LimitOrderExecutorService {\r\n  constructor(\r\n    private config: LimitOrderExecutorConfig,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('LimitOrderExecutorService initialized', {\r\n      enabled: config.enabled,\r\n      timeoutMs: config.timeoutMs,\r\n      slippagePercent: config.slippagePercent,\r\n      fallbackToMarket: config.fallbackToMarket,\r\n      maxRetries: config.maxRetries,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate optimal limit price for entry\r\n   *\r\n   * For LONG: Place limit order below current ask (bid side)\r\n   * For SHORT: Place limit order above current bid (ask side)\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param currentPrice - Current market price\r\n   * @param slippagePercent - Slippage % (e.g., 0.02 = 0.02%)\r\n   * @returns Calculated limit price\r\n   */\r\n  calculateLimitPrice(\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n    slippagePercent: number,\r\n  ): number {\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: Place bid below ask to get filled as maker\r\n      // Example: ask = 100, slippage = 0.02% â†’ limit = 99.98\r\n      return currentPrice * (1 - slippagePercent / PERCENT_MULTIPLIER);\r\n    } else {\r\n      // SHORT: Place ask above bid to get filled as maker\r\n      // Example: bid = 100, slippage = 0.02% â†’ limit = 100.02\r\n      return currentPrice * (1 + slippagePercent / PERCENT_MULTIPLIER);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Place limit order with retry logic\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param quantity - Order quantity (contracts)\r\n   * @param limitPrice - Limit price\r\n   * @param leverage - Position leverage\r\n   * @returns LimitOrderResult with order details\r\n   */\r\n  async placeLimitOrder(\r\n    direction: SignalDirection,\r\n    quantity: number,\r\n    limitPrice: number,\r\n    leverage: number,\r\n  ): Promise<LimitOrderResult> {\r\n    const startTime = Date.now();\r\n    let lastError: Error | undefined;\r\n\r\n    // Retry logic\r\n    for (let attempt = 1; attempt <= this.config.maxRetries + 1; attempt++) {\r\n      try {\r\n        this.logger.info('ðŸ“ Placing limit order', {\r\n          attempt,\r\n          maxAttempts: this.config.maxRetries + 1,\r\n          direction,\r\n          quantity,\r\n          limitPrice,\r\n          leverage,\r\n        });\r\n\r\n        // Set leverage first\r\n        await this.bybitService.setLeverage(leverage);\r\n\r\n        // Round quantity and price to exchange precision\r\n        const orderQty = this.bybitService.roundQuantity(quantity);\r\n        const orderPrice = this.bybitService.roundPrice(limitPrice);\r\n\r\n        // Submit limit order\r\n        const response = await this.bybitService.getRestClient().submitOrder({\r\n          category: 'linear',\r\n          symbol: this.bybitService.getSymbol(),\r\n          side: direction === SignalDirection.LONG ? 'Buy' : 'Sell',\r\n          orderType: 'Limit',\r\n          qty: orderQty,\r\n          price: orderPrice,\r\n          timeInForce: 'GTC', // Good Till Cancelled\r\n          positionIdx: POSITION_IDX_ONE_WAY,\r\n        });\r\n\r\n        if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n          throw new Error(`Failed to place limit order: ${response.retMsg}`);\r\n        }\r\n\r\n        const orderId = response.result.orderId;\r\n        const executionTime = Date.now() - startTime;\r\n\r\n        this.logger.info('âœ… Limit order placed successfully', {\r\n          orderId,\r\n          direction,\r\n          quantity: orderQty,\r\n          limitPrice: orderPrice,\r\n          executionTime,\r\n        });\r\n\r\n        return {\r\n          orderId,\r\n          filled: false, // Order placed but not filled yet\r\n          feePaid: 0, // Fee will be calculated after fill\r\n          executionTime,\r\n        };\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        this.logger.warn(`Limit order placement failed (attempt ${attempt})`, {\r\n          error: error instanceof Error ? error.message : String(error),\r\n        });\r\n\r\n        // Retry only if we have attempts left\r\n        if (attempt < this.config.maxRetries + 1) {\r\n          await this.sleep(500); // Wait 500ms before retry\r\n        }\r\n      }\r\n    }\r\n\r\n    // All retries failed\r\n    throw new Error(\r\n      `Failed to place limit order after ${this.config.maxRetries + 1} attempts: ${lastError?.message}`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Wait for limit order to fill with timeout\r\n   *\r\n   * Checks order status every 200ms until filled or timeout\r\n   *\r\n   * @param orderId - Order ID to monitor\r\n   * @param timeoutMs - Max wait time (ms)\r\n   * @returns True if filled, false if timeout\r\n   */\r\n  async waitForFill(orderId: string, timeoutMs: number): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    const endTime = startTime + timeoutMs;\r\n\r\n    this.logger.debug('â³ Waiting for limit order fill', {\r\n      orderId,\r\n      timeoutMs,\r\n    });\r\n\r\n    while (Date.now() < endTime) {\r\n      try {\r\n        // Get order status\r\n        const response = await this.bybitService.getRestClient().getActiveOrders({\r\n          category: 'linear',\r\n          symbol: this.bybitService.getSymbol(),\r\n          orderId,\r\n        });\r\n\r\n        if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n          this.logger.warn('Failed to check order status', {\r\n            orderId,\r\n            error: response.retMsg,\r\n          });\r\n          await this.sleep(ORDER_CHECK_INTERVAL_MS);\r\n          continue;\r\n        }\r\n\r\n        const orders = response.result?.list || [];\r\n\r\n        // If order not in active list, it was filled or cancelled\r\n        if (orders.length === 0) {\r\n          // Check order history to confirm fill\r\n          const historyResponse = await this.bybitService.getRestClient().getHistoricOrders({\r\n            category: 'linear',\r\n            symbol: this.bybitService.getSymbol(),\r\n            orderId,\r\n          });\r\n\r\n          if (historyResponse.retCode === BYBIT_SUCCESS_CODE) {\r\n            const historicOrders = historyResponse.result?.list || [];\r\n            if (historicOrders.length > 0) {\r\n              const order = historicOrders[0];\r\n              const filled = order.orderStatus === 'Filled';\r\n\r\n              this.logger.info(filled ? 'âœ… Limit order filled' : 'âŒ Limit order not filled', {\r\n                orderId,\r\n                status: order.orderStatus,\r\n                fillPrice: order.avgPrice,\r\n                executionTime: Date.now() - startTime,\r\n              });\r\n\r\n              return filled;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Order still active, wait and check again\r\n        await this.sleep(ORDER_CHECK_INTERVAL_MS);\r\n      } catch (error) {\r\n        this.logger.warn('Error checking order status', {\r\n          orderId,\r\n          error: error instanceof Error ? error.message : String(error),\r\n        });\r\n        await this.sleep(ORDER_CHECK_INTERVAL_MS);\r\n      }\r\n    }\r\n\r\n    // Timeout reached\r\n    const executionTime = Date.now() - startTime;\r\n    this.logger.warn('â±ï¸ Limit order fill timeout', {\r\n      orderId,\r\n      timeoutMs,\r\n      executionTime,\r\n    });\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Cancel unfilled limit order\r\n   *\r\n   * @param orderId - Order ID to cancel\r\n   * @returns True if cancelled successfully\r\n   */\r\n  async cancelOrder(orderId: string): Promise<boolean> {\r\n    try {\r\n      this.logger.info('ðŸš« Cancelling unfilled limit order', { orderId });\r\n\r\n      const response = await this.bybitService.getRestClient().cancelOrder({\r\n        category: 'linear',\r\n        symbol: this.bybitService.getSymbol(),\r\n        orderId,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        // Order might already be filled or cancelled\r\n        if (response.retMsg.includes('not exists') || response.retMsg.includes('too late')) {\r\n          this.logger.warn('Order already filled or cancelled', {\r\n            orderId,\r\n            reason: response.retMsg,\r\n          });\r\n          return false;\r\n        }\r\n\r\n        throw new Error(`Failed to cancel order: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('âœ… Order cancelled successfully', { orderId });\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Failed to cancel order', {\r\n        orderId,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fallback to market order execution\r\n   *\r\n   * Used when limit order times out or fails\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param quantity - Order quantity (contracts)\r\n   * @param leverage - Position leverage\r\n   * @returns MarketOrderResult with execution details\r\n   */\r\n  async fallbackToMarket(\r\n    direction: SignalDirection,\r\n    quantity: number,\r\n    leverage: number,\r\n  ): Promise<MarketOrderResult> {\r\n    const startTime = Date.now();\r\n\r\n    this.logger.info('ðŸ”„ Falling back to market order', {\r\n      direction,\r\n      quantity,\r\n      leverage,\r\n    });\r\n\r\n    try {\r\n      // Use existing BybitService.openPosition for market order\r\n      const side = direction === SignalDirection.LONG ? PositionSide.LONG : PositionSide.SHORT;\r\n\r\n      const orderId = await this.bybitService.openPosition({\r\n        side,\r\n        quantity,\r\n        leverage,\r\n      });\r\n\r\n      // Get order details to find fill price\r\n      const response = await this.bybitService.getRestClient().getHistoricOrders({\r\n        category: 'linear',\r\n        symbol: this.bybitService.getSymbol(),\r\n        orderId,\r\n        limit: 1,\r\n      });\r\n\r\n      let fillPrice = 0;\r\n      if (response.retCode === BYBIT_SUCCESS_CODE && response.result?.list?.length > 0) {\r\n        const order = response.result.list[0];\r\n        fillPrice = parseFloat(order.avgPrice || '0');\r\n      }\r\n\r\n      const executionTime = Date.now() - startTime;\r\n\r\n      // Calculate taker fee (0.06%)\r\n      const feePaid = (quantity * fillPrice * TAKER_FEE_PERCENT) / PERCENT_MULTIPLIER;\r\n\r\n      this.logger.info('âœ… Market order executed', {\r\n        orderId,\r\n        fillPrice,\r\n        feePaid,\r\n        executionTime,\r\n      });\r\n\r\n      return {\r\n        orderId,\r\n        filled: true as const, // Market orders are always filled\r\n        fillPrice,\r\n        feePaid,\r\n        executionTime,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to execute market order', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute entry with limit order and optional market fallback\r\n   *\r\n   * Main entry point for limit order execution:\r\n   * 1. Calculate limit price\r\n   * 2. Place limit order\r\n   * 3. Wait for fill with timeout\r\n   * 4. If not filled â†’ cancel and fallback to market (if enabled)\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param quantity - Order quantity (contracts)\r\n   * @param currentPrice - Current market price\r\n   * @param leverage - Position leverage\r\n   * @returns Execution result (limit or market)\r\n   */\r\n  async executeEntry(\r\n    direction: SignalDirection,\r\n    quantity: number,\r\n    currentPrice: number,\r\n    leverage: number,\r\n  ): Promise<LimitOrderResult | MarketOrderResult> {\r\n    if (!this.config.enabled) {\r\n      this.logger.warn('Limit order execution disabled, using market order');\r\n      return await this.fallbackToMarket(direction, quantity, leverage);\r\n    }\r\n\r\n    try {\r\n      // 1. Calculate limit price\r\n      const limitPrice = this.calculateLimitPrice(\r\n        direction,\r\n        currentPrice,\r\n        this.config.slippagePercent,\r\n      );\r\n\r\n      this.logger.info('ðŸ“Š Limit order execution started', {\r\n        direction,\r\n        quantity,\r\n        currentPrice,\r\n        limitPrice,\r\n        slippage: this.config.slippagePercent,\r\n      });\r\n\r\n      // 2. Place limit order\r\n      const limitResult = await this.placeLimitOrder(direction, quantity, limitPrice, leverage);\r\n\r\n      // 3. Wait for fill\r\n      const filled = await this.waitForFill(limitResult.orderId, this.config.timeoutMs);\r\n\r\n      if (filled) {\r\n        // Success! Calculate maker fee (0.01%)\r\n        const feePaid = (quantity * limitPrice * MAKER_FEE_PERCENT) / PERCENT_MULTIPLIER;\r\n\r\n        this.logger.info('ðŸ’° Limit order filled successfully - Fee savings achieved!', {\r\n          orderId: limitResult.orderId,\r\n          fillPrice: limitPrice,\r\n          feePaid,\r\n          feeSavings: `${(TAKER_FEE_PERCENT - MAKER_FEE_PERCENT).toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n        });\r\n\r\n        return {\r\n          ...limitResult,\r\n          filled: true,\r\n          fillPrice: limitPrice,\r\n          feePaid,\r\n        };\r\n      }\r\n\r\n      // 4. Not filled - cancel and fallback\r\n      this.logger.warn('Limit order not filled within timeout', {\r\n        orderId: limitResult.orderId,\r\n        timeoutMs: this.config.timeoutMs,\r\n      });\r\n\r\n      await this.cancelOrder(limitResult.orderId);\r\n\r\n      if (this.config.fallbackToMarket) {\r\n        this.logger.info('Fallback to market order enabled, executing market order');\r\n        return await this.fallbackToMarket(direction, quantity, leverage);\r\n      }\r\n\r\n      // No fallback - return unfilled result\r\n      this.logger.warn('Fallback to market disabled - entry failed');\r\n      return {\r\n        ...limitResult,\r\n        filled: false,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Limit order execution failed', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      // If fallback enabled, try market order\r\n      if (this.config.fallbackToMarket) {\r\n        this.logger.info('Attempting market order fallback due to error');\r\n        return await this.fallbackToMarket(direction, quantity, leverage);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Sleep for specified milliseconds\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\logger.service.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1505,1561],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 7.","line":73,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":73,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":73,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":73,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":73,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":45},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":85,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":89,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":87,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":87,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":87,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":87,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":66},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2339,2410],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2466,2530],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2581,2636],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":104,"column":10,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":104,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2814,2820],"text":"today.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2814,2820],"text":"today === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2814,2820],"text":"!Boolean(today)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":115,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":115,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3098,3111],"text":"(entry.context != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":151,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":151,"endColumn":36},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":168,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":168,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4753,4818],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":192,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":192,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[5344,5397],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":195,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":195,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[5452,5504],"text":""},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":198,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":198,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5560,5612],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":201,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":201,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5670,5723],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Logger Service\r\n *\r\n * Centralized logging service with file and console support\r\n * Features:\r\n * - File logging with daily rotation\r\n * - Console logging with colors\r\n * - Async queue-based file writes\r\n * - 7-day log cleanup\r\n *\r\n * RULE: NO fallbacks, FAIL FAST\r\n */\r\n\r\nimport { existsSync, mkdirSync } from 'fs';\r\nimport { appendFile } from 'fs/promises';\r\nimport { join } from 'path';\r\nimport { LogLevel, LogEntry } from '../types';\r\n\r\nconst LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {\r\n  [LogLevel.DEBUG]: 0,\r\n  [LogLevel.INFO]: 1,\r\n  [LogLevel.WARN]: 2,\r\n  [LogLevel.ERROR]: 3,\r\n};\r\n\r\ninterface WriteQueueItem {\r\n  filePath: string;\r\n  content: string;\r\n}\r\n\r\nexport class LoggerService {\r\n  private readonly minLevel: LogLevel;\r\n  private readonly logDir: string;\r\n  private readonly logToFile: boolean;\r\n  private logs: LogEntry[] = [];\r\n  private writeQueue: WriteQueueItem[] = [];\r\n  private isProcessingQueue: boolean = false;\r\n\r\n  constructor(\r\n    minLevel: LogLevel = LogLevel.INFO,\r\n    logDir: string = './logs',\r\n    logToFile: boolean = true,\r\n  ) {\r\n    this.minLevel = minLevel;\r\n    this.logDir = logDir;\r\n    this.logToFile = logToFile;\r\n\r\n    if (this.logToFile) {\r\n      this.ensureLogDirectory();\r\n      // Start cleanup in background\r\n      void this.cleanOldLogs();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure log directory exists\r\n   */\r\n  private ensureLogDirectory(): void {\r\n    if (!existsSync(this.logDir)) {\r\n      mkdirSync(this.logDir, { recursive: true });\r\n      console.log(`ðŸ“ Created log directory: ${this.logDir}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean old log files (>7 days)\r\n   */\r\n  private async cleanOldLogs(): Promise<void> {\r\n    try {\r\n      const { readdir, stat, unlink } = await import('fs/promises');\r\n      const files = await readdir(this.logDir);\r\n      const now = Date.now();\r\n      const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n      for (const file of files) {\r\n        if (!file.endsWith('.log')) {\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          const filePath = join(this.logDir, file);\r\n          const stats = await stat(filePath);\r\n          const age = now - stats.mtime.getTime();\r\n\r\n          if (age > maxAge) {\r\n            await unlink(filePath);\r\n            const daysOld = Math.floor(age / (24 * 60 * 60 * 1000));\r\n            console.log(`ðŸ—‘ï¸ Deleted old log file: ${file} (${daysOld} days old)`);\r\n          }\r\n        } catch (fileError) {\r\n          console.error(`Failed to process log file ${file}:`, fileError);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to clean old log files:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get today's date string for filename\r\n   */\r\n  private getTodayString(): string {\r\n    const today = new Date().toISOString().split('T')[0];\r\n    if (!today) {\r\n      throw new Error('Failed to get date string');\r\n    }\r\n    return today;\r\n  }\r\n\r\n  /**\r\n   * Format log entry as string\r\n   */\r\n  private formatLogEntry(entry: LogEntry): string {\r\n    const timestamp = new Date(entry.timestamp).toISOString();\r\n    const contextStr = entry.context ? ` | ${JSON.stringify(entry.context)}` : '';\r\n    return `[${timestamp}] [${entry.level}] ${entry.message}${contextStr}`;\r\n  }\r\n\r\n  /**\r\n   * Write log entry to file (async queue)\r\n   */\r\n  private writeToFile(entry: LogEntry): void {\r\n    if (!this.logToFile) {\r\n      return;\r\n    }\r\n\r\n    const today = this.getTodayString();\r\n    const fileName = `trading-bot-${today}.log`;\r\n    const filePath = join(this.logDir, fileName);\r\n    const logLine = this.formatLogEntry(entry) + '\\n';\r\n\r\n    this.writeQueue.push({ filePath, content: logLine });\r\n    void this.processWriteQueue();\r\n  }\r\n\r\n  /**\r\n   * Process write queue asynchronously\r\n   */\r\n  private async processWriteQueue(): Promise<void> {\r\n    if (this.isProcessingQueue || this.writeQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.isProcessingQueue = true;\r\n\r\n    try {\r\n      // Group writes by file for efficiency\r\n      const fileGroups = new Map<string, string[]>();\r\n\r\n      // Process up to 10 entries at a time\r\n      const batchSize = Math.min(10, this.writeQueue.length);\r\n      const batch = this.writeQueue.splice(0, batchSize);\r\n\r\n      for (const { filePath, content } of batch) {\r\n        if (!fileGroups.has(filePath)) {\r\n          fileGroups.set(filePath, []);\r\n        }\r\n        fileGroups.get(filePath)!.push(content);\r\n      }\r\n\r\n      // Write all groups in parallel\r\n      const writePromises = Array.from(fileGroups.entries()).map(\r\n        async ([filePath, contents]) => {\r\n          try {\r\n            const combinedContent = contents.join('');\r\n            await appendFile(filePath, combinedContent);\r\n          } catch (error) {\r\n            console.error(`Failed to write to log file ${filePath}:`, error);\r\n          }\r\n        },\r\n      );\r\n\r\n      await Promise.all(writePromises);\r\n    } finally {\r\n      this.isProcessingQueue = false;\r\n\r\n      // Process remaining queue\r\n      if (this.writeQueue.length > 0) {\r\n        setImmediate(() => void this.processWriteQueue());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write log entry to console with colors\r\n   */\r\n  private writeToConsole(entry: LogEntry): void {\r\n    const formattedMessage = this.formatLogEntry(entry);\r\n\r\n    switch (entry.level) {\r\n    case LogLevel.DEBUG:\r\n      console.debug('\\x1b[36m%s\\x1b[0m', formattedMessage); // Cyan\r\n      break;\r\n    case LogLevel.INFO:\r\n      console.info('\\x1b[32m%s\\x1b[0m', formattedMessage); // Green\r\n      break;\r\n    case LogLevel.WARN:\r\n      console.warn('\\x1b[33m%s\\x1b[0m', formattedMessage); // Yellow\r\n      break;\r\n    case LogLevel.ERROR:\r\n      console.error('\\x1b[31m%s\\x1b[0m', formattedMessage); // Red\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log debug message\r\n   */\r\n  debug(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.DEBUG, message, context);\r\n  }\r\n\r\n  /**\r\n   * Log info message\r\n   */\r\n  info(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.INFO, message, context);\r\n  }\r\n\r\n  /**\r\n   * Log warning message\r\n   */\r\n  warn(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.WARN, message, context);\r\n  }\r\n\r\n  /**\r\n   * Log error message\r\n   */\r\n  error(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.ERROR, message, context);\r\n  }\r\n\r\n  /**\r\n   * Internal log method\r\n   */\r\n  private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {\r\n    const levelPriority = LOG_LEVEL_PRIORITY[level];\r\n    const minPriority = LOG_LEVEL_PRIORITY[this.minLevel];\r\n\r\n    if (levelPriority < minPriority) {\r\n      return; // Skip logs below minimum level\r\n    }\r\n\r\n    const entry: LogEntry = {\r\n      level,\r\n      message,\r\n      timestamp: Date.now(),\r\n      context,\r\n    };\r\n\r\n    this.logs.push(entry);\r\n    this.writeToConsole(entry);\r\n    this.writeToFile(entry);\r\n  }\r\n\r\n  /**\r\n   * Get all logs\r\n   */\r\n  getLogs(): LogEntry[] {\r\n    return [...this.logs];\r\n  }\r\n\r\n  /**\r\n   * Get logs by level\r\n   */\r\n  getLogsByLevel(level: LogLevel): LogEntry[] {\r\n    return this.logs.filter((log) => log.level === level);\r\n  }\r\n\r\n  /**\r\n   * Clear logs\r\n   */\r\n  clear(): void {\r\n    this.logs = [];\r\n  }\r\n\r\n  /**\r\n   * Get current log file path\r\n   */\r\n  getLogFilePath(): string | null {\r\n    if (!this.logToFile) {\r\n      return null;\r\n    }\r\n    const today = this.getTodayString();\r\n    const fileName = `trading-bot-${today}.log`;\r\n    return join(this.logDir, fileName);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\loss-streak.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":68,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":68,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2060,2087],"text":"(this.config.stopAfterLosses != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2060,2087],"text":"(this.config.stopAfterLosses ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2060,2087],"text":"(Boolean(this.config.stopAfterLosses))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":86,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":90,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":90,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":94,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":94,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":125,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":125,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3470,3497],"text":"(this.config.stopAfterLosses != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3470,3497],"text":"(this.config.stopAfterLosses ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3470,3497],"text":"(Boolean(this.config.stopAfterLosses))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Loss Streak Service (PHASE 5)\r\n *\r\n * Reduces position size after consecutive losses to limit drawdown.\r\n *\r\n * Problem:\r\n * - Bot continues trading at full size after losses\r\n * - Can amplify drawdown during bad market conditions\r\n *\r\n * Solution: Adaptive Position Sizing\r\n * - After 1 loss: Normal size (100%)\r\n * - After 2 losses in a row: Reduce to 75%\r\n * - After 3 losses in a row: Reduce to 50%\r\n * - After 4+ losses in a row: Reduce to 25% (or stop)\r\n * - After 1 win: Reset to normal\r\n *\r\n * Features:\r\n * - Tracks consecutive wins/losses\r\n * - Progressive size reduction\r\n * - Optional emergency stop after N losses\r\n * - Automatic reset after win\r\n */\r\n\r\nimport { LossStreakConfig, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// LOSS STREAK SERVICE\r\n// ============================================================================\r\n\r\nexport class LossStreakService {\r\n  private consecutiveLosses: number = 0;\r\n  private consecutiveWins: number = 0;\r\n\r\n  constructor(\r\n    private config: LossStreakConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Record trade result\r\n   * Call after each trade closes\r\n   *\r\n   * @param isWin - True if trade was profitable, false if loss\r\n   */\r\n  recordTrade(isWin: boolean): void {\r\n    if (isWin) {\r\n      this.consecutiveWins++;\r\n      this.consecutiveLosses = 0; // Reset loss streak\r\n\r\n      this.logger.info('âœ… Win recorded - loss streak reset (PHASE 5)', {\r\n        consecutiveWins: this.consecutiveWins,\r\n        sizeMultiplier: '100%',\r\n      });\r\n    } else {\r\n      this.consecutiveLosses++;\r\n      this.consecutiveWins = 0; // Reset win streak\r\n\r\n      const multiplier = this.getSizeMultiplier();\r\n\r\n      this.logger.warn('âŒ Loss recorded (PHASE 5)', {\r\n        consecutiveLosses: this.consecutiveLosses,\r\n        sizeMultiplier: (multiplier * PERCENT_MULTIPLIER).toFixed(0) + '%',\r\n      });\r\n\r\n      // Check if need to stop\r\n      if (\r\n        this.config.stopAfterLosses &&\r\n        this.consecutiveLosses >= this.config.stopAfterLosses\r\n      ) {\r\n        this.logger.error(\r\n          `â›” ${this.config.stopAfterLosses} consecutive losses - EMERGENCY STOP (PHASE 5)`,\r\n        );\r\n        process.exit(1); // Stop bot\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current position size multiplier\r\n   * Apply this to calculated position size before opening trade\r\n   *\r\n   * @returns Multiplier (0.25 to 1.0)\r\n   */\r\n  getSizeMultiplier(): number {\r\n    if (this.consecutiveLosses >= 4) {\r\n      return this.config.reductions.after4Losses;\r\n    }\r\n\r\n    if (this.consecutiveLosses >= 3) {\r\n      return this.config.reductions.after3Losses;\r\n    }\r\n\r\n    if (this.consecutiveLosses >= 2) {\r\n      return this.config.reductions.after2Losses;\r\n    }\r\n\r\n    return 1.0; // Normal size\r\n  }\r\n\r\n  /**\r\n   * Get consecutive losses count\r\n   * @returns Number of consecutive losses\r\n   */\r\n  getConsecutiveLosses(): number {\r\n    return this.consecutiveLosses;\r\n  }\r\n\r\n  /**\r\n   * Get consecutive wins count\r\n   * @returns Number of consecutive wins\r\n   */\r\n  getConsecutiveWins(): number {\r\n    return this.consecutiveWins;\r\n  }\r\n\r\n  /**\r\n   * Check if trading should be blocked\r\n   * Returns true if stop limit reached\r\n   *\r\n   * @returns Object with blocked flag and optional reason\r\n   */\r\n  canTrade(): { allowed: boolean; reason?: string } {\r\n    if (\r\n      this.config.stopAfterLosses &&\r\n      this.consecutiveLosses >= this.config.stopAfterLosses\r\n    ) {\r\n      return {\r\n        allowed: false,\r\n        reason: `${this.consecutiveLosses} consecutive losses (limit: ${this.config.stopAfterLosses})`,\r\n      };\r\n    }\r\n\r\n    return { allowed: true };\r\n  }\r\n\r\n  /**\r\n   * Manually reset streak (for testing)\r\n   * Should not be used in production\r\n   */\r\n  reset(): void {\r\n    this.logger.warn('âš ï¸ Loss streak manually reset');\r\n    this.consecutiveLosses = 0;\r\n    this.consecutiveWins = 0;\r\n  }\r\n\r\n  /**\r\n   * Get config for testing/debugging\r\n   * @returns Deep copy of config\r\n   */\r\n  getConfig(): LossStreakConfig {\r\n    return {\r\n      ...this.config,\r\n      reductions: { ...this.config.reductions }, // Deep copy\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\market-data-collector.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":62,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":62,"endColumn":46,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2330,2367],"text":"(config.indicators.stochastic?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2330,2367],"text":"(config.indicators.stochastic?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":69,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":69,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2686,2727],"text":"(config.indicators.bollingerBands?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2686,2727],"text":"(config.indicators.bollingerBands?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":83,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":83,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3336,3363],"text":"(config.tfAlignment?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3336,3363],"text":"(config.tfAlignment?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'collect' has a complexity of 39. Maximum allowed is 10.","line":96,"column":16,"nodeType":"FunctionExpression","messageId":"complex","endLine":300,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":113,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":113,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4449,4475],"text":"(ema[TimeframeRole.PRIMARY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":116,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":116,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4674,4698],"text":"(ema[TimeframeRole.ENTRY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":123,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":123,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":157,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":157,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6338,6362],"text":"(this.stochasticIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":157,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":157,"endColumn":72,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6366,6399],"text":"(this.config.indicators.stochastic != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":180,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":180,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7319,7342],"text":"(this.bollingerIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":180,"column":38,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":180,"endColumn":75,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7346,7383],"text":"(this.config.indicators.bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":183,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":190,"endColumn":12},{"ruleId":"max-len","severity":1,"message":"This line has a length of 123. Maximum allowed is 120.","line":221,"column":1,"nodeType":"Program","messageId":"max","endLine":221,"endColumn":124},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9077,9100],"text":"(this.tfAlignmentService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":38,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9104,9128],"text":"(ema[TimeframeRole.ENTRY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":66,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":92,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9132,9158],"text":"(ema[TimeframeRole.PRIMARY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":96,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":121,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9162,9187],"text":"(ema[TimeframeRole.TREND1] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'entryCandles' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":256,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":256,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":259,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":259,"endColumn":27},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":263,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":265,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":263,"column":15,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":263,"endColumn":28}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Market Data Collector Service\r\n *\r\n * Collects market data from multiple sources:\r\n * - Current price (Bybit)\r\n * - RSI data (Multi-timeframe)\r\n * - EMA data (Multi-timeframe)\r\n * - ZigZag swing points (Highs/Lows)\r\n * - Market structure (Pattern/Bias)\r\n * - Stochastic oscillator (optional)\r\n * - Bollinger Bands (optional)\r\n * - ATR for adaptive BB params\r\n *\r\n * Extracted from SignalGeneratorService for better testability and SRP.\r\n */\r\n\r\nimport {\r\n  SwingPoint,\r\n  Candle,\r\n  TimeframeRole,\r\n  LoggerService,\r\n  MarketData,\r\n  Config,\r\n  RSIValues,\r\n  EMAValues,\r\n} from '../types';\r\nimport { MultiTimeframeRSIAnalyzer } from '../analyzers/multi-timeframe-rsi.analyzer';\r\nimport { MultiTimeframeEMAAnalyzer } from '../analyzers/multi-timeframe-ema.analyzer';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { StochasticIndicator } from '../indicators/stochastic.indicator';\r\nimport { BollingerBandsIndicator } from '../indicators/bollinger.indicator';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { VWAPIndicator } from '../indicators/vwap.indicator';\r\nimport { MarketStructureAnalyzer } from '../analyzers/market-structure.analyzer';\r\nimport { TFAlignmentService } from './tf-alignment.service';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { BybitService } from './bybit';\r\n\r\n// ============================================================================\r\n// MARKET DATA COLLECTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class MarketDataCollector {\r\n  private stochasticIndicator?: StochasticIndicator;\r\n  private bollingerIndicator?: BollingerBandsIndicator;\r\n  private atrIndicator: ATRIndicator;\r\n  private vwapIndicator: VWAPIndicator;\r\n  private tfAlignmentService?: TFAlignmentService;\r\n\r\n  constructor(\r\n    private rsiAnalyzer: MultiTimeframeRSIAnalyzer,\r\n    private emaAnalyzer: MultiTimeframeEMAAnalyzer,\r\n    private zigzagIndicator: ZigZagIndicator,\r\n    private structureAnalyzer: MarketStructureAnalyzer,\r\n    private candleProvider: CandleProvider,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n    private config: Config,\r\n  ) {\r\n    // Initialize Stochastic if enabled\r\n    if (config.indicators.stochastic?.enabled) {\r\n      const { kPeriod, dPeriod, smooth } = config.indicators.stochastic;\r\n      this.stochasticIndicator = new StochasticIndicator(kPeriod, dPeriod, smooth);\r\n      this.logger.info('âœ… StochasticIndicator initialized', { kPeriod, dPeriod, smooth });\r\n    }\r\n\r\n    // Initialize Bollinger Bands if enabled\r\n    if (config.indicators.bollingerBands?.enabled) {\r\n      const { period, stdDev } = config.indicators.bollingerBands;\r\n      this.bollingerIndicator = new BollingerBandsIndicator(period, stdDev);\r\n      this.logger.info('âœ… BollingerBandsIndicator initialized', { period, stdDev });\r\n    }\r\n\r\n    // Always initialize ATR (used for adaptive BB and strategies)\r\n    this.atrIndicator = new ATRIndicator(config.indicators.atrPeriod);\r\n\r\n    // Always initialize VWAP (PHASE 6)\r\n    this.vwapIndicator = new VWAPIndicator();\r\n    this.logger.info('âœ… VWAPIndicator initialized (PHASE 6)');\r\n\r\n    // Initialize TFAlignmentService if enabled (PHASE 6)\r\n    if (config.tfAlignment?.enabled) {\r\n      this.tfAlignmentService = new TFAlignmentService(config.tfAlignment, logger);\r\n      this.logger.info('âœ… TFAlignmentService initialized (PHASE 6)', {\r\n        minAlignmentScore: config.tfAlignment.minAlignmentScore,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collect all market data from sources\r\n   *\r\n   * @returns MarketData object or null if collection fails\r\n   */\r\n  async collect(): Promise<MarketData | null> {\r\n    try {\r\n      // Get current price\r\n      const currentPrice = await this.getCurrentPrice();\r\n      this.logger.debug('Current price', { price: currentPrice });\r\n\r\n      // Get RSI data\r\n      const rsi = await this.getRSIData();\r\n      this.logger.debug('RSI data collected', {\r\n        primary: rsi[TimeframeRole.PRIMARY]?.toFixed(DECIMAL_PLACES.PERCENT),\r\n        entry: rsi[TimeframeRole.ENTRY]?.toFixed(DECIMAL_PLACES.PERCENT),\r\n        trend1: rsi[TimeframeRole.TREND1]?.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Get EMA data\r\n      const ema = await this.getEMAData();\r\n      this.logger.debug('EMA data collected', {\r\n        primary: ema[TimeframeRole.PRIMARY]\r\n          ? `fast=${ema[TimeframeRole.PRIMARY].fast?.toFixed(DECIMAL_PLACES.PERCENT)}, slow=${ema[TimeframeRole.PRIMARY].slow?.toFixed(DECIMAL_PLACES.PERCENT)}`\r\n          : 'N/A',\r\n        entry: ema[TimeframeRole.ENTRY]\r\n          ? `fast=${ema[TimeframeRole.ENTRY].fast?.toFixed(DECIMAL_PLACES.PERCENT)}, slow=${ema[TimeframeRole.ENTRY].slow?.toFixed(DECIMAL_PLACES.PERCENT)}`\r\n          : 'N/A',\r\n      });\r\n\r\n      // Get ZigZag data (PRIMARY timeframe)\r\n      const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n      if (!primaryCandles || primaryCandles.length === 0) {\r\n        this.logger.warn('No PRIMARY candles available');\r\n        return null;\r\n      }\r\n\r\n      const { highs: zigzagHighs, lows: zigzagLows } = this.getZigZagData(primaryCandles);\r\n\r\n      this.logger.debug('ZigZag data collected', {\r\n        highs: zigzagHighs.length,\r\n        lows: zigzagLows.length,\r\n        recentHigh: zigzagHighs.length > 0 ? zigzagHighs[zigzagHighs.length - 1].price : 'N/A',\r\n        recentLow: zigzagLows.length > 0 ? zigzagLows[zigzagLows.length - 1].price : 'N/A',\r\n      });\r\n\r\n      // Analyze structure\r\n      const pattern = this.structureAnalyzer.getLastPattern(zigzagHighs, zigzagLows);\r\n      const bias = this.structureAnalyzer.getTrendBias(zigzagHighs, zigzagLows);\r\n\r\n      this.logger.info('ðŸ“Š Market structure', {\r\n        pattern,\r\n        bias,\r\n      });\r\n\r\n      // Calculate ATR (always available)\r\n      let atr: number | undefined;\r\n      try {\r\n        atr = this.atrIndicator.calculate(primaryCandles);\r\n        this.logger.debug('ATR calculated', { atr: atr?.toFixed(DECIMAL_PLACES.PRICE) });\r\n      } catch (error) {\r\n        this.logger.warn('ATR calculation failed', { error });\r\n      }\r\n\r\n      // Calculate Stochastic if enabled\r\n      let stochastic: MarketData['stochastic'];\r\n      if (this.stochasticIndicator && this.config.indicators.stochastic) {\r\n        try {\r\n          const result = this.stochasticIndicator.calculate(primaryCandles);\r\n          const { oversoldThreshold, overboughtThreshold } = this.config.indicators.stochastic;\r\n          stochastic = {\r\n            k: result.k,\r\n            d: result.d,\r\n            isOversold: result.k < oversoldThreshold,\r\n            isOverbought: result.k > overboughtThreshold,\r\n          };\r\n          this.logger.debug('Stochastic calculated', {\r\n            k: result.k.toFixed(DECIMAL_PLACES.PERCENT),\r\n            d: result.d.toFixed(DECIMAL_PLACES.PERCENT),\r\n            oversold: stochastic.isOversold,\r\n            overbought: stochastic.isOverbought,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Stochastic calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate Bollinger Bands if enabled\r\n      let bollingerBands: MarketData['bollingerBands'];\r\n      if (this.bollingerIndicator && this.config.indicators.bollingerBands) {\r\n        try {\r\n          // Apply adaptive params if enabled and ATR available\r\n          if (this.config.indicators.bollingerBands.adaptiveParams && atr !== undefined) {\r\n            const adaptiveParams = this.bollingerIndicator.getAdaptiveParams(atr, currentPrice);\r\n            this.bollingerIndicator.applyAdaptiveParams(adaptiveParams);\r\n            this.logger.debug('BB adaptive params applied', {\r\n              period: adaptiveParams.period,\r\n              stdDev: adaptiveParams.stdDev,\r\n            });\r\n          }\r\n\r\n          const result = this.bollingerIndicator.calculate(primaryCandles);\r\n          const isSqueeze = this.bollingerIndicator.isSqueeze(\r\n            this.config.indicators.bollingerBands.squeezeThreshold,\r\n          );\r\n\r\n          bollingerBands = {\r\n            upper: result.upper,\r\n            middle: result.middle,\r\n            lower: result.lower,\r\n            width: result.width,\r\n            percentB: result.percentB,\r\n            isSqueeze,\r\n          };\r\n\r\n          this.logger.debug('Bollinger Bands calculated', {\r\n            upper: result.upper.toFixed(DECIMAL_PLACES.PERCENT),\r\n            middle: result.middle.toFixed(DECIMAL_PLACES.PERCENT),\r\n            lower: result.lower.toFixed(DECIMAL_PLACES.PERCENT),\r\n            width: result.width.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n            percentB: result.percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n            squeeze: isSqueeze,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Bollinger Bands calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate TF Alignment (PHASE 6)\r\n      let tfAlignment: MarketData['tfAlignment'];\r\n      if (this.tfAlignmentService && ema[TimeframeRole.ENTRY] && ema[TimeframeRole.PRIMARY] && ema[TimeframeRole.TREND1]) {\r\n        try {\r\n          const longAlignment = this.tfAlignmentService.calculateAlignment('LONG', currentPrice, {\r\n            entry: { ema20: ema[TimeframeRole.ENTRY]?.fast ?? 0 },\r\n            primary: { ema20: ema[TimeframeRole.PRIMARY]?.fast ?? 0, ema50: ema[TimeframeRole.PRIMARY]?.slow ?? 0 },\r\n            trend1: { ema20: ema[TimeframeRole.TREND1]?.fast ?? 0, ema50: ema[TimeframeRole.TREND1]?.slow ?? 0 },\r\n          });\r\n\r\n          const shortAlignment = this.tfAlignmentService.calculateAlignment(\r\n            'SHORT',\r\n            currentPrice,\r\n            {\r\n              entry: { ema20: ema[TimeframeRole.ENTRY]?.fast ?? 0 },\r\n              primary: { ema20: ema[TimeframeRole.PRIMARY]?.fast ?? 0, ema50: ema[TimeframeRole.PRIMARY]?.slow ?? 0 },\r\n              trend1: { ema20: ema[TimeframeRole.TREND1]?.fast ?? 0, ema50: ema[TimeframeRole.TREND1]?.slow ?? 0 },\r\n            },\r\n          );\r\n\r\n          tfAlignment = {\r\n            long: longAlignment,\r\n            short: shortAlignment,\r\n          };\r\n\r\n          this.logger.debug('TF Alignment calculated (PHASE 6)', {\r\n            long: `${longAlignment.score.toFixed(0)}% (${longAlignment.aligned ? 'aligned' : 'not aligned'})`,\r\n            short: `${shortAlignment.score.toFixed(0)}% (${shortAlignment.aligned ? 'aligned' : 'not aligned'})`,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('TF Alignment calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate VWAP (PHASE 6)\r\n      let vwap: MarketData['vwap'];\r\n      try {\r\n        const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n        const trend1Candles = await this.candleProvider.getCandles(TimeframeRole.TREND1);\r\n\r\n        if (primaryCandles && primaryCandles.length > 0) {\r\n          const vwapPrimary = this.vwapIndicator.calculate(primaryCandles);\r\n\r\n          let vwapTrend1 = 0;\r\n          if (trend1Candles && trend1Candles.length > 0) {\r\n            vwapTrend1 = this.vwapIndicator.calculate(trend1Candles);\r\n          }\r\n\r\n          vwap = {\r\n            primary: vwapPrimary,\r\n            trend1: vwapTrend1,\r\n          };\r\n\r\n          this.logger.debug('VWAP calculated (PHASE 6)', {\r\n            primary: vwapPrimary.toFixed(DECIMAL_PLACES.PERCENT),\r\n            trend1: vwapTrend1.toFixed(DECIMAL_PLACES.PERCENT),\r\n          });\r\n        }\r\n      } catch (error) {\r\n        this.logger.warn('VWAP calculation failed', { error });\r\n      }\r\n\r\n      return {\r\n        rsi,\r\n        ema,\r\n        zigzagHighs,\r\n        zigzagLows,\r\n        currentPrice,\r\n        candles: primaryCandles,\r\n        pattern,\r\n        bias,\r\n        stochastic,\r\n        bollingerBands,\r\n        atr,\r\n        tfAlignment,\r\n        vwap,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error collecting market data', { error });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current price from exchange\r\n   *\r\n   * @returns Current price\r\n   * @throws Error if fetch fails\r\n   */\r\n  async getCurrentPrice(): Promise<number> {\r\n    return await this.bybitService.getCurrentPrice();\r\n  }\r\n\r\n  /**\r\n   * Get RSI data from all timeframes\r\n   *\r\n   * @returns RSI values from all timeframes\r\n   */\r\n  async getRSIData(): Promise<RSIValues> {\r\n    return (await this.rsiAnalyzer.calculateAll()) as unknown as RSIValues;\r\n  }\r\n\r\n  /**\r\n   * Get EMA data from all timeframes\r\n   *\r\n   * @returns EMA values from all timeframes\r\n   */\r\n  async getEMAData(): Promise<EMAValues> {\r\n    return (await this.emaAnalyzer.calculateAll()) as unknown as EMAValues;\r\n  }\r\n\r\n  /**\r\n   * Get ZigZag swing points from candles\r\n   *\r\n   * @param candles - Candle data\r\n   * @returns Object with highs and lows arrays\r\n   */\r\n  getZigZagData(candles: Candle[]): { highs: SwingPoint[]; lows: SwingPoint[] } {\r\n    const highs = this.zigzagIndicator.findSwingHighs(candles);\r\n    const lows = this.zigzagIndicator.findSwingLows(candles);\r\n\r\n    return { highs, lows };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\max-concurrent-risk.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\micro-wall-detector.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":77,"column":21,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":77,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":78,"column":21,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":78,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":79,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":79,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":114,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":114,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":147,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":39},{"ruleId":"max-len","severity":1,"message":"This line has a length of 142. Maximum allowed is 120.","line":163,"column":1,"nodeType":"Program","messageId":"max","endLine":163,"endColumn":143},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":164,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":91},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":164,"column":93,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":95},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":168,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 25.","line":168,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":168,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":294,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":294,"endColumn":55}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Micro Wall Detector Service - Scalping Strategy\r\n *\r\n * Detects small orderbook walls (5-10% of total volume) for scalping\r\n * Unlike WhaleDetector (15-20% walls), MicroWall targets frequent small movements\r\n *\r\n * Strategy:\r\n * - Detect micro walls (5-10% of orderbook)\r\n * - Wait for price to break through wall\r\n * - Enter quickly with tight TP (0.15%) and SL (0.08%)\r\n * - Exit within 1-2 minutes\r\n *\r\n * IMPORTANT: Requires WebSocket orderbook for real-time data\r\n */\r\n\r\nimport { LoggerService, SignalDirection, MicroWallDetectorConfig, MicroWall, OrderBook, OrderbookLevel } from '../types';\r\n\r\n// ============================================================================\r\n// MICRO WALL DETECTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class MicroWallDetectorService {\r\n  private trackedWalls: Map<string, MicroWall> = new Map();\r\n  private brokenWalls: Map<string, number> = new Map(); // wall key â†’ broken timestamp\r\n\r\n  constructor(\r\n    private config: MicroWallDetectorConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('ðŸ” MicroWallDetectorService initialized', {\r\n      minWallSizePercent: config.minWallSizePercent,\r\n      breakConfirmationMs: config.breakConfirmationMs,\r\n      maxConfidence: config.maxConfidence,\r\n      wallExpiryMs: config.wallExpiryMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Detect micro walls in current orderbook\r\n   * @param orderbook - Current orderbook snapshot\r\n   * @returns Array of detected micro walls\r\n   */\r\n  detectMicroWalls(orderbook: OrderBook): MicroWall[] {\r\n    const now = Date.now();\r\n    const detectedWalls: MicroWall[] = [];\r\n\r\n    // Helper to extract price and size from OrderbookLevel union type\r\n    const getPrice = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n    };\r\n    const getSize = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n    };\r\n\r\n    // Calculate total orderbook volume\r\n    const totalBidVolume = orderbook.bids.reduce((sum: number, level: OrderbookLevel) => {\r\n      const price = getPrice(level);\r\n      const size = getSize(level);\r\n      return sum + price * size;\r\n    }, 0);\r\n    const totalAskVolume = orderbook.asks.reduce((sum: number, level: OrderbookLevel) => {\r\n      const price = getPrice(level);\r\n      const size = getSize(level);\r\n      return sum + price * size;\r\n    }, 0);\r\n    const totalVolume = totalBidVolume + totalAskVolume;\r\n\r\n    if (totalVolume === 0) {\r\n      this.logger.debug('âŒ MicroWall: Empty orderbook, skipping detection');\r\n      return [];\r\n    }\r\n\r\n    // Get current price (midpoint)\r\n    const firstBid = orderbook.bids[0];\r\n    const firstAsk = orderbook.asks[0];\r\n    const bestBid = firstBid ? getPrice(firstBid) : 0;\r\n    const bestAsk = firstAsk ? getPrice(firstAsk) : 0;\r\n    const currentPrice = (bestBid + bestAsk) / 2;\r\n\r\n    if (currentPrice === 0) {\r\n      this.logger.debug('âŒ MicroWall: Invalid price, skipping detection');\r\n      return [];\r\n    }\r\n\r\n    // Check bids for micro walls\r\n    for (const level of orderbook.bids) {\r\n      const price = getPrice(level);\r\n      const qty = getSize(level);\r\n      const volumeUSDT = price * qty;\r\n      const percentOfTotal = (volumeUSDT / totalVolume) * PERCENT_MULTIPLIER;\r\n\r\n      if (percentOfTotal >= this.config.minWallSizePercent) {\r\n        const distance = ((currentPrice - price) / currentPrice) * PERCENT_MULTIPLIER;\r\n        const wallKey = `BID_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n        const wall: MicroWall = {\r\n          side: 'BID',\r\n          price,\r\n          size: volumeUSDT,\r\n          percentOfTotal,\r\n          distance,\r\n          timestamp: now,\r\n          broken: false,\r\n        };\r\n\r\n        detectedWalls.push(wall);\r\n        this.trackedWalls.set(wallKey, wall);\r\n\r\n        this.logger.debug('ðŸŸ¢ MicroWall detected (BID)', {\r\n          price,\r\n          size: volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n          percent: percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n          distance: distance.toFixed(3),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check asks for micro walls\r\n    for (const level of orderbook.asks) {\r\n      const price = getPrice(level);\r\n      const qty = getSize(level);\r\n      const volumeUSDT = price * qty;\r\n      const percentOfTotal = (volumeUSDT / totalVolume) * PERCENT_MULTIPLIER;\r\n\r\n      if (percentOfTotal >= this.config.minWallSizePercent) {\r\n        const distance = ((price - currentPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n        const wallKey = `ASK_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n        const wall: MicroWall = {\r\n          side: 'ASK',\r\n          price,\r\n          size: volumeUSDT,\r\n          percentOfTotal,\r\n          distance,\r\n          timestamp: now,\r\n          broken: false,\r\n        };\r\n\r\n        detectedWalls.push(wall);\r\n        this.trackedWalls.set(wallKey, wall);\r\n\r\n        this.logger.debug('ðŸ”´ MicroWall detected (ASK)', {\r\n          price,\r\n          size: volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n          percent: percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n          distance: distance.toFixed(3),\r\n        });\r\n      }\r\n    }\r\n\r\n    return detectedWalls;\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for a micro wall\r\n   * Based on wall size and distance from current price\r\n   * @param wall - Micro wall to evaluate\r\n   * @returns Confidence score (0-100)\r\n   */\r\n  calculateWallConfidence(wall: MicroWall): number {\r\n    // Size score: 0-60 points (based on % of orderbook)\r\n    // 5% = PERCENTAGE_THRESHOLDS.MODERATE points, 10% = PERCENTAGE_THRESHOLDS.VERY_HIGH points, 15%+ = PERCENTAGE_THRESHOLDS.VERY_HIGH points\r\n    const sizeScore = Math.min((wall.percentOfTotal / this.config.minWallSizePercent) * 30, 60);\r\n\r\n    // Distance score: 0-30 points (closer = higher score)\r\n    // 0.1% distance = 25 points, 0.5% = 15 points, 1%+ = 5 points\r\n    const distanceScore = Math.max(30 - wall.distance * 25, 5);\r\n\r\n    const confidence = Math.min(sizeScore + distanceScore, this.config.maxConfidence);\r\n\r\n    this.logger.debug('ðŸ“Š MicroWall confidence calculated', {\r\n      side: wall.side,\r\n      price: wall.price,\r\n      sizeScore: sizeScore.toFixed(1),\r\n      distanceScore: distanceScore.toFixed(1),\r\n      confidence: confidence.toFixed(1),\r\n    });\r\n\r\n    return confidence;\r\n  }\r\n\r\n  /**\r\n   * Check if a micro wall was broken by current price\r\n   * @param wall - Micro wall to check\r\n   * @param currentPrice - Current market price\r\n   * @returns True if wall was broken\r\n   */\r\n  isWallBroken(wall: MicroWall, currentPrice: number): boolean {\r\n    const now = Date.now();\r\n\r\n    // Check if wall was already marked as broken\r\n    if (wall.broken) {\r\n      return true;\r\n    }\r\n\r\n    // BID wall broken = price moved DOWN through wall\r\n    if (wall.side === 'BID' && currentPrice < wall.price) {\r\n      const wallKey = `BID_${wall.price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n      // Check if this wall was already broken previously (skip duplicate)\r\n      if (this.brokenWalls.has(wallKey)) {\r\n        this.logger.debug('â­ï¸ MicroWall already broken previously (BID)', {\r\n          price: wall.price,\r\n          wallKey,\r\n        });\r\n        return false; // Wall already processed, skip to avoid duplicate signals\r\n      }\r\n\r\n      // Wait for confirmation period\r\n      const timeSinceDetection = now - wall.timestamp;\r\n      if (timeSinceDetection < this.config.breakConfirmationMs) {\r\n        this.logger.debug('â³ MicroWall break confirmation pending (BID)', {\r\n          price: wall.price,\r\n          currentPrice,\r\n          waitMs: this.config.breakConfirmationMs - timeSinceDetection,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      wall.broken = true;\r\n      wall.brokenAt = now;\r\n      this.brokenWalls.set(wallKey, now);\r\n\r\n      this.logger.info('ðŸ’¥ MicroWall BROKEN (BID â†’ SHORT signal)', {\r\n        wallPrice: wall.price,\r\n        currentPrice,\r\n        size: wall.size.toFixed(DECIMAL_PLACES.PERCENT),\r\n        percent: wall.percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    // ASK wall broken = price moved UP through wall\r\n    if (wall.side === 'ASK' && currentPrice > wall.price) {\r\n      const wallKey = `ASK_${wall.price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n      // Check if this wall was already broken previously (skip duplicate)\r\n      if (this.brokenWalls.has(wallKey)) {\r\n        this.logger.debug('â­ï¸ MicroWall already broken previously (ASK)', {\r\n          price: wall.price,\r\n          wallKey,\r\n        });\r\n        return false; // Wall already processed, skip to avoid duplicate signals\r\n      }\r\n\r\n      // Wait for confirmation period\r\n      const timeSinceDetection = now - wall.timestamp;\r\n      if (timeSinceDetection < this.config.breakConfirmationMs) {\r\n        this.logger.debug('â³ MicroWall break confirmation pending (ASK)', {\r\n          price: wall.price,\r\n          currentPrice,\r\n          waitMs: this.config.breakConfirmationMs - timeSinceDetection,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      wall.broken = true;\r\n      wall.brokenAt = now;\r\n      this.brokenWalls.set(wallKey, now);\r\n\r\n      this.logger.info('ðŸ’¥ MicroWall BROKEN (ASK â†’ LONG signal)', {\r\n        wallPrice: wall.price,\r\n        currentPrice,\r\n        size: wall.size.toFixed(DECIMAL_PLACES.PERCENT),\r\n        percent: wall.percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired walls from tracking\r\n   * Removes walls older than wallExpiryMs\r\n   */\r\n  cleanupExpiredWalls(): void {\r\n    const now = Date.now();\r\n    let cleanedCount = 0;\r\n\r\n    // Cleanup tracked walls\r\n    for (const [key, wall] of this.trackedWalls.entries()) {\r\n      const age = now - wall.timestamp;\r\n      if (age > this.config.wallExpiryMs) {\r\n        this.trackedWalls.delete(key);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    // Cleanup broken walls (prevent re-detection for longer period)\r\n    const breakExpiryMs = this.config.wallExpiryMs * 5; // 5x longer for broken walls\r\n    for (const [key, brokenAt] of this.brokenWalls.entries()) {\r\n      const age = now - brokenAt;\r\n      if (age > breakExpiryMs) {\r\n        this.brokenWalls.delete(key);\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      this.logger.debug('ðŸ§¹ MicroWall cleanup', {\r\n        removed: cleanedCount,\r\n        remaining: this.trackedWalls.size,\r\n        brokenTracked: this.brokenWalls.size,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all currently tracked micro walls\r\n   * @returns Array of tracked walls\r\n   */\r\n  getTrackedWalls(): MicroWall[] {\r\n    return Array.from(this.trackedWalls.values());\r\n  }\r\n\r\n  /**\r\n   * Check if wall was recently broken (prevents re-entry)\r\n   * @param side - Wall side\r\n   * @param price - Wall price\r\n   * @returns True if wall was recently broken\r\n   */\r\n  wasRecentlyBroken(side: 'BID' | 'ASK', price: number): boolean {\r\n    const wallKey = `${side}_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n    return this.brokenWalls.has(wallKey);\r\n  }\r\n\r\n  /**\r\n   * Get signal direction from broken wall\r\n   * @param wall - Broken wall\r\n   * @returns Signal direction (LONG or SHORT)\r\n   */\r\n  getSignalDirection(wall: MicroWall): SignalDirection {\r\n    // ASK wall broken = price went UP â†’ LONG\r\n    if (wall.side === 'ASK') {\r\n      return SignalDirection.LONG;\r\n    }\r\n    // BID wall broken = price went DOWN â†’ SHORT\r\n    return SignalDirection.SHORT;\r\n  }\r\n\r\n  /**\r\n   * Reset detector state (for testing)\r\n   */\r\n  reset(): void {\r\n    this.trackedWalls.clear();\r\n    this.brokenWalls.clear();\r\n    this.logger.debug('ðŸ”„ MicroWallDetector reset');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\order-flow-analyzer.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":65,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":65,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2197,2216],"text":"(this.lastOrderbook == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":65,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":65,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2220,2238],"text":"(this.lastMidPrice == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2221,2238],"text":"(this.lastMidPrice ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2220,2238],"text":"(!Boolean(this.lastMidPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":93,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":93,"endColumn":52},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":118,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":118,"endColumn":52},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 999.","line":168,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 999.","line":172,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":172,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":193,"column":88,"nodeType":"Literal","messageId":"noMagic","endLine":193,"endColumn":90},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":193,"column":92,"nodeType":"Literal","messageId":"noMagic","endLine":193,"endColumn":95},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":194,"column":78,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":80},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":194,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":84},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 999.","line":231,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":231,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.001.","line":234,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":234,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":244,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":244,"endColumn":68},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":287,"column":21,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":287,"endColumn":122,"fix":{"range":[8980,8990],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":287,"column":93,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":287,"endColumn":106,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[8961,8974],"text":"((firstBid?.[0]) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[8961,8974],"text":"(!Number.isNaN((firstBid?.[0])))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8961,8974],"text":"(Boolean((firstBid?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":288,"column":21,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":288,"endColumn":122,"fix":{"range":[9104,9114],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":288,"column":93,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":288,"endColumn":106,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[9085,9098],"text":"((firstAsk?.[0]) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[9085,9098],"text":"(!Number.isNaN((firstAsk?.[0])))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9085,9098],"text":"(Boolean((firstAsk?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":289,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":289,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'side' is defined but never used. Allowed unused args must match /^_/u.","line":306,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":306,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":330,"column":23,"nodeType":"CallExpression","messageId":"conditionErrorNullableNumber","endLine":330,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10562,10587],"text":"(newPriceMap.get(oldPrice) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10562,10587],"text":"(newPriceMap.get(oldPrice) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10562,10587],"text":"(Boolean(newPriceMap.get(oldPrice)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":330,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":330,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[10588,10590],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Order Flow Analyzer Service (Phase 5)\r\n *\r\n * Analyzes order flow imbalance by tracking aggressive buy/sell activity\r\n * from orderbook changes.\r\n *\r\n * Logic:\r\n * - Aggressive Buy: Price moved UP + asks removed â†’ buyers taking liquidity\r\n * - Aggressive Sell: Price moved DOWN + bids removed â†’ sellers taking liquidity\r\n * - Flow Ratio: aggressive_buy_volume / aggressive_sell_volume\r\n * - Threshold: 3.0x (buy:sell or sell:buy)\r\n *\r\n * Detection Window: 3000ms (3 seconds)\r\n * Min Volume: 5000 USDT\r\n */\r\n\r\nimport {\r\n  OrderFlowAnalyzerConfig,\r\n  AggressiveFlow,\r\n  FlowImbalance,\r\n  SignalDirection,\r\n  LoggerService,\r\n  OrderBook,\r\n  OrderbookLevel,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_FLOW_HISTORY = 500; // Max aggressive flow events to keep\r\nconst PRICE_MOVE_THRESHOLD = 0.01; // 0.01% price change to detect direction\r\n\r\n// ============================================================================\r\n// ORDER FLOW ANALYZER SERVICE\r\n// ============================================================================\r\n\r\nexport class OrderFlowAnalyzerService {\r\n  private flowHistory: AggressiveFlow[] = [];\r\n  private lastOrderbook: OrderBook | null = null;\r\n  private lastMidPrice: number | null = null;\r\n\r\n  constructor(\r\n    private config: OrderFlowAnalyzerConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('âœ… OrderFlowAnalyzerService initialized', {\r\n      aggressiveBuyThreshold: config.aggressiveBuyThreshold,\r\n      detectionWindow: config.detectionWindow,\r\n      minVolumeUSDT: config.minVolumeUSDT,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Process orderbook update and detect aggressive flow\r\n   *\r\n   * @param orderbook - Current orderbook snapshot\r\n   */\r\n  processOrderbookUpdate(orderbook: OrderBook): void {\r\n    if (!this.lastOrderbook || !this.lastMidPrice) {\r\n      // First update - just store\r\n      this.lastOrderbook = orderbook;\r\n      this.lastMidPrice = this.calculateMidPrice(orderbook);\r\n      return;\r\n    }\r\n\r\n    const currentMidPrice = this.calculateMidPrice(orderbook);\r\n    const priceChangePercent = ((currentMidPrice - this.lastMidPrice) / this.lastMidPrice) * PERCENT_MULTIPLIER;\r\n\r\n    // Detect aggressive buy (price up + asks removed)\r\n    if (priceChangePercent > PRICE_MOVE_THRESHOLD) {\r\n      const removedAsksVolume = this.calculateRemovedVolume(\r\n        this.lastOrderbook.asks,\r\n        orderbook.asks,\r\n        'asks',\r\n      );\r\n\r\n      if (removedAsksVolume > 0) {\r\n        const flow: AggressiveFlow = {\r\n          direction: 'BUY',\r\n          volumeUSDT: removedAsksVolume * currentMidPrice,\r\n          timestamp: Date.now(),\r\n          price: currentMidPrice,\r\n        };\r\n        this.addFlow(flow);\r\n\r\n        this.logger.debug('ðŸŸ¢ Aggressive BUY detected', {\r\n          priceChange: priceChangePercent.toFixed(3),\r\n          volumeRemoved: removedAsksVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n          volumeUSDT: flow.volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Detect aggressive sell (price down + bids removed)\r\n    if (priceChangePercent < -PRICE_MOVE_THRESHOLD) {\r\n      const removedBidsVolume = this.calculateRemovedVolume(\r\n        this.lastOrderbook.bids,\r\n        orderbook.bids,\r\n        'bids',\r\n      );\r\n\r\n      if (removedBidsVolume > 0) {\r\n        const flow: AggressiveFlow = {\r\n          direction: 'SELL',\r\n          volumeUSDT: removedBidsVolume * currentMidPrice,\r\n          timestamp: Date.now(),\r\n          price: currentMidPrice,\r\n        };\r\n        this.addFlow(flow);\r\n\r\n        this.logger.debug('ðŸ”´ Aggressive SELL detected', {\r\n          priceChange: priceChangePercent.toFixed(3),\r\n          volumeRemoved: removedBidsVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n          volumeUSDT: flow.volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update last snapshot\r\n    this.lastOrderbook = orderbook;\r\n    this.lastMidPrice = currentMidPrice;\r\n  }\r\n\r\n  /**\r\n   * Detect flow imbalance (aggressive buy/sell ratio)\r\n   *\r\n   * @returns FlowImbalance if detected, null otherwise\r\n   */\r\n  detectFlowImbalance(): FlowImbalance | null {\r\n    const cutoffTime = Date.now() - this.config.detectionWindow;\r\n    const recentFlow = this.flowHistory.filter((f) => f.timestamp >= cutoffTime);\r\n\r\n    if (recentFlow.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Calculate buy/sell volumes\r\n    let buyVolume = 0;\r\n    let sellVolume = 0;\r\n\r\n    for (const flow of recentFlow) {\r\n      if (flow.direction === 'BUY') {\r\n        buyVolume += flow.volumeUSDT;\r\n      } else {\r\n        sellVolume += flow.volumeUSDT;\r\n      }\r\n    }\r\n\r\n    const totalVolume = buyVolume + sellVolume;\r\n\r\n    // Check minimum volume\r\n    if (totalVolume < this.config.minVolumeUSDT) {\r\n      return null;\r\n    }\r\n\r\n    // Calculate flow ratio\r\n    let flowRatio: number;\r\n    let direction: SignalDirection;\r\n\r\n    if (sellVolume === 0) {\r\n      // Only buy flow\r\n      flowRatio = buyVolume > 0 ? 999 : MULTIPLIERS.NEUTRAL;\r\n      direction = SignalDirection.LONG;\r\n    } else if (buyVolume === 0) {\r\n      // Only sell flow\r\n      flowRatio = 999;\r\n      direction = SignalDirection.SHORT;\r\n    } else {\r\n      const buyToSellRatio = buyVolume / sellVolume;\r\n      const sellToBuyRatio = sellVolume / buyVolume;\r\n\r\n      if (buyToSellRatio >= this.config.aggressiveBuyThreshold) {\r\n        // Aggressive buy dominance\r\n        flowRatio = buyToSellRatio;\r\n        direction = SignalDirection.LONG;\r\n      } else if (sellToBuyRatio >= this.config.aggressiveBuyThreshold) {\r\n        // Aggressive sell dominance\r\n        flowRatio = sellToBuyRatio;\r\n        direction = SignalDirection.SHORT;\r\n      } else {\r\n        // No clear imbalance\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Calculate confidence (ratio-based, capped at max)\r\n    const baseConfidence = Math.min((flowRatio / this.config.aggressiveBuyThreshold) * 70, 100);\r\n    const volumeBoost = Math.min((totalVolume / this.config.minVolumeUSDT) * 10, 20);\r\n    const confidence = Math.min(baseConfidence + volumeBoost, this.config.maxConfidence);\r\n\r\n    return {\r\n      direction,\r\n      ratio: flowRatio,\r\n      confidence,\r\n      totalVolumeUSDT: totalVolume,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate flow ratio (for testing/debugging)\r\n   *\r\n   * @param windowMs - Time window (default: config.detectionWindow)\r\n   * @returns Flow ratio (buy/sell or sell/buy)\r\n   */\r\n  calculateFlowRatio(windowMs: number = this.config.detectionWindow): number {\r\n    const cutoffTime = Date.now() - windowMs;\r\n    const recentFlow = this.flowHistory.filter((f) => f.timestamp >= cutoffTime);\r\n\r\n    if (recentFlow.length === 0) {\r\n      return 1.0; // Neutral\r\n    }\r\n\r\n    let buyVolume = 0;\r\n    let sellVolume = 0;\r\n\r\n    for (const flow of recentFlow) {\r\n      if (flow.direction === 'BUY') {\r\n        buyVolume += flow.volumeUSDT;\r\n      } else {\r\n        sellVolume += flow.volumeUSDT;\r\n      }\r\n    }\r\n\r\n    if (sellVolume === 0) {\r\n      return buyVolume > 0 ? 999 : MULTIPLIERS.NEUTRAL;\r\n    }\r\n    if (buyVolume === 0) {\r\n      return 0.001;\r\n    }\r\n\r\n    return buyVolume / sellVolume;\r\n  }\r\n\r\n  /**\r\n   * Cleanup old flow data (beyond 2x detection window)\r\n   */\r\n  cleanupOldFlow(): void {\r\n    const cutoffTime = Date.now() - this.config.detectionWindow * 2;\r\n    this.flowHistory = this.flowHistory.filter((f) => f.timestamp >= cutoffTime);\r\n  }\r\n\r\n  /**\r\n   * Clear all flow history (for testing)\r\n   */\r\n  clearHistory(): void {\r\n    this.flowHistory = [];\r\n    this.lastOrderbook = null;\r\n    this.lastMidPrice = null;\r\n  }\r\n\r\n  /**\r\n   * Get flow history (for testing)\r\n   */\r\n  getFlowHistory(): AggressiveFlow[] {\r\n    return this.flowHistory;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Add aggressive flow event to history\r\n   */\r\n  private addFlow(flow: AggressiveFlow): void {\r\n    this.flowHistory.push(flow);\r\n\r\n    // Limit history size\r\n    if (this.flowHistory.length > MAX_FLOW_HISTORY) {\r\n      this.flowHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate mid price from orderbook\r\n   * Supports both OrderbookManagerService format {price, size} and tuple format [price, qty]\r\n   */\r\n  private calculateMidPrice(orderbook: OrderBook): number {\r\n    const firstBid = orderbook.bids[0];\r\n    const firstAsk = orderbook.asks[0];\r\n    const bestBid = (typeof firstBid === 'object' && 'price' in firstBid ? firstBid.price : firstBid?.[0] || 0) as number;\r\n    const bestAsk = (typeof firstAsk === 'object' && 'price' in firstAsk ? firstAsk.price : firstAsk?.[0] || 0) as number;\r\n    return (bestBid + bestAsk) / 2;\r\n  }\r\n\r\n  /**\r\n   * Calculate volume removed from orderbook side\r\n   *\r\n   * Compares old and new orderbook to find removed volume\r\n   * Supports both OrderbookManagerService format {price, size} and tuple format [price, qty]\r\n   *\r\n   * @param oldSide - Old orderbook side (bids or asks)\r\n   * @param newSide - New orderbook side\r\n   * @param side - 'bids' or 'asks'\r\n   * @returns Total volume removed\r\n   */\r\n  private calculateRemovedVolume(\r\n    oldSide: OrderbookLevel[],\r\n    newSide: OrderbookLevel[],\r\n    side: 'bids' | 'asks',\r\n  ): number {\r\n    // Helper to extract price and size from OrderbookLevel union type\r\n    const getPrice = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n    };\r\n    const getSize = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n    };\r\n\r\n    // Build map of new prices â†’ sizes\r\n    const newPriceMap = new Map<number, number>();\r\n    for (const level of newSide) {\r\n      const price = getPrice(level);\r\n      const size = getSize(level);\r\n      newPriceMap.set(price, size);\r\n    }\r\n\r\n    let removedVolume = 0;\r\n\r\n    // Check old levels that disappeared or reduced\r\n    for (const oldLevel of oldSide) {\r\n      const oldPrice = getPrice(oldLevel);\r\n      const oldSize = getSize(oldLevel);\r\n      const newSize = newPriceMap.get(oldPrice) || 0;\r\n\r\n      if (newSize < oldSize) {\r\n        // Volume was removed\r\n        removedVolume += oldSize - newSize;\r\n      }\r\n    }\r\n\r\n    return removedVolume;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\orderbook-imbalance.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":72,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":72,"endColumn":55}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Orderbook Imbalance Service (PHASE 4 Feature 4)\r\n *\r\n * Analyzes bid/ask volume ratio in orderbook to detect buying/selling pressure.\r\n *\r\n * Imbalance = (bidVolume - askVolume) / totalVolume * PERCENT_MULTIPLIER\r\n *\r\n * Use Cases:\r\n * - Entry timing (enter when imbalance matches direction)\r\n * - Reversal signals (sudden imbalance flip)\r\n * - Confirmation filter (strong BID imbalance confirms LONG)\r\n *\r\n * Data Source: Orderbook depth (top N levels from OrderbookManagerService)\r\n */\r\n\r\nimport { OrderbookImbalanceConfig, ImbalanceAnalysis, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// ORDERBOOK IMBALANCE SERVICE\r\n// ============================================================================\r\n\r\nexport class OrderbookImbalanceService {\r\n  constructor(\r\n    private config: OrderbookImbalanceConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('OrderbookImbalanceService initialized', {\r\n      enabled: config.enabled,\r\n      levels: config.levels,\r\n      minImbalancePercent: config.minImbalancePercent,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyze orderbook imbalance from bids/asks\r\n   *\r\n   * @param orderbook - Orderbook with bids [[price, size]] and asks [[price, size]]\r\n   * @returns Imbalance analysis with direction and strength\r\n   */\r\n  analyze(orderbook: { bids: [number, number][]; asks: [number, number][] }): ImbalanceAnalysis {\r\n    if (!this.config.enabled) {\r\n      // Disabled - return neutral\r\n      return this.getNeutralAnalysis();\r\n    }\r\n\r\n    const levels = this.config.levels;\r\n\r\n    // Get top N levels\r\n    const bids = orderbook.bids.slice(0, levels);\r\n    const asks = orderbook.asks.slice(0, levels);\r\n\r\n    // Calculate volumes\r\n    const bidVolume = bids.reduce((sum, [_, qty]) => sum + qty, 0);\r\n    const askVolume = asks.reduce((sum, [_, qty]) => sum + qty, 0);\r\n    const totalVolume = bidVolume + askVolume;\r\n\r\n    // Calculate imbalance\r\n    const imbalance = totalVolume > 0 ? ((bidVolume - askVolume) / totalVolume) * PERCENT_MULTIPLIER : 0;\r\n\r\n    // Determine direction\r\n    let direction: 'BID' | 'ASK' | 'NEUTRAL';\r\n    if (Math.abs(imbalance) < this.config.minImbalancePercent) {\r\n      direction = 'NEUTRAL';\r\n    } else if (imbalance > 0) {\r\n      direction = 'BID'; // More bid volume â†’ bullish pressure\r\n    } else {\r\n      direction = 'ASK'; // More ask volume â†’ bearish pressure\r\n    }\r\n\r\n    // Calculate strength (0-100)\r\n    const strength = Math.min(Math.abs(imbalance), 100);\r\n\r\n    const analysis: ImbalanceAnalysis = {\r\n      timestamp: Date.now(),\r\n      bidVolume,\r\n      askVolume,\r\n      totalVolume,\r\n      imbalance,\r\n      direction,\r\n      strength,\r\n    };\r\n\r\n    /* this.logger.debug('Orderbook imbalance analyzed', {\r\n      bidVol: bidVolume.toFixed(0),\r\n      askVol: askVolume.toFixed(0),\r\n      imbalance: imbalance.toFixed(1) + '%',\r\n      direction,\r\n      strength: strength.toFixed(0),\r\n    });\r\n*/\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * Get neutral analysis (no imbalance)\r\n   */\r\n  private getNeutralAnalysis(): ImbalanceAnalysis {\r\n    return {\r\n      timestamp: Date.now(),\r\n      bidVolume: 0,\r\n      askVolume: 0,\r\n      totalVolume: 0,\r\n      imbalance: 0,\r\n      direction: 'NEUTRAL',\r\n      strength: 0,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\orderbook-manager.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":241,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":241,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6976,6992],"text":"this.wallTracker != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":249,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":249,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7222,7238],"text":"this.wallTracker != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TIME_UNITS } from '../constants';\r\n/**\r\n * Orderbook Manager Service\r\n *\r\n * Maintains local orderbook snapshot from WebSocket updates:\r\n * - Receives snapshot on initial subscription\r\n * - Applies delta updates to maintain current state\r\n * - Provides full orderbook on demand for whale detection\r\n *\r\n * Responsibilities:\r\n * - Snapshot storage and management\r\n * - Delta application logic\r\n * - Memory management (prevent leaks)\r\n *\r\n * Single Responsibility: Orderbook state management\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\nimport { WallTrackerService } from './wall-tracker.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_ORDERBOOK_LEVELS = 100; // Max levels to store (prevents memory leak)\r\nconst SNAPSHOT_RESET_THRESHOLD_MS = TIME_UNITS.MINUTE; // Reset if no snapshot for 1 min\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface OrderbookLevel {\r\n  price: number;\r\n  size: number;\r\n}\r\n\r\nexport interface OrderbookSnapshot {\r\n  bids: OrderbookLevel[];\r\n  asks: OrderbookLevel[];\r\n  timestamp: number;\r\n  updateId: number;\r\n}\r\n\r\nexport interface OrderbookUpdate {\r\n  type: 'snapshot' | 'delta';\r\n  bids: Array<[string, string]>; // [price, size] from Bybit\r\n  asks: Array<[string, string]>;\r\n  updateId: number;\r\n  timestamp: number;\r\n}\r\n\r\n// ============================================================================\r\n// ORDERBOOK MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class OrderbookManagerService {\r\n  // Snapshot storage (Map for O(1) lookup/update/delete)\r\n  private bidsMap: Map<number, number> = new Map(); // price -> size\r\n  private asksMap: Map<number, number> = new Map();\r\n  private lastUpdateId: number = 0;\r\n  private lastSnapshotTime: number = 0;\r\n  private isInitialized: boolean = false;\r\n\r\n  constructor(\r\n    private readonly symbol: string,\r\n    private readonly logger: LoggerService,\r\n    private readonly wallTracker?: WallTrackerService,\r\n  ) {}\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Process orderbook update from WebSocket\r\n   * Handles both snapshot and delta messages\r\n   */\r\n  processUpdate(update: OrderbookUpdate): void {\r\n    if (update.type === 'snapshot') {\r\n      this.handleSnapshot(update);\r\n    } else {\r\n      this.handleDelta(update);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current orderbook snapshot\r\n   * Returns sorted bids (descending) and asks (ascending)\r\n   */\r\n  getSnapshot(): OrderbookSnapshot | null {\r\n    if (!this.isInitialized) {\r\n      this.logger.warn('Orderbook not initialized yet', { symbol: this.symbol });\r\n      return null;\r\n    }\r\n\r\n    // Check if snapshot is stale\r\n    const now = Date.now();\r\n    if (now - this.lastSnapshotTime > SNAPSHOT_RESET_THRESHOLD_MS) {\r\n      this.logger.warn('Orderbook snapshot is stale, waiting for new data', {\r\n        symbol: this.symbol,\r\n        ageMs: now - this.lastSnapshotTime,\r\n      });\r\n      return null;\r\n    }\r\n\r\n    // Convert Maps to sorted arrays\r\n    const bids = this.getSortedBids();\r\n    const asks = this.getSortedAsks();\r\n\r\n    return {\r\n      bids,\r\n      asks,\r\n      timestamp: this.lastSnapshotTime,\r\n      updateId: this.lastUpdateId,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if orderbook is initialized and ready\r\n   */\r\n  isReady(): boolean {\r\n    return this.isInitialized && this.bidsMap.size > 0 && this.asksMap.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Get current orderbook statistics\r\n   */\r\n  getStats(): {\r\n    bidsCount: number;\r\n    asksCount: number;\r\n    initialized: boolean;\r\n    lastUpdate: number;\r\n    } {\r\n    return {\r\n      bidsCount: this.bidsMap.size,\r\n      asksCount: this.asksMap.size,\r\n      initialized: this.isInitialized,\r\n      lastUpdate: this.lastSnapshotTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset orderbook state\r\n   * Used when connection is lost or on explicit reset\r\n   */\r\n  reset(): void {\r\n    this.bidsMap.clear();\r\n    this.asksMap.clear();\r\n    this.lastUpdateId = 0;\r\n    this.lastSnapshotTime = 0;\r\n    this.isInitialized = false;\r\n\r\n    this.logger.info('Orderbook reset', { symbol: this.symbol });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Handle snapshot message (full orderbook)\r\n   * Reset local state and store new snapshot\r\n   */\r\n  private handleSnapshot(update: OrderbookUpdate): void {\r\n    this.logger.info('ðŸ“¸ Orderbook snapshot received', {\r\n      symbol: this.symbol,\r\n      bids: update.bids.length,\r\n      asks: update.asks.length,\r\n      updateId: update.updateId,\r\n    });\r\n\r\n    // Reset existing data\r\n    this.bidsMap.clear();\r\n    this.asksMap.clear();\r\n\r\n    // Store snapshot\r\n    this.applyLevels(this.bidsMap, update.bids, true);\r\n    this.applyLevels(this.asksMap, update.asks, false);\r\n\r\n    this.lastUpdateId = update.updateId;\r\n    this.lastSnapshotTime = Date.now();\r\n    this.isInitialized = true;\r\n\r\n    this.logger.debug('Snapshot applied', {\r\n      bidsCount: this.bidsMap.size,\r\n      asksCount: this.asksMap.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle delta message (incremental update)\r\n   * Apply changes to existing snapshot\r\n   */\r\n  private handleDelta(update: OrderbookUpdate): void {\r\n    if (!this.isInitialized) {\r\n      this.logger.warn('Received delta before snapshot, ignoring', {\r\n        symbol: this.symbol,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Apply delta to bids and asks\r\n    this.applyLevels(this.bidsMap, update.bids, true);\r\n    this.applyLevels(this.asksMap, update.asks, false);\r\n\r\n    this.lastUpdateId = update.updateId;\r\n    this.lastSnapshotTime = Date.now();\r\n\r\n    // Log periodically (1% of updates to avoid spam)\r\n    /*if (Math.random() < 0.01) {\r\n      this.logger.debug('Delta applied', {\r\n        bidsCount: this.bidsMap.size,\r\n        asksCount: this.asksMap.size,\r\n        updateId: update.updateId,\r\n      });\r\n    }*/\r\n  }\r\n\r\n  /**\r\n   * Apply price levels to map\r\n   * Rules:\r\n   * - size = 0 â†’ delete level\r\n   * - size > 0 â†’ insert or update level\r\n   */\r\n  private applyLevels(\r\n    map: Map<number, number>,\r\n    levels: Array<[string, string]>,\r\n    isBids: boolean = true,\r\n  ): void {\r\n    const side: 'BID' | 'ASK' = isBids ? 'BID' : 'ASK';\r\n\r\n    for (const [priceStr, sizeStr] of levels) {\r\n      const price = parseFloat(priceStr);\r\n      const size = parseFloat(sizeStr);\r\n\r\n      if (size === 0) {\r\n        // Delete level\r\n        map.delete(price);\r\n\r\n        // PHASE 4: Notify Wall Tracker (wall removed)\r\n        if (this.wallTracker) {\r\n          this.wallTracker.removeWall(price, side);\r\n        }\r\n      } else {\r\n        // Insert or update level\r\n        map.set(price, size);\r\n\r\n        // PHASE 4: Notify Wall Tracker (wall detected/updated)\r\n        if (this.wallTracker) {\r\n          this.wallTracker.detectWall(price, size, side);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Memory leak protection: trim if too large\r\n    if (map.size > MAX_ORDERBOOK_LEVELS) {\r\n      this.trimOrderbook(map, isBids);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trim orderbook to prevent memory leaks\r\n   * Keep only best N levels\r\n   * For bids: keep highest prices\r\n   * For asks: keep lowest prices\r\n   */\r\n  private trimOrderbook(map: Map<number, number>, isBids: boolean = true): void {\r\n    if (map.size <= MAX_ORDERBOOK_LEVELS) {\r\n      return;\r\n    }\r\n\r\n    // Convert to array and sort\r\n    // Bids: descending (highest first), Asks: ascending (lowest first)\r\n    const sorted = Array.from(map.entries()).sort((a, b) => {\r\n      return isBids ? b[0] - a[0] : a[0] - b[0];\r\n    });\r\n\r\n    const toKeep = sorted.slice(0, MAX_ORDERBOOK_LEVELS);\r\n\r\n    map.clear();\r\n    for (const [price, size] of toKeep) {\r\n      map.set(price, size);\r\n    }\r\n\r\n    this.logger.warn('Orderbook trimmed to prevent memory leak', {\r\n      symbol: this.symbol,\r\n      side: isBids ? 'bids' : 'asks',\r\n      previousSize: sorted.length,\r\n      newSize: map.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get sorted bids (highest price first)\r\n   */\r\n  private getSortedBids(): OrderbookLevel[] {\r\n    return Array.from(this.bidsMap.entries())\r\n      .sort((a, b) => b[0] - a[0]) // Descending price\r\n      .map(([price, size]) => ({ price, size }));\r\n  }\r\n\r\n  /**\r\n   * Get sorted asks (lowest price first)\r\n   */\r\n  private getSortedAsks(): OrderbookLevel[] {\r\n    return Array.from(this.asksMap.entries())\r\n      .sort((a, b) => a[0] - b[0]) // Ascending price\r\n      .map(([price, size]) => ({ price, size }));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\pnl-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'directionMultiplier' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":131,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":131,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * PnL Calculator Service\r\n *\r\n * Calculates profit/loss for trades with correct fees.\r\n * Separated for testability and reusability.\r\n *\r\n * Formula:\r\n * - pnlGross = (exitPrice - entryPrice) Ã— quantity Ã— directionMultiplier\r\n * - fees = (entryValue + exitValue) Ã— feeRate\r\n * - pnlNet = pnlGross - fees\r\n *\r\n * Where directionMultiplier:\r\n * - LONG: +1 (profit when price goes up)\r\n * - SHORT: -1 (profit when price goes down)\r\n */\r\n\r\nimport { PositionSide } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nexport const BYBIT_TAKER_FEE = 0.00055; // 0.055% for non-VIP users\r\nexport const BYBIT_MAKER_FEE = 0.0002; // 0.02% for non-VIP users\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface PnLResult {\r\n  pnlGross: number; // PnL before fees\r\n  fees: number; // Trading fees\r\n  pnlNet: number; // PnL after fees\r\n  pnlPercent: number; // PnL as percentage of entry value\r\n}\r\n\r\n// ============================================================================\r\n// PNL CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class PnLCalculatorService {\r\n  /**\r\n   * Calculate PnL for a trade\r\n   * @param side - Position side (LONG or SHORT)\r\n   * @param entryPrice - Entry price\r\n   * @param exitPrice - Exit price\r\n   * @param quantity - Quantity traded\r\n   * @param feeRate - Fee rate (default: taker fee 0.055%)\r\n   */\r\n  static calculate(\r\n    side: PositionSide,\r\n    entryPrice: number,\r\n    exitPrice: number,\r\n    quantity: number,\r\n    feeRate: number = BYBIT_TAKER_FEE,\r\n  ): PnLResult {\r\n    // Calculate gross PnL\r\n    const priceDiff = exitPrice - entryPrice;\r\n    const directionMultiplier = side === PositionSide.LONG ? 1 : -1;\r\n    const pnlGross = priceDiff * quantity * directionMultiplier;\r\n\r\n    // Calculate fees\r\n    const entryValue = entryPrice * quantity;\r\n    const exitValue = exitPrice * quantity;\r\n    const fees = (entryValue + exitValue) * feeRate;\r\n\r\n    // Calculate net PnL\r\n    const pnlNet = pnlGross - fees;\r\n\r\n    // Calculate percentage\r\n    const pnlPercent = (priceDiff / entryPrice) * PERCENT_MULTIPLIER * directionMultiplier;\r\n\r\n    return {\r\n      pnlGross,\r\n      fees,\r\n      pnlNet,\r\n      pnlPercent,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate total PnL from multiple partial closes\r\n   */\r\n  static calculatePartialCloses(\r\n    side: PositionSide,\r\n    entryPrice: number,\r\n    closes: Array<{ quantity: number; exitPrice: number }>,\r\n    feeRate: number = BYBIT_TAKER_FEE,\r\n  ): PnLResult {\r\n    let totalPnlGross = 0;\r\n    let totalFees = 0;\r\n\r\n    closes.forEach((close) => {\r\n      const result = this.calculate(side, entryPrice, close.exitPrice, close.quantity, feeRate);\r\n      totalPnlGross += result.pnlGross;\r\n      totalFees += result.fees;\r\n    });\r\n\r\n    const totalPnlNet = totalPnlGross - totalFees;\r\n\r\n    // Calculate weighted average percentage\r\n    const totalQuantity = closes.reduce((sum, c) => sum + c.quantity, 0);\r\n    const weightedAvgExitPrice =\r\n      closes.reduce((sum, c) => sum + c.exitPrice * c.quantity, 0) / totalQuantity;\r\n    const priceDiff = weightedAvgExitPrice - entryPrice;\r\n    const directionMultiplier = side === PositionSide.LONG ? 1 : -1;\r\n    const pnlPercent = (priceDiff / entryPrice) * PERCENT_MULTIPLIER * directionMultiplier;\r\n\r\n    return {\r\n      pnlGross: totalPnlGross,\r\n      fees: totalFees,\r\n      pnlNet: totalPnlNet,\r\n      pnlPercent,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate break-even price (price at which PnL = 0 after fees)\r\n   */\r\n  static calculateBreakeven(\r\n    side: PositionSide,\r\n    entryPrice: number,\r\n    feeRate: number = BYBIT_TAKER_FEE,\r\n  ): number {\r\n    // Break-even: pnlGross = fees\r\n    // (exitPrice - entryPrice) Ã— qty Ã— mult = (entryPrice Ã— qty + exitPrice Ã— qty) Ã— feeRate\r\n    // Simplify (divide by qty):\r\n    // (exitPrice - entryPrice) Ã— mult = (entryPrice + exitPrice) Ã— feeRate\r\n\r\n    const directionMultiplier = side === PositionSide.LONG ? 1 : -1;\r\n\r\n    // For LONG: exitPrice - entryPrice = (entryPrice + exitPrice) Ã— feeRate\r\n    // For SHORT: -(exitPrice - entryPrice) = (entryPrice + exitPrice) Ã— feeRate\r\n\r\n    // Solve for exitPrice:\r\n    // LONG: exitPrice Ã— (1 - feeRate) = entryPrice Ã— (1 + feeRate)\r\n    // SHORT: exitPrice Ã— (1 + feeRate) = entryPrice Ã— (1 - feeRate)\r\n\r\n    if (side === PositionSide.LONG) {\r\n      return (entryPrice * (1 + feeRate)) / (1 - feeRate);\r\n    } else {\r\n      return (entryPrice * (1 - feeRate)) / (1 + feeRate);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\position-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PRECISION_MULTIPLIER_BASE' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":123,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":123,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3995,4013],"text":"limits.maxOrderQty != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3995,4013],"text":"limits.maxOrderQty ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3995,4013],"text":"Boolean(limits.maxOrderQty)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Position Calculator Service\r\n *\r\n * Centralizes ALL position sizing calculations:\r\n * - Quantity calculation with leverage\r\n * - Rounding to exchange precision (qtyStep, tickSize)\r\n * - Validation against exchange limits\r\n * - Position value and margin calculations\r\n *\r\n * Single Responsibility: Position sizing mathematics\r\n *\r\n * Rules:\r\n * - NO hardcoded values (qtyStep, tickSize must be provided)\r\n * - ONE place for rounding logic\r\n * - Strict validation before returning\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface ExchangeLimits {\r\n  qtyStep: string;      // Min quantity increment (e.g., \"0.1\", \"0.01\")\r\n  tickSize: string;     // Min price increment (e.g., \"0.0001\")\r\n  minOrderQty: string;  // Minimum order quantity\r\n  maxOrderQty?: string; // Maximum order quantity (optional)\r\n}\r\n\r\nexport interface QuantityCalculation {\r\n  quantity: number;          // Raw calculated quantity\r\n  roundedQuantity: string;   // Rounded to qtyStep precision\r\n  notionalValue: number;     // Total position value (qty * price)\r\n  marginUsed: number;        // USDT locked as margin\r\n  isValid: boolean;          // Passes all validations\r\n  validationErrors: string[]; // List of validation errors\r\n}\r\n\r\nexport interface PriceRounding {\r\n  price: number;\r\n  roundedPrice: string;\r\n  isValid: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PRECISION_MULTIPLIER_BASE = 10;\r\n\r\n// ============================================================================\r\n// POSITION CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class PositionCalculatorService {\r\n  constructor(private readonly logger: LoggerService) {}\r\n\r\n  // ==========================================================================\r\n  // QUANTITY CALCULATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate position quantity with leverage\r\n   *\r\n   * Formula: quantity = (positionSizeUsdt * leverage) / price\r\n   *\r\n   * Example:\r\n   * - positionSizeUsdt: 10 USDT\r\n   * - leverage: 10x\r\n   * - price: 1.20 USDT\r\n   * - Result: (10 * 10) / 1.20 = 83.33 coins\r\n   *\r\n   * @param positionSizeUsdt - Amount of USDT to use as margin\r\n   * @param leverage - Leverage multiplier\r\n   * @param price - Current market price\r\n   * @param limits - Exchange limits for validation\r\n   * @returns Quantity calculation with validation\r\n   */\r\n  calculateQuantity(\r\n    positionSizeUsdt: number,\r\n    leverage: number,\r\n    price: number,\r\n    limits: ExchangeLimits,\r\n  ): QuantityCalculation {\r\n    const validationErrors: string[] = [];\r\n\r\n    // Input validation\r\n    if (positionSizeUsdt <= 0) {\r\n      validationErrors.push('Position size must be positive');\r\n    }\r\n    if (leverage <= 0) {\r\n      validationErrors.push('Leverage must be positive');\r\n    }\r\n    if (price <= 0) {\r\n      validationErrors.push('Price must be positive');\r\n    }\r\n\r\n    if (validationErrors.length > 0) {\r\n      return {\r\n        quantity: 0,\r\n        roundedQuantity: '0',\r\n        notionalValue: 0,\r\n        marginUsed: 0,\r\n        isValid: false,\r\n        validationErrors,\r\n      };\r\n    }\r\n\r\n    // Calculate raw quantity\r\n    const quantity = (positionSizeUsdt * leverage) / price;\r\n\r\n    // Round to exchange precision\r\n    const roundedQuantity = this.roundToStep(quantity, limits.qtyStep);\r\n    const roundedQtyNum = parseFloat(roundedQuantity);\r\n\r\n    // Validate against limits\r\n    const minQty = parseFloat(limits.minOrderQty);\r\n    if (roundedQtyNum < minQty) {\r\n      validationErrors.push(`Quantity ${roundedQuantity} below minimum ${limits.minOrderQty}`);\r\n    }\r\n\r\n    if (limits.maxOrderQty) {\r\n      const maxQty = parseFloat(limits.maxOrderQty);\r\n      if (roundedQtyNum > maxQty) {\r\n        validationErrors.push(`Quantity ${roundedQuantity} exceeds maximum ${limits.maxOrderQty}`);\r\n      }\r\n    }\r\n\r\n    // Calculate position values\r\n    const notionalValue = roundedQtyNum * price;\r\n    const marginUsed = notionalValue / leverage;\r\n\r\n    this.logger.debug('Quantity calculated', {\r\n      positionSizeUsdt,\r\n      leverage,\r\n      price,\r\n      rawQuantity: quantity,\r\n      roundedQuantity,\r\n      notionalValue,\r\n      marginUsed,\r\n      qtyStep: limits.qtyStep,\r\n    });\r\n\r\n    return {\r\n      quantity,\r\n      roundedQuantity,\r\n      notionalValue,\r\n      marginUsed,\r\n      isValid: validationErrors.length === 0,\r\n      validationErrors,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ROUNDING UTILITIES\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Round value to exchange step precision\r\n   *\r\n   * Rules:\r\n   * - Always round DOWN (Math.floor) to avoid exceeding balance\r\n   * - Respect step precision (e.g., 0.1, 0.01, 1.0)\r\n   *\r\n   * Example:\r\n   * - value: 83.577, step: \"0.1\" â†’ \"83.5\"\r\n   * - value: 83.577, step: \"0.01\" â†’ \"83.57\"\r\n   * - value: 83.577, step: \"1.0\" â†’ \"83\"\r\n   *\r\n   * @param value - Number to round\r\n   * @param step - Exchange step size (as string)\r\n   * @returns Rounded value as string with correct precision\r\n   */\r\n  roundToStep(value: number, step: string): string {\r\n    const stepNum = parseFloat(step);\r\n\r\n    if (stepNum <= 0) {\r\n      this.logger.error('Invalid step size', { step });\r\n      throw new Error(`Invalid step size: ${step}`);\r\n    }\r\n\r\n    // Round down to nearest step\r\n    const rounded = Math.floor(value / stepNum) * stepNum;\r\n\r\n    // Format to match step precision (count decimals in step)\r\n    const decimals = this.getDecimalPlaces(step);\r\n    const result = rounded.toFixed(decimals);\r\n\r\n    this.logger.debug('Rounded to step', {\r\n      input: value,\r\n      step,\r\n      stepNum,\r\n      rounded,\r\n      decimals,\r\n      result,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Round price to tick size\r\n   *\r\n   * Example:\r\n   * - price: 1.00249, tickSize: \"0.0001\" â†’ \"1.0024\"\r\n   * - price: 1.00249, tickSize: \"0.01\" â†’ \"1.00\"\r\n   *\r\n   * @param price - Price to round\r\n   * @param tickSize - Exchange tick size\r\n   * @returns Rounded price as string\r\n   */\r\n  roundPrice(price: number, tickSize: string): PriceRounding {\r\n    try {\r\n      const rounded = this.roundToStep(price, tickSize);\r\n      return {\r\n        price,\r\n        roundedPrice: rounded,\r\n        isValid: true,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to round price', {\r\n        price,\r\n        tickSize,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      return {\r\n        price,\r\n        roundedPrice: price.toString(),\r\n        isValid: false,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // POSITION VALUE CALCULATIONS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate position value and margin\r\n   *\r\n   * @param quantity - Position quantity\r\n   * @param price - Entry price\r\n   * @param leverage - Leverage multiplier\r\n   * @returns Notional value and margin used\r\n   */\r\n  calculatePositionValue(quantity: number, price: number, leverage: number): {\r\n    notionalValue: number;\r\n    marginUsed: number;\r\n  } {\r\n    const notionalValue = quantity * price;\r\n    const marginUsed = notionalValue / leverage;\r\n\r\n    return {\r\n      notionalValue,\r\n      marginUsed,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get number of decimal places in a number string\r\n   *\r\n   * Example:\r\n   * - \"0.1\" â†’ 1\r\n   * - \"0.01\" â†’ 2\r\n   * - \"0.0001\" â†’ 4\r\n   * - \"1\" â†’ 0\r\n   *\r\n   * @param numStr - Number as string\r\n   * @returns Number of decimal places\r\n   */\r\n  private getDecimalPlaces(numStr: string): number {\r\n    const parts = numStr.split('.');\r\n    if (parts.length === 1) {\r\n      return 0;\r\n    }\r\n\r\n    // Count ALL decimals (do NOT trim trailing zeros)\r\n    // \"0.1\" must return 1, not 0!\r\n    return parts[1].length;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\position-manager.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConfirmationResult' is defined but never used. Allowed unused vars must match /^_/u.","line":44,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":103,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":103,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4505,4533],"text":"(smartTrailingConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4505,4533],"text":"(smartTrailingConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":109,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":109,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4802,4828],"text":"(adaptiveTP3Config?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4802,4828],"text":"(adaptiveTP3Config?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'getStrategySmartBreakevenConfig' has a complexity of 15. Maximum allowed is 10.","line":123,"column":42,"nodeType":"FunctionExpression","messageId":"complex","endLine":147,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":124,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":124,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5436,5449],"text":"strategyType == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5437,5449],"text":"(strategyType ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5436,5449],"text":"!Boolean(strategyType)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":130,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":131,"endColumn":98},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":131,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":131,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5629,5678],"text":"((this.fullConfig.scalpingMicroWall?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":131,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":131,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5679,5681],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":132,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":133,"endColumn":98},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":133,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":133,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5770,5819],"text":"((this.fullConfig.scalpingTickDelta?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":133,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":133,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5820,5822],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":134,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":135,"endColumn":98},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":135,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":135,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5911,5960],"text":"((this.fullConfig.scalpingOrderFlow?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":135,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":135,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5961,5963],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":136,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":137,"endColumn":99},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":137,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":137,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6053,6103],"text":"((this.fullConfig.scalpingLimitOrder?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":137,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":137,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6104,6106],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":138,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":139,"endColumn":97},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":139,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":139,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6194,6242],"text":"((this.fullConfig.scalpingLadderTp?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":139,"column":63,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":139,"endColumn":65,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6243,6245],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":140,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":140,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":141,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":142,"endColumn":92},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":142,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":142,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6369,6412],"text":"((this.fullConfig.whaleHunter?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":142,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":142,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6413,6415],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"complexity","severity":1,"message":"Async method 'openPosition' has a complexity of 28. Maximum allowed is 10.","line":158,"column":21,"nodeType":"FunctionExpression","messageId":"complex","endLine":483,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":171,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":171,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7648,7679],"text":"(this.compoundInterestCalculator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":193,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":193,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8799,8826],"text":"this.riskBasedSizingService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":212,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":212,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9627,9649],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'slOrderId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":295,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":295,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":306,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":306,"endColumn":28},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":332,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":338,"endColumn":12},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":343,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":354,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":407,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":407,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17477,17490],"text":"(tpOrderIds[i] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[17477,17490],"text":"(tpOrderIds[i] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[17477,17490],"text":"(Boolean(tpOrderIds[i]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":407,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":407,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[17491,17493],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (1055). Maximum allowed is 300.","line":413,"column":1,"nodeType":null,"messageId":"exceed","endLine":1514,"endColumn":1},{"ruleId":"max-len","severity":1,"message":"This line has a length of 135. Maximum allowed is 120.","line":447,"column":1,"nodeType":"Program","messageId":"max","endLine":447,"endColumn":136},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":447,"column":22,"nodeType":"TSAsExpression","messageId":"conditionErrorObject","endLine":447,"endColumn":66},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":448,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":448,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19058,19072],"text":"(signal.btcData != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":448,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":448,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19073,19075],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":456,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":456,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19393,19410],"text":"(this.sessionStats != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":456,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":456,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19414,19427],"text":"(entrySnapshot != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'onTakeProfitHit' has a complexity of 35. Maximum allowed is 10.","line":488,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":707,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":495,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":495,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20930,20939],"text":"(tpConfig == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":516,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":516,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21671,21687],"text":"tpConfig.orderId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[21671,21687],"text":"tpConfig.orderId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[21671,21687],"text":"Boolean(tpConfig.orderId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":525,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":525,"endColumn":49},{"ruleId":"max-len","severity":1,"message":"This line has a length of 130. Maximum allowed is 120.","line":526,"column":1,"nodeType":"Program","messageId":"max","endLine":526,"endColumn":131},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":526,"column":28,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":526,"endColumn":50},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":531,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":531,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22523,22549],"text":"(this.smartBreakevenService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":531,"column":41,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":531,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22553,22569],"text":"(strategyBEConfig != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":541,"column":31,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":541,"endColumn":67,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[23001,23007],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 135. Maximum allowed is 120.","line":545,"column":1,"nodeType":"Program","messageId":"max","endLine":545,"endColumn":136},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":610,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":610,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26123,26150],"text":"this.smartTrailingV2Service != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":618,"column":78,"nodeType":"Literal","messageId":"noMagic","endLine":618,"endColumn":79},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":619,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":619,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26525,26548],"text":"(this.adaptiveTP3Service != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":619,"column":38,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":619,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26552,26555],"text":"(tp3 != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 134. Maximum allowed is 120.","line":620,"column":1,"nodeType":"Program","messageId":"max","endLine":620,"endColumn":135},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":631,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":631,"endColumn":28,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[27123,27140],"text":"((smartTP3?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[27123,27140],"text":"((smartTP3?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":631,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":631,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27144,27156],"text":"((tp3?.orderId) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[27144,27156],"text":"((tp3?.orderId) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27144,27156],"text":"(Boolean((tp3?.orderId)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":639,"column":18,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":639,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27512,27524],"text":"(tp3?.orderId) != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[27512,27524],"text":"(tp3?.orderId) ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27512,27524],"text":"Boolean((tp3?.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":718,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":718,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30603,30624],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":718,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":718,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30628,30656],"text":"(this.smartTrailingV2Service == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":738,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":738,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31202,31222],"text":"this.currentPosition != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":763,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":763,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31932,31953],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":763,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":763,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31957,31985],"text":"(this.smartTrailingV2Service == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'updateSmartTP3' has a complexity of 19. Maximum allowed is 10.","line":801,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":940,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":803,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":803,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33159,33180],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":809,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":809,"endColumn":27,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[33349,33366],"text":"((smartTP3?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[33348,33366],"text":"(smartTP3?.enabled) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":814,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":814,"endColumn":77},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":815,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":815,"endColumn":18,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[33533,33541],"text":"((tp2?.hit) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[33532,33541],"text":"(tp2?.hit) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":820,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":820,"endColumn":77},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":821,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":821,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33714,33718],"text":"(tp3 == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":821,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":821,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33733,33745],"text":"(tp3.orderId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[33734,33745],"text":"(tp3.orderId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[33733,33745],"text":"(!Boolean(tp3.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":827,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":827,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33920,33936],"text":"activationPrice == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[33921,33936],"text":"(activationPrice ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[33920,33936],"text":"!Boolean(activationPrice)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":843,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":843,"endColumn":69,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[34453,34496],"text":"(this.currentPosition.stopLoss.tp3MovedTicks != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[34453,34496],"text":"(this.currentPosition.stopLoss.tp3MovedTicks ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[34453,34496],"text":"(Boolean(this.currentPosition.stopLoss.tp3MovedTicks))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":843,"column":70,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":843,"endColumn":72,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[34497,34499],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":849,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":849,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[34750,34761],"text":"(tp3.orderId.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[34750,34761],"text":"(tp3.orderId !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[34750,34761],"text":"(Boolean(tp3.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'checkAdaptiveTP3Extension' has a complexity of 13. Maximum allowed is 10.","line":951,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":1033,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":958,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":958,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[38876,38900],"text":"this.adaptiveTP3Service == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":963,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":963,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39000,39021],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":968,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":968,"endColumn":77},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":969,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":969,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39225,39229],"text":"(tp3 == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":969,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":969,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39244,39256],"text":"(tp3.orderId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[39245,39256],"text":"(tp3.orderId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[39244,39256],"text":"(!Boolean(tp3.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":982,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":982,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39528,39548],"text":"(result.newTP3Percent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[39528,39548],"text":"(result.newTP3Percent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[39528,39548],"text":"(Boolean(result.newTP3Percent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1154,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1154,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[45523,45532],"text":"openTrade != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":1178,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":1178,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[46640,46656],"text":"position.status.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[46640,46656],"text":"position.status === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[46640,46656],"text":"!Boolean(position.status)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1212,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1212,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47959,47982],"text":"(this.adaptiveTP3Service != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1212,"column":36,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1212,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47986,48006],"text":"(this.currentPosition != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'recordPositionClose' has a complexity of 16. Maximum allowed is 10.","line":1223,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":1363,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1230,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1230,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48429,48450],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1254,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1254,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[49259,49281],"text":"this.takeProfitManager != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.00055.","line":1280,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":1280,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":1292,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":1292,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51135,51166],"text":"this.currentPosition.journalId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[51136,51166],"text":"(this.currentPosition.journalId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51135,51166],"text":"!Boolean(this.currentPosition.journalId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":1319,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":1319,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":1320,"column":23,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":1320,"endColumn":47,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[52061,52072],"text":"ExitType.STOP_LOSS"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1336,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1336,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[52717,52734],"text":"(this.sessionStats != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":1336,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":1336,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[52738,52768],"text":"(this.currentPosition.journalId.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[52738,52768],"text":"(this.currentPosition.journalId !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[52738,52768],"text":"(Boolean(this.currentPosition.journalId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1345,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1345,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[53052,53094],"text":"(this.currentPosition.stopLoss.initialPrice !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[53052,53094],"text":"(!Number.isNaN(this.currentPosition.stopLoss.initialPrice))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[53052,53094],"text":"(Boolean(this.currentPosition.stopLoss.initialPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1355,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1355,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[53547,53570],"text":"this.adaptiveTP3Service != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1381,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1381,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[54449,54470],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1391,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1391,"endColumn":49,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[54700,54739],"text":"((this.riskConfig.bbTrailingStop?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[54699,54739],"text":"(this.riskConfig.bbTrailingStop?.enabled) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":1429,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1429,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":1446,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1446,"endColumn":43}],"suppressedMessages":[],"errorCount":89,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Position Manager Service\r\n * Manages trading positions for futures with TP/SL\r\n *\r\n * Features:\r\n * - Open positions with multiple take-profit levels\r\n * - Automatic stop-loss and take-profit order placement\r\n * - Breakeven stop-loss after TP1\r\n * - Trailing stop activation after TP2\r\n * - Position size calculation based on fixed USDT amount\r\n *\r\n * Risk Management:\r\n * - Fixed position size in USDT (e.g., 10 USDT)\r\n * - Quantity calculation via PositionCalculatorService\r\n *   Example: (10 USDT * 10x) / 1.20 = 83.33 coins\r\n *   This gives total position notional = 100 USDT, margin used = 10 USDT\r\n * - Multiple TP levels with partial closes\r\n * - Automatic SL management\r\n */\r\n\r\nimport {\r\n  Position,\r\n  PositionSide,\r\n  Signal,\r\n  SignalDirection,\r\n  TradingConfig,\r\n  RiskManagementConfig,\r\n  LoggerService,\r\n  EntryConfirmationConfig,\r\n  ExitType,\r\n  SessionEntryCondition,\r\n  SessionTradeRecord,\r\n  SmartTrailingConfig,\r\n  AdaptiveTP3Config,\r\n  Config,\r\n  SmartBreakevenConfig,\r\n  SignalType,\r\n} from '../types';\r\nimport { BybitService } from './bybit';\r\nimport { TelegramService } from './telegram.service';\r\nimport { TradingJournalService } from './trading-journal.service';\r\nimport { TakeProfitManagerService, PartialClose } from './take-profit-manager.service';\r\nimport { EntryConfirmationManager, ConfirmationResult } from './entry-confirmation.service';\r\nimport { PositionCalculatorService } from './position-calculator.service';\r\nimport { CompoundInterestCalculatorService } from './compound-interest-calculator.service';\r\nimport { SessionStatsService } from './session-stats.service';\r\nimport { SmartBreakevenService } from './smart-breakeven.service';\r\nimport { SmartTrailingV2Service } from './smart-trailing-v2.service';\r\nimport { AdaptiveTP3Service } from './adaptive-tp3.service';\r\nimport { RiskBasedSizingService } from './risk-based-sizing.service';\r\nimport { LossStreakService } from './loss-streak.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PERCENT_TO_DECIMAL = 100;\r\n\r\n// ============================================================================\r\n// POSITION MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class PositionManagerService {\r\n  private currentPosition: Position | null = null;\r\n  private takeProfitManager: TakeProfitManagerService | null = null;\r\n  private entryConfirmation: EntryConfirmationManager;\r\n  private readonly positionCalculator: PositionCalculatorService;\r\n  private readonly compoundInterestCalculator?: CompoundInterestCalculatorService;\r\n  private readonly sessionStats?: SessionStatsService;\r\n  private readonly smartBreakevenService?: SmartBreakevenService;\r\n  private readonly smartTrailingV2Service?: SmartTrailingV2Service;\r\n  private readonly adaptiveTP3Service?: AdaptiveTP3Service;\r\n  private readonly riskBasedSizingService?: RiskBasedSizingService;\r\n  private readonly lossStreakService?: LossStreakService;\r\n\r\n  constructor(\r\n    private readonly bybitService: BybitService,\r\n    private readonly tradingConfig: TradingConfig,\r\n    private readonly riskConfig: RiskManagementConfig,\r\n    private readonly telegram: TelegramService,\r\n    private readonly logger: LoggerService,\r\n    private readonly journal: TradingJournalService,\r\n    private readonly entryConfirmationConfig: EntryConfirmationConfig,\r\n    private readonly fullConfig: Config,\r\n    compoundInterestCalculator?: CompoundInterestCalculatorService,\r\n    sessionStats?: SessionStatsService,\r\n    smartBreakevenService?: SmartBreakevenService,\r\n    smartTrailingConfig?: SmartTrailingConfig,\r\n    adaptiveTP3Config?: AdaptiveTP3Config,\r\n    riskBasedSizingService?: RiskBasedSizingService,\r\n    lossStreakService?: LossStreakService,\r\n  ) {\r\n    this.entryConfirmation = new EntryConfirmationManager(entryConfirmationConfig, logger);\r\n    this.positionCalculator = new PositionCalculatorService(logger);\r\n    this.compoundInterestCalculator = compoundInterestCalculator;\r\n    this.sessionStats = sessionStats;\r\n    this.smartBreakevenService = smartBreakevenService;\r\n    this.riskBasedSizingService = riskBasedSizingService;\r\n    this.lossStreakService = lossStreakService;\r\n\r\n    // Phase 3: Initialize SmartTrailingV2Service if config provided and enabled\r\n    if (smartTrailingConfig?.enabled) {\r\n      this.smartTrailingV2Service = new SmartTrailingV2Service(smartTrailingConfig, logger);\r\n      this.logger.info('âœ… SmartTrailingV2Service initialized (Phase 3)');\r\n    }\r\n\r\n    // Phase 3: Initialize AdaptiveTP3Service if config provided and enabled\r\n    if (adaptiveTP3Config?.enabled) {\r\n      this.adaptiveTP3Service = new AdaptiveTP3Service(adaptiveTP3Config, logger);\r\n      this.logger.info('âœ… AdaptiveTP3Service initialized (Phase 3)');\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get strategy-specific SmartBreakeven config\r\n   * Falls back to global config if strategy doesn't have specific config\r\n   */\r\n  private getStrategySmartBreakevenConfig(strategyType?: string): SmartBreakevenConfig | undefined {\r\n    if (!strategyType) {\r\n      return this.fullConfig.smartBreakeven;\r\n    }\r\n\r\n    // Map strategy type to config\r\n    switch (strategyType) {\r\n    case SignalType.SCALPING_MICRO_WALL:\r\n      return this.fullConfig.scalpingMicroWall?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_TICK_DELTA:\r\n      return this.fullConfig.scalpingTickDelta?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_ORDER_FLOW:\r\n      return this.fullConfig.scalpingOrderFlow?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_LIMIT_ORDER:\r\n      return this.fullConfig.scalpingLimitOrder?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_LADDER_TP:\r\n      return this.fullConfig.scalpingLadderTp?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.WHALE_HUNTER:\r\n    case SignalType.WHALE_HUNTER_FOLLOW:\r\n      return this.fullConfig.whaleHunter?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    default:\r\n      // For basic strategies (TrendFollowing, LevelBased, CounterTrend), use global config\r\n      return this.fullConfig.smartBreakeven;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Open a new position based on signal\r\n   * @param signal - Trading signal with entry details\r\n   * @param entrySnapshot - Optional full entry condition snapshot for session stats\r\n   */\r\n  async openPosition(signal: Signal, entrySnapshot?: SessionEntryCondition): Promise<Position> {\r\n    if (this.currentPosition !== null) {\r\n      throw new Error('Position already exists. Close existing position first.');\r\n    }\r\n\r\n    // IMPORTANT: Cancel any hanging conditional orders from previous position\r\n    // This prevents old SL/TP orders from triggering on the new position\r\n    this.logger.debug('ðŸ§¹ Cancelling any hanging conditional orders before opening position...');\r\n    await this.bybitService.cancelAllConditionalOrders();\r\n\r\n    // Determine position size (fixed or compound interest)\r\n    let positionSizeUsdt: number;\r\n\r\n    if (this.compoundInterestCalculator && this.compoundInterestCalculator.isEnabled()) {\r\n      // Use compound interest calculator for dynamic position sizing\r\n      const compoundResult = await this.compoundInterestCalculator.calculatePositionSize();\r\n      positionSizeUsdt = compoundResult.positionSize;\r\n\r\n      this.logger.info('ðŸ’° Compound interest position sizing', {\r\n        currentBalance: compoundResult.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\r\n        totalProfit: compoundResult.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\r\n        positionSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n        growthFactor: (positionSizeUsdt / this.riskConfig.positionSizeUsdt).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n        protectionActive: compoundResult.protectionActive,\r\n      });\r\n    } else {\r\n      // Use fixed position size from config\r\n      positionSizeUsdt = this.riskConfig.positionSizeUsdt;\r\n\r\n      this.logger.debug('ðŸ“Š Fixed position sizing', {\r\n        positionSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n    }\r\n\r\n    // PHASE 5: Apply Risk-Based Sizing (overrides compound/fixed size)\r\n    if (this.riskBasedSizingService) {\r\n      const currentBalance = await this.bybitService.getBalance();\r\n      const riskBasedSize = this.riskBasedSizingService.calculatePositionSize(\r\n        currentBalance,\r\n        signal.price,\r\n        signal.stopLoss,\r\n      );\r\n\r\n      this.logger.info('ðŸŽ¯ Risk-Based Sizing applied (PHASE 5)', {\r\n        originalSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n        riskBasedSize: riskBasedSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        slDistance: Math.abs(signal.price - signal.stopLoss).toFixed(DECIMAL_PLACES.PERCENT),\r\n        slPercent: (Math.abs(signal.price - signal.stopLoss) / signal.price * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      positionSizeUsdt = riskBasedSize;\r\n    }\r\n\r\n    // PHASE 5: Apply Loss Streak multiplier\r\n    if (this.lossStreakService) {\r\n      const multiplier = this.lossStreakService.getSizeMultiplier();\r\n      const originalSize = positionSizeUsdt;\r\n      positionSizeUsdt = positionSizeUsdt * multiplier;\r\n\r\n      this.logger.info('ðŸ”» Loss Streak multiplier applied (PHASE 5)', {\r\n        consecutiveLosses: this.lossStreakService.getConsecutiveLosses(),\r\n        multiplier: (multiplier * PERCENT_MULTIPLIER).toFixed(0) + '%',\r\n        originalSize: originalSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        adjustedSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n    }\r\n\r\n    // Calculate quantity using PositionCalculatorService\r\n    const limits = this.bybitService.getExchangeLimits();\r\n    const calculation = this.positionCalculator.calculateQuantity(\r\n      positionSizeUsdt,\r\n      this.tradingConfig.leverage,\r\n      signal.price,\r\n      limits,\r\n    );\r\n\r\n    if (!calculation.isValid) {\r\n      this.logger.error('âŒ Position calculation failed - quantity invalid', {\r\n        errors: calculation.validationErrors,\r\n        positionSizeUsdt: this.riskConfig.positionSizeUsdt,\r\n        leverage: this.tradingConfig.leverage,\r\n        price: signal.price,\r\n        limits,\r\n      });\r\n      throw new Error(`Position calculation failed: ${calculation.validationErrors.join(', ')}`);\r\n    }\r\n\r\n    const quantity = parseFloat(calculation.roundedQuantity);\r\n\r\n    this.logger.info('âœ… Position quantity calculated', {\r\n      quantity,\r\n      roundedQuantity: calculation.roundedQuantity,\r\n      marginUsed: calculation.marginUsed,\r\n      notionalValue: calculation.notionalValue,\r\n    });\r\n\r\n    // Determine position side\r\n    const isLong = signal.direction === SignalDirection.LONG;\r\n    const side = isLong ? PositionSide.LONG : PositionSide.SHORT;\r\n\r\n    // 1. Open position with limit order\r\n    const orderId = await this.bybitService.openPosition({\r\n      side,\r\n      quantity,\r\n      leverage: this.tradingConfig.leverage,\r\n    });\r\n\r\n    // 2. Place take-profit levels\r\n    const tpOrderIds = await this.bybitService.placeTakeProfitLevels({\r\n      side,\r\n      entryPrice: signal.price,\r\n      totalQuantity: quantity,\r\n      levels: signal.takeProfits,\r\n    });\r\n\r\n    // 3. Set position-level stop-loss\r\n    // Recalculate SL based on actual market price to avoid slippage issues\r\n    const isLongPosition = signal.direction === SignalDirection.LONG;\r\n    const slDistancePercent = Math.abs((signal.stopLoss - signal.price) / signal.price * PERCENT_MULTIPLIER);\r\n\r\n    // Get current market price (after position opened)\r\n    const currentPrice = await this.bybitService.getCurrentPrice();\r\n    const slDistance = currentPrice * (slDistancePercent / PERCENT_MULTIPLIER);\r\n    const actualStopLoss = isLongPosition\r\n      ? currentPrice - slDistance\r\n      : currentPrice + slDistance;\r\n\r\n    this.logger.info('ðŸ“Š SL recalculated for actual entry', {\r\n      signalPrice: signal.price,\r\n      signalSL: signal.stopLoss,\r\n      currentPrice,\r\n      slDistancePercent: slDistancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      actualStopLoss,\r\n    });\r\n\r\n    // Use setTradingStop instead of conditional order\r\n    await this.bybitService.updateStopLoss(actualStopLoss);\r\n    const slOrderId = null; // No orderId for position-level SL\r\n\r\n    // ðŸš¨ CRITICAL: Verify protection is actually set (double-check)\r\n    const MAX_VERIFICATION_RETRIES = 3;\r\n    let verificationAttempt = 0;\r\n    let protectionVerified = false;\r\n\r\n    while (verificationAttempt < MAX_VERIFICATION_RETRIES && !protectionVerified) {\r\n      verificationAttempt++;\r\n\r\n      // Wait 1 second before verification to allow orders to propagate\r\n      await this.sleep(1000);\r\n\r\n      this.logger.debug(`ðŸ” Verifying protection (attempt ${verificationAttempt}/${MAX_VERIFICATION_RETRIES})...`);\r\n\r\n      const verification = await this.bybitService.verifyProtectionSet(side);\r\n\r\n      if (verification.verified) {\r\n        protectionVerified = true;\r\n        this.logger.info('âœ… Protection verified successfully', {\r\n          hasStopLoss: verification.hasStopLoss,\r\n          hasTakeProfit: verification.hasTakeProfit,\r\n          stopLossPrice: verification.stopLossPrice,\r\n          takeProfitCount: verification.takeProfitPrices?.length,\r\n          activeOrders: verification.activeOrders,\r\n          hasTrailingStop: verification.hasTrailingStop,\r\n        });\r\n      } else {\r\n        this.logger.warn(`âš ï¸ Protection verification failed (attempt ${verificationAttempt})`, {\r\n          hasStopLoss: verification.hasStopLoss,\r\n          hasTakeProfit: verification.hasTakeProfit,\r\n          activeOrders: verification.activeOrders,\r\n        });\r\n\r\n        // Retry setting protection if missing\r\n        if (!verification.hasStopLoss && verificationAttempt < MAX_VERIFICATION_RETRIES) {\r\n          this.logger.warn('ðŸ”„ Retrying SL placement...');\r\n          try {\r\n            await this.bybitService.updateStopLoss(actualStopLoss);\r\n          } catch (error) {\r\n            this.logger.error('Failed to retry SL placement', {\r\n              error: error instanceof Error ? error.message : String(error),\r\n            });\r\n          }\r\n        }\r\n\r\n        if (!verification.hasTakeProfit && verificationAttempt < MAX_VERIFICATION_RETRIES) {\r\n          this.logger.warn('ðŸ”„ Retrying TP placement...');\r\n          try {\r\n            await this.bybitService.placeTakeProfitLevels({\r\n              side,\r\n              entryPrice: signal.price,\r\n              totalQuantity: quantity,\r\n              levels: signal.takeProfits,\r\n            });\r\n          } catch (error) {\r\n            this.logger.error('Failed to retry TP placement', {\r\n              error: error instanceof Error ? error.message : String(error),\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ðŸš¨ CRITICAL ERROR: Protection still missing after retries\r\n    if (!protectionVerified) {\r\n      this.logger.error('ðŸš¨ CRITICAL: Failed to verify protection after retries!', {\r\n        side,\r\n        entryPrice: signal.price,\r\n        quantity,\r\n      });\r\n\r\n      // Emergency: Close position immediately (better to lose fees than leave unprotected)\r\n      this.logger.error('ðŸš¨ EMERGENCY: Closing position without protection!');\r\n      try {\r\n        await this.bybitService.closePosition(side, quantity);\r\n        await this.telegram.sendAlert('ðŸš¨ EMERGENCY: Position closed due to missing TP/SL protection!');\r\n      } catch (closeError) {\r\n        this.logger.error('Failed to emergency close position!', {\r\n          error: closeError instanceof Error ? closeError.message : String(closeError),\r\n        });\r\n        await this.telegram.sendAlert('ðŸš¨ðŸš¨ðŸš¨ CRITICAL: Position open WITHOUT PROTECTION - MANUAL INTERVENTION REQUIRED!');\r\n      }\r\n\r\n      throw new Error('Failed to set protection for position - position closed for safety');\r\n    }\r\n\r\n    // 4. Create Position object\r\n    const timestamp = Date.now();\r\n    const sideName = side === PositionSide.LONG ? 'Buy' : 'Sell';\r\n    const exchangeId = `${this.bybitService['symbol']}_${sideName}`;\r\n    const journalId = `${exchangeId}_${timestamp}`;\r\n\r\n    this.currentPosition = {\r\n      id: exchangeId, // Exchange ID for WebSocket sync (e.g., \"APEXUSDT_Sell\")\r\n      journalId, // Unique ID for trade history (e.g., \"APEXUSDT_Sell_1761696424935\")\r\n      symbol: this.bybitService['symbol'],\r\n      side,\r\n      quantity,\r\n      entryPrice: signal.price,\r\n      leverage: this.tradingConfig.leverage,\r\n      marginUsed: this.riskConfig.positionSizeUsdt,\r\n      stopLoss: {\r\n        price: actualStopLoss,\r\n        initialPrice: actualStopLoss,\r\n        orderId: undefined, // Position-level SL doesn't have orderId\r\n        isBreakeven: false,\r\n        isTrailing: false,\r\n        updatedAt: Date.now(),\r\n      },\r\n      takeProfits: signal.takeProfits.map((tp, i) => ({\r\n        ...tp,\r\n        orderId: tpOrderIds[i] || undefined, // Use undefined if orderId not returned (order failed)\r\n        hit: false,\r\n      })),\r\n      openedAt: timestamp,\r\n      unrealizedPnL: 0,\r\n      orderId,\r\n      reason: signal.reason,\r\n      confidence: signal.confidence,\r\n      strategy: signal.type,\r\n      protectionVerifiedOnce: true, // Protection already verified during opening\r\n      status: 'OPEN', // Initialize as OPEN\r\n    };\r\n\r\n    // 5. Initialize Take Profit Manager for partial close tracking\r\n    this.takeProfitManager = new TakeProfitManagerService(\r\n      {\r\n        positionId: this.currentPosition.id,\r\n        symbol: this.currentPosition.symbol,\r\n        side,\r\n        entryPrice: signal.price,\r\n        totalQuantity: quantity,\r\n        leverage: this.tradingConfig.leverage,\r\n      },\r\n      this.logger,\r\n    );\r\n\r\n    // Send Telegram notification\r\n    await this.telegram.notifyPositionOpened(this.currentPosition);\r\n\r\n    // Record trade opening in journal\r\n    // Simplified: just serialize the entire Signal object + any additional data\r\n    this.journal.recordTradeOpen({\r\n      id: this.currentPosition.journalId!, // Use unique journal ID\r\n      symbol: this.currentPosition.symbol,\r\n      side,\r\n      entryPrice: signal.price,\r\n      quantity,\r\n      leverage: this.tradingConfig.leverage,\r\n      entryCondition: {\r\n        signal, // Complete Signal object with all data (includes marketData and btcData)\r\n        marketData: (signal.marketData as Record<string, unknown>) || undefined, // Already included in signal, but keeping for clarity\r\n        btcData: signal.btcData || undefined, // BTC confirmation data (if BTC filter was enabled)\r\n        // Add any other data needed for ML:\r\n        // indicators: allIndicatorValues,\r\n        // rawData: { candles, swingPoints, etc. }\r\n      },\r\n    });\r\n\r\n    // Record trade entry in session stats (if available and snapshot provided)\r\n    if (this.sessionStats && entrySnapshot) {\r\n      const sessionTrade: SessionTradeRecord = {\r\n        tradeId: this.currentPosition.journalId!,\r\n        timestamp: new Date(timestamp).toISOString(),\r\n        direction: signal.direction,\r\n        entryPrice: signal.price,\r\n        exitPrice: 0, // Will be updated on close\r\n        quantity,\r\n        pnl: 0, // Will be updated on close\r\n        pnlPercent: 0, // Will be updated on close\r\n        exitType: ExitType.MANUAL, // Will be updated on close\r\n        tpHitLevels: [], // Will be updated on close\r\n        holdingTimeMs: 0, // Will be updated on close\r\n        entryCondition: entrySnapshot,\r\n        stopLoss: {\r\n          initial: actualStopLoss,\r\n          final: actualStopLoss, // Will be updated if SL moves\r\n          movedToBreakeven: false,\r\n          trailingActivated: false,\r\n        },\r\n      };\r\n\r\n      this.sessionStats.recordTradeEntry(sessionTrade);\r\n      this.logger.debug('ðŸ“Š Trade entry recorded in session stats', { tradeId: this.currentPosition.journalId });\r\n    }\r\n\r\n    return this.currentPosition;\r\n  }\r\n\r\n  /**\r\n   * Handle take-profit hit - adjust SL to breakeven or activate trailing\r\n   */\r\n  async onTakeProfitHit(tpLevel: number, currentPrice: number): Promise<void> {\r\n    if (this.currentPosition === null || this.takeProfitManager === null) {\r\n      return;\r\n    }\r\n\r\n    // Check if this TP level was already hit (prevent duplicate processing)\r\n    const tpConfig = this.currentPosition.takeProfits.find((tp) => tp.level === tpLevel);\r\n    if (!tpConfig || tpConfig.hit) {\r\n      this.logger.debug('ðŸ§¹ TP event ignored - already hit or not found', {\r\n        tpLevel,\r\n        alreadyHit: tpConfig?.hit,\r\n        positionId: this.currentPosition.id,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Record partial close in TakeProfitManager\r\n    // Calculate quantity for this TP level\r\n    const partialQuantity = (this.currentPosition.quantity * tpConfig.sizePercent) / PERCENT_MULTIPLIER;\r\n\r\n    // Record the partial close\r\n    this.takeProfitManager.recordPartialClose(tpLevel, partialQuantity, currentPrice);\r\n\r\n    // Mark TP as hit\r\n    tpConfig.hit = true;\r\n    tpConfig.hitAt = Date.now();\r\n\r\n    // Clear orderId to prevent Smart TP3 from trying to update a filled order\r\n    if (tpConfig.orderId) {\r\n      tpConfig.orderId = undefined;\r\n    }\r\n\r\n    // Breakeven after TP1\r\n    // Race condition: check position still exists before accessing stopLoss\r\n    if (tpLevel === 1 && this.currentPosition !== null && !this.currentPosition.stopLoss.isBreakeven) {\r\n      // PHASE 1: Smart Breakeven - Activate Pre-BE mode instead of immediate breakeven\r\n      // FIX: Pass realized PnL and remaining quantity to account for TP1 profit\r\n      const realizedPnL = this.takeProfitManager ? this.takeProfitManager.getTotalRealizedPnL() : 0;\r\n      const remainingQty = this.takeProfitManager ? this.takeProfitManager.getRemainingQuantity() : this.currentPosition.quantity;\r\n\r\n      // Get strategy-specific SmartBreakeven config\r\n      const strategyBEConfig = this.getStrategySmartBreakevenConfig(this.currentPosition.strategy);\r\n\r\n      if (this.smartBreakevenService && strategyBEConfig && this.smartBreakevenService.shouldActivate(\r\n        this.currentPosition,\r\n        currentPrice,\r\n        realizedPnL,\r\n        remainingQty,\r\n        strategyBEConfig, // Pass strategy-specific config\r\n      )) {\r\n        this.smartBreakevenService.activatePreBE(this.currentPosition.symbol);\r\n\r\n        // Calculate total profit for logging (realized + unrealized)\r\n        const pnlMultiplier = this.currentPosition.side === 'LONG' ? 1 : -1;\r\n        const priceDiff = currentPrice - this.currentPosition.entryPrice;\r\n        const unrealizedPnL = priceDiff * remainingQty * pnlMultiplier * this.currentPosition.leverage;\r\n        const totalPnL = realizedPnL + unrealizedPnL;\r\n        const totalProfitPercent = (totalPnL / (this.currentPosition.entryPrice * this.currentPosition.quantity)) * PERCENT_MULTIPLIER;\r\n\r\n        this.logger.info('âš¡ TP1 hit - Pre-Breakeven mode activated (not moving SL yet)', {\r\n          positionId: this.currentPosition.id,\r\n          realizedPnL: realizedPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\r\n          unrealizedPnL: unrealizedPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\r\n          totalProfit: totalProfitPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        });\r\n        return; // Don't move SL immediately - wait for impulse confirmation\r\n      }\r\n\r\n      // Legacy behavior: Immediate breakeven (when Smart Breakeven disabled)\r\n      const breakevenPrice = this.calculateBreakevenPrice(\r\n        this.currentPosition.entryPrice,\r\n        this.currentPosition.side,\r\n        this.riskConfig.breakevenOffsetPercent,\r\n      );\r\n\r\n      this.logger.info('ðŸŽ¯ Moving SL to breakeven after TP1 (legacy mode)', {\r\n        positionId: this.currentPosition.id,\r\n        side: this.currentPosition.side,\r\n        entryPrice: this.currentPosition.entryPrice,\r\n        currentSL: this.currentPosition.stopLoss.price,\r\n        newSL: breakevenPrice,\r\n      });\r\n\r\n      // Update stop-loss to breakeven (setTradingStop automatically replaces previous SL)\r\n      await this.bybitService.updateStopLoss(breakevenPrice);\r\n\r\n      // Race condition check: position might have been closed during async operation\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('ðŸ§¹ Position closed during breakeven update, skipping');\r\n        return;\r\n      }\r\n\r\n      this.currentPosition.stopLoss.price = breakevenPrice;\r\n      this.currentPosition.stopLoss.isBreakeven = true;\r\n      this.currentPosition.stopLoss.updatedAt = Date.now();\r\n\r\n      this.logger.info('âœ… SL moved to breakeven successfully', {\r\n        positionId: this.currentPosition.id,\r\n        newSL: breakevenPrice,\r\n      });\r\n\r\n      // Send Telegram notification\r\n      await this.telegram.notifyBreakeven(this.currentPosition, breakevenPrice);\r\n\r\n      // Race condition check after telegram notification\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('ðŸ§¹ Position closed during breakeven notification, skipping');\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Activate trailing stop after TP2\r\n    // Race condition: check position still exists before accessing stopLoss\r\n    // IMPORTANT: Do NOT activate trailing if SL is already in breakeven!\r\n    if (\r\n      tpLevel === this.riskConfig.trailingStopActivationLevel &&\r\n      this.riskConfig.trailingStopEnabled &&\r\n      this.currentPosition !== null &&\r\n      !this.currentPosition.stopLoss.isTrailing &&\r\n      !this.currentPosition.stopLoss.isBreakeven // Protect breakeven SL\r\n    ) {\r\n      // Phase 3: Activate SmartTrailingV2 if enabled\r\n      if (this.smartTrailingV2Service) {\r\n        this.smartTrailingV2Service.activateOnTP2(this.currentPosition.id);\r\n        this.logger.info('ðŸš€ Phase 3: SmartTrailingV2 activated on TP2', {\r\n          positionId: this.currentPosition.id,\r\n        });\r\n      }\r\n\r\n      // Phase 3: Initialize AdaptiveTP3 if enabled\r\n      const tp3 = this.currentPosition.takeProfits.find((tp) => tp.level === 3);\r\n      if (this.adaptiveTP3Service && tp3) {\r\n        const baseTP3Percent = ((tp3.price - this.currentPosition.entryPrice) / this.currentPosition.entryPrice) * PERCENT_MULTIPLIER;\r\n        this.adaptiveTP3Service.initialize(this.currentPosition.id, Math.abs(baseTP3Percent));\r\n        this.logger.info('ðŸš€ Phase 3: AdaptiveTP3 initialized on TP2', {\r\n          positionId: this.currentPosition.id,\r\n          baseTP3: baseTP3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        });\r\n      }\r\n\r\n      // Check if smart TP3 movement is enabled\r\n      const smartTP3 = this.riskConfig.smartTP3;\r\n\r\n      if (smartTP3?.enabled && tp3?.orderId) {\r\n        // Smart TP3: Keep TP3 active, will move it by ticks\r\n        this.logger.info('ðŸŽ¯ Trailing activated - TP3 will move smartly by ticks', {\r\n          positionId: this.currentPosition.id,\r\n          tp3Price: tp3.price,\r\n          tickSize: smartTP3.tickSizePercent + '%',\r\n          maxTicks: smartTP3.maxTicks,\r\n        });\r\n      } else if (tp3?.orderId) {\r\n        // Legacy behavior: Cancel TP3 immediately\r\n        await this.bybitService.cancelTakeProfit(tp3.orderId);\r\n\r\n        // Race condition check: position might have been closed during async operation\r\n        if (this.currentPosition === null) {\r\n          this.logger.debug('ðŸ§¹ Position closed during TP3 cancellation, skipping');\r\n          return;\r\n        }\r\n\r\n        this.logger.info('ðŸŽ¯ TP3 cancelled - trailing stop activated', {\r\n          positionId: this.currentPosition.id,\r\n          tp3Price: tp3.price,\r\n        });\r\n      }\r\n\r\n      // Activate server-side trailing stop\r\n      await this.bybitService.setTrailingStop({\r\n        side: this.currentPosition.side,\r\n        activationPrice: currentPrice,\r\n        trailingPercent: this.riskConfig.trailingStopPercent,\r\n      });\r\n\r\n      // Race condition check: position might have been closed during async operation\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('ðŸ§¹ Position closed during trailing stop activation, skipping');\r\n        return;\r\n      }\r\n\r\n      this.currentPosition.stopLoss.isTrailing = true;\r\n      this.currentPosition.stopLoss.trailingPercent = this.riskConfig.trailingStopPercent;\r\n      this.currentPosition.stopLoss.trailingActivationPrice = currentPrice; // Store TP2 hit price\r\n      this.currentPosition.stopLoss.tp3MovedTicks = 0; // Initialize tick counter\r\n      this.currentPosition.stopLoss.updatedAt = Date.now();\r\n\r\n      // Calculate new stop price (trailing distance from current price)\r\n      const newStopPrice = this.calculateTrailingStopPrice(\r\n        currentPrice,\r\n        this.currentPosition.side,\r\n        this.riskConfig.trailingStopPercent,\r\n      );\r\n\r\n      // Send Telegram notification\r\n      await this.telegram.notifyTrailingActivated(\r\n        this.currentPosition,\r\n        currentPrice,\r\n        newStopPrice,\r\n        this.riskConfig.trailingStopPercent,\r\n      );\r\n\r\n      // Race condition check after telegram notification\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('ðŸ§¹ Position closed during trailing notification, skipping');\r\n        return;\r\n      }\r\n    } else if (\r\n      tpLevel === this.riskConfig.trailingStopActivationLevel &&\r\n      this.riskConfig.trailingStopEnabled &&\r\n      this.currentPosition !== null &&\r\n      this.currentPosition.stopLoss.isBreakeven\r\n    ) {\r\n      // Trailing NOT activated because SL is already in breakeven\r\n      this.logger.info('âœ… Trailing activation skipped - SL already in breakeven (protecting profit)', {\r\n        positionId: this.currentPosition.id,\r\n        breakevenSL: this.currentPosition.stopLoss.price.toFixed(DECIMAL_PLACES.PRICE),\r\n        tpLevel,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update SmartTrailingV2 stop loss (Phase 3)\r\n   * Called from TradingOrchestrator on candle close\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param ema20 - Current EMA20 value\r\n   * @param atr - Current ATR value\r\n   */\r\n  async updateSmartTrailingV2(currentPrice: number, ema20: number, atr: number): Promise<void> {\r\n    if (!this.currentPosition || !this.smartTrailingV2Service) {\r\n      return;\r\n    }\r\n\r\n    // Check if trailing is active\r\n    if (!this.smartTrailingV2Service.isActive(this.currentPosition.id)) {\r\n      return;\r\n    }\r\n\r\n    // Update trailing stop via SmartTrailingV2Service\r\n    await this.smartTrailingV2Service.updateTrailingStop(\r\n      this.currentPosition,\r\n      currentPrice,\r\n      ema20,\r\n      atr,\r\n      async (newSL: number) => {\r\n        // Callback to update stop loss on exchange\r\n        await this.bybitService.updateStopLoss(newSL);\r\n\r\n        // Update local position\r\n        if (this.currentPosition) {\r\n          this.currentPosition.stopLoss.price = newSL;\r\n          this.currentPosition.stopLoss.updatedAt = Date.now();\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if SmartTrailingV2 impulse activation should trigger (Phase 3)\r\n   * Called from TradingOrchestrator on candle close\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param ema20 - Current EMA20 value\r\n   * @param currentVolume - Current candle volume\r\n   * @param avgVolume - Average volume\r\n   * @param emaAngle - EMA angle (slope)\r\n   */\r\n  checkSmartTrailingImpulse(\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number,\r\n  ): boolean {\r\n    if (!this.currentPosition || !this.smartTrailingV2Service) {\r\n      return false;\r\n    }\r\n\r\n    // Don't check if already active\r\n    if (this.smartTrailingV2Service.isActive(this.currentPosition.id)) {\r\n      return false;\r\n    }\r\n\r\n    // Check impulse activation\r\n    const result = this.smartTrailingV2Service.checkImpulseActivation(\r\n      this.currentPosition,\r\n      currentPrice,\r\n      ema20,\r\n      currentVolume,\r\n      avgVolume,\r\n      emaAngle,\r\n    );\r\n\r\n    // Activate if conditions met\r\n    if (result.shouldActivate) {\r\n      this.smartTrailingV2Service.activateOnTP2(this.currentPosition.id); // Use activateOnTP2 for impulse too\r\n      this.logger.info('ðŸš€ Phase 3: SmartTrailingV2 activated on IMPULSE', {\r\n        positionId: this.currentPosition.id,\r\n        reason: result.reason,\r\n      });\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Update Smart TP3 - Move TP3 by ticks as price moves favorably\r\n   * Called from orderbook updates when trailing is active\r\n   *\r\n   * @param currentPrice - Current market price (mid price from orderbook)\r\n   */\r\n  async updateSmartTP3(currentPrice: number): Promise<void> {\r\n    // Check if we have an active position with trailing stop\r\n    if (!this.currentPosition || !this.currentPosition.stopLoss.isTrailing) {\r\n      return;\r\n    }\r\n\r\n    // Check if smart TP3 is enabled\r\n    const smartTP3 = this.riskConfig.smartTP3;\r\n    if (!smartTP3?.enabled) {\r\n      return;\r\n    }\r\n\r\n    // CRITICAL: Check that TP2 is actually hit\r\n    const tp2 = this.currentPosition.takeProfits.find((tp) => tp.level === 2);\r\n    if (!tp2?.hit) {\r\n      return;\r\n    }\r\n\r\n    // Check that TP3 exists, not hit, and has orderId\r\n    const tp3 = this.currentPosition.takeProfits.find((tp) => tp.level === 3);\r\n    if (!tp3 || tp3.hit || !tp3.orderId) {\r\n      return;\r\n    }\r\n\r\n    // Get trailing activation price (TP2 hit price)\r\n    const activationPrice = this.currentPosition.stopLoss.trailingActivationPrice;\r\n    if (!activationPrice) {\r\n      return;\r\n    }\r\n\r\n    // Calculate profit since trailing activation (TP2 hit)\r\n    const side = this.currentPosition.side;\r\n    let profitPercent: number;\r\n\r\n    if (side === PositionSide.LONG) {\r\n      profitPercent = ((currentPrice - activationPrice) / activationPrice) * PERCENT_MULTIPLIER;\r\n    } else {\r\n      // SHORT\r\n      profitPercent = ((activationPrice - currentPrice) / activationPrice) * PERCENT_MULTIPLIER;\r\n    }\r\n\r\n    // Calculate how many ticks we should be at\r\n    const currentTicks = this.currentPosition.stopLoss.tp3MovedTicks || 0;\r\n    const newTicks = Math.floor(profitPercent / smartTP3.tickSizePercent);\r\n\r\n    // Check if we reached max ticks\r\n    if (newTicks >= smartTP3.maxTicks) {\r\n      // Max ticks reached - stop moving TP3\r\n      if (smartTP3.cancelAfterMaxTicks && tp3.orderId) {\r\n        // Cancel TP3, let trailing stop close the position\r\n        this.logger.info('ðŸŽ¯ Smart TP3: Max ticks reached, cancelling TP3', {\r\n          positionId: this.currentPosition.id,\r\n          maxTicks: smartTP3.maxTicks,\r\n          currentPrice,\r\n          tp3Price: tp3.price,\r\n        });\r\n\r\n        await this.bybitService.cancelTakeProfit(tp3.orderId);\r\n        tp3.orderId = undefined; // Mark as cancelled\r\n      } else {\r\n        // Keep TP3 active at final position - let it compete with trailing stop\r\n        this.logger.debug('ðŸŽ¯ Smart TP3: Max ticks reached, TP3 stays active', {\r\n          positionId: this.currentPosition.id,\r\n          maxTicks: smartTP3.maxTicks,\r\n          tp3Price: tp3.price,\r\n          currentPrice,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Check if we need to move TP3 to a new tick\r\n    if (newTicks > currentTicks) {\r\n      // Calculate new TP3 price (move it further by tick size)\r\n      const ticksToMove = newTicks - currentTicks;\r\n      let newTP3Price: number;\r\n\r\n      if (side === PositionSide.LONG) {\r\n        // LONG: TP3 higher than current, move it higher\r\n        newTP3Price = tp3.price * (1 + (smartTP3.tickSizePercent / PERCENT_MULTIPLIER) * ticksToMove);\r\n      } else {\r\n        // SHORT: TP3 lower than current, move it lower\r\n        newTP3Price = tp3.price * (1 - (smartTP3.tickSizePercent / PERCENT_MULTIPLIER) * ticksToMove);\r\n      }\r\n\r\n      this.logger.info('ðŸŽ¯ Smart TP3: Moving TP3 by ticks', {\r\n        positionId: this.currentPosition.id,\r\n        currentPrice,\r\n        activationPrice,\r\n        profitPercent: profitPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        oldTicks: currentTicks,\r\n        newTicks,\r\n        ticksMoved: ticksToMove,\r\n        oldTP3Price: tp3.price,\r\n        newTP3Price: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n\r\n      // Update position state BEFORE exchange call to prevent duplicate attempts\r\n      // (If exchange call fails but order was updated, we won't retry with same price)\r\n      const oldPrice = tp3.price;\r\n      tp3.price = newTP3Price;\r\n      this.currentPosition.stopLoss.tp3MovedTicks = newTicks;\r\n      this.currentPosition.stopLoss.updatedAt = Date.now();\r\n\r\n      // Update TP3 order on exchange\r\n      try {\r\n        await this.bybitService.updateTakeProfit(tp3.orderId, newTP3Price);\r\n      } catch (error) {\r\n        // TP3 may have been filled/cancelled during update (race condition)\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n\r\n        // Check if error is \"order not modified\" - this means price is already set correctly\r\n        if (errorMsg.includes('not modified')) {\r\n          this.logger.debug('TP3 already at target price, ignoring error', {\r\n            targetPrice: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return; // Keep new price in memory\r\n        }\r\n\r\n        // For other errors (order filled/cancelled), revert state and stop updates\r\n        this.logger.warn('Failed to update TP3 - may have been filled', {\r\n          error: errorMsg,\r\n          tp3OrderId: tp3.orderId,\r\n        });\r\n\r\n        // Revert price change\r\n        tp3.price = oldPrice;\r\n\r\n        // Mark orderId as invalid to stop future update attempts\r\n        tp3.orderId = undefined;\r\n        return;\r\n      }\r\n\r\n      this.logger.info('âœ… Smart TP3: TP3 moved successfully', {\r\n        positionId: this.currentPosition.id,\r\n        newTP3Price: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalTicks: newTicks,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check Adaptive TP3 Extension (Phase 3)\r\n   * Called on candle close to check if TP3 should be extended based on momentum\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param currentVolume - Current candle volume\r\n   * @param avgVolume - Average volume\r\n   * @param emaAngle - EMA slope angle in degrees\r\n   */\r\n  async checkAdaptiveTP3Extension(\r\n    currentPrice: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number,\r\n  ): Promise<void> {\r\n    // Check if AdaptiveTP3 is enabled\r\n    if (!this.adaptiveTP3Service) {\r\n      return;\r\n    }\r\n\r\n    // Check if we have an active position with trailing stop\r\n    if (!this.currentPosition || !this.currentPosition.stopLoss.isTrailing) {\r\n      return;\r\n    }\r\n\r\n    // Check that TP3 exists and not hit\r\n    const tp3 = this.currentPosition.takeProfits.find((tp) => tp.level === 3);\r\n    if (!tp3 || tp3.hit || !tp3.orderId) {\r\n      return;\r\n    }\r\n\r\n    // Check extension conditions\r\n    const result = this.adaptiveTP3Service.checkExtension(\r\n      this.currentPosition,\r\n      currentPrice,\r\n      currentVolume,\r\n      avgVolume,\r\n      emaAngle,\r\n    );\r\n\r\n    if (result.shouldExtend && result.newTP3Percent) {\r\n      // Calculate new TP3 price\r\n      const side = this.currentPosition.side;\r\n      const entryPrice = this.currentPosition.entryPrice;\r\n      let newTP3Price: number;\r\n\r\n      if (side === PositionSide.LONG) {\r\n        newTP3Price = entryPrice * (1 + result.newTP3Percent / PERCENT_MULTIPLIER);\r\n      } else {\r\n        newTP3Price = entryPrice * (1 - result.newTP3Percent / PERCENT_MULTIPLIER);\r\n      }\r\n\r\n      this.logger.info('ðŸ“ˆ Phase 3: Extending TP3', {\r\n        positionId: this.currentPosition.id,\r\n        reason: result.reason,\r\n        oldTP3: tp3.price.toFixed(DECIMAL_PLACES.PRICE),\r\n        newTP3: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n        newTP3Percent: result.newTP3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      // Update TP3 on exchange\r\n      try {\r\n        await this.bybitService.updateTakeProfit(tp3.orderId, newTP3Price);\r\n\r\n        // Update service state\r\n        this.adaptiveTP3Service.extendTP3(this.currentPosition.id, newTP3Price);\r\n\r\n        // Update local position state\r\n        tp3.price = newTP3Price;\r\n\r\n        this.logger.info('âœ… Phase 3: TP3 extended successfully', {\r\n          positionId: this.currentPosition.id,\r\n          newTP3Price: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n        this.logger.warn('âš ï¸ Failed to extend TP3', {\r\n          error: errorMsg,\r\n          tp3OrderId: tp3.orderId,\r\n        });\r\n\r\n        // Mark orderId as invalid to stop future update attempts\r\n        if (!errorMsg.includes('not modified')) {\r\n          tp3.orderId = undefined;\r\n        }\r\n      }\r\n    } else {\r\n      this.logger.debug('Phase 3: TP3 extension not needed', {\r\n        reason: result.reason,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close current position\r\n   */\r\n  async closePosition(): Promise<boolean> {\r\n    if (this.currentPosition === null) {\r\n      throw new Error('No position to close');\r\n    }\r\n\r\n    await this.bybitService.closePosition(\r\n      this.currentPosition.side,\r\n      this.currentPosition.quantity,\r\n    );\r\n\r\n    // Cancel any remaining conditional orders (SL/TP) after closing position\r\n    this.logger.debug('ðŸ§¹ Cancelling conditional orders after position close...');\r\n    await this.bybitService.cancelAllConditionalOrders();\r\n\r\n    this.currentPosition = null;\r\n    this.takeProfitManager = null;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get current position\r\n   */\r\n  getCurrentPosition(): Position | null {\r\n    return this.currentPosition;\r\n  }\r\n\r\n  /**\r\n   * Check if confirmation is enabled for direction\r\n   */\r\n  isConfirmationEnabled(direction: SignalDirection): boolean {\r\n    return this.entryConfirmation.isEnabled(direction);\r\n  }\r\n\r\n  /**\r\n   * Add pending signal waiting for candle confirmation\r\n   * @param signal - Signal to be confirmed\r\n   * @param keyLevel - Support (LONG) or Resistance (SHORT) level price\r\n   * @returns Pending entry ID\r\n   */\r\n  addPendingSignal(signal: Signal, keyLevel: number): string {\r\n    return this.entryConfirmation.addPending({\r\n      symbol: this.bybitService['symbol'],\r\n      direction: signal.direction,\r\n      keyLevel,\r\n      detectedAt: Date.now(),\r\n      signalData: signal as unknown as Record<string, unknown>,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check pending signals for confirmation\r\n   * Called every trading cycle with latest 1m candle close price\r\n   * @param currentCandleClose - Current 1m candle close price\r\n   * @returns Confirmed signal or null\r\n   */\r\n  checkPendingConfirmations(currentCandleClose: number): Signal | null {\r\n    const allPending = this.entryConfirmation.getAllPending();\r\n\r\n    for (const pending of allPending) {\r\n      const result = this.entryConfirmation.checkConfirmation(pending.id, currentCandleClose);\r\n\r\n      if (result.confirmed) {\r\n        const levelType = pending.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n        this.logger.info(`âœ… ${pending.direction} signal confirmed - ready to enter`, {\r\n          pendingId: pending.id,\r\n          direction: pending.direction,\r\n          [`${levelType}Level`]: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n\r\n        // Return the confirmed signal\r\n        return pending.signalData as unknown as Signal;\r\n      }\r\n\r\n      // Log rejections\r\n      if (!result.confirmed) {\r\n        if (pending.direction === SignalDirection.LONG && result.reason.includes('below support')) {\r\n          this.logger.info('âŒ LONG signal rejected - falling knife avoided', {\r\n            pendingId: pending.id,\r\n            supportLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n            candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n        } else if (pending.direction === SignalDirection.SHORT && result.reason.includes('above resistance')) {\r\n          this.logger.info('âŒ SHORT signal rejected - pump continues', {\r\n            pendingId: pending.id,\r\n            resistanceLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n            candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Cleanup expired entries\r\n    this.entryConfirmation.cleanupExpired();\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get count of pending signals\r\n   * @param direction - Optional: filter by direction\r\n   */\r\n  getPendingCount(direction?: SignalDirection): number {\r\n    return this.entryConfirmation.getPendingCount(direction);\r\n  }\r\n\r\n  /**\r\n   * Sync position from WebSocket update\r\n   */\r\n  syncWithWebSocket(position: Position): void {\r\n    if (this.currentPosition === null) {\r\n      // Position restored from WebSocket (e.g., after bot restart)\r\n      // Try to find matching open trade in journal by symbol\r\n      const openTrade = this.journal.getOpenPositionBySymbol(position.symbol);\r\n\r\n      if (openTrade) {\r\n        // Restore journalId from open trade\r\n        position.journalId = openTrade.id;\r\n        this.logger.info('âœ… Position restored from WebSocket with journal ID', {\r\n          exchangeId: position.id,\r\n          journalId: position.journalId,\r\n          symbol: position.symbol,\r\n        });\r\n      } else {\r\n        // No open trade in journal - DO NOT create journal entry (Session #57 decision)\r\n        // Position will be managed (TP/SL) but NOT tracked in journal statistics\r\n        this.logger.warn('âš ï¸ Position restored from WebSocket but not found in journal - IGNORING from statistics', {\r\n          exchangeId: position.id,\r\n          symbol: position.symbol,\r\n          entryPrice: position.entryPrice,\r\n          quantity: position.quantity,\r\n          note: 'This position will be managed (TP/SL) but NOT recorded in journal. Consider closing manually if unwanted.',\r\n        });\r\n\r\n        // Set journalId to undefined - this will prevent journal recording on close\r\n        position.journalId = undefined;\r\n      }\r\n\r\n      // Initialize status for restored positions\r\n      if (!position.status) {\r\n        position.status = 'OPEN';\r\n      }\r\n\r\n      this.currentPosition = position;\r\n      return;\r\n    }\r\n\r\n    // Update existing position\r\n    this.currentPosition.quantity = position.quantity;\r\n    this.currentPosition.unrealizedPnL = position.unrealizedPnL;\r\n\r\n    // âš ï¸ CRITICAL: Only update entryPrice if it's valid (> 0) and current is 0\r\n    // Bybit sends entryPrice=0 for MARKET orders before they're filled\r\n    // We must preserve the signal.price set during openPosition()\r\n    if (position.entryPrice > 0 && this.currentPosition.entryPrice === 0) {\r\n      this.currentPosition.entryPrice = position.entryPrice;\r\n      this.logger.info('âœ… Entry price updated from WebSocket', {\r\n        positionId: this.currentPosition.id,\r\n        entryPrice: position.entryPrice,\r\n      });\r\n    }\r\n    // DO NOT overwrite entryPrice if we already have it from signal!\r\n  }\r\n\r\n  /**\r\n   * Clear position (called when WebSocket reports position closed)\r\n   */\r\n  async clearPosition(): Promise<void> {\r\n    // Cancel any remaining conditional orders (SL/TP) when position closed via WebSocket\r\n    this.logger.debug('ðŸ§¹ Cancelling conditional orders after WebSocket position close...');\r\n    await this.bybitService.cancelAllConditionalOrders();\r\n\r\n    // Phase 3: Reset AdaptiveTP3 state\r\n    if (this.adaptiveTP3Service && this.currentPosition) {\r\n      this.adaptiveTP3Service.reset(this.currentPosition.id);\r\n    }\r\n\r\n    this.currentPosition = null;\r\n    this.takeProfitManager = null;\r\n  }\r\n\r\n  /**\r\n   * Record position close in journal\r\n   */\r\n  recordPositionClose(\r\n    exitPrice: number,\r\n    exitReason: string,\r\n    exitType: ExitType,\r\n    tpLevelsHit: number[] = [],\r\n  ): void {\r\n    // IDEMPOTENT: Check if position is null or already closed\r\n    if (!this.currentPosition) {\r\n      this.logger.debug('recordPositionClose called but position is null');\r\n      return;\r\n    }\r\n\r\n    if (this.currentPosition.status === 'CLOSED') {\r\n      this.logger.debug('recordPositionClose called but position already closed - skipping duplicate recording', {\r\n        positionId: this.currentPosition.id,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Mark as CLOSED BEFORE any operations to prevent race conditions\r\n    this.currentPosition.status = 'CLOSED';\r\n\r\n    const holdingTimeMs = Date.now() - this.currentPosition.openedAt;\r\n    const holdingTimeMinutes = holdingTimeMs / TIME_UNITS.MINUTE;\r\n\r\n    // Calculate total PnL using TakeProfitManager\r\n    let realizedPnL: number;\r\n    let pnlGross: number;\r\n    let tradingFees: number;\r\n    let partialCloses: PartialClose[] = [];\r\n\r\n    if (this.takeProfitManager) {\r\n      // Calculate final PnL including all partial closes + remaining quantity\r\n      const finalPnL = this.takeProfitManager.calculateFinalPnL(exitPrice);\r\n      realizedPnL = finalPnL.totalPnL.pnlNet;\r\n      pnlGross = finalPnL.totalPnL.pnlGross;\r\n      tradingFees = finalPnL.totalPnL.fees;\r\n      partialCloses = this.takeProfitManager.getPartialCloses();\r\n\r\n      this.logger.info('ðŸ“Š Final PnL calculated', {\r\n        positionId: this.currentPosition.id,\r\n        partialClosesCount: partialCloses.length,\r\n        partialPnL: finalPnL.partialPnL.pnlNet.toFixed(DECIMAL_PLACES.PRICE),\r\n        remainingPnL: finalPnL.remainingPnL.pnlNet.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalPnL: realizedPnL.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalFees: tradingFees.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n    } else {\r\n      // Fallback: Calculate PnL the old way (no partial closes)\r\n      const priceDiff = exitPrice - this.currentPosition.entryPrice;\r\n      const isLong = this.currentPosition.side === PositionSide.LONG;\r\n      const pnlMultiplier = isLong ? 1 : -1;\r\n\r\n      pnlGross = priceDiff * this.currentPosition.quantity * pnlMultiplier * this.tradingConfig.leverage;\r\n\r\n      const entryValue = this.currentPosition.entryPrice * this.currentPosition.quantity;\r\n      const exitValue = exitPrice * this.currentPosition.quantity;\r\n      tradingFees = (entryValue + exitValue) * 0.00055;\r\n\r\n      realizedPnL = pnlGross - tradingFees;\r\n    }\r\n\r\n    const priceDiff = exitPrice - this.currentPosition.entryPrice;\r\n    const isLong = this.currentPosition.side === PositionSide.LONG;\r\n    const pnlMultiplier = isLong ? 1 : -1;\r\n    const pnlPercent = (priceDiff / this.currentPosition.entryPrice) * PERCENT_MULTIPLIER * pnlMultiplier;\r\n\r\n    try {\r\n      // Skip journal recording if position was restored without journalId\r\n      if (!this.currentPosition.journalId) {\r\n        this.logger.warn('âš ï¸ Skipping journal recording - position has no journalId', {\r\n          positionId: this.currentPosition.id,\r\n          exitType,\r\n        });\r\n        return;\r\n      }\r\n\r\n      this.journal.recordTradeClose({\r\n        id: this.currentPosition.journalId,\r\n        exitPrice,\r\n        realizedPnL,\r\n        exitCondition: {\r\n          exitType,\r\n          price: exitPrice,\r\n          timestamp: Date.now(),\r\n          reason: exitReason,\r\n          pnlUsdt: realizedPnL,\r\n          pnlPercent,\r\n          realizedPnL,\r\n          tpLevelsHit,\r\n          tpLevelsHitCount: tpLevelsHit.length,\r\n          partialCloses: partialCloses.length > 0 ? partialCloses : undefined,\r\n          pnlGross,\r\n          tradingFees,\r\n          holdingTimeMs,\r\n          holdingTimeMinutes,\r\n          holdingTimeHours: holdingTimeMinutes / 60,\r\n          stoppedOut: exitType === 'STOP_LOSS',\r\n          slMovedToBreakeven: this.currentPosition.stopLoss.isBreakeven,\r\n          trailingStopActivated: this.currentPosition.stopLoss.isTrailing,\r\n          maxProfitPercent: pnlPercent > 0 ? pnlPercent : 0,\r\n          maxDrawdownPercent: pnlPercent < 0 ? Math.abs(pnlPercent) : 0,\r\n        },\r\n      });\r\n\r\n      this.logger.info('ðŸ“ Position close recorded in journal', {\r\n        positionId: this.currentPosition.id,\r\n        exitType,\r\n        pnl: realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      // Update session stats (if available)\r\n      if (this.sessionStats && this.currentPosition.journalId) {\r\n        this.sessionStats.updateTradeExit(this.currentPosition.journalId, {\r\n          exitPrice,\r\n          pnl: realizedPnL,\r\n          pnlPercent,\r\n          exitType,\r\n          tpHitLevels: tpLevelsHit,\r\n          holdingTimeMs,\r\n          stopLoss: {\r\n            initial: this.currentPosition.stopLoss.initialPrice || this.currentPosition.stopLoss.price,\r\n            final: this.currentPosition.stopLoss.price,\r\n            movedToBreakeven: this.currentPosition.stopLoss.isBreakeven,\r\n            trailingActivated: this.currentPosition.stopLoss.isTrailing,\r\n          },\r\n        });\r\n        this.logger.debug('ðŸ“Š Trade exit updated in session stats', { tradeId: this.currentPosition.journalId });\r\n      }\r\n\r\n      // Phase 3: Reset AdaptiveTP3 state\r\n      if (this.adaptiveTP3Service) {\r\n        this.adaptiveTP3Service.reset(this.currentPosition.id);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to record position close', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update trailing stop based on Bollinger Bands (BB.MD Section 3.3)\r\n   *\r\n   * Formula: newStop = bb.lower - (atr Ã— multiplier)\r\n   * IMPORTANT: Only moves stop UP (LONG) or DOWN (SHORT) to protect profit\r\n   *\r\n   * @param bollingerBands - Current Bollinger Bands data\r\n   * @param atr - Current ATR value (absolute, not percent)\r\n   * @param currentPrice - Current market price\r\n   */\r\n  async updateBBTrailingStop(\r\n    bollingerBands: { lower: number; middle: number; upper: number },\r\n    atr: number,\r\n    currentPrice: number,\r\n  ): Promise<void> {\r\n    // Check if we have an open position\r\n    if (!this.currentPosition) {\r\n      return;\r\n    }\r\n\r\n    // Check if position is already closed (prevent race conditions)\r\n    if (this.currentPosition.status === 'CLOSED') {\r\n      return;\r\n    }\r\n\r\n    // Check if BB trailing stop is enabled\r\n    if (!this.riskConfig.bbTrailingStop?.enabled) {\r\n      return;\r\n    }\r\n\r\n    const config = this.riskConfig.bbTrailingStop;\r\n    const side = this.currentPosition.side;\r\n    const currentStopLoss = this.currentPosition.stopLoss.price;\r\n\r\n    // Calculate new stop based on BB.lower - (atr Ã— multiplier)\r\n    let newStop: number;\r\n    if (side === PositionSide.LONG) {\r\n      newStop = bollingerBands.lower - (atr * config.atrMultiplier);\r\n    } else {\r\n      // For SHORT: use BB.upper + (atr Ã— multiplier)\r\n      newStop = bollingerBands.upper + (atr * config.atrMultiplier);\r\n    }\r\n\r\n    // IMPORTANT: Only move stop in favorable direction\r\n    const shouldUpdate =\r\n      side === PositionSide.LONG\r\n        ? newStop > currentStopLoss // LONG: move SL up only\r\n        : newStop < currentStopLoss; // SHORT: move SL down only\r\n\r\n    if (!shouldUpdate) {\r\n      this.logger.debug('ðŸ”µ BB trailing: New stop not better than current', {\r\n        side,\r\n        currentSL: currentStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        newSL: newStop.toFixed(DECIMAL_PLACES.PRICE),\r\n        bbLower: bollingerBands.lower.toFixed(DECIMAL_PLACES.PRICE),\r\n        atr: atr.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Check minimum move threshold\r\n    const movePercent = Math.abs((newStop - currentStopLoss) / currentStopLoss) * PERCENT_MULTIPLIER;\r\n    if (movePercent < config.minMovePercent) {\r\n      this.logger.debug('ðŸ”µ BB trailing: Move too small', {\r\n        movePercent: movePercent.toFixed(3) + '%',\r\n        minRequired: config.minMovePercent + '%',\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Update stop loss on exchange\r\n    try {\r\n      await this.bybitService.updateStopLoss(newStop);\r\n\r\n      // Update local position\r\n      this.currentPosition.stopLoss.price = newStop;\r\n\r\n      this.logger.info('ðŸŽ¯ BB Trailing Stop Updated', {\r\n        side,\r\n        oldSL: currentStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        newSL: newStop.toFixed(DECIMAL_PLACES.PRICE),\r\n        movePercent: movePercent.toFixed(3) + '%',\r\n        currentPrice: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        bbLower: bollingerBands.lower.toFixed(DECIMAL_PLACES.PRICE),\r\n        atr: atr.toFixed(DECIMAL_PLACES.PRICE),\r\n        multiplier: config.atrMultiplier,\r\n      });\r\n\r\n      // Send Telegram notification\r\n      await this.telegram.sendAlert(\r\n        'ðŸŽ¯ BB Trailing Stop Updated\\n' +\r\n        `Side: ${side}\\n` +\r\n        `Old SL: ${currentStopLoss.toFixed(DECIMAL_PLACES.PRICE)}\\n` +\r\n        `New SL: ${newStop.toFixed(DECIMAL_PLACES.PRICE)}\\n` +\r\n        `Move: +${movePercent.toFixed(DECIMAL_PLACES.PERCENT)}%\\n` +\r\n        `Current: ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      );\r\n    } catch (error) {\r\n      this.logger.error('Failed to update BB trailing stop', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate breakeven price with offset\r\n   */\r\n  private calculateBreakevenPrice(\r\n    entryPrice: number,\r\n    side: PositionSide,\r\n    offsetPercent: number,\r\n  ): number {\r\n    const offset = (offsetPercent / PERCENT_TO_DECIMAL) * entryPrice;\r\n\r\n    if (side === PositionSide.LONG) {\r\n      return entryPrice + offset;\r\n    } else {\r\n      return entryPrice - offset;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate trailing stop price\r\n   */\r\n  private calculateTrailingStopPrice(\r\n    currentPrice: number,\r\n    side: PositionSide,\r\n    trailingPercent: number,\r\n  ): number {\r\n    const offset = (trailingPercent / PERCENT_TO_DECIMAL) * currentPrice;\r\n\r\n    if (side === PositionSide.LONG) {\r\n      return currentPrice - offset;\r\n    } else {\r\n      return currentPrice + offset;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sleep helper for async delays\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\position-monitor.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30000.","line":68,"column":8,"nodeType":"Literal","messageId":"noMagic","endLine":68,"endColumn":13},{"ruleId":"complexity","severity":1,"message":"Async method 'monitorPosition' has a complexity of 14. Maximum allowed is 10.","line":111,"column":32,"nodeType":"FunctionExpression","messageId":"complex","endLine":232,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":145,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":145,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4705,4743],"text":"(currentPosition.protectionVerifiedOnce ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[4704,4743],"text":"currentPosition.protectionVerifiedOnce === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":161,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":190,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":273,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":273,"endColumn":66},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.2.","line":274,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":274,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":278,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":278,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":278,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":278,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":284,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":284,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":339,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":339,"endColumn":70},{"ruleId":"complexity","severity":1,"message":"Method 'determineExitTypeFromHistory' has a complexity of 12. Maximum allowed is 10.","line":384,"column":39,"nodeType":"FunctionExpression","messageId":"complex","endLine":440,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":419,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":419,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":422,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":422,"endColumn":24},{"ruleId":"complexity","severity":1,"message":"Async method 'deepSyncCheck' has a complexity of 14. Maximum allowed is 10.","line":479,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":608,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 120000.","line":491,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":491,"endColumn":33},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (382). Maximum allowed is 300.","line":501,"column":1,"nodeType":null,"messageId":"exceed","endLine":610,"endColumn":1},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":577,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":577,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":600,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":600,"endColumn":81}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\n/**\n * Position Monitor Service\n * Monitors open positions for TP/SL hits via WebSocket events\n *\n * Responsibilities:\n * 1. Listen to WebSocket order execution events\n * 2. Detect TP hits and trigger breakeven/trailing logic\n * 3. Periodic sync check with exchange\n *\n * Single Responsibility: Position monitoring and TP/SL event handling\n */\n\nimport { EventEmitter } from 'events';\nimport { BybitService } from './bybit';\nimport { PositionManagerService } from './position-manager.service';\nimport { Position, PositionSide, RiskManagementConfig, LoggerService, ExitType, BybitOrder, isStopLossOrder, isTakeProfitOrder } from '../types';\nimport { TelegramService } from './telegram.service';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nconst MONITOR_INTERVAL_MS = 10000; // Check every 10 seconds\nconst POSITION_SIZE_ZERO = 0;\n\n// ============================================================================\n// POSITION MONITOR SERVICE\n// ============================================================================\n\nexport class PositionMonitorService extends EventEmitter {\n  private monitorInterval: NodeJS.Timeout | null = null;\n  private deepSyncInterval: NodeJS.Timeout | null = null;\n  private isMonitoring: boolean = false;\n\n  constructor(\n    private readonly bybitService: BybitService,\n    private readonly positionManager: PositionManagerService,\n    private readonly riskConfig: RiskManagementConfig,\n    private readonly telegram: TelegramService,\n    private readonly logger: LoggerService,\n  ) {\n    super();\n  }\n\n  // ==========================================================================\n  // PUBLIC API\n  // ==========================================================================\n\n  /**\n   * Start monitoring positions\n   */\n  start(): void {\n    if (this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = true;\n\n    // Level 1: Position consistency check (every 10s)\n    this.monitorInterval = setInterval(() => {\n      void this.monitorPosition();\n    }, MONITOR_INTERVAL_MS);\n\n    // Level 2: Deep sync check (every 30s)\n    this.deepSyncInterval = setInterval(() => {\n      void this.deepSyncCheck();\n    }, 30000); // 30 seconds\n\n    this.emit('started');\n  }\n\n  /**\n   * Stop monitoring positions\n   */\n  stop(): void {\n    if (!this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = false;\n\n    if (this.monitorInterval !== null) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n\n    if (this.deepSyncInterval !== null) {\n      clearInterval(this.deepSyncInterval);\n      this.deepSyncInterval = null;\n    }\n\n    this.emit('stopped');\n  }\n\n  /**\n   * Check if monitoring is active\n   */\n  isActive(): boolean {\n    return this.isMonitoring;\n  }\n\n  // ==========================================================================\n  // PRIVATE HELPERS\n  // ==========================================================================\n\n  /**\n   * Monitor position (called periodically)\n   * This is a safety check - main logic is driven by WebSocket events\n   */\n  private async monitorPosition(): Promise<void> {\n    try {\n      // 1. Get current position from memory\n      const currentPosition = this.positionManager.getCurrentPosition();\n\n      if (currentPosition === null) {\n        return;\n      }\n\n      // FIX: Skip monitoring if position already closed (prevents duplicate external close events)\n      if (currentPosition.status === 'CLOSED') {\n        this.logger.debug('Position already closed, skipping monitor check');\n        return;\n      }\n\n      // 2. SAFETY CHECK: Verify position exists on exchange\n      const exchangePosition = await this.bybitService.getPosition();\n\n      if (exchangePosition === null || exchangePosition.quantity === POSITION_SIZE_ZERO) {\n        // Double-check: position might have been closed by WebSocket during async call\n        const pos = this.positionManager.getCurrentPosition();\n        if (pos === null || pos.status === 'CLOSED') {\n          this.logger.debug('Position closed by WebSocket during monitor check, skipping external event');\n          return;\n        }\n\n        // Position closed on exchange but WebSocket event missed - sync state\n        await this.syncClosedPosition(currentPosition);\n        return;\n      }\n\n      // ðŸš¨ CRITICAL: Verify TP/SL protection is active\n      // BUT only check ONCE after position open (not every cycle!)\n      // After first successful verification, we rely on trailing stop or manual management\n      if (!currentPosition.protectionVerifiedOnce) {\n        this.logger.debug('ðŸ” Initial protection verification check...');\n        const protection = await this.bybitService.verifyProtectionSet(currentPosition.side);\n\n        if (!protection.verified) {\n          this.logger.error('ðŸš¨ UNPROTECTED POSITION DETECTED - CLOSING IMMEDIATELY!', {\n            positionId: currentPosition.id,\n            side: currentPosition.side,\n            entryPrice: currentPosition.entryPrice,\n            hasStopLoss: protection.hasStopLoss,\n            hasTakeProfit: protection.hasTakeProfit,\n            hasTrailingStop: protection.hasTrailingStop,\n            activeOrders: protection.activeOrders,\n          });\n\n          // Close position immediately - no emergency protection attempts\n          try {\n            await this.bybitService.closePosition(currentPosition.side, currentPosition.quantity);\n\n            await this.telegram.sendAlert(\n              'ðŸš¨ UNPROTECTED POSITION CLOSED @ market price!\\n' +\n              `Side: ${currentPosition.side}\\n` +\n              `Entry: ${currentPosition.entryPrice}\\n` +\n              'Reason: No SL/TP protection detected',\n            );\n\n            this.emit('positionClosedEmergency', currentPosition);\n            await this.positionManager.clearPosition();\n\n            this.logger.warn('âœ… Unprotected position closed successfully');\n            return; // Exit monitoring - position closed\n          } catch (closeError) {\n            this.logger.error('ðŸš¨ðŸš¨ðŸš¨ CRITICAL: Failed to close unprotected position!', {\n              error: closeError instanceof Error ? closeError.message : String(closeError),\n            });\n\n            await this.telegram.sendAlert(\n              'ðŸš¨ðŸš¨ðŸš¨ CRITICAL ALERT ðŸš¨ðŸš¨ðŸš¨\\n' +\n              `Position ${currentPosition.id} is UNPROTECTED and CANNOT BE CLOSED!\\n` +\n              'MANUAL INTERVENTION REQUIRED IMMEDIATELY!\\n' +\n              `Side: ${currentPosition.side}\\n` +\n              `Entry: ${currentPosition.entryPrice}\\n` +\n              `Quantity: ${currentPosition.quantity}`,\n            );\n            return; // Exit monitoring - manual intervention needed\n          }\n        } else {\n          // Protection verified - set flag to skip future checks\n          currentPosition.protectionVerifiedOnce = true;\n          this.logger.info('âœ… Protection verified - no further checks needed', {\n            positionId: currentPosition.id,\n            hasTrailingStop: protection.hasTrailingStop,\n          });\n        }\n      }\n\n      // 3. Get current price\n      const currentPrice = await this.bybitService.getCurrentPrice();\n\n      // 4. Check if SL hit (safety backup - primary detection via WebSocket)\n      const slHit = this.checkStopLoss(currentPosition, currentPrice);\n      if (slHit) {\n        this.emit('stopLossHit', {\n          position: currentPosition,\n          currentPrice,\n          reason: `Stop Loss hit at ${currentPrice}`,\n        });\n      }\n\n      // 5. TP detection now handled via WebSocket 'order' topic\n      // No more price-based TP checking - WebSocket provides real-time TP fills\n\n      // 6. Check time-based exit (if enabled)\n      const timeBasedExit = this.checkTimeBasedExit(currentPosition, currentPrice);\n      if (timeBasedExit.shouldExit) {\n        this.emit('timeBasedExit', {\n          position: currentPosition,\n          currentPrice,\n          reason: timeBasedExit.reason,\n          openedMinutes: timeBasedExit.openedMinutes,\n          pnlPercent: timeBasedExit.pnlPercent,\n        });\n      }\n\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Check if stop-loss is hit\n   */\n  private checkStopLoss(position: Position, currentPrice: number): boolean {\n    if (position.side === PositionSide.LONG) {\n      return currentPrice <= position.stopLoss.price;\n    } else {\n      return currentPrice >= position.stopLoss.price;\n    }\n  }\n\n  // REMOVED: checkTakeProfits() - TP detection now handled via WebSocket 'order' topic\n  // Price-based TP checking was unreliable (missed TPs when price retraced before next check)\n  // Real-time TP fills now detected through WebSocket events\n\n  /**\n   * Check time-based exit conditions\n   * Exit if position is open for too long without significant profit\n   *\n   * @param position - Current position\n   * @param currentPrice - Current market price\n   * @returns Exit decision with reason\n   */\n  private checkTimeBasedExit(\n    position: Position,\n    currentPrice: number,\n  ): {\n    shouldExit: boolean;\n    reason?: string;\n    openedMinutes?: number;\n    pnlPercent?: number;\n  } {\n    // Check if time-based exit is enabled\n    const enabled = this.riskConfig.timeBasedExitEnabled ?? false;\n    if (!enabled) {\n      return { shouldExit: false };\n    }\n\n    // Get config (with defaults)\n    const maxMinutes = this.riskConfig.timeBasedExitMinutes ?? 30;\n    const minPnlPercent = this.riskConfig.timeBasedExitMinPnl ?? 0.2;\n\n    // Calculate how long position has been open (in minutes)\n    const openedMs = Date.now() - position.openedAt;\n    const openedMinutes = openedMs / 1000 / 60;\n\n    // Calculate current PnL %\n    const pnlPercent = this.calculatePnL(position, currentPrice);\n\n    // Log current state (debug)\n    if (openedMinutes > maxMinutes / 2) {\n      // Log when position is open for more than half the max time\n      this.logger.debug('Time-based exit check', {\n        openedMinutes: openedMinutes.toFixed(1),\n        maxMinutes,\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT),\n        minPnlPercent,\n      });\n    }\n\n    // Check if should exit\n    if (openedMinutes > maxMinutes && pnlPercent < minPnlPercent) {\n      return {\n        shouldExit: true,\n        reason: `Position open for ${openedMinutes.toFixed(0)} min with low PnL (${pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)`,\n        openedMinutes,\n        pnlPercent,\n      };\n    }\n\n    return { shouldExit: false };\n  }\n\n  /**\n   * Calculate current PnL percentage\n   *\n   * @param position - Current position\n   * @param currentPrice - Current market price\n   * @returns PnL in percentage\n   */\n  private calculatePnL(position: Position, currentPrice: number): number {\n    if (position.side === PositionSide.LONG) {\n      return ((currentPrice - position.entryPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\n    } else {\n      return ((position.entryPrice - currentPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\n    }\n  }\n\n  // ==========================================================================\n  // SAFETY MONITOR: SYNC WITH EXCHANGE\n  // ==========================================================================\n\n  /**\n   * Sync closed position state when WebSocket event was missed\n   * Queries order history to determine correct exitType\n   */\n  private async syncClosedPosition(position: Position): Promise<void> {\n    this.logger.warn('âš ï¸ Position closed on exchange but WebSocket event missed', {\n      positionId: position.id,\n      entryPrice: position.entryPrice,\n      side: position.side,\n    });\n\n    try {\n      // Get order history to determine exitType\n      const orderHistory = await this.bybitService.getOrderHistory(20);\n      const exitType = this.determineExitTypeFromHistory(orderHistory, position);\n\n      // Get current price for PnL calculation\n      const currentPrice = await this.bybitService.getCurrentPrice();\n\n      // Record close with correct exitType (NOT MANUAL unless truly manual)\n      this.positionManager.recordPositionClose(\n        currentPrice,\n        `Position closed on exchange (WebSocket event missed) - ${exitType}`,\n        exitType,\n        [], // TP levels unknown when syncing\n      );\n\n      // Send alert\n      await this.telegram.sendAlert(\n        'âš ï¸ SYNC: Position closed on exchange\\n' +\n        `Exit Type: ${exitType}\\n` +\n        `Entry: ${position.entryPrice}\\n` +\n        `Exit: ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)}\\n` +\n        'Reason: WebSocket event missed',\n      );\n\n      // Clear position\n      await this.positionManager.clearPosition();\n\n      this.logger.info('âœ… Position state synced with exchange', {\n        positionId: position.id,\n        exitType,\n      });\n    } catch (error) {\n      this.logger.error('Failed to sync closed position', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      // Fallback: emit external close event\n      this.emit('positionClosedExternally', position);\n      await this.positionManager.clearPosition();\n    }\n  }\n\n  /**\n   * Determine exitType from order history\n   * Analyzes filled orders to understand how position was closed\n   */\n  private determineExitTypeFromHistory(orderHistory: BybitOrder[], position: Position): ExitType {\n    // Find filled orders for this symbol\n    const filledOrders = orderHistory\n      .filter((o) => o.symbol === position.symbol && o.orderStatus === 'Filled')\n      .sort((a, b) => {\n        const aTime = (a as Record<string, unknown>).updatedTime as number;\n        const bTime = (b as Record<string, unknown>).updatedTime as number;\n        return bTime - aTime;\n      }); // Most recent first\n\n    if (filledOrders.length === 0) {\n      this.logger.warn('No filled orders found in history, assuming MANUAL close');\n      return ExitType.MANUAL;\n    }\n\n    // Check last filled order\n    const lastOrder = filledOrders[0];\n\n    // Stop Loss: triggerPrice exists + reduceOnly + side matches close direction\n    if (lastOrder.stopOrderType === 'Stop' || lastOrder.stopOrderType === 'StopLoss') {\n      return ExitType.STOP_LOSS;\n    }\n\n    // Trailing Stop\n    if (lastOrder.stopOrderType === 'TrailingStop') {\n      return ExitType.TRAILING_STOP;\n    }\n\n    // Take Profit: Limit order + reduceOnly\n    if (lastOrder.orderType === 'Limit' && lastOrder.reduceOnly === true) {\n      // Try to determine TP level from price\n      const tpLevel = this.identifyTPLevel(parseFloat(lastOrder.price), position);\n      if (tpLevel === 1) {\n        return ExitType.TAKE_PROFIT_1;\n      }\n      if (tpLevel === 2) {\n        return ExitType.TAKE_PROFIT_2;\n      }\n      if (tpLevel === 3) {\n        return ExitType.TAKE_PROFIT_3;\n      }\n      return ExitType.TAKE_PROFIT_1; // Fallback\n    }\n\n    // Market order + reduceOnly = likely manual close\n    if (lastOrder.orderType === 'Market' && lastOrder.reduceOnly === true) {\n      return ExitType.MANUAL;\n    }\n\n    this.logger.warn('Could not determine exitType from order history', {\n      lastOrderType: lastOrder.orderType,\n      stopOrderType: lastOrder.stopOrderType,\n      reduceOnly: lastOrder.reduceOnly,\n    });\n\n    return ExitType.MANUAL; // Fallback\n  }\n\n  /**\n   * Identify TP level from price\n   * Returns 1, 2, or 3 based on which TP level price is closest to\n   */\n  private identifyTPLevel(price: number, position: Position): number {\n    const tpLevels = position.takeProfits;\n\n    if (tpLevels.length === 0) {\n      return 1; // Default\n    }\n\n    // Find closest TP level\n    let closestLevel = 1;\n    let closestDistance = Math.abs(price - tpLevels[0].price);\n\n    for (let i = 1; i < tpLevels.length; i++) {\n      const distance = Math.abs(price - tpLevels[i].price);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestLevel = i + 1;\n      }\n    }\n\n    return closestLevel;\n  }\n\n  // ==========================================================================\n  // DEEP SYNC CHECK (Level 2 Safety)\n  // ==========================================================================\n\n  /**\n   * Deep sync check - runs every 30s for positions > 2 minutes old\n   * Verifies:\n   * 1. TP/SL orders still active on exchange\n   * 2. Stop Loss not missing (emergency close if missing)\n   * 3. Position quantity matches exchange\n   */\n  private async deepSyncCheck(): Promise<void> {\n    try {\n      const position = this.positionManager.getCurrentPosition();\n\n      // No position or already closed\n      if (position === null || position.status === 'CLOSED') {\n        return;\n      }\n\n      const positionAgeMs = Date.now() - position.openedAt;\n\n      // Only run deep check if position > 2 minutes old\n      if (positionAgeMs < 120000) {\n        return;\n      }\n\n      this.logger.debug('ðŸ” Running deep sync check', {\n        positionId: position.id,\n        ageMinutes: Math.floor(positionAgeMs / TIME_UNITS.MINUTE),\n      });\n\n      // 1. Verify position still exists on exchange\n      const exchangePos = await this.bybitService.getPosition();\n\n      if (exchangePos === null || exchangePos.quantity === POSITION_SIZE_ZERO) {\n        // Position closed on exchange - already handled by syncClosedPosition\n        this.logger.debug('Deep sync: Position closed on exchange (will be handled by monitor)');\n        return;\n      }\n\n      // 2. Verify TP/SL orders still active\n      const activeOrders = await this.bybitService.getActiveOrders();\n\n      // Check for Stop Loss order\n      const hasStopLoss = activeOrders.some((order: BybitOrder) => {\n        const isSL = isStopLossOrder(order);\n\n        const correctSide = position.side === PositionSide.LONG\n          ? order.side === 'Sell'\n          : order.side === 'Buy';\n\n        return isSL && correctSide;\n      });\n\n      // Check for Take Profit orders\n      const hasTakeProfit = activeOrders.some((order: BybitOrder) => {\n        const isTP = isTakeProfitOrder(order);\n\n        const correctSide = position.side === PositionSide.LONG\n          ? order.side === 'Sell'\n          : order.side === 'Buy';\n\n        return isTP && correctSide;\n      });\n\n      // Check for Trailing Stop via position info\n      let hasTrailingStop = false;\n      if (position.stopLoss.isTrailing) {\n        hasTrailingStop = true;\n        this.logger.debug('Deep sync: Trailing stop active (position flag set)');\n      }\n\n      // ðŸš¨ CRITICAL: Stop Loss missing!\n      if (!hasStopLoss && !hasTrailingStop) {\n        this.logger.error('ðŸš¨ CRITICAL: Stop Loss order missing!', {\n          positionId: position.id,\n          hasTrailing: hasTrailingStop,\n          activeOrders: activeOrders.length,\n        });\n\n        await this.telegram.sendAlert(\n          'ðŸš¨ CRITICAL: Stop Loss missing!\\n' +\n          `Position: ${position.id}\\n` +\n          `Side: ${position.side}\\n` +\n          `Entry: ${position.entryPrice}\\n` +\n          `Age: ${Math.floor(positionAgeMs / TIME_UNITS.MINUTE)} minutes\\n` +\n          'Action: Closing position immediately',\n        );\n\n        // Emergency close\n        try {\n          await this.bybitService.closePosition(position.side, position.quantity);\n          this.logger.warn('âœ… Unprotected position closed successfully (deep sync)');\n        } catch (closeError) {\n          this.logger.error('ðŸš¨ðŸš¨ðŸš¨ CRITICAL: Failed to close unprotected position!', {\n            error: closeError instanceof Error ? closeError.message : String(closeError),\n          });\n\n          await this.telegram.sendAlert(\n            'ðŸš¨ðŸš¨ðŸš¨ CRITICAL ALERT ðŸš¨ðŸš¨ðŸš¨\\n' +\n            `Position ${position.id} is UNPROTECTED and CANNOT BE CLOSED!\\n` +\n            'MANUAL INTERVENTION REQUIRED IMMEDIATELY!',\n          );\n        }\n        return;\n      }\n\n      // 3. Sync position quantity mismatch\n      if (Math.abs(exchangePos.quantity - position.quantity) > 0.01) {\n        this.logger.warn('Position quantity mismatch - syncing', {\n          local: position.quantity,\n          exchange: exchangePos.quantity,\n          difference: Math.abs(exchangePos.quantity - position.quantity),\n        });\n\n        // Update local position quantity\n        this.positionManager.syncWithWebSocket(exchangePos);\n\n        await this.telegram.sendAlert(\n          'âš ï¸ Position quantity synced\\n' +\n          `Position: ${position.id}\\n` +\n          `Local: ${position.quantity}\\n` +\n          `Exchange: ${exchangePos.quantity}\\n` +\n          'Updated to match exchange',\n        );\n      }\n\n      this.logger.debug('âœ… Deep sync check passed', {\n        hasStopLoss,\n        hasTakeProfit,\n        hasTrailingStop,\n        quantityMatch: Math.abs(exchangePos.quantity - position.quantity) < 0.01,\n      });\n\n    } catch (error) {\n      this.logger.error('Deep sync check failed', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\public-websocket.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'role' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":156,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":21},{"ruleId":"complexity","severity":1,"message":"Method 'handleMessage' has a complexity of 14. Maximum allowed is 10.","line":186,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":228,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":208,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":208,"endColumn":46,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6501,6536],"text":"((message.topic?.startsWith('kline.')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6501,6536],"text":"((message.topic?.startsWith('kline.')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":213,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":213,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6723,6762],"text":"((message.topic?.startsWith('orderbook.')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6723,6762],"text":"((message.topic?.startsWith('orderbook.')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":218,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":218,"endColumn":52,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6967,7008],"text":"((message.topic?.startsWith('publicTrade.')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6967,7008],"text":"((message.topic?.startsWith('publicTrade.')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":224,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":224,"endColumn":36},{"ruleId":"complexity","severity":1,"message":"Method 'handleKlineUpdate' has a complexity of 12. Maximum allowed is 10.","line":233,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":273,"endColumn":4},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":257,"column":16,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":257,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Method 'handleOrderbookUpdate' has a complexity of 13. Maximum allowed is 10.","line":279,"column":32,"nodeType":"FunctionExpression","messageId":"complex","endLine":332,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":283,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":283,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9065,9081],"text":"(orderbookData.b == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":283,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":283,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9085,9101],"text":"(orderbookData.a == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":285,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":285,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9187,9203],"text":"(orderbookData.b == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":286,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":286,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9223,9239],"text":"(orderbookData.a == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":287,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":287,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":299,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":299,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[9669,9696],"text":"(this.lastIncompleteWarning === 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[9669,9696],"text":"(Number.isNaN(this.lastIncompleteWarning))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9669,9696],"text":"(!Boolean(this.lastIncompleteWarning))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 40.","line":300,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":300,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 40.","line":301,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":301,"endColumn":38},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":344,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":344,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11033,11045],"text":"(tradeData.T == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11034,11045],"text":"(tradeData.T ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11033,11045],"text":"(!Boolean(tradeData.T))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":344,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":344,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":344,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":344,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11065,11077],"text":"(tradeData.v == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11066,11077],"text":"(tradeData.v ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11065,11077],"text":"(!Boolean(tradeData.v))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":344,"column":62,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":344,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11081,11093],"text":"(tradeData.p == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11082,11093],"text":"(tradeData.p ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11081,11093],"text":"(!Boolean(tradeData.p))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":346,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":346,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11183,11195],"text":"(tradeData.T == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11184,11195],"text":"(tradeData.T ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11183,11195],"text":"(!Boolean(tradeData.T))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":347,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":347,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":348,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":348,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11259,11271],"text":"(tradeData.v == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11260,11271],"text":"(tradeData.v ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11259,11271],"text":"(!Boolean(tradeData.v))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":349,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":349,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11297,11309],"text":"(tradeData.p == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11298,11309],"text":"(tradeData.p ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11297,11309],"text":"(!Boolean(tradeData.p))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Public WebSocket Service\r\n * Subscribes to public market data (kline/candles)\r\n *\r\n * Responsibilities:\r\n * 1. Connect to Bybit Public WebSocket V5\r\n * 2. Subscribe to kline (candle) updates\r\n * 3. Emit events when new candle closes\r\n * 4. Handle reconnection and errors\r\n *\r\n * Single Responsibility: Public market data streaming\r\n */\r\n\r\nimport WebSocket from 'ws';\r\nimport { EventEmitter } from 'events';\r\nimport { Candle, ExchangeConfig, TimeframeRole, LoggerService, KlineData, OrderbookData, TradeData } from '../types';\r\nimport { TimeframeProvider } from '../providers/timeframe.provider';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\n// NOTE: Public WebSocket uses the same URL for both demo and live accounts\r\n// Only Private WebSocket has separate demo endpoint\r\nconst WS_PUBLIC_URL = 'wss://stream.bybit.com/v5/public/linear';\r\nconst PING_INTERVAL_MS = 20000;\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst MAX_RECONNECT_ATTEMPTS = 10;\r\n\r\n// ============================================================================\r\n// PUBLIC WEBSOCKET SERVICE\r\n// ============================================================================\r\n\r\nexport class PublicWebSocketService extends EventEmitter {\r\n  private ws: WebSocket | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts: number = 0;\r\n  private isConnecting: boolean = false;\r\n  private shouldReconnect: boolean = true;\r\n  private subscribedTopics: Set<string> = new Set();\r\n  private lastIncompleteWarning: number = 0; // Timestamp of last incomplete orderbook warning\r\n\r\n  constructor(\r\n    private readonly config: ExchangeConfig,\r\n    private readonly symbol: string,\r\n    private readonly timeframeProvider: TimeframeProvider,\r\n    private readonly logger: LoggerService,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Connect to Public WebSocket and subscribe to kline\r\n   */\r\n  connect(): void {\r\n    if (this.isConnecting || (this.ws !== null && this.ws.readyState === WebSocket.OPEN)) {\r\n      return;\r\n    }\r\n\r\n    this.isConnecting = true;\r\n    // Public WebSocket always uses the main URL (same for demo and live)\r\n    const wsUrl = WS_PUBLIC_URL;\r\n\r\n    this.logger.info('Connecting to Public WebSocket', { wsUrl });\r\n    this.ws = new WebSocket(wsUrl);\r\n\r\n    this.ws.on('open', () => {\r\n      this.isConnecting = false;\r\n      this.reconnectAttempts = 0;\r\n      this.logger.info('Public WebSocket connected');\r\n      this.subscribe();\r\n      this.startPing();\r\n      this.emit('connected');\r\n    });\r\n\r\n    this.ws.on('message', (data: WebSocket.Data) => {\r\n      let message: string;\r\n      if (typeof data === 'string') {\r\n        message = data;\r\n      } else if (Buffer.isBuffer(data)) {\r\n        message = data.toString('utf-8');\r\n      } else if (Array.isArray(data)) {\r\n        message = Buffer.concat(data).toString('utf-8');\r\n      } else {\r\n        return;\r\n      }\r\n      this.handleMessage(message);\r\n    });\r\n\r\n    this.ws.on('error', (error: Error) => {\r\n      this.logger.error('Public WebSocket error', { error: error.message });\r\n      this.emit('error', error);\r\n    });\r\n\r\n    this.ws.on('close', () => {\r\n      this.isConnecting = false;\r\n      this.stopPing();\r\n      this.logger.warn('Public WebSocket disconnected');\r\n      this.emit('disconnected');\r\n\r\n      if (this.shouldReconnect && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n        this.reconnectAttempts++;\r\n        this.logger.info('Reconnecting to Public WebSocket', {\r\n          attempt: this.reconnectAttempts,\r\n          maxAttempts: MAX_RECONNECT_ATTEMPTS,\r\n        });\r\n        setTimeout(() => {\r\n          this.connect();\r\n        }, RECONNECT_DELAY_MS);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Disconnect from Public WebSocket\r\n   */\r\n  disconnect(): void {\r\n    this.shouldReconnect = false;\r\n    this.stopPing();\r\n\r\n    if (this.ws !== null) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n\r\n    this.logger.info('Public WebSocket disconnected');\r\n  }\r\n\r\n  /**\r\n   * Check if WebSocket is connected\r\n   */\r\n  isConnected(): boolean {\r\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Subscribe to kline topics for all enabled timeframes and orderbook\r\n   */\r\n  private subscribe(): void {\r\n    if (this.ws === null || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n    const topics: string[] = [];\r\n\r\n    // Subscribe to kline (candles)\r\n    for (const [role, config] of timeframes) {\r\n      // Topic: kline.{interval}.{symbol}\r\n      // Example: kline.5.BTCUSDT\r\n      const topic = `kline.${config.interval}.${this.symbol}`;\r\n      topics.push(topic);\r\n      this.subscribedTopics.add(topic);\r\n    }\r\n\r\n    // Subscribe to orderbook (depth 50 for whale detection)\r\n    const orderbookTopic = `orderbook.50.${this.symbol}`;\r\n    topics.push(orderbookTopic);\r\n    this.subscribedTopics.add(orderbookTopic);\r\n\r\n    // Subscribe to public trades (for Delta Analysis)\r\n    const tradeTopic = `publicTrade.${this.symbol}`;\r\n    topics.push(tradeTopic);\r\n    this.subscribedTopics.add(tradeTopic);\r\n\r\n    const subscribeMessage = {\r\n      op: 'subscribe',\r\n      args: topics,\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeMessage));\r\n    this.logger.info('Subscribed to timeframes, orderbook, and public trades', { topics });\r\n  }\r\n\r\n  /**\r\n   * Handle incoming WebSocket message\r\n   */\r\n  private handleMessage(data: string): void {\r\n    try {\r\n      const message = JSON.parse(data) as {\r\n        success?: boolean;\r\n        op?: string;\r\n        topic?: string;\r\n        type?: string;\r\n        data?: unknown;\r\n      };\r\n\r\n      // Handle subscription confirmation\r\n      if (message.op === 'subscribe' && message.success === true) {\r\n        this.logger.debug('Subscription confirmed');\r\n        return;\r\n      }\r\n\r\n      // Handle pong\r\n      if (message.op === 'pong') {\r\n        return;\r\n      }\r\n\r\n      // Handle kline data\r\n      if (message.topic?.startsWith('kline.') && message.data !== undefined && message.data !== null) {\r\n        this.handleKlineUpdate(message.data as KlineData | KlineData[]);\r\n      }\r\n\r\n      // Handle orderbook data\r\n      if (message.topic?.startsWith('orderbook.') && message.data !== undefined && message.data !== null) {\r\n        this.handleOrderbookUpdate(message.data as OrderbookData);\r\n      }\r\n\r\n      // Handle public trade data (for Delta Analysis)\r\n      if (message.topic?.startsWith('publicTrade.') && message.data !== undefined && message.data !== null) {\r\n        this.handleTradeUpdate(message.data as TradeData | TradeData[]);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse Public WebSocket message', {\r\n        error: String(error),\r\n        data: data.substring(0, 200),\r\n      });\r\n      this.emit('error', new Error(`Failed to parse message: ${String(error)}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle kline update from WebSocket\r\n   */\r\n  private handleKlineUpdate(data: KlineData | KlineData[]): void {\r\n    const klines = Array.isArray(data) ? data : [data];\r\n\r\n    for (const kline of klines) {\r\n      const klineData = kline;\r\n\r\n      // Only emit on closed candles (confirm = true)\r\n      if (klineData.confirm !== true) {\r\n        continue;\r\n      }\r\n\r\n      const candle: Candle = {\r\n        timestamp: parseInt(klineData.start ?? '0'),\r\n        open: parseFloat(klineData.open ?? '0'),\r\n        high: parseFloat(klineData.high ?? '0'),\r\n        low: parseFloat(klineData.low ?? '0'),\r\n        close: parseFloat(klineData.close ?? '0'),\r\n        volume: parseFloat(klineData.volume ?? '0'),\r\n      };\r\n\r\n      // Determine timeframe role from interval\r\n      const interval = klineData.interval ?? '';\r\n      const role = this.getTimeframeRole(interval);\r\n\r\n      if (role == null) {\r\n        this.logger.warn('Unknown interval received', { interval });\r\n        continue;\r\n      }\r\n\r\n      this.logger.info('ðŸ•¯ï¸ New candle closed', {\r\n        symbol: this.symbol,\r\n        role,\r\n        interval,\r\n        timestamp: new Date(candle.timestamp).toISOString(),\r\n        close: candle.close,\r\n      });\r\n\r\n      // Emit event with role - bot will update cache and potentially trigger trading cycle\r\n      this.emit('candleClosed', { role, candle });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle orderbook update from WebSocket\r\n   * Detects snapshot vs delta and emits raw update for OrderbookManager\r\n   */\r\n  private handleOrderbookUpdate(data: OrderbookData): void {\r\n    try {\r\n      const orderbookData = data;\r\n\r\n      if (!orderbookData.b || !orderbookData.a) {\r\n        this.logger.warn('âš ï¸ Orderbook data missing b or a', {\r\n          hasB: !!orderbookData.b,\r\n          hasA: !!orderbookData.a,\r\n          rawData: JSON.stringify(data).substring(0, 200),\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Detect message type:\r\n      // - \"snapshot\" type field OR\r\n      // - updateId = 1 indicates service restart (treat as snapshot) OR\r\n      // - Large number of levels (>40) on first message = snapshot\r\n      const isSnapshot =\r\n        orderbookData.type === 'snapshot' ||\r\n        orderbookData.u === 1 ||\r\n        (!this.lastIncompleteWarning && // First message\r\n          orderbookData.b.length > 40 &&\r\n          orderbookData.a.length > 40);\r\n\r\n      // Log snapshot detection\r\n      if (isSnapshot) {\r\n        this.logger.info('ðŸ“¸ Orderbook SNAPSHOT detected', {\r\n          bids: orderbookData.b.length,\r\n          asks: orderbookData.a.length,\r\n          updateId: orderbookData.u,\r\n          type: orderbookData.type,\r\n        });\r\n      }\r\n\r\n      // Emit raw orderbook update for OrderbookManager\r\n      this.emit('orderbookUpdate', {\r\n        type: isSnapshot ? 'snapshot' : 'delta',\r\n        symbol: orderbookData.s ?? this.symbol,\r\n        bids: orderbookData.b,\r\n        asks: orderbookData.a,\r\n        updateId: orderbookData.u ?? 0,\r\n        timestamp: Date.now(),\r\n      });\r\n\r\n      // Mark as initialized after first message\r\n      if (isSnapshot) {\r\n        this.lastIncompleteWarning = Date.now();\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to handle orderbook update', {\r\n        error: String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle public trade update from WebSocket (for Delta Analysis)\r\n   */\r\n  private handleTradeUpdate(data: TradeData | TradeData[]): void {\r\n    try {\r\n      const trades = Array.isArray(data) ? data : [data];\r\n\r\n      for (const trade of trades) {\r\n        const tradeData = trade;\r\n\r\n        if (!tradeData.T || !tradeData.S || !tradeData.v || !tradeData.p) {\r\n          this.logger.warn('âš ï¸ Incomplete trade data', {\r\n            hasTimestamp: !!tradeData.T,\r\n            hasSide: !!tradeData.S,\r\n            hasVolume: !!tradeData.v,\r\n            hasPrice: !!tradeData.p,\r\n          });\r\n          continue;\r\n        }\r\n\r\n        // Emit trade event for DeltaAnalyzerService\r\n        this.emit('trade', {\r\n          timestamp: tradeData.T,\r\n          price: parseFloat(tradeData.p),\r\n          quantity: parseFloat(tradeData.v),\r\n          side: tradeData.S === 'Buy' ? 'BUY' : 'SELL',\r\n        });\r\n\r\n        // Commented out: Too spammy (logs every trade tick)\r\n        // this.logger.debug('ðŸ“Š Trade tick received', {\r\n        //   side: tradeData.S,\r\n        //   price: tradeData.p,\r\n        //   quantity: tradeData.v,\r\n        // });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to handle trade update', {\r\n        error: String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get timeframe role from interval string\r\n   */\r\n  private getTimeframeRole(interval: string): TimeframeRole | null {\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role, config] of timeframes) {\r\n      if (config.interval === interval) {\r\n        return role;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Start ping interval to keep connection alive\r\n   */\r\n  private startPing(): void {\r\n    this.stopPing();\r\n\r\n    this.pingInterval = setInterval(() => {\r\n      if (this.ws !== null && this.ws.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ op: 'ping' }));\r\n      }\r\n    }, PING_INTERVAL_MS);\r\n  }\r\n\r\n  /**\r\n   * Stop ping interval\r\n   */\r\n  private stopPing(): void {\r\n    if (this.pingInterval !== null) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\retest-entry.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":37,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":37,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":56,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":137,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":55},{"ruleId":"complexity","severity":1,"message":"Method 'checkRetest' has a complexity of 13. Maximum allowed is 10.","line":146,"column":14,"nodeType":"FunctionExpression","messageId":"complex","endLine":242,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":156,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":156,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5096,5101],"text":"zone == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":164,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'volumeThreshold' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":188,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":201,"column":25,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":201,"endColumn":50,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[6703,6709],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":209,"column":96,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":209,"endColumn":121,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[6991,6997],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":214,"column":29,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":214,"endColumn":54,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7157,7163],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":222,"column":72,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":222,"endColumn":97,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7431,7437],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":263,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":263,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8497,8501],"text":"zone != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Retest Entry Service\r\n *\r\n * Enter on Fibonacci retest after missing initial impulse.\r\n *\r\n * Problem:\r\n * - Signal generated but price already moved (impulse happened before signal)\r\n * - Example: Price breaks resistance at 10:00, bot generates signal at 10:02 when price already +0.5%\r\n *   â†’ Enter late at worse price â†’ Often hit SL immediately\r\n *\r\n * Solution:\r\n * - Detect if impulse already happened (>0.5% move in recent candles)\r\n * - Create Fibonacci retest zone (50-61.8% retracement)\r\n * - Wait for price to return to zone\r\n * - Enter on calm retest (low volume + structure intact)\r\n *\r\n * Benefits:\r\n * - Better entry price (closer to impulse start)\r\n * - +10-15% more trades (captures retests)\r\n * - Higher win rate (structured entries)\r\n */\r\n\r\nimport { RetestConfig, RetestZone, Signal, Candle, LoggerService, SignalDirection } from '../types';\r\n\r\nexport class RetestEntryService {\r\n  private retestZones: Map<string, RetestZone> = new Map();\r\n\r\n  constructor(\r\n    private config: RetestConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('RetestEntryService initialized', {\r\n      enabled: config.enabled,\r\n      minImpulse: `${config.minImpulsePercent}%`,\r\n      fibZone: `${config.retestZoneFibStart}%-${config.retestZoneFibEnd}%`,\r\n      maxWait: `${config.maxRetestWaitMs / 1000}s`,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Detect if impulse already happened\r\n   *\r\n   * Looks back at recent candles (last 5) to check for large price move\r\n   */\r\n  detectImpulse(\r\n    symbol: string,\r\n    currentPrice: number,\r\n    candles: Candle[],\r\n  ): { hasImpulse: boolean; impulseStart: number; impulseEnd: number } {\r\n    if (!this.config.enabled) {\r\n      return { hasImpulse: false, impulseStart: 0, impulseEnd: 0 };\r\n    }\r\n\r\n    // Look back 5 candles for impulse\r\n    const lookback = Math.min(5, candles.length);\r\n    if (lookback === 0) {\r\n      return { hasImpulse: false, impulseStart: 0, impulseEnd: 0 };\r\n    }\r\n\r\n    const recentCandles = candles.slice(-lookback);\r\n    const startPrice = recentCandles[0].open;\r\n    const endPrice = currentPrice;\r\n\r\n    const priceChange = Math.abs((endPrice - startPrice) / startPrice) * PERCENT_MULTIPLIER;\r\n\r\n    const hasImpulse = priceChange >= this.config.minImpulsePercent;\r\n\r\n    if (hasImpulse) {\r\n      this.logger.info('ðŸ“Š Impulse detected!', {\r\n        symbol,\r\n        startPrice: startPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        endPrice: endPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        change: `${priceChange.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n        direction: endPrice > startPrice ? 'UP' : 'DOWN',\r\n        candlesAgo: lookback,\r\n      });\r\n    }\r\n\r\n    return {\r\n      hasImpulse,\r\n      impulseStart: startPrice,\r\n      impulseEnd: endPrice,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Fibonacci retest zone\r\n   *\r\n   * Zone = CONFIDENCE_THRESHOLDS.MODERATE-61.8% retracement of impulse\r\n   */\r\n  createRetestZone(\r\n    symbol: string,\r\n    signal: Signal,\r\n    impulseStart: number,\r\n    impulseEnd: number,\r\n  ): RetestZone {\r\n    const impulseRange = Math.abs(impulseEnd - impulseStart);\r\n\r\n    // Fibonacci levels\r\n    const fibStart = this.config.retestZoneFibStart / PERCENT_MULTIPLIER; // 0.50\r\n    const fibEnd = this.config.retestZoneFibEnd / PERCENT_MULTIPLIER; // 0.618\r\n\r\n    let zoneLow: number;\r\n    let zoneHigh: number;\r\n\r\n    if (signal.direction === SignalDirection.LONG) {\r\n      // LONG: impulse UP, retest DOWN (back to zone)\r\n      zoneLow = impulseEnd - (impulseRange * fibEnd); // 61.8% retrace\r\n      zoneHigh = impulseEnd - (impulseRange * fibStart); // 50% retrace\r\n    } else {\r\n      // SHORT: impulse DOWN, retest UP (back to zone)\r\n      zoneLow = impulseEnd + (impulseRange * fibStart); // 50% retrace\r\n      zoneHigh = impulseEnd + (impulseRange * fibEnd); // 61.8% retrace\r\n    }\r\n\r\n    const zone: RetestZone = {\r\n      symbol,\r\n      direction: signal.direction,\r\n      impulseStart,\r\n      impulseEnd,\r\n      zoneLow,\r\n      zoneHigh,\r\n      createdAt: Date.now(),\r\n      expiresAt: Date.now() + this.config.maxRetestWaitMs,\r\n      originalSignal: signal,\r\n    };\r\n\r\n    this.retestZones.set(symbol, zone);\r\n\r\n    this.logger.info('ðŸŽ¯ Retest zone created', {\r\n      symbol,\r\n      direction: signal.direction,\r\n      impulseRange: `${impulseStart.toFixed(DECIMAL_PLACES.PRICE)} â†’ ${impulseEnd.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      zoneRange: `${zoneLow.toFixed(DECIMAL_PLACES.PRICE)} - ${zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      fibLevels: `${this.config.retestZoneFibStart}% - ${this.config.retestZoneFibEnd}%`,\r\n      expiresIn: `${this.config.maxRetestWaitMs / 1000}s`,\r\n    });\r\n\r\n    return zone;\r\n  }\r\n\r\n  /**\r\n   * Check if price in retest zone and conditions met\r\n   */\r\n  checkRetest(\r\n    symbol: string,\r\n    currentPrice: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    ema20: number,\r\n    seniorTFTrend: 'UP' | 'DOWN' | 'NEUTRAL',\r\n  ): { inZone: boolean; shouldEnter: boolean; reason: string } {\r\n    const zone = this.retestZones.get(symbol);\r\n\r\n    if (!zone) {\r\n      return { inZone: false, shouldEnter: false, reason: 'No retest zone' };\r\n    }\r\n\r\n    // Check expiry\r\n    if (Date.now() > zone.expiresAt) {\r\n      this.logger.debug('Retest zone expired', {\r\n        symbol,\r\n        age: `${(Date.now() - zone.createdAt) / 1000}s`,\r\n      });\r\n      this.retestZones.delete(symbol);\r\n      return { inZone: false, shouldEnter: false, reason: 'Retest zone expired' };\r\n    }\r\n\r\n    // Check if price in zone\r\n    const inZone = currentPrice >= zone.zoneLow && currentPrice <= zone.zoneHigh;\r\n\r\n    if (!inZone) {\r\n      return {\r\n        inZone: false,\r\n        shouldEnter: false,\r\n        reason: `Price ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} outside zone [${zone.zoneLow.toFixed(DECIMAL_PLACES.PRICE)}, ${zone.zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}]`,\r\n      };\r\n    }\r\n\r\n    this.logger.debug('Price in retest zone!', {\r\n      symbol,\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      zone: `${zone.zoneLow.toFixed(DECIMAL_PLACES.PRICE)} - ${zone.zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n    });\r\n\r\n    // Check volume (should be calm, not aggressive)\r\n    const volumeThreshold = avgVolume * this.config.volumeMultiplier;\r\n\r\n    if (currentVolume > avgVolume) {\r\n      return {\r\n        inZone: true,\r\n        shouldEnter: false,\r\n        reason: `Volume too high: ${currentVolume.toFixed(0)} > ${avgVolume.toFixed(0)} (aggressive, not calm retest)`,\r\n      };\r\n    }\r\n\r\n    // Check structure (EMA + senior TF)\r\n    if (this.config.requireStructureIntact) {\r\n      // EMA structure\r\n      const emaIntact = zone.direction === 'LONG'\r\n        ? currentPrice > ema20\r\n        : currentPrice < ema20;\r\n\r\n      if (!emaIntact) {\r\n        return {\r\n          inZone: true,\r\n          shouldEnter: false,\r\n          reason: `EMA structure broken: price ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} ${zone.direction === 'LONG' ? '<' : '>'} EMA ${ema20.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n\r\n      // Senior TF alignment\r\n      const seniorAligned = zone.direction === 'LONG'\r\n        ? seniorTFTrend === 'UP'\r\n        : seniorTFTrend === 'DOWN';\r\n\r\n      if (!seniorAligned) {\r\n        return {\r\n          inZone: true,\r\n          shouldEnter: false,\r\n          reason: `Senior TF not aligned: ${seniorTFTrend} (expected ${zone.direction === 'LONG' ? 'UP' : 'DOWN'})`,\r\n        };\r\n      }\r\n    }\r\n\r\n    this.logger.info('âœ… Retest entry conditions met!', {\r\n      symbol,\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      zone: `${zone.zoneLow.toFixed(DECIMAL_PLACES.PRICE)} - ${zone.zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      volume: currentVolume.toFixed(0),\r\n      volumeRatio: (currentVolume / avgVolume).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n      ema20: ema20.toFixed(DECIMAL_PLACES.PRICE),\r\n      seniorTF: seniorTFTrend,\r\n    });\r\n\r\n    return {\r\n      inZone: true,\r\n      shouldEnter: true,\r\n      reason: 'Calm retest with structure intact',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get retest zone\r\n   */\r\n  getRetestZone(symbol: string): RetestZone | undefined {\r\n    return this.retestZones.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Check if retest zone exists\r\n   */\r\n  hasRetestZone(symbol: string): boolean {\r\n    return this.retestZones.has(symbol);\r\n  }\r\n\r\n  /**\r\n   * Clear retest zone\r\n   */\r\n  clearZone(symbol: string): void {\r\n    const zone = this.retestZones.get(symbol);\r\n    if (zone) {\r\n      this.logger.debug('Retest zone cleared', {\r\n        symbol,\r\n        reason: 'Entry executed or zone invalidated',\r\n      });\r\n    }\r\n    this.retestZones.delete(symbol);\r\n  }\r\n\r\n  /**\r\n   * Get all active retest zones\r\n   */\r\n  getAllZones(): RetestZone[] {\r\n    return Array.from(this.retestZones.values());\r\n  }\r\n\r\n  /**\r\n   * Clean expired zones (call periodically)\r\n   */\r\n  cleanExpiredZones(): void {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n\r\n    for (const [symbol, zone] of this.retestZones.entries()) {\r\n      if (now > zone.expiresAt) {\r\n        this.retestZones.delete(symbol);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      this.logger.debug(`Cleaned ${cleaned} expired retest zones`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): RetestConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\risk-based-sizing.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\session-stats.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SessionEntryCondition' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -5.","line":75,"column":79,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":75,"endColumn":81},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":238,"column":12,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":238,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7117,7178],"text":"(this.database.sessions.find((s) => s.sessionId === sessionId) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":238,"column":74,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":238,"endColumn":76,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7179,7181],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":258,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":258,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7727,7734],"text":"(session != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'calculateSummary' has a complexity of 12. Maximum allowed is 10.","line":268,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":348,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":379,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":379,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":53},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":379,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":380,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":51},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":380,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":380,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":380,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":71},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":380,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":400,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":400,"endColumn":76}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Session Statistics Service\r\n *\r\n * Manages persistent session-based trading statistics for performance analysis.\r\n * Tracks all trades with full entry context (indicators, patterns, levels, context)\r\n * and generates comparative analysis across different configurations.\r\n *\r\n * Version: v3.4.0\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport {\r\n  LoggerService,\r\n  Session,\r\n  SessionDatabase,\r\n  SessionTradeRecord,\r\n  SessionEntryCondition,\r\n  SessionSummary,\r\n  StrategyStats,\r\n  DirectionStats,\r\n  SignalDirection,\r\n  ExitType,\r\n  Config,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_DATA_DIR = './data';\r\nconst SESSION_STATS_FILE = 'session-stats.json';\r\nconst BOT_VERSION = 'v3.4.0';\r\n\r\n// ============================================================================\r\n// SESSION STATS SERVICE\r\n// ============================================================================\r\n\r\nexport class SessionStatsService {\r\n  private readonly logger: LoggerService;\r\n  private readonly dataDir: string;\r\n  private readonly filePath: string;\r\n\r\n  private database: SessionDatabase = { sessions: [] };\r\n  private currentSession: Session | null = null;\r\n\r\n  constructor(logger: LoggerService, dataDir: string = DEFAULT_DATA_DIR) {\r\n    this.logger = logger;\r\n    this.dataDir = dataDir;\r\n    this.filePath = path.join(dataDir, SESSION_STATS_FILE);\r\n\r\n    // Load existing database\r\n    this.load();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // SESSION LIFECYCLE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Start a new trading session\r\n   * @param config - Full bot configuration snapshot\r\n   * @param symbol - Trading symbol (e.g., \"APEXUSDT\")\r\n   * @returns Session ID\r\n   */\r\n  startSession(config: Config, symbol: string): string {\r\n    // Close previous session if exists\r\n    if (this.currentSession !== null) {\r\n      this.logger.warn('Previous session not closed, closing now');\r\n      this.endSession();\r\n    }\r\n\r\n    // Generate session ID\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\r\n    const sessionId = `session_${timestamp}`;\r\n\r\n    // Create new session\r\n    this.currentSession = {\r\n      sessionId,\r\n      startTime: new Date().toISOString(),\r\n      endTime: null,\r\n      version: BOT_VERSION,\r\n      symbol,\r\n      config,\r\n      trades: [],\r\n      summary: this.createEmptySummary(),\r\n    };\r\n\r\n    // Add to database\r\n    this.database.sessions.push(this.currentSession);\r\n\r\n    this.logger.info('ðŸ“Š Trading session started', {\r\n      sessionId,\r\n      symbol,\r\n      version: BOT_VERSION,\r\n    });\r\n\r\n    this.save();\r\n\r\n    return sessionId;\r\n  }\r\n\r\n  /**\r\n   * End current trading session\r\n   */\r\n  endSession(): void {\r\n    if (this.currentSession === null) {\r\n      this.logger.warn('No active session to end');\r\n      return;\r\n    }\r\n\r\n    // Update session end time\r\n    this.currentSession.endTime = new Date().toISOString();\r\n\r\n    // Recalculate summary with all trades\r\n    this.currentSession.summary = this.calculateSummary(this.currentSession.trades);\r\n\r\n    this.logger.info('ðŸ“Š Trading session ended', {\r\n      sessionId: this.currentSession.sessionId,\r\n      totalTrades: this.currentSession.trades.length,\r\n      winRate: this.currentSession.summary.winRate.toFixed(1) + '%',\r\n      totalPnl: this.currentSession.summary.totalPnl.toFixed(DECIMAL_PLACES.PERCENT),\r\n      duration: this.calculateDuration(this.currentSession.startTime, this.currentSession.endTime),\r\n    });\r\n\r\n    this.save();\r\n    this.currentSession = null;\r\n  }\r\n\r\n  /**\r\n   * Get current active session\r\n   */\r\n  getCurrentSession(): Session | null {\r\n    return this.currentSession;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // TRADE RECORDING\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Record trade entry\r\n   * @param trade - Trade record with entry condition\r\n   */\r\n  recordTradeEntry(trade: SessionTradeRecord): void {\r\n    if (this.currentSession === null) {\r\n      this.logger.error('Cannot record trade - no active session');\r\n      return;\r\n    }\r\n\r\n    // Add trade to current session\r\n    this.currentSession.trades.push(trade);\r\n\r\n    this.logger.debug('ðŸ“ Trade entry recorded', {\r\n      sessionId: this.currentSession.sessionId,\r\n      tradeId: trade.tradeId,\r\n      direction: trade.direction,\r\n      strategy: trade.entryCondition.signal.type,\r\n    });\r\n\r\n    // Update summary incrementally\r\n    this.currentSession.summary = this.calculateSummary(this.currentSession.trades);\r\n\r\n    this.save();\r\n  }\r\n\r\n  /**\r\n   * Update trade exit\r\n   * @param tradeId - Trade ID to update\r\n   * @param exitData - Exit data (price, PnL, exitType, etc.)\r\n   */\r\n  updateTradeExit(\r\n    tradeId: string,\r\n    exitData: {\r\n      exitPrice: number;\r\n      pnl: number;\r\n      pnlPercent: number;\r\n      exitType: ExitType;\r\n      tpHitLevels: number[];\r\n      holdingTimeMs: number;\r\n      stopLoss: {\r\n        initial: number;\r\n        final: number;\r\n        movedToBreakeven: boolean;\r\n        trailingActivated: boolean;\r\n      };\r\n    },\r\n  ): void {\r\n    if (this.currentSession === null) {\r\n      this.logger.warn('Cannot update trade - no active session (session may have ended)');\r\n      return;\r\n    }\r\n\r\n    // Find trade by ID\r\n    const trade = this.currentSession.trades.find((t) => t.tradeId === tradeId);\r\n    if (trade === undefined) {\r\n      // GRACEFUL DEGRADATION: Don't error for missing trades (may be restored positions)\r\n      this.logger.warn('Trade not found in session (may be restored position without journalId)', {\r\n        tradeId,\r\n        sessionId: this.currentSession.sessionId,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Update trade exit data\r\n    trade.exitPrice = exitData.exitPrice;\r\n    trade.pnl = exitData.pnl;\r\n    trade.pnlPercent = exitData.pnlPercent;\r\n    trade.exitType = exitData.exitType;\r\n    trade.tpHitLevels = exitData.tpHitLevels;\r\n    trade.holdingTimeMs = exitData.holdingTimeMs;\r\n    trade.stopLoss = exitData.stopLoss;\r\n\r\n    this.logger.debug('ðŸ“ Trade exit updated', {\r\n      sessionId: this.currentSession.sessionId,\r\n      tradeId,\r\n      exitType: exitData.exitType,\r\n      pnl: exitData.pnl.toFixed(DECIMAL_PLACES.PERCENT),\r\n    });\r\n\r\n    // Recalculate summary\r\n    this.currentSession.summary = this.calculateSummary(this.currentSession.trades);\r\n\r\n    this.save();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ANALYSIS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get session by ID\r\n   * @param sessionId - Session ID\r\n   * @returns Session or null if not found\r\n   */\r\n  getSession(sessionId: string): Session | null {\r\n    return this.database.sessions.find((s) => s.sessionId === sessionId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all sessions\r\n   * @returns All sessions sorted by start time (newest first)\r\n   */\r\n  getAllSessions(): Session[] {\r\n    return [...this.database.sessions].sort((a, b) =>\r\n      new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get session summary\r\n   * @param sessionId - Session ID\r\n   * @returns Session summary or null if not found\r\n   */\r\n  getSessionSummary(sessionId: string): SessionSummary | null {\r\n    const session = this.getSession(sessionId);\r\n    return session ? session.summary : null;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // SUMMARY CALCULATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate summary statistics from trades\r\n   */\r\n  private calculateSummary(trades: SessionTradeRecord[]): SessionSummary {\r\n    if (trades.length === 0) {\r\n      return this.createEmptySummary();\r\n    }\r\n\r\n    // Overall statistics\r\n    const wins = trades.filter((t) => t.pnl > 0);\r\n    const losses = trades.filter((t) => t.pnl <= 0);\r\n    const totalPnl = trades.reduce((sum, t) => sum + t.pnl, 0);\r\n    const avgWin = wins.length > 0 ? wins.reduce((sum, t) => sum + t.pnl, 0) / wins.length : 0;\r\n    const avgLoss = losses.length > 0 ? losses.reduce((sum, t) => sum + t.pnl, 0) / losses.length : 0;\r\n    const wlRatio = avgLoss !== 0 ? avgWin / Math.abs(avgLoss) : 0;\r\n\r\n    // Stop-out rate\r\n    const stopOuts = losses.filter((t) => t.exitType === ExitType.STOP_LOSS).length;\r\n    const stopOutRate = losses.length > 0 ? (stopOuts / losses.length) * PERCENT_MULTIPLIER : 0;\r\n\r\n    // Average holding time\r\n    const avgHoldingTimeMs = trades.reduce((sum, t) => sum + t.holdingTimeMs, 0) / trades.length;\r\n\r\n    // By strategy\r\n    const byStrategy: Record<string, StrategyStats> = {};\r\n    for (const trade of trades) {\r\n      const strategyType = trade.entryCondition.signal.type;\r\n      if (byStrategy[strategyType] === undefined) {\r\n        byStrategy[strategyType] = {\r\n          count: 0,\r\n          wins: 0,\r\n          losses: 0,\r\n          winRate: 0,\r\n          totalPnl: 0,\r\n        };\r\n      }\r\n\r\n      byStrategy[strategyType].count++;\r\n      byStrategy[strategyType].totalPnl += trade.pnl;\r\n\r\n      if (trade.pnl > 0) {\r\n        byStrategy[strategyType].wins++;\r\n      } else {\r\n        byStrategy[strategyType].losses++;\r\n      }\r\n    }\r\n\r\n    // Calculate win rates for strategies\r\n    for (const strategyType in byStrategy) {\r\n      const stats = byStrategy[strategyType];\r\n      stats.winRate = (stats.wins / stats.count) * PERCENT_MULTIPLIER;\r\n    }\r\n\r\n    // By direction\r\n    const byDirection: Record<string, DirectionStats> = {};\r\n    for (const direction of [SignalDirection.LONG, SignalDirection.SHORT]) {\r\n      const dirTrades = trades.filter((t) => t.direction === direction);\r\n      const dirWins = dirTrades.filter((t) => t.pnl > 0);\r\n      const dirLosses = dirTrades.filter((t) => t.pnl <= 0);\r\n\r\n      byDirection[direction] = {\r\n        count: dirTrades.length,\r\n        wins: dirWins.length,\r\n        losses: dirLosses.length,\r\n        winRate: dirTrades.length > 0 ? (dirWins.length / dirTrades.length) * PERCENT_MULTIPLIER : 0,\r\n        totalPnl: dirTrades.reduce((sum, t) => sum + t.pnl, 0),\r\n      };\r\n    }\r\n\r\n    return {\r\n      totalTrades: trades.length,\r\n      wins: wins.length,\r\n      losses: losses.length,\r\n      winRate: (wins.length / trades.length) * PERCENT_MULTIPLIER,\r\n      totalPnl,\r\n      avgWin,\r\n      avgLoss,\r\n      wlRatio,\r\n      stopOutRate,\r\n      avgHoldingTimeMs,\r\n      byStrategy,\r\n      byDirection,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create empty summary for new session\r\n   */\r\n  private createEmptySummary(): SessionSummary {\r\n    return {\r\n      totalTrades: 0,\r\n      wins: 0,\r\n      losses: 0,\r\n      winRate: 0,\r\n      totalPnl: 0,\r\n      avgWin: 0,\r\n      avgLoss: 0,\r\n      wlRatio: 0,\r\n      stopOutRate: 0,\r\n      avgHoldingTimeMs: 0,\r\n      byStrategy: {},\r\n      byDirection: {},\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate duration between two timestamps\r\n   */\r\n  private calculateDuration(startTime: string, endTime: string | null): string {\r\n    if (endTime === null) {\r\n      return 'ACTIVE';\r\n    }\r\n\r\n    const durationMs = new Date(endTime).getTime() - new Date(startTime).getTime();\r\n    const hours = Math.floor(durationMs / (1000 * 60 * 60));\r\n    const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));\r\n\r\n    return `${hours}h ${minutes}m`;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PERSISTENCE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Save database to file\r\n   */\r\n  private save(): void {\r\n    try {\r\n      // Ensure data directory exists\r\n      if (!fs.existsSync(this.dataDir)) {\r\n        fs.mkdirSync(this.dataDir, { recursive: true });\r\n      }\r\n\r\n      // Write to file\r\n      fs.writeFileSync(this.filePath, JSON.stringify(this.database, null, 2), 'utf-8');\r\n\r\n      this.logger.debug('Session stats saved', { path: this.filePath });\r\n    } catch (error) {\r\n      this.logger.error('Failed to save session stats', { error: String(error) });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load database from file\r\n   */\r\n  private load(): void {\r\n    try {\r\n      if (!fs.existsSync(this.filePath)) {\r\n        this.logger.info('Session stats file not found, creating new database');\r\n        this.database = { sessions: [] };\r\n        return;\r\n      }\r\n\r\n      const data = fs.readFileSync(this.filePath, 'utf-8');\r\n      this.database = JSON.parse(data) as SessionDatabase;\r\n\r\n      this.logger.info('Session stats loaded', {\r\n        totalSessions: this.database.sessions.length,\r\n        path: this.filePath,\r\n      });\r\n\r\n      // Resume last session if it was not closed\r\n      const lastSession = this.database.sessions[this.database.sessions.length - 1];\r\n      if (lastSession !== undefined && lastSession.endTime === null) {\r\n        this.currentSession = lastSession;\r\n        this.logger.info('Resumed active session', {\r\n          sessionId: lastSession.sessionId,\r\n          startTime: lastSession.startTime,\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to load session stats', { error: String(error) });\r\n      this.database = { sessions: [] };\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\signal-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":45,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":45,"endColumn":34,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1405,1430],"text":"(flatMarketConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1405,1430],"text":"(flatMarketConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":54,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":54,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1735,1767],"text":"(config.adaptiveStopLoss?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1735,1767],"text":"(config.adaptiveStopLoss?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3631,3654],"text":"(this.flatMarketDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":36,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3658,3665],"text":"(candles != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":47,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3669,3676],"text":"(context != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":144,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":144,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4757,4778],"text":"(evaluation.confidence != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4757,4778],"text":"(evaluation.confidence ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4757,4778],"text":"(Boolean(evaluation.confidence))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":144,"column":100,"nodeType":"Literal","messageId":"noMagic","endLine":144,"endColumn":103},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":150,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":150,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5013,5024],"text":"btcAnalysis != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'calculateStopLoss' has a complexity of 17. Maximum allowed is 10.","line":173,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":292,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6363,6391],"text":"(this.adaptiveStopLossService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":42,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6396,6407],"text":"(swingPoints != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":192,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":192,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6396,6425],"text":"(swingPoints ?? liquidityZones)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":57,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6411,6425],"text":"(liquidityZones != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":192,"column":72,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":192,"endColumn":74,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6411,6435],"text":"(liquidityZones ?? levels)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":75,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":81,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6429,6435],"text":"(levels != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":192,"column":82,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":192,"endColumn":84,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6436,6438],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":192,"column":85,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":192,"endColumn":88,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6439,6442],"text":"(atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6439,6442],"text":"(atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6439,6442],"text":"(Boolean(atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":222,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":222,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7324,7338],"text":"(bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":224,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":224,"endColumn":53,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7377,7423],"text":"((this.config.indicators.bollingerBands?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7377,7423],"text":"((this.config.indicators.bollingerBands?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":226,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":226,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.95.","line":239,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":239,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.05.","line":240,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":240,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":264,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":264,"endColumn":44,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[8949,8984],"text":"(this.config.sessionBasedSL?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[8949,8984],"text":"(this.config.sessionBasedSL?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":302,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":302,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10165,10172],"text":"config == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":366,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":366,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12013,12027],"text":"(bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.65.","line":368,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":368,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":369,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":369,"endColumn":53,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12114,12160],"text":"((this.config.indicators.bollingerBands?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12114,12160],"text":"((this.config.indicators.bollingerBands?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":374,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":374,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 65.","line":381,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":381,"endColumn":41},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (321). Maximum allowed is 300.","line":442,"column":1,"nodeType":null,"messageId":"exceed","endLine":468,"endColumn":1}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Signal Calculator Service\r\n *\r\n * Calculates signal prices:\r\n * - Entry price (current market price)\r\n * - Stop Loss (based on risk management config)\r\n * - Take Profits (multiple levels from config)\r\n *\r\n * Pure calculation logic - no external dependencies except config.\r\n * Extracted from SignalGeneratorService for better testability.\r\n */\r\n\r\nimport {\r\n  Signal,\r\n  SignalType,\r\n  SignalDirection,\r\n  Config,\r\n  LoggerService,\r\n  StrategyEvaluation,\r\n  Candle,\r\n  TradingContext,\r\n  FlatMarketConfig,\r\n  SwingPoint,\r\n  BTCAnalysis,\r\n} from '../types';\r\nimport { SessionDetector } from '../utils/session-detector';\r\nimport { FlatMarketDetector } from '../analyzers/flat-market.detector';\r\nimport { AdaptiveStopLossService } from './adaptive-stop-loss.service';\r\n\r\n// ============================================================================\r\n// SIGNAL CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class SignalCalculator {\r\n  private flatMarketDetector?: FlatMarketDetector;\r\n  private adaptiveStopLossService?: AdaptiveStopLossService;\r\n\r\n  constructor(\r\n    private config: Config,\r\n    private logger: LoggerService,\r\n    flatMarketConfig?: FlatMarketConfig,\r\n  ) {\r\n    // Initialize FlatMarketDetector if config provided\r\n    if (flatMarketConfig?.enabled) {\r\n      this.flatMarketDetector = new FlatMarketDetector(flatMarketConfig, logger);\r\n      this.logger.info('âœ… FlatMarketDetector initialized', {\r\n        threshold: flatMarketConfig.flatThreshold,\r\n        factors: 6,\r\n      });\r\n    }\r\n\r\n    // Initialize AdaptiveStopLossService if enabled\r\n    if (config.adaptiveStopLoss?.enabled) {\r\n      this.adaptiveStopLossService = new AdaptiveStopLossService(\r\n        config.adaptiveStopLoss,\r\n        logger,\r\n      );\r\n      this.logger.info('âœ… AdaptiveStopLossService initialized');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create Signal object from strategy evaluation\r\n   *\r\n   * @param evaluation - Strategy evaluation result\r\n   * @param currentPrice - Current market price\r\n   * @param btcAnalysis - Optional BTC analysis data\r\n   * @param marketBias - Market bias (BULLISH/BEARISH/NEUTRAL) for flat detection (legacy)\r\n   * @param candles - Optional candles array for advanced flat detection\r\n   * @param context - Optional trading context for advanced flat detection\r\n   * @param ema20 - Optional EMA20 value for advanced flat detection\r\n   * @param ema50 - Optional EMA50 value for advanced flat detection\r\n   * @param bollingerBands - Optional Bollinger Bands data for dynamic SL/TP\r\n   * @param atr - Optional ATR value for BB-based SL calculation\r\n   * @returns Complete Signal object\r\n   */\r\n  createSignal(\r\n    evaluation: StrategyEvaluation,\r\n    currentPrice: number,\r\n    btcAnalysis?: BTCAnalysis,\r\n    marketBias?: string,\r\n    candles?: Candle[],\r\n    context?: TradingContext,\r\n    ema20?: number,\r\n    ema50?: number,\r\n    bollingerBands?: {\r\n      upper: number;\r\n      middle: number;\r\n      lower: number;\r\n      width: number;\r\n      percentB: number;\r\n      isSqueeze: boolean;\r\n    },\r\n    atr?: number,\r\n  ): Signal {\r\n    const direction = evaluation.direction;\r\n\r\n    // Calculate Stop Loss (with BB support)\r\n    const stopLoss = this.calculateStopLoss(direction, currentPrice, bollingerBands, atr);\r\n\r\n    // Calculate Take Profits\r\n    // In FLAT market: use single TP to capture quick profit\r\n    let isFlat = false;\r\n    let flatConfidence = 0;\r\n\r\n    // Try advanced flat detection if FlatMarketDetector is available\r\n    if (this.flatMarketDetector && candles && context && ema20 !== undefined && ema50 !== undefined) {\r\n      const flatResult = this.flatMarketDetector.detect(candles, context, ema20, ema50);\r\n      isFlat = flatResult.isFlat;\r\n      flatConfidence = flatResult.confidence;\r\n\r\n      this.logger.info(\r\n        isFlat ? 'âš¡ FLAT market detected (multi-factor)' : 'ðŸ“ˆ TRENDING market (multi-factor)',\r\n        {\r\n          confidence: flatConfidence.toFixed(1) + '%',\r\n          isFlat,\r\n          factors: flatResult.explanation,\r\n        },\r\n      );\r\n    } else {\r\n      // Fallback to legacy simple check\r\n      isFlat = marketBias === 'NEUTRAL';\r\n      if (isFlat) {\r\n        this.logger.info('âš¡ FLAT market detected (legacy: marketBias=NEUTRAL)');\r\n      }\r\n    }\r\n\r\n    const takeProfits = this.calculateTakeProfits(\r\n      direction,\r\n      currentPrice,\r\n      isFlat,\r\n      bollingerBands,\r\n      evaluation.confidence,\r\n    );\r\n\r\n    // Create signal\r\n    const signal: Signal = {\r\n      type: SignalType.TREND_FOLLOWING,\r\n      direction,\r\n      price: currentPrice,\r\n      stopLoss,\r\n      takeProfits,\r\n      confidence: evaluation.confidence ? Math.round(evaluation.confidence * PERCENT_MULTIPLIER) : 100,\r\n      reason: evaluation.reason,\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    // Add BTC data if available (entire BTCAnalysis object for complete ML analysis)\r\n    if (btcAnalysis) {\r\n      signal.btcData = btcAnalysis; // Store complete BTCAnalysis object\r\n    }\r\n\r\n    return signal;\r\n  }\r\n\r\n  /**\r\n   * Calculate stop loss price\r\n   *\r\n   * BB.MD DYNAMIC SL:\r\n   * If Bollinger Bands available: SL = bb.lower - (atr Ã— 0.5) for LONG\r\n   *                                SL = bb.upper + (atr Ã— 0.5) for SHORT\r\n   * This places SL beyond volatility band to avoid noise stop-outs.\r\n   *\r\n   * Fallback: fixed percentage from config\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param currentPrice - Current market price\r\n   * @param bollingerBands - Optional BB data for dynamic SL\r\n   * @param atr - Optional ATR value for BB-based SL\r\n   * @returns Stop loss price\r\n   */\r\n  calculateStopLoss(\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n    bollingerBands?: {\r\n      upper: number;\r\n      middle: number;\r\n      lower: number;\r\n      width: number;\r\n      percentB: number;\r\n      isSqueeze: boolean;\r\n    },\r\n    atr?: number,\r\n    swingPoints?: SwingPoint[],\r\n    liquidityZones?: Array<{ price: number; type: 'BUY_SIDE' | 'SELL_SIDE'; timestamp: number }>,\r\n    levels?: Array<{ price: number; strength: number; touches: number }>,\r\n  ): number {\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Priority 1: Adaptive SL (structure-based) - Phase 3\r\n    if (this.adaptiveStopLossService && (swingPoints || liquidityZones || levels || atr)) {\r\n      try {\r\n        const result = this.adaptiveStopLossService.calculateStopLoss(\r\n          currentPrice,\r\n          direction,\r\n          {\r\n            swingPoints,\r\n            liquidityZones,\r\n            supportResistance: levels,\r\n            atr,\r\n          },\r\n          currentPrice,\r\n        );\r\n\r\n        this.logger.info('ðŸŽ¯ Adaptive SL (Phase 3)', {\r\n          type: result.type,\r\n          price: result.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          distance: result.distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n          reason: result.reason,\r\n        });\r\n\r\n        return result.price;\r\n      } catch (error) {\r\n        this.logger.warn('âš ï¸ Adaptive SL failed, using fallback', { error });\r\n        // Fall through to BB or percentage-based SL\r\n      }\r\n    }\r\n\r\n    // Priority 2: BB.MD - BB-based dynamic SL (if available)\r\n    if (\r\n      bollingerBands &&\r\n      atr !== undefined &&\r\n      this.config.indicators.bollingerBands?.enabled\r\n    ) {\r\n      const atrBuffer = atr * 0.5;\r\n      let bbStopLoss: number;\r\n\r\n      if (isLong) {\r\n        // LONG: SL below lower band\r\n        bbStopLoss = bollingerBands.lower - atrBuffer;\r\n      } else {\r\n        // SHORT: SL above upper band\r\n        bbStopLoss = bollingerBands.upper + atrBuffer;\r\n      }\r\n\r\n      // Ensure SL is reasonable (max 5% from entry per BB.MD)\r\n      const maxStopLoss = isLong\r\n        ? currentPrice * 0.95 // LONG: max 5% below entry\r\n        : currentPrice * 1.05; // SHORT: max 5% above entry\r\n\r\n      const finalStopLoss = isLong\r\n        ? Math.max(bbStopLoss, maxStopLoss) // LONG: pick higher (closer to entry)\r\n        : Math.min(bbStopLoss, maxStopLoss); // SHORT: pick lower (closer to entry)\r\n\r\n      this.logger.info('ðŸŽ¯ BB-based Dynamic SL', {\r\n        direction,\r\n        currentPrice,\r\n        bbBand: isLong ? bollingerBands.lower : bollingerBands.upper,\r\n        atrBuffer: atrBuffer.toFixed(DECIMAL_PLACES.PRICE),\r\n        bbStopLoss: bbStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        maxStopLoss: maxStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        finalStopLoss: finalStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        distance: (Math.abs((finalStopLoss - currentPrice) / currentPrice) * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      return finalStopLoss;\r\n    }\r\n\r\n    // Fallback: Percentage-based SL\r\n    let stopLossPercent = this.config.riskManagement.stopLossPercent;\r\n\r\n    // Apply session-based SL widening if enabled\r\n    if (this.config.sessionBasedSL?.enabled) {\r\n      const currentSession = SessionDetector.getCurrentSession();\r\n      const sessionMultiplier = this.getSessionMultiplier(currentSession);\r\n\r\n      if (sessionMultiplier > 1.0) {\r\n        stopLossPercent *= sessionMultiplier;\r\n\r\n        this.logger.debug('ðŸ“ Session-based SL widening applied', {\r\n          session: currentSession,\r\n          multiplier: sessionMultiplier,\r\n          baseSL: this.config.riskManagement.stopLossPercent + '%',\r\n          adjustedSL: stopLossPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        });\r\n      }\r\n    }\r\n\r\n    const stopLoss = isLong\r\n      ? currentPrice * (1 - stopLossPercent / PERCENT_MULTIPLIER)\r\n      : currentPrice * (1 + stopLossPercent / PERCENT_MULTIPLIER);\r\n\r\n    this.logger.debug('Stop Loss calculated (percentage-based)', {\r\n      direction,\r\n      currentPrice,\r\n      stopLossPercent,\r\n      stopLoss,\r\n    });\r\n\r\n    return stopLoss;\r\n  }\r\n\r\n  /**\r\n   * Get session-based SL multiplier\r\n   *\r\n   * @param session - Current trading session\r\n   * @returns SL multiplier for the session\r\n   */\r\n  private getSessionMultiplier(session: string): number {\r\n    const config = this.config.sessionBasedSL;\r\n    if (!config) {\r\n      return 1.0;\r\n    }\r\n\r\n    switch (session) {\r\n    case 'OVERLAP':\r\n      return config.overlapMultiplier;\r\n    case 'LONDON':\r\n      return config.londonMultiplier;\r\n    case 'NY':\r\n      return config.nyMultiplier;\r\n    case 'ASIAN':\r\n      return config.asianMultiplier;\r\n    default:\r\n      return 1.0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate take profit levels\r\n   *\r\n   * BB.MD DYNAMIC TP:\r\n   * If BB available and signal strong:\r\n   *  - Strength >= 80%: Target bb.upper (aggressive)\r\n   *  - Strength >= 65%: Target bb.middle (moderate)\r\n   *  - Strength < 65%: Conservative target (60% to middle)\r\n   *\r\n   * FLAT MARKET OPTIMIZATION:\r\n   * In neutral/flat markets, use single TP to capture quick profit\r\n   * and exit before reversal. Better to take TP1 and breakeven stop\r\n   * than wait for TP2/TP3 that may never hit.\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param currentPrice - Current market price\r\n   * @param isFlat - Is market in flat/neutral bias\r\n   * @param bollingerBands - Optional BB data for dynamic TP\r\n   * @param signalConfidence - Optional signal confidence (0-1)\r\n   * @returns Array of take profit objects\r\n   */\r\n  calculateTakeProfits(\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n    isFlat: boolean = false,\r\n    bollingerBands?: {\r\n      upper: number;\r\n      middle: number;\r\n      lower: number;\r\n      width: number;\r\n      percentB: number;\r\n      isSqueeze: boolean;\r\n    },\r\n    signalConfidence?: number,\r\n  ): Array<{\r\n    level: number;\r\n    price: number;\r\n    sizePercent: number;\r\n    percent: number;\r\n    hit: boolean;\r\n  }> {\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const tpConfig = this.config.riskManagement.takeProfits;\r\n\r\n    // BB.MD: BB-based dynamic TP (if available and signal strong enough)\r\n    if (\r\n      bollingerBands &&\r\n      signalConfidence !== undefined &&\r\n      signalConfidence >= 0.65 &&\r\n      this.config.indicators.bollingerBands?.enabled\r\n    ) {\r\n      const confidencePercent = signalConfidence * PERCENT_MULTIPLIER;\r\n      let dynamicTP: number;\r\n\r\n      if (confidencePercent >= 80) {\r\n        // Very strong signal: target upper/lower band\r\n        dynamicTP = isLong ? bollingerBands.upper : bollingerBands.lower;\r\n        this.logger.info('ðŸŽ¯ BB Dynamic TP: AGGRESSIVE (target band)', {\r\n          confidence: confidencePercent.toFixed(1) + '%',\r\n          target: dynamicTP.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n      } else if (confidencePercent >= 65) {\r\n        // Medium signal: target middle band\r\n        dynamicTP = bollingerBands.middle;\r\n        this.logger.info('ðŸŽ¯ BB Dynamic TP: MODERATE (target middle)', {\r\n          confidence: confidencePercent.toFixed(1) + '%',\r\n          target: dynamicTP.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n      } else {\r\n        // Should not reach here (confidence < 65)\r\n        dynamicTP = currentPrice;\r\n      }\r\n\r\n      // Calculate TP distance\r\n      const tpDistance = Math.abs((dynamicTP - currentPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n      // Create TPs: TP1 at BB target, TP2/TP3 scaled from config\r\n      const takeProfits = tpConfig.map((tp, index) => {\r\n        let tpPrice: number;\r\n\r\n        if (index === 0) {\r\n          // TP1: Use BB-based target\r\n          tpPrice = dynamicTP;\r\n        } else {\r\n          // TP2/TP3: Scale from config percentages\r\n          tpPrice = isLong\r\n            ? currentPrice * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n            : currentPrice * (1 - tp.percent / PERCENT_MULTIPLIER);\r\n        }\r\n\r\n        return {\r\n          level: tp.level,\r\n          price: tpPrice,\r\n          sizePercent: tp.sizePercent,\r\n          percent: index === 0 ? tpDistance : tp.percent,\r\n          hit: false,\r\n        };\r\n      });\r\n\r\n      return takeProfits;\r\n    }\r\n\r\n    // FLAT MARKET: Single TP at TP1 price, close 100% position\r\n    if (isFlat) {\r\n      const firstTP = tpConfig[0];\r\n      const takeProfits = [\r\n        {\r\n          level: 1,\r\n          price: isLong\r\n            ? currentPrice * (1 + firstTP.percent / PERCENT_MULTIPLIER)\r\n            : currentPrice * (1 - firstTP.percent / PERCENT_MULTIPLIER),\r\n          sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Close 100% on TP1 in flat\r\n          percent: firstTP.percent,\r\n          hit: false,\r\n        },\r\n      ];\r\n\r\n      this.logger.info('âš¡ FLAT market detected - using single TP for quick profit', {\r\n        direction,\r\n        currentPrice,\r\n        tpPrice: takeProfits[0].price.toFixed(DECIMAL_PLACES.PRICE),\r\n        tpPercent: firstTP.percent,\r\n      });\r\n\r\n      return takeProfits;\r\n    }\r\n\r\n    // TRENDING MARKET: Multiple TPs as configured\r\n    const takeProfits = tpConfig.map((tp) => ({\r\n      level: tp.level,\r\n      price: isLong\r\n        ? currentPrice * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n        : currentPrice * (1 - tp.percent / PERCENT_MULTIPLIER),\r\n      sizePercent: tp.sizePercent,\r\n      percent: tp.percent,\r\n      hit: false,\r\n    }));\r\n\r\n    this.logger.debug('Take Profits calculated', {\r\n      direction,\r\n      currentPrice,\r\n      levels: takeProfits.length,\r\n      takeProfits: takeProfits.map((tp) => `TP${tp.level}: ${tp.price.toFixed(DECIMAL_PLACES.PRICE)}`),\r\n    });\r\n\r\n    return takeProfits;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\smart-breakeven.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":54,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":54,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1836,1844],"text":"(existing != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":90,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":90,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[2800,2806],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":139,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":139,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4191,4197],"text":"(state == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":165,"column":24,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":165,"endColumn":48,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[4956,4962],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":233,"column":27,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":233,"endColumn":51,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7417,7423],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":263,"column":26,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":263,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8558,8572],"text":"(configOverride != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":263,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":263,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8573,8575],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":270,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":270,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8717,8722],"text":"(state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.","line":274,"column":17,"nodeType":"ConditionalExpression","messageId":"preferNullishOverTernary","endLine":274,"endColumn":78,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8831,8892],"text":"remainingQty ?? position.quantity"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":308,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":308,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9719,9724],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Smart Breakeven Service\r\n *\r\n * Pre-BE mode - only move SL to profit when impulse is confirmed.\r\n *\r\n * Problem:\r\n * - Moving SL to breakeven immediately after TP1 often results in stop-outs on micro-pullbacks\r\n * - Example: Entry 1.2000, TP1 hits at 1.2060, SL moved to 1.2000\r\n *   â†’ Price pulls back to 1.1995 â†’ Stopped out at breakeven\r\n *   â†’ Then price goes to 1.2100 (missed profit!)\r\n *\r\n * Solution:\r\n * - Enter \"Pre-BE mode\" after profit threshold reached (0.3%)\r\n * - Check impulse retention: EMA hold + volume normal\r\n * - Only move SL to +0.1% profit when impulse confirmed\r\n * - If impulse lost (EMA broken + volume spike) â†’ move to breakeven immediately\r\n *\r\n * Benefits:\r\n * - Fewer micro-pullback stop-outs\r\n * - Still protects if trend reverses\r\n * - Locks in small profit (+0.1%) instead of breakeven\r\n */\r\n\r\nimport { SmartBreakevenConfig, BreakevenMode, BreakevenState, Position, LoggerService } from '../types';\r\n\r\nexport class SmartBreakevenService {\r\n  private states: Map<string, BreakevenState> = new Map();\r\n\r\n  constructor(\r\n    private config: SmartBreakevenConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('SmartBreakevenService initialized', {\r\n      enabled: config.enabled,\r\n      activationProfit: `${config.activationProfitPercent}%`,\r\n      beProfit: `${config.breakevenProfitPercent}%`,\r\n      requireEMA: config.requireEMAHold,\r\n      requireVolume: config.requireVolumeConfirmation,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate Pre-BE mode when profit threshold reached\r\n   *\r\n   * Called when: profit >= activationProfitPercent (default 0.3%)\r\n   */\r\n  activatePreBE(symbol: string): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    const existing = this.states.get(symbol);\r\n    if (existing && existing.mode !== BreakevenMode.NONE) {\r\n      this.logger.debug('Pre-BE already active or completed', {\r\n        symbol,\r\n        currentMode: existing.mode,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.states.set(symbol, {\r\n      mode: BreakevenMode.PRE_BE,\r\n      activatedAt: Date.now(),\r\n      candlesWaited: 0,\r\n      lastCheckPrice: 0,\r\n    });\r\n\r\n    this.logger.info('âš¡ Pre-Breakeven mode activated', {\r\n      symbol,\r\n      waitingFor: 'impulse confirmation',\r\n      maxCandles: this.config.maxWaitCandles,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if impulse retained\r\n   *\r\n   * Conditions for retained impulse:\r\n   * 1. Price holding above/below EMA (LONG/SHORT)\r\n   * 2. Volume normal (no reverse spike)\r\n   */\r\n  checkImpulseRetention(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n  ): { retained: boolean; reason: string } {\r\n    const isLong = position.side === 'LONG';\r\n\r\n    // 1. Check EMA hold\r\n    if (this.config.requireEMAHold) {\r\n      const emaHolds = isLong\r\n        ? currentPrice > ema20\r\n        : currentPrice < ema20;\r\n\r\n      if (!emaHolds) {\r\n        return {\r\n          retained: false,\r\n          reason: `Price broke EMA(${this.config.emaPeriod}): ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} ${isLong ? '<' : '>'} ${ema20.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Check volume (no reversal spike)\r\n    if (this.config.requireVolumeConfirmation) {\r\n      const volumeThreshold = avgVolume * this.config.volumeReverseMultiplier;\r\n\r\n      if (currentVolume > volumeThreshold) {\r\n        return {\r\n          retained: false,\r\n          reason: `Volume spike detected: ${currentVolume.toFixed(0)} > ${volumeThreshold.toFixed(0)} (reversal signal)`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      retained: true,\r\n      reason: 'Impulse confirmed: EMA hold + volume normal',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update breakeven state on candle close\r\n   *\r\n   * Called every candle close while in Pre-BE mode\r\n   */\r\n  async updateBreakeven(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    updateStopLossFn: (newSL: number) => Promise<void>,\r\n  ): Promise<void> {\r\n    const state = this.states.get(position.symbol);\r\n\r\n    if (!state || state.mode !== BreakevenMode.PRE_BE) {\r\n      return; // Not in Pre-BE mode\r\n    }\r\n\r\n    state.candlesWaited++;\r\n    state.lastCheckPrice = currentPrice;\r\n\r\n    this.logger.debug('Checking impulse retention...', {\r\n      symbol: position.symbol,\r\n      candlesWaited: state.candlesWaited,\r\n      maxCandles: this.config.maxWaitCandles,\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      ema20: ema20.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    // Check impulse\r\n    const impulse = this.checkImpulseRetention(\r\n      position,\r\n      currentPrice,\r\n      ema20,\r\n      currentVolume,\r\n      avgVolume,\r\n    );\r\n\r\n    if (impulse.retained) {\r\n      // Impulse confirmed - move SL to +0.1% profit\r\n      const profitSL = position.side === 'LONG'\r\n        ? position.entryPrice * (1 + this.config.breakevenProfitPercent / PERCENT_MULTIPLIER)\r\n        : position.entryPrice * (1 - this.config.breakevenProfitPercent / PERCENT_MULTIPLIER);\r\n\r\n      await updateStopLossFn(profitSL);\r\n\r\n      state.mode = BreakevenMode.BE_ACTIVE;\r\n\r\n      this.logger.info('âœ… Smart Breakeven activated!', {\r\n        symbol: position.symbol,\r\n        newSL: profitSL.toFixed(DECIMAL_PLACES.PRICE),\r\n        profit: `+${this.config.breakevenProfitPercent}%`,\r\n        candlesWaited: state.candlesWaited,\r\n        reason: impulse.reason,\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // Impulse lost - move to breakeven immediately\r\n    this.logger.warn('âš ï¸ Impulse lost - moving to breakeven', {\r\n      symbol: position.symbol,\r\n      reason: impulse.reason,\r\n      candlesWaited: state.candlesWaited,\r\n    });\r\n\r\n    await updateStopLossFn(position.entryPrice);\r\n    state.mode = BreakevenMode.BE_ACTIVE;\r\n\r\n    this.logger.info('ðŸ“ SL moved to breakeven (impulse lost)', {\r\n      symbol: position.symbol,\r\n      newSL: position.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    // Check timeout\r\n    if (state.candlesWaited >= this.config.maxWaitCandles) {\r\n      this.logger.warn('â±ï¸ Pre-BE timeout reached', {\r\n        symbol: position.symbol,\r\n        candlesWaited: state.candlesWaited,\r\n        maxCandles: this.config.maxWaitCandles,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate current profit percent including realized PnL from partial closes\r\n   *\r\n   * FIX: This now accounts for partial TP closes (TP1, TP2) which were previously ignored\r\n   *\r\n   * Example (SHORT):\r\n   * - Entry: 0.8108, Qty: 100\r\n   * - TP1 @ 0.8059: Close 50 units â†’ +2.97 USDT realized\r\n   * - Current price: 0.8054, Remaining: 50 units â†’ -0.27 USDT unrealized\r\n   * - OLD: profit = -0.27 / (0.8108 * PERCENT_MULTIPLIER) = -0.33% âŒ (ignores TP1!)\r\n   * - NEW: profit = (2.97 - 0.27) / (0.8108 * PERCENT_MULTIPLIER) = +3.33% âœ… (includes TP1)\r\n   *\r\n   * @param position Current position\r\n   * @param currentPrice Current market price\r\n   * @param realizedPnL Total PnL from partial closes (from TakeProfitManager)\r\n   * @param remainingQty Remaining position quantity\r\n   */\r\n  private calculateProfitPercent(\r\n    position: Position,\r\n    currentPrice: number,\r\n    realizedPnL: number,\r\n    remainingQty: number,\r\n  ): number {\r\n    // Calculate unrealized PnL for remaining position\r\n    const pnlMultiplier = position.side === 'LONG' ? 1 : -1;\r\n    const priceDiff = currentPrice - position.entryPrice;\r\n    const unrealizedPnL = priceDiff * remainingQty * pnlMultiplier * position.leverage;\r\n\r\n    // Total PnL = realized (from closed TPs) + unrealized (from remaining qty)\r\n    const totalPnL = realizedPnL + unrealizedPnL;\r\n\r\n    // Calculate profit percent based on initial position value\r\n    const initialValue = position.entryPrice * position.quantity;\r\n    const profitPercent = (totalPnL / initialValue) * PERCENT_MULTIPLIER;\r\n\r\n    return profitPercent;\r\n  }\r\n\r\n  /**\r\n   * Check if should activate Pre-BE mode\r\n   *\r\n   * @param position Current position\r\n   * @param currentPrice Current market price\r\n   * @param realizedPnL Total PnL from partial closes (default: 0)\r\n   * @param remainingQty Remaining position quantity (default: full position)\r\n   * @param configOverride Optional strategy-specific config (overrides this.config)\r\n   */\r\n  shouldActivate(\r\n    position: Position,\r\n    currentPrice: number,\r\n    realizedPnL: number = 0,\r\n    remainingQty?: number,\r\n    configOverride?: SmartBreakevenConfig,\r\n  ): boolean {\r\n    const activeConfig = configOverride || this.config;\r\n\r\n    if (!activeConfig.enabled) {\r\n      return false;\r\n    }\r\n\r\n    const state = this.states.get(position.symbol);\r\n    if (state && state.mode !== BreakevenMode.NONE) {\r\n      return false; // Already activated\r\n    }\r\n\r\n    const qty = remainingQty !== undefined ? remainingQty : position.quantity;\r\n    const profitPercent = this.calculateProfitPercent(position, currentPrice, realizedPnL, qty);\r\n\r\n    return profitPercent >= activeConfig.activationProfitPercent;\r\n  }\r\n\r\n  /**\r\n   * Get breakeven state\r\n   */\r\n  getState(symbol: string): BreakevenState | undefined {\r\n    return this.states.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Check if in Pre-BE mode\r\n   */\r\n  isInPreBEMode(symbol: string): boolean {\r\n    const state = this.states.get(symbol);\r\n    return state?.mode === BreakevenMode.PRE_BE;\r\n  }\r\n\r\n  /**\r\n   * Check if BE active\r\n   */\r\n  isBEActive(symbol: string): boolean {\r\n    const state = this.states.get(symbol);\r\n    return state?.mode === BreakevenMode.BE_ACTIVE;\r\n  }\r\n\r\n  /**\r\n   * Reset state (position closed)\r\n   */\r\n  reset(symbol: string): void {\r\n    const state = this.states.get(symbol);\r\n    if (state) {\r\n      this.logger.debug('Resetting breakeven state', {\r\n        symbol,\r\n        finalMode: state.mode,\r\n        candlesWaited: state.candlesWaited,\r\n      });\r\n    }\r\n    this.states.delete(symbol);\r\n  }\r\n\r\n  /**\r\n   * Get all states (for monitoring)\r\n   */\r\n  getAllStates(): Map<string, BreakevenState> {\r\n    return new Map(this.states);\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): SmartBreakevenConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\smart-trailing-v2.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":62,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":62,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2018,2026],"text":"(existing != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'checkImpulseActivation' has a complexity of 13. Maximum allowed is 10.","line":88,"column":25,"nodeType":"FunctionExpression","messageId":"complex","endLine":154,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":102,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":102,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3200,3208],"text":"(existing != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":106,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":106,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[3345,3351],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.2.","line":131,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":131,"endColumn":28},{"ruleId":"complexity","severity":1,"message":"Method 'calculateTrailingStop' has a complexity of 13. Maximum allowed is 10.","line":179,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":225,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":186,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":186,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5921,5927],"text":"(state == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":190,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":190,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[6015,6021],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":248,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":248,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7820,7825],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":273,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":273,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[8636,8642],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":290,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":290,"endColumn":25,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[9231,9244],"text":"((state?.active) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[9231,9244],"text":"((state?.active) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":290,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":290,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9245,9247],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":305,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":305,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9554,9559],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Smart Trailing Stop Service v2 (Phase 3)\r\n *\r\n * Impulse-based trailing stop that activates BEFORE TP2.\r\n * Old behavior: Wait for TP2 â†’ then start trailing\r\n * New behavior: Detect impulse â†’ start trailing immediately\r\n *\r\n * Why v2 is better:\r\n * - Captures more profit on strong impulses (don't wait for TP2)\r\n * - Activates on TP2 hit (legacy mode still works)\r\n * - Reduces \"give back\" scenarios (profit â†’ reversal â†’ SL)\r\n *\r\n * Example:\r\n * Entry: 1.2000, current: 1.2085 (+0.7% profit)\r\n * - EMA hold: price > EMA20 âœ…\r\n * - Strong volume: 1.8x avg âœ…\r\n * - Result: Activate trailing @ 1.2083 (0.15% below) âœ…\r\n * - Why: Impulse detected, protect profit early\r\n */\r\n\r\nimport {\r\n  SmartTrailingConfig,\r\n  TrailingState,\r\n  Position,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// SMART TRAILING V2 SERVICE\r\n// ============================================================================\r\n\r\nexport class SmartTrailingV2Service {\r\n  private states: Map<string, TrailingState> = new Map();\r\n\r\n  constructor(\r\n    private config: SmartTrailingConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('SmartTrailingV2Service initialized', {\r\n      enabled: config.enabled,\r\n      activateOnTP2: config.activateOnTP2,\r\n      activateOnImpulse: config.activateOnImpulse,\r\n      trailingMode: config.trailingMode,\r\n      impulseThreshold: config.impulseThreshold.minProfitPercent + '%',\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Activate trailing stop (called on TP2 hit - legacy mode)\r\n   */\r\n  activateOnTP2(positionId: string): void {\r\n    if (!this.config.enabled || !this.config.activateOnTP2) {\r\n      return;\r\n    }\r\n\r\n    const existing = this.states.get(positionId);\r\n    if (existing && existing.active) {\r\n      this.logger.debug('Trailing already active', { positionId });\r\n      return;\r\n    }\r\n\r\n    this.states.set(positionId, {\r\n      active: true,\r\n      activatedBy: 'TP2',\r\n      activatedAt: Date.now(),\r\n      lastUpdatePrice: 0,\r\n      lastStopLoss: 0,\r\n      updateCount: 0,\r\n    });\r\n\r\n    this.logger.info('âœ… Trailing activated on TP2', { positionId });\r\n  }\r\n\r\n  /**\r\n   * Check if should activate on impulse (NEW in v2)\r\n   *\r\n   * Conditions:\r\n   * 1. Current profit >= minProfitPercent (e.g., 0.7%)\r\n   * 2. Price holding above/below EMA (LONG/SHORT)\r\n   * 3. Volume elevated (confirming impulse)\r\n   * 4. EMA angle steep enough (momentum)\r\n   */\r\n  checkImpulseActivation(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number, // EMA slope in degrees\r\n  ): { shouldActivate: boolean; reason: string } {\r\n    if (!this.config.enabled || !this.config.activateOnImpulse) {\r\n      return { shouldActivate: false, reason: 'Impulse activation disabled' };\r\n    }\r\n\r\n    // Already active?\r\n    const existing = this.states.get(position.id);\r\n    if (existing && existing.active) {\r\n      return { shouldActivate: false, reason: 'Already active' };\r\n    }\r\n\r\n    const isLong = position.side === 'LONG';\r\n\r\n    // 1. Check profit threshold\r\n    const profitPercent = this.calculateProfitPercent(position, currentPrice);\r\n    if (profitPercent < this.config.impulseThreshold.minProfitPercent) {\r\n      return {\r\n        shouldActivate: false,\r\n        reason: `Profit too low: ${profitPercent.toFixed(DECIMAL_PLACES.PERCENT)}% < ${this.config.impulseThreshold.minProfitPercent}%`,\r\n      };\r\n    }\r\n\r\n    // 2. Check EMA hold\r\n    if (this.config.impulseThreshold.requireEMAHold) {\r\n      const emaHolds = isLong ? currentPrice > ema20 : currentPrice < ema20;\r\n      if (!emaHolds) {\r\n        return {\r\n          shouldActivate: false,\r\n          reason: `Price broke EMA: ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} ${isLong ? '<=' : '>='} ${ema20.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Check volume\r\n    if (this.config.impulseThreshold.requireVolume) {\r\n      const volumeRatio = currentVolume / avgVolume;\r\n      if (volumeRatio < 1.2) {\r\n        // Volume not elevated\r\n        return {\r\n          shouldActivate: false,\r\n          reason: `Volume too low: ${volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 4. Check EMA angle\r\n    const absAngle = Math.abs(emaAngle);\r\n    if (absAngle < this.config.impulseThreshold.emaAngleThreshold) {\r\n      return {\r\n        shouldActivate: false,\r\n        reason: `EMA angle too flat: ${absAngle.toFixed(DECIMAL_PLACES.PERCENT)}Â° < ${this.config.impulseThreshold.emaAngleThreshold}Â°`,\r\n      };\r\n    }\r\n\r\n    // All checks passed - activate!\r\n    return {\r\n      shouldActivate: true,\r\n      reason: `Impulse detected: +${profitPercent.toFixed(DECIMAL_PLACES.PERCENT)}% profit, EMA hold, ${(currentVolume / avgVolume).toFixed(DECIMAL_PLACES.PERCENT)}x volume`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Activate trailing on impulse\r\n   */\r\n  activateOnImpulse(positionId: string, reason: string): void {\r\n    this.states.set(positionId, {\r\n      active: true,\r\n      activatedBy: 'IMPULSE',\r\n      activatedAt: Date.now(),\r\n      lastUpdatePrice: 0,\r\n      lastStopLoss: 0,\r\n      updateCount: 0,\r\n    });\r\n\r\n    this.logger.info('ðŸš€ Trailing activated on IMPULSE', { positionId, reason });\r\n  }\r\n\r\n  /**\r\n   * Calculate trailing stop price\r\n   *\r\n   * Two modes:\r\n   * 1. EMA mode: SL = EMA20 - emaDistance%\r\n   * 2. ATR mode: SL = current - (ATR * atrMultiplier)\r\n   */\r\n  calculateTrailingStop(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    atr: number,\r\n  ): number | null {\r\n    const state = this.states.get(position.id);\r\n    if (!state || !state.active) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = position.side === 'LONG';\r\n    let trailingSL: number;\r\n\r\n    if (this.config.trailingMode === 'EMA') {\r\n      // EMA-based trailing\r\n      const distance = ema20 * (this.config.emaDistance / PERCENT_MULTIPLIER);\r\n      trailingSL = isLong ? ema20 - distance : ema20 + distance;\r\n    } else {\r\n      // ATR-based trailing\r\n      const distance = atr * this.config.atrMultiplier;\r\n      trailingSL = isLong ? currentPrice - distance : currentPrice + distance;\r\n    }\r\n\r\n    // Ensure minimum distance from current price\r\n    const minDistance = currentPrice * (this.config.minDistancePercent / PERCENT_MULTIPLIER);\r\n    const actualDistance = Math.abs(currentPrice - trailingSL);\r\n\r\n    if (actualDistance < minDistance) {\r\n      // Too tight, adjust\r\n      trailingSL = isLong\r\n        ? currentPrice - minDistance\r\n        : currentPrice + minDistance;\r\n    }\r\n\r\n    // Only move SL in favorable direction (never widen)\r\n    if (state.lastStopLoss > 0) {\r\n      if (isLong && trailingSL <= state.lastStopLoss) {\r\n        return null; // Don't lower SL for LONG\r\n      }\r\n      if (!isLong && trailingSL >= state.lastStopLoss) {\r\n        return null; // Don't raise SL for SHORT\r\n      }\r\n    }\r\n\r\n    return trailingSL;\r\n  }\r\n\r\n  /**\r\n   * Update trailing stop (call this periodically or on candle close)\r\n   */\r\n  async updateTrailingStop(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    atr: number,\r\n    updateStopLossFn: (newSL: number) => Promise<void>,\r\n  ): Promise<boolean> {\r\n    const newSL = this.calculateTrailingStop(position, currentPrice, ema20, atr);\r\n\r\n    if (newSL === null) {\r\n      return false; // No update needed\r\n    }\r\n\r\n    // Update SL on exchange\r\n    await updateStopLossFn(newSL);\r\n\r\n    // Update state\r\n    const state = this.states.get(position.id);\r\n    if (state) {\r\n      state.lastUpdatePrice = currentPrice;\r\n      state.lastStopLoss = newSL;\r\n      state.updateCount++;\r\n\r\n      this.logger.info('ðŸ“ˆ Trailing SL updated', {\r\n        positionId: position.id,\r\n        newSL: newSL.toFixed(DECIMAL_PLACES.PRICE),\r\n        currentPrice: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        mode: this.config.trailingMode,\r\n        updateCount: state.updateCount,\r\n      });\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate current profit percent\r\n   */\r\n  private calculateProfitPercent(position: Position, currentPrice: number): number {\r\n    const isLong = position.side === 'LONG';\r\n    if (isLong) {\r\n      return ((currentPrice - position.entryPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    } else {\r\n      return ((position.entryPrice - currentPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC: STATE MANAGEMENT\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Check if trailing is active\r\n   */\r\n  isActive(positionId: string): boolean {\r\n    const state = this.states.get(positionId);\r\n    return state?.active || false;\r\n  }\r\n\r\n  /**\r\n   * Get trailing state\r\n   */\r\n  getState(positionId: string): TrailingState | undefined {\r\n    return this.states.get(positionId);\r\n  }\r\n\r\n  /**\r\n   * Reset state (position closed)\r\n   */\r\n  reset(positionId: string): void {\r\n    const state = this.states.get(positionId);\r\n    if (state) {\r\n      this.logger.debug('Resetting trailing state', {\r\n        positionId,\r\n        activatedBy: state.activatedBy,\r\n        updateCount: state.updateCount,\r\n      });\r\n    }\r\n    this.states.delete(positionId);\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): SmartTrailingConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\strategy-coordinator.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Async method 'evaluateStrategies' has a complexity of 15. Maximum allowed is 10.","line":80,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":146,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":118,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":118,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4288,4301],"text":"(result.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":128,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":128,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4725,4738],"text":"(result.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS } from '../constants';\r\n/**\r\n * Strategy Coordinator Service\r\n *\r\n * Coordinates multiple trading strategies using priority-based selection.\r\n * Implements \"FIRST VALID WINS\" logic - returns the first strategy that produces a valid signal.\r\n *\r\n * Strategy Priority Order:\r\n * 1. Trend-Following Strategy (Priority 1 - Highest)\r\n * 2. Level-Based Strategy (Priority 2)\r\n * 3. Counter-Trend Strategy (Priority 3)\r\n * 4. Reversal-Pattern Strategy (Priority 4 - Experimental)\r\n */\r\n\r\nimport { IStrategy, StrategyMarketData, StrategySignal, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_CONFIDENCE_THRESHOLD = MULTIPLIERS.HALF;\r\n\r\n// ============================================================================\r\n// STRATEGY COORDINATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class StrategyCoordinator {\r\n  private strategies: IStrategy[] = [];\r\n\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Register a strategy\r\n   * Strategies are automatically sorted by priority (lowest number = highest priority)\r\n   */\r\n  registerStrategy(strategy: IStrategy): void {\r\n    this.strategies.push(strategy);\r\n    // Sort by priority (ascending - lower number = higher priority)\r\n    this.strategies.sort((a, b) => a.priority - b.priority);\r\n    this.logger.info(`Strategy registered: ${strategy.name} (priority ${strategy.priority})`);\r\n  }\r\n\r\n  /**\r\n   * Unregister a strategy by name\r\n   */\r\n  unregisterStrategy(strategyName: string): boolean {\r\n    const initialLength = this.strategies.length;\r\n    this.strategies = this.strategies.filter((s) => s.name !== strategyName);\r\n    const removed = this.strategies.length < initialLength;\r\n    if (removed) {\r\n      this.logger.info(`Strategy unregistered: ${strategyName}`);\r\n    }\r\n    return removed;\r\n  }\r\n\r\n  /**\r\n   * Get all registered strategies (sorted by priority)\r\n   */\r\n  getStrategies(): IStrategy[] {\r\n    return [...this.strategies];\r\n  }\r\n\r\n  /**\r\n   * Clear all strategies\r\n   */\r\n  clearStrategies(): void {\r\n    this.strategies = [];\r\n    this.logger.info('All strategies cleared');\r\n  }\r\n\r\n  /**\r\n   * Evaluate all strategies and return the first valid signal\r\n   * FIRST VALID WINS logic - stops at the first strategy that produces a valid signal\r\n   *\r\n   * @param marketData - Market data to evaluate\r\n   * @param minConfidence - Minimum confidence threshold (default: MULTIPLIERS.HALF)\r\n   * @param excludeRealtimeStrategies - If true, excludes real-time strategies (WHALE_HUNTER, WHALE_HUNTER_FOLLOW)\r\n   * @returns Strategy signal or null if no valid signals\r\n   */\r\n  async evaluateStrategies(\r\n    marketData: StrategyMarketData,\r\n    minConfidence: number = MIN_CONFIDENCE_THRESHOLD,\r\n    excludeRealtimeStrategies: boolean = true,\r\n  ): Promise<StrategySignal | null> {\r\n    if (this.strategies.length === 0) {\r\n      this.logger.warn('No strategies registered');\r\n      return null;\r\n    }\r\n\r\n    // Filter out real-time strategies (they work on orderbook updates, not candle close)\r\n    const strategiesToEvaluate = excludeRealtimeStrategies\r\n      ? this.strategies.filter(s => s.name !== 'WHALE_HUNTER' && s.name !== 'WHALE_HUNTER_FOLLOW')\r\n      : this.strategies;\r\n\r\n    if (strategiesToEvaluate.length === 0) {\r\n      this.logger.warn('No strategies to evaluate (all filtered out)');\r\n      return null;\r\n    }\r\n\r\n    this.logger.debug(`Evaluating ${strategiesToEvaluate.length} strategies`, {\r\n      timestamp: marketData.timestamp,\r\n      price: marketData.currentPrice,\r\n      excluded: excludeRealtimeStrategies ? 'WHALE_HUNTER' : 'none',\r\n    });\r\n\r\n    // FIRST VALID WINS - iterate by priority\r\n    for (const strategy of strategiesToEvaluate) {\r\n      try {\r\n        const result = await strategy.evaluate(marketData);\r\n\r\n        this.logger.debug(`Strategy ${strategy.name} evaluated`, {\r\n          valid: result.valid,\r\n          confidence: result.signal?.confidence,\r\n          reason: result.reason,\r\n        });\r\n\r\n        // Check if signal is valid and meets confidence threshold\r\n        if (result.valid && result.signal && result.signal.confidence >= minConfidence) {\r\n          this.logger.info(`âœ… Strategy signal accepted: ${strategy.name}`, {\r\n            direction: result.signal.direction,\r\n            confidence: result.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n            priority: strategy.priority,\r\n          });\r\n          return result;\r\n        }\r\n\r\n        // Log why signal was rejected\r\n        if (result.valid && result.signal && result.signal.confidence < minConfidence) {\r\n          this.logger.debug(`Strategy ${strategy.name} rejected: confidence too low`, {\r\n            confidence: result.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n            minRequired: minConfidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n          });\r\n        }\r\n      } catch (error) {\r\n        this.logger.error(`Strategy ${strategy.name} evaluation failed`, {\r\n          error: error instanceof Error ? error.message : String(error),\r\n          stack: error instanceof Error ? error.stack : undefined,\r\n        });\r\n        // Continue to next strategy on error\r\n      }\r\n    }\r\n\r\n    // No valid signals found\r\n    this.logger.debug('No valid signals from any strategy');\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get strategy count\r\n   */\r\n  getStrategyCount(): number {\r\n    return this.strategies.length;\r\n  }\r\n\r\n  /**\r\n   * Check if a strategy is registered\r\n   */\r\n  hasStrategy(strategyName: string): boolean {\r\n    return this.strategies.some((s) => s.name === strategyName);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\take-profit-manager.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\telegram.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":23,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":23,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[667,682],"text":"(config.botToken != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[667,682],"text":"(config.botToken ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[667,682],"text":"(Boolean(config.botToken))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":23,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":23,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[683,685],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":24,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":24,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[711,724],"text":"(config.chatId != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[711,724],"text":"(config.chatId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[711,724],"text":"(Boolean(config.chatId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":24,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":24,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[725,727],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":40,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":25,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[773,787],"text":"(this.botToken == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[774,787],"text":"(this.botToken ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[773,787],"text":"(!Boolean(this.botToken))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":59,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":25,"endColumn":70,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[792,804],"text":"(this.chatId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[793,804],"text":"(this.chatId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[792,804],"text":"(!Boolean(this.chatId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":42,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":42,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1217,1231],"text":"(this.botToken == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1218,1231],"text":"(this.botToken ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1217,1231],"text":"(!Boolean(this.botToken))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":42,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":42,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1235,1247],"text":"(this.chatId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1236,1247],"text":"(this.chatId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1235,1247],"text":"(!Boolean(this.chatId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":98,"column":3,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":98,"endColumn":9,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2623,2629],"text":"(reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2623,2629],"text":"(reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2623,2629],"text":"(Boolean(reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":130,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":130,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3674,3691],"text":"(position.strategy != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3674,3691],"text":"(position.strategy ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3674,3691],"text":"(Boolean(position.strategy))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":130,"column":34,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":130,"endColumn":36,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3692,3694],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":131,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":131,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3729,3748],"text":"(position.confidence != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3729,3748],"text":"(position.confidence ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3729,3748],"text":"(Boolean(position.confidence))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":131,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":131,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3749,3751],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":132,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":132,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[3804,3819],"text":"(position.reason.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[3804,3819],"text":"(position.reason !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3804,3819],"text":"(Boolean(position.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'notifyPositionClosed' has a complexity of 11. Maximum allowed is 10.","line":141,"column":29,"nodeType":"FunctionExpression","messageId":"complex","endLine":188,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":164,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":165,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":165,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":168,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":52},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyTrailingUpdated' has no 'await' expression.","line":266,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":266,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Async method 'sendTradeNotification' has a complexity of 14. Maximum allowed is 10.","line":280,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":335,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":301,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":301,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8934,8949],"text":"params.stopLoss != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8934,8949],"text":"params.stopLoss ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8934,8949],"text":"Boolean(params.stopLoss)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":304,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":304,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9063,9081],"text":"(params.takeProfits != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":310,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":310,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9347,9364],"text":"params.confidence != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9347,9364],"text":"params.confidence ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9347,9364],"text":"Boolean(params.confidence)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":313,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":313,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9484,9497],"text":"params.reason != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[9484,9497],"text":"params.reason ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9484,9497],"text":"Boolean(params.reason)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":326,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":326,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10007,10020],"text":"params.reason != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[10007,10020],"text":"params.reason ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10007,10020],"text":"Boolean(params.reason)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Telegram Notification Service\r\n * Sends trading event notifications to Telegram\r\n */\r\n\r\nimport { Position, SignalDirection, PositionSide, LoggerService } from '../types';\r\n\r\nexport interface TelegramConfig {\r\n  botToken?: string;\r\n  chatId?: string;\r\n  enabled: boolean;\r\n}\r\n\r\nexport class TelegramService {\r\n  private readonly botToken: string | null;\r\n  private readonly chatId: string | null;\r\n  private readonly enabled: boolean;\r\n  private readonly logger: LoggerService;\r\n\r\n  constructor(config: TelegramConfig, logger: LoggerService) {\r\n    this.logger = logger;\r\n    this.botToken = config.botToken || null;\r\n    this.chatId = config.chatId || null;\r\n    this.enabled = config.enabled && !!this.botToken && !!this.chatId;\r\n\r\n    if (this.enabled) {\r\n      this.logger.info('âœ… Telegram notifications ENABLED', {\r\n        chatId: this.chatId,\r\n      });\r\n    } else {\r\n      this.logger.info(\r\n        'âš ï¸ Telegram notifications DISABLED (set telegram config in config.json)',\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send message to Telegram\r\n   */\r\n  private async sendMessage(message: string): Promise<void> {\r\n    if (!this.enabled || !this.botToken || !this.chatId) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const url = `https://api.telegram.org/bot${this.botToken}/sendMessage`;\r\n      const response = await fetch(url, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          chat_id: this.chatId,\r\n          text: message,\r\n          parse_mode: 'HTML',\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        throw new Error(`Telegram API error: ${response.status} ${errorText}`);\r\n      }\r\n\r\n      this.logger.debug('ðŸ“¤ Telegram notification sent', {\r\n        messageLength: message.length,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('âŒ Failed to send Telegram notification', { error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notification: Bot started\r\n   */\r\n  async notifyBotStarted(symbol: string, timeframes: string[]): Promise<void> {\r\n    const message = `\r\nðŸš€ <b>BOT STARTED</b>\r\n\r\nðŸ“Š Symbol: ${symbol}\r\nâ° Timeframes: ${timeframes.join(', ')}\r\nâ° Time: ${new Date().toISOString()}\r\n\r\nâœ… Bot is now monitoring the market...\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Bot stopped\r\n   */\r\n  async notifyBotStopped(reason?: string): Promise<void> {\r\n    const message = `\r\nðŸ›‘ <b>BOT STOPPED</b>\r\n\r\nâ° Time: ${new Date().toISOString()}\r\n${reason ? `ðŸ“ Reason: ${reason}` : ''}\r\n\r\nâŒ Bot has stopped monitoring.\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Position opened\r\n   */\r\n  async notifyPositionOpened(position: Position): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'ðŸŸ¢' : 'ðŸ”´';\r\n    const leverageText = position.leverage > 1 ? ` ${position.leverage}x` : '';\r\n\r\n    const message = `\r\n${sideEmoji} <b>${position.side.toUpperCase()}${leverageText} OPENED</b>\r\n\r\nðŸ“Š Symbol: ${position.symbol}\r\nðŸ’° Entry: $${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nðŸ“¦ Size: ${position.quantity} (${position.marginUsed.toFixed(DECIMAL_PLACES.PERCENT)} USDT margin)\r\n\r\nðŸŽ¯ Take Profits:\r\n${position.takeProfits\r\n    .map(\r\n      (tp) =>\r\n        `  TP${tp.level}: $${tp.price.toFixed(DECIMAL_PLACES.PRICE)} (+${tp.percent.toFixed(DECIMAL_PLACES.PERCENT)}%) - ${tp.sizePercent}%${tp.hit ? ' âœ…' : ''}`,\r\n    )\r\n    .join('\\n')}\r\n\r\nðŸ›¡ï¸ Stop Loss: $${position.stopLoss.price.toFixed(DECIMAL_PLACES.PRICE)}\r\n\r\nðŸ“ Strategy: ${position.strategy || 'SmartTrend'}\r\nðŸ“ Confidence: ${((position.confidence || 0) * PERCENT_MULTIPLIER).toFixed(1)}%\r\nðŸ“ Reason: ${position.reason || 'N/A'}\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Position closed\r\n   */\r\n  async notifyPositionClosed(\r\n    position: Position,\r\n    closeReason: string,\r\n    closePrice: number,\r\n    realizedPnL: number,\r\n    realizedPnLPercent: number,\r\n  ): Promise<void> {\r\n    const pnlEmoji = realizedPnL >= 0 ? 'ðŸ’°' : 'ðŸ’¸';\r\n    const pnlSign = realizedPnL >= 0 ? '+' : '';\r\n\r\n    // Emoji for close type\r\n    let closeEmoji = 'ðŸ”š';\r\n    if (closeReason.includes('Stop Loss') || closeReason.includes('SL')) {\r\n      closeEmoji = 'ðŸ›¡ï¸';\r\n    } else if (closeReason.includes('Take Profit') || closeReason.includes('TP')) {\r\n      closeEmoji = 'ðŸŽ¯';\r\n    } else if (closeReason.toLowerCase().includes('trailing')) {\r\n      closeEmoji = 'ðŸ“ˆ';\r\n    } else if (closeReason.toLowerCase().includes('time')) {\r\n      closeEmoji = 'â°';\r\n    }\r\n\r\n    const holdingTimeMs = Date.now() - position.openedAt;\r\n    const holdingTimeSec = Math.floor(holdingTimeMs / 1000);\r\n    const holdingTimeMin = Math.floor(holdingTimeSec / 60);\r\n    const holdingTimeFormatted =\r\n      holdingTimeMin > 0\r\n        ? `${holdingTimeMin}m ${holdingTimeSec % 60}s`\r\n        : `${holdingTimeSec}s`;\r\n\r\n    const tpsHit = position.takeProfits.filter((tp) => tp.hit);\r\n\r\n    const message = `\r\n${closeEmoji} <b>${position.side.toUpperCase()} CLOSED</b>\r\n\r\nðŸ“Š Symbol: ${position.symbol}\r\nðŸ’° Entry: $${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nðŸšª Exit: $${closePrice.toFixed(DECIMAL_PLACES.PRICE)}\r\n\r\n${pnlEmoji} <b>PnL: ${pnlSign}${realizedPnL.toFixed(DECIMAL_PLACES.PERCENT)} USDT (${pnlSign}${realizedPnLPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)</b>\r\n\r\nðŸŽ¯ TPs Hit: ${tpsHit.length > 0 ? tpsHit.map((tp) => `TP${tp.level}`).join(', ') : 'None'}\r\nâ±ï¸ Duration: ${holdingTimeFormatted}\r\nðŸ“ Reason: ${closeReason}\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Take Profit hit\r\n   */\r\n  async notifyTakeProfitHit(\r\n    position: Position,\r\n    tpLevel: number,\r\n    tpPrice: number,\r\n    tpPercent: number,\r\n    sizePercent: number,\r\n  ): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'ðŸŸ¢' : 'ðŸ”´';\r\n\r\n    const message = `\r\nðŸŽ¯ <b>TP${tpLevel} HIT!</b>\r\n\r\n${sideEmoji} ${position.symbol} ${position.side.toUpperCase()}\r\nðŸ’° Price: $${tpPrice.toFixed(DECIMAL_PLACES.PRICE)} (+${tpPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)\r\nðŸ“¦ Closed: ${sizePercent}% of position\r\n\r\nðŸ’¸ Estimated Profit: ~${(\r\n    ((position.marginUsed * sizePercent) / PERCENT_MULTIPLIER) *\r\n      (tpPercent / PERCENT_MULTIPLIER) *\r\n      position.leverage\r\n  ).toFixed(DECIMAL_PLACES.PERCENT)} USDT\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Stop moved to breakeven\r\n   */\r\n  async notifyBreakeven(position: Position, newStopPrice: number): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'ðŸŸ¢' : 'ðŸ”´';\r\n\r\n    const message = `\r\nðŸ›¡ï¸ <b>STOP MOVED TO BREAKEVEN!</b>\r\n\r\n${sideEmoji} ${position.symbol} ${position.side.toUpperCase()}\r\nðŸ’° Entry: $${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nðŸ›¡ï¸ New Stop: $${newStopPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\n\r\nâœ… Risk-free position! Minimum profit guaranteed.\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Trailing stop activated\r\n   */\r\n  async notifyTrailingActivated(\r\n    position: Position,\r\n    currentPrice: number,\r\n    newStopPrice: number,\r\n    trailingPercent: number,\r\n  ): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'ðŸŸ¢' : 'ðŸ”´';\r\n\r\n    const message = `\r\nðŸ“ˆ <b>TRAILING STOP ACTIVATED!</b>\r\n\r\n${sideEmoji} ${position.symbol} ${position.side.toUpperCase()}\r\nðŸ’° Current Price: $${currentPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nðŸ›¡ï¸ New Stop: $${newStopPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nðŸ“Š Trailing Distance: ${trailingPercent.toFixed(DECIMAL_PLACES.PERCENT)}%\r\n\r\nðŸŽ¯ Locking in profits! Stop will follow price movement.\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Trailing stop updated (silent, only debug)\r\n   */\r\n  async notifyTrailingUpdated(\r\n    position: Position,\r\n    newStopPrice: number,\r\n  ): Promise<void> {\r\n    // Silent notification - only log, don't spam Telegram\r\n    this.logger.debug('ðŸ“ˆ Trailing stop updated', {\r\n      symbol: position.symbol,\r\n      newStop: newStopPrice,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notification: Trade signal (entry/exit)\r\n   */\r\n  async sendTradeNotification(params: {\r\n    type: 'ENTRY' | 'EXIT';\r\n    direction: SignalDirection;\r\n    price: number;\r\n    stopLoss?: number;\r\n    takeProfits?: Array<{ level: number; price: number; sizePercent: number }>;\r\n    confidence?: number;\r\n    reason?: string;\r\n    pnl?: number;\r\n    pnlPercent?: number;\r\n  }): Promise<void> {\r\n    const emoji = params.type === 'ENTRY'\r\n      ? (params.direction === SignalDirection.LONG ? 'ðŸŸ¢' : 'ðŸ”´')\r\n      : 'âšª';\r\n\r\n    let message = `\r\n${emoji} <b>${params.type}: ${params.direction}</b>\r\n\r\nðŸ’° Price: $${params.price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n    if (params.type === 'ENTRY') {\r\n      if (params.stopLoss) {\r\n        message += `\\nðŸ›¡ï¸ Stop Loss: $${params.stopLoss.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n      }\r\n      if (params.takeProfits && params.takeProfits.length > 0) {\r\n        message += '\\nðŸŽ¯ Take Profits:';\r\n        params.takeProfits.forEach(tp => {\r\n          message += `\\n  â€¢ TP${tp.level}: $${tp.price.toFixed(DECIMAL_PLACES.PRICE)} (${tp.sizePercent}%)`;\r\n        });\r\n      }\r\n      if (params.confidence) {\r\n        message += `\\nðŸ“Š Confidence: ${(params.confidence * PERCENT_MULTIPLIER).toFixed(0)}%`;\r\n      }\r\n      if (params.reason) {\r\n        message += `\\nðŸ“ Reason: ${params.reason}`;\r\n      }\r\n    } else {\r\n      // EXIT\r\n      if (params.pnl !== undefined) {\r\n        const pnlSign = params.pnl >= 0 ? '+' : '';\r\n        message += `\\nðŸ’µ PnL: ${pnlSign}$${params.pnl.toFixed(DECIMAL_PLACES.PERCENT)}`;\r\n      }\r\n      if (params.pnlPercent !== undefined) {\r\n        const pnlSign = params.pnlPercent >= 0 ? '+' : '';\r\n        message += `\\nðŸ“ˆ PnL%: ${pnlSign}${params.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)}%`;\r\n      }\r\n      if (params.reason) {\r\n        message += `\\nðŸ“ Reason: ${params.reason}`;\r\n      }\r\n    }\r\n\r\n    message += `\\nâ° Time: ${new Date().toISOString()}`;\r\n    message = message.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Critical error\r\n   */\r\n  async notifyError(errorType: string, details: string): Promise<void> {\r\n    const message = `\r\nâš ï¸ <b>ERROR: ${errorType}</b>\r\n\r\n${details}\r\n\r\nâ° Time: ${new Date().toISOString()}\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Send critical alert message\r\n   * Used for emergency notifications (unprotected positions, etc)\r\n   */\r\n  async sendAlert(message: string): Promise<void> {\r\n    await this.sendMessage(message);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\tf-alignment.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENT_MULTIPLIER' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS } from '../constants';\r\n/**\r\n * Timeframe Alignment Service (PHASE 6)\r\n *\r\n * Calculates multi-timeframe alignment score to boost signal confidence.\r\n * When all timeframes agree on direction, signal gets higher confidence.\r\n *\r\n * Scoring Logic:\r\n * - Entry TF (M1): price > EMA20 â†’ +20 points\r\n * - Primary TF (M5): price > EMA20 â†’ +30, price > EMA50 â†’ +20\r\n * - Trend1 TF (M30): EMA20 > EMA50 â†’ +30 points\r\n *\r\n * Total: 0-100 points\r\n * If score >= minAlignmentScore â†’ aligned = true\r\n *\r\n * Example:\r\n * LONG signal at $100\r\n * - Entry M1: $100 > EMA20($99) âœ… +20 points\r\n * - Primary M5: $100 > EMA20($98) âœ… +30, $100 > EMA50($97) âœ… +20\r\n * - Trend1 M30: EMA20($99) > EMA50($96) âœ… +30 points\r\n * Total: 100 points â†’ fully aligned â†’ boost confidence\r\n */\r\n\r\nimport { TFAlignmentConfig, TFAlignmentResult, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PERCENT_MULTIPLIER = 100;\r\nconst PRIMARY_EMA20_WEIGHT = CONFIDENCE_THRESHOLDS.LOW; // 60% of primary weight\r\nconst PRIMARY_EMA50_WEIGHT = 0.4; // 40% of primary weight\r\n\r\n// ============================================================================\r\n// TF ALIGNMENT SERVICE\r\n// ============================================================================\r\n\r\nexport class TFAlignmentService {\r\n  constructor(\r\n    private config: TFAlignmentConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Calculate timeframe alignment score\r\n   *\r\n   * @param direction - Trade direction ('LONG' or 'SHORT')\r\n   * @param currentPrice - Current market price\r\n   * @param indicators - Indicator values from all timeframes\r\n   * @returns TFAlignmentResult with score, aligned flag, contributions, and details\r\n   */\r\n  calculateAlignment(\r\n    direction: 'LONG' | 'SHORT',\r\n    currentPrice: number,\r\n    indicators: {\r\n      entry: { ema20: number };\r\n      primary: { ema20: number; ema50: number };\r\n      trend1: { ema20: number; ema50: number };\r\n    },\r\n  ): TFAlignmentResult {\r\n    if (!this.config.enabled) {\r\n      return this.createDisabledResult();\r\n    }\r\n\r\n    let score = 0;\r\n    const contributions = { entry: 0, primary: 0, trend1: 0 };\r\n\r\n    // ========================================================================\r\n    // Entry TF (M1): Price vs EMA20\r\n    // ========================================================================\r\n    const entryAligned =\r\n      direction === 'LONG'\r\n        ? currentPrice > indicators.entry.ema20\r\n        : currentPrice < indicators.entry.ema20;\r\n\r\n    if (entryAligned) {\r\n      contributions.entry = this.config.timeframes.entry.weight;\r\n      score += contributions.entry;\r\n    }\r\n\r\n    // ========================================================================\r\n    // Primary TF (M5): Price vs EMA20 + EMA50\r\n    // ========================================================================\r\n    const primaryEMA20Aligned =\r\n      direction === 'LONG'\r\n        ? currentPrice > indicators.primary.ema20\r\n        : currentPrice < indicators.primary.ema20;\r\n\r\n    const primaryEMA50Aligned =\r\n      direction === 'LONG'\r\n        ? currentPrice > indicators.primary.ema50\r\n        : currentPrice < indicators.primary.ema50;\r\n\r\n    if (primaryEMA20Aligned) {\r\n      contributions.primary +=\r\n        this.config.timeframes.primary.weight * PRIMARY_EMA20_WEIGHT;\r\n    }\r\n\r\n    if (primaryEMA50Aligned) {\r\n      contributions.primary +=\r\n        this.config.timeframes.primary.weight * PRIMARY_EMA50_WEIGHT;\r\n    }\r\n\r\n    score += contributions.primary;\r\n\r\n    // ========================================================================\r\n    // Trend1 TF (M30): EMA20 vs EMA50 (trend direction)\r\n    // ========================================================================\r\n    const trend1Aligned =\r\n      direction === 'LONG'\r\n        ? indicators.trend1.ema20 > indicators.trend1.ema50\r\n        : indicators.trend1.ema20 < indicators.trend1.ema50;\r\n\r\n    if (trend1Aligned) {\r\n      contributions.trend1 = this.config.timeframes.trend1.weight;\r\n      score += contributions.trend1;\r\n    }\r\n\r\n    // ========================================================================\r\n    // Result\r\n    // ========================================================================\r\n    const aligned = score >= this.config.minAlignmentScore;\r\n\r\n    const details = `Entry: ${contributions.entry}, Primary: ${contributions.primary.toFixed(0)}, Trend1: ${contributions.trend1}`;\r\n\r\n    this.logger.debug('TF Alignment calculated', {\r\n      direction,\r\n      score: score.toFixed(0),\r\n      aligned,\r\n      details,\r\n    });\r\n\r\n    return {\r\n      score,\r\n      aligned,\r\n      contributions,\r\n      details,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create result for disabled service\r\n   */\r\n  private createDisabledResult(): TFAlignmentResult {\r\n    return {\r\n      score: 0,\r\n      aligned: false,\r\n      contributions: { entry: 0, primary: 0, trend1: 0 },\r\n      details: 'TF Alignment disabled',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get configuration\r\n   */\r\n  getConfig(): TFAlignmentConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\tick-delta-analyzer.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.0.","line":122,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":122,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":127,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":17},{"ruleId":"complexity","severity":1,"message":"Method 'detectMomentumSpike' has a complexity of 13. Maximum allowed is 10.","line":140,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":241,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.0.","line":189,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":189,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":191,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.0.","line":206,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":206,"endColumn":66},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":209,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":209,"endColumn":21},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":249,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":249,"endColumn":68}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\n/**\n * Tick Delta Analyzer Service (Phase 4)\n *\n * Analyzes buy/sell tick delta for momentum detection.\n *\n * Features:\n * - Tracks tick history (buy/sell trades)\n * - Calculates buy/sell delta ratio\n * - Detects momentum spikes (e.g., 2x more buys than sells)\n * - Automatic cleanup of old ticks\n *\n * Example:\n * - 40 buy ticks, 15 sell ticks â†’ deltaRatio = 2.67 â†’ BUY momentum spike\n * - 10 buy ticks, 35 sell ticks â†’ deltaRatio = 0.29 (inverse 3.5) â†’ SELL momentum spike\n */\n\nimport {\n  LoggerService,\n  SignalDirection,\n  Tick,\n  MomentumSpike,\n  TickDeltaAnalyzerConfig,\n} from '../types';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nconst MAX_TICK_HISTORY = 1000; // Max ticks to keep in memory\nconst CLEANUP_INTERVAL_MS = 10000; // Cleanup old ticks every 10s\n\n// ============================================================================\n// TICK DELTA ANALYZER SERVICE\n// ============================================================================\n\nexport class TickDeltaAnalyzerService {\n  private tickHistory: Tick[] = [];\n  private lastCleanupTime: number = Date.now();\n\n  constructor(\n    private config: TickDeltaAnalyzerConfig,\n    private logger: LoggerService,\n  ) {\n    this.logger.info('TickDeltaAnalyzerService initialized', {\n      minDeltaRatio: config.minDeltaRatio,\n      detectionWindow: config.detectionWindow,\n      minTickCount: config.minTickCount,\n      minVolumeUSDT: config.minVolumeUSDT,\n    });\n  }\n\n  // ==========================================================================\n  // PUBLIC METHODS\n  // ==========================================================================\n\n  /**\n   * Add new tick to history\n   *\n   * @param tick - New trade/tick\n   */\n  addTick(tick: Tick): void {\n    this.tickHistory.push(tick);\n\n    // Limit history size\n    if (this.tickHistory.length > MAX_TICK_HISTORY) {\n      this.tickHistory.shift(); // Remove oldest tick\n    }\n\n    // Periodic cleanup\n    if (Date.now() - this.lastCleanupTime > CLEANUP_INTERVAL_MS) {\n      this.cleanupOldTicks();\n    }\n\n    //     this.logger.debug('Tick added', {\n    //       side: tick.side,\n    //       price: tick.price,\n    //       size: tick.size,\n    //       historySize: this.tickHistory.length,\n    //     });\n  }\n\n  /**\n   * Calculate buy/sell delta ratio for recent window\n   *\n   * Returns ratio of buy volume to sell volume.\n   * - Ratio > 1: More buy pressure (bullish)\n   * - Ratio < 1: More sell pressure (bearish)\n   *\n   * @param windowMs - Time window to analyze (ms, default: config.detectionWindow)\n   * @returns Delta ratio (buy/sell)\n   */\n  calculateDeltaRatio(windowMs: number = this.config.detectionWindow): number {\n    const cutoffTime = Date.now() - windowMs;\n\n    // Filter ticks in window\n    const recentTicks = this.tickHistory.filter((tick) => tick.timestamp >= cutoffTime);\n\n    if (recentTicks.length === 0) {\n      return 1.0; // Neutral (no data)\n    }\n\n    // Calculate buy and sell volumes\n    let buyVolume = 0;\n    let sellVolume = 0;\n\n    for (const tick of recentTicks) {\n      if (tick.side === 'BUY') {\n        buyVolume += tick.size;\n      } else {\n        sellVolume += tick.size;\n      }\n    }\n\n    // Avoid division by zero\n    if (sellVolume === 0 && buyVolume === 0) {\n      return 1.0; // Neutral (no volume)\n    }\n\n    if (sellVolume === 0) {\n      // Only buys: strong bullish, but cap at reasonable max (10x instead of 999)\n      return 10.0;\n    }\n\n    if (buyVolume === 0) {\n      // Only sells: strong bearish (inverse will be 10x for SHORT)\n      return 0.1;\n    }\n\n    return buyVolume / sellVolume;\n  }\n\n  /**\n   * Detect momentum spike from recent ticks\n   *\n   * Checks if delta ratio exceeds threshold and meets volume requirements.\n   *\n   * @returns MomentumSpike if detected, null otherwise\n   */\n  detectMomentumSpike(): MomentumSpike | null {\n    const cutoffTime = Date.now() - this.config.detectionWindow;\n\n    // Filter recent ticks\n    const recentTicks = this.tickHistory.filter((tick) => tick.timestamp >= cutoffTime);\n\n    // Check min tick count\n    if (recentTicks.length < this.config.minTickCount) {\n      this.logger.debug('Not enough ticks for momentum detection', {\n        tickCount: recentTicks.length,\n        minRequired: this.config.minTickCount,\n      });\n      return null;\n    }\n\n    // Calculate volumes\n    let buyVolume = 0;\n    let sellVolume = 0;\n    let totalVolumeContracts = 0;\n\n    for (const tick of recentTicks) {\n      totalVolumeContracts += tick.size;\n      if (tick.side === 'BUY') {\n        buyVolume += tick.size;\n      } else {\n        sellVolume += tick.size;\n      }\n    }\n\n    // Calculate average price for USDT volume estimation\n    const avgPrice =\n      recentTicks.reduce((sum, tick) => sum + tick.price, 0) / recentTicks.length;\n    const volumeUSDT = totalVolumeContracts * avgPrice;\n\n    // Check min volume\n    if (volumeUSDT < this.config.minVolumeUSDT) {\n      this.logger.debug('Volume too low for momentum spike', {\n        volumeUSDT,\n        minRequired: this.config.minVolumeUSDT,\n      });\n      return null;\n    }\n\n    // Calculate delta ratio (with safety checks)\n    let deltaRatio: number;\n    if (sellVolume === 0 && buyVolume === 0) {\n      this.logger.debug('No volume in window', {volumeUSDT});\n      return null; // Skip if no volume\n    } else if (sellVolume === 0) {\n      deltaRatio = 10.0; // Cap at 10x instead of 999\n    } else if (buyVolume === 0) {\n      deltaRatio = 0.1; // Inverse 10x for SHORT\n    } else {\n      deltaRatio = buyVolume / sellVolume;\n    }\n\n    // Detect spike\n    let direction: SignalDirection | null = null;\n    let actualRatio = deltaRatio;\n\n    if (deltaRatio >= this.config.minDeltaRatio) {\n      // Buy momentum\n      direction = SignalDirection.LONG;\n    } else if (deltaRatio <= 1 / this.config.minDeltaRatio) {\n      // Sell momentum (inverse ratio)\n      direction = SignalDirection.SHORT;\n      actualRatio = buyVolume > 0 ? sellVolume / buyVolume : 10.0; // Safe division\n    }\n\n    if (direction == null) {\n      this.logger.debug('Delta ratio not strong enough', {\n        deltaRatio,\n        minRequired: this.config.minDeltaRatio,\n      });\n      return null;\n    }\n\n    // Calculate confidence (0-maxConfidence)\n    // Higher ratio = higher confidence\n    const confidence = Math.min(\n      this.config.maxConfidence,\n      ((actualRatio - this.config.minDeltaRatio) / this.config.minDeltaRatio) * PERCENT_MULTIPLIER,\n    );\n\n    const spike: MomentumSpike = {\n      direction,\n      deltaRatio: actualRatio,\n      confidence,\n      tickCount: recentTicks.length,\n      volumeUSDT,\n    };\n\n    this.logger.info('ðŸš€ Momentum spike detected!', {\n      direction,\n      deltaRatio: actualRatio.toFixed(DECIMAL_PLACES.PERCENT),\n      confidence: confidence.toFixed(1),\n      tickCount: recentTicks.length,\n      volumeUSDT: volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\n    });\n\n    return spike;\n  }\n\n  /**\n   * Cleanup old ticks beyond detection window\n   *\n   * Removes ticks older than 2x detection window\n   */\n  cleanupOldTicks(): void {\n    const cutoffTime = Date.now() - this.config.detectionWindow * 2;\n    const beforeCount = this.tickHistory.length;\n\n    this.tickHistory = this.tickHistory.filter((tick) => tick.timestamp >= cutoffTime);\n\n    const afterCount = this.tickHistory.length;\n    const removed = beforeCount - afterCount;\n\n    if (removed > 0) {\n      this.logger.debug('Old ticks cleaned up', {\n        removed,\n        remaining: afterCount,\n      });\n    }\n\n    this.lastCleanupTime = Date.now();\n  }\n\n  /**\n   * Get tick history (for testing/debugging)\n   */\n  getTickHistory(): Tick[] {\n    return this.tickHistory;\n  }\n\n  /**\n   * Clear all tick history (for testing)\n   */\n  clearHistory(): void {\n    this.tickHistory = [];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\time.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":39,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":39,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":40,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":40,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":47,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":47,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[1210,1225],"text":"(syncIntervalMs === 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[1210,1225],"text":"(Number.isNaN(syncIntervalMs))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1210,1225],"text":"(!Boolean(syncIntervalMs))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":69,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":69,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1778,1796],"text":"this.bybitService == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":198,"column":10,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":198,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[5419,5427],"text":"dateStr.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[5419,5427],"text":"dateStr === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5419,5427],"text":"!Boolean(dateStr)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Time Service\r\n * Synchronization with exchange server time\r\n *\r\n * Responsibilities:\r\n * - Time offset calculation and management\r\n * - Periodic synchronization with exchange\r\n * - Time conversion (local <-> server)\r\n * - Sync health monitoring\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\nimport { BybitService } from './bybit';\r\n\r\n/**\r\n * Sync info return type\r\n */\r\ninterface SyncInfo {\r\n  offset: number;\r\n  lastSync: Date;\r\n  isRecent: boolean;\r\n  nextSyncIn: number;\r\n}\r\n\r\n/**\r\n * TimeService - Synchronization with exchange server time\r\n */\r\nexport class TimeService {\r\n  private logger: LoggerService;\r\n  private syncInterval: number;\r\n  private maxSyncFailures: number;\r\n  private bybitService?: BybitService;\r\n\r\n  private timeOffset: number = 0; // Ñ€Ð°Ð·Ð½Ð¸Ñ†Ð° Ð¼ÐµÐ¶Ð´Ñƒ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¼ Ð²Ñ€ÐµÐ¼ÐµÐ½ÐµÐ¼ Ð¸ Ð²Ñ€ÐµÐ¼ÐµÐ½ÐµÐ¼ Ð±Ð¸Ñ€Ð¶Ð¸\r\n  private lastSyncTime: number = 0;\r\n  private criticalSyncFailures: number = 0;\r\n\r\n  // Constants\r\n  private static readonly TIME_SYNC_DEFAULT_MAX_FAILURES = 3;\r\n  private static readonly TIME_SYNC_LATENCY_DIVISOR = 2;\r\n\r\n  constructor(\r\n    logger: LoggerService,\r\n    syncIntervalMs: number,\r\n    maxSyncFailures: number = TimeService.TIME_SYNC_DEFAULT_MAX_FAILURES,\r\n  ) {\r\n    if (!syncIntervalMs || syncIntervalMs <= 0) {\r\n      throw new Error(\r\n        'TimeService: syncIntervalMs is required and must be positive',\r\n      );\r\n    }\r\n\r\n    this.logger = logger;\r\n    this.syncInterval = syncIntervalMs;\r\n    this.maxSyncFailures = maxSyncFailures;\r\n  }\r\n\r\n  /**\r\n   * Set Bybit service for time synchronization\r\n   */\r\n  public setBybitService(bybitService: BybitService): void {\r\n    this.bybitService = bybitService;\r\n  }\r\n\r\n  /**\r\n   * Synchronize time with exchange server\r\n   */\r\n  public async syncWithExchange(): Promise<void> {\r\n    if (!this.bybitService) {\r\n      this.logger.warn('âš ï¸ Bybit service not set for time sync');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const localTimeBefore = Date.now();\r\n\r\n      // Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ getServerTime Ð¸Ð· bybit-api SDK\r\n      const serverTime = await this.bybitService.getServerTime();\r\n\r\n      const localTimeAfter = Date.now();\r\n      const networkLatency =\r\n        (localTimeAfter - localTimeBefore) / TimeService.TIME_SYNC_LATENCY_DIVISOR;\r\n\r\n      // Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÑÐµÐ¼ Ñ€Ð°Ð·Ð½Ð¸Ñ†Ñƒ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ (ÑÐµÑ€Ð²ÐµÑ€Ð½Ð¾Ðµ - Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ)\r\n      if (serverTime === undefined) {\r\n        throw new Error('CRITICAL: Server time is undefined');\r\n      }\r\n\r\n      this.timeOffset = serverTime - localTimeAfter;\r\n      this.lastSyncTime = localTimeAfter;\r\n\r\n      // Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÑ‡ÐµÑ‚Ñ‡Ð¸Ðº Ð¾ÑˆÐ¸Ð±Ð¾Ðº Ð¿Ñ€Ð¸ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾Ð¹ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸\r\n      this.criticalSyncFailures = 0;\r\n\r\n      this.logger.info('â° Time synchronized with Bybit', {\r\n        serverTime: new Date(Number(serverTime)).toISOString(),\r\n        localTime: new Date(localTimeAfter).toISOString(),\r\n        offset: this.timeOffset,\r\n        latency: networkLatency,\r\n      });\r\n    } catch (error) {\r\n      this.criticalSyncFailures++;\r\n\r\n      this.logger.error('âŒ Failed to sync time with exchange', {\r\n        error,\r\n        failureCount: this.criticalSyncFailures,\r\n        maxAllowed: this.maxSyncFailures,\r\n      });\r\n\r\n      if (this.criticalSyncFailures >= this.maxSyncFailures) {\r\n        this.logger.warn('âš ï¸ Time sync failed, continuing with local time', {\r\n          failureCount: this.criticalSyncFailures,\r\n          note: 'Demo trading can continue without precise time sync',\r\n        });\r\n        // Continue without throwing - demo trading is more resilient\r\n      }\r\n\r\n      // ÐÐµ ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ timeOffset = 0 - Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ð¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ offset\r\n      this.logger.warn(\r\n        `âš ï¸ Using last known time offset: ${this.timeOffset}ms`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure time is synchronized (auto-sync if needed)\r\n   */\r\n  public async ensureSync(): Promise<void> {\r\n    const now = Date.now();\r\n\r\n    // Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ ÐµÑÐ»Ð¸ Ð¿Ñ€Ð¾ÑˆÐ»Ð¾ Ð±Ð¾Ð»ÑŒÑˆÐµ syncInterval Ð¸Ð»Ð¸ ÐµÑ‰Ðµ Ð½Ðµ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð»Ð¸ÑÑŒ\r\n    if (\r\n      now - this.lastSyncTime > this.syncInterval ||\r\n      this.lastSyncTime === 0\r\n    ) {\r\n      await this.syncWithExchange();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current timestamp synchronized with exchange\r\n   */\r\n  public now(): number {\r\n    return Date.now() + this.timeOffset;\r\n  }\r\n\r\n  /**\r\n   * Get Date object synchronized with exchange\r\n   */\r\n  public nowDate(): Date {\r\n    return new Date(this.now());\r\n  }\r\n\r\n  /**\r\n   * Convert local timestamp to server time\r\n   */\r\n  public toServerTime(localTimestamp: number): number {\r\n    return localTimestamp + this.timeOffset;\r\n  }\r\n\r\n  /**\r\n   * Convert server timestamp to local time\r\n   */\r\n  public toLocalTime(serverTimestamp: number): number {\r\n    return serverTimestamp - this.timeOffset;\r\n  }\r\n\r\n  /**\r\n   * Check if sync is recent (within sync interval)\r\n   */\r\n  public isSyncRecent(): boolean {\r\n    return Date.now() - this.lastSyncTime < this.syncInterval;\r\n  }\r\n\r\n  /**\r\n   * Get synchronization information\r\n   */\r\n  public getSyncInfo(): SyncInfo {\r\n    const now = Date.now();\r\n    const nextSyncIn = Math.max(\r\n      0,\r\n      this.syncInterval - (now - this.lastSyncTime),\r\n    );\r\n\r\n    return {\r\n      offset: this.timeOffset,\r\n      lastSync: new Date(this.lastSyncTime),\r\n      isRecent: this.isSyncRecent(),\r\n      nextSyncIn,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get today's date string (for logging filenames)\r\n   */\r\n  public getTodayString(): string {\r\n    const dateStr = this.nowDate().toISOString().split('T')[0];\r\n    if (!dateStr) {\r\n      throw new Error('Failed to get date string');\r\n    }\r\n    return dateStr;\r\n  }\r\n\r\n  /**\r\n   * Get bot uptime (for trading statistics)\r\n   */\r\n  public getUptime(startTime: number): number {\r\n    return this.now() - startTime;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\trade-history.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":129,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":129,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":132,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":132,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":134,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":134,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":137,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":137,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":152,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":152,"endColumn":71},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'appendTrade' has no 'await' expression.","line":258,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":258,"endColumn":20},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'readAllTrades' has no 'await' expression.","line":316,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":316,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":330,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":330,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9221,9224],"text":"row != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":353,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":353,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[9800,9809],"text":"(values[i].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[9800,9809],"text":"(values[i] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9800,9809],"text":"(Boolean(values[i]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":369,"column":27,"nodeType":"CallExpression","messageId":"conditionErrorNumber","endLine":369,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[10194,10211],"text":"(parseFloat(value) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[10194,10211],"text":"(!Number.isNaN(parseFloat(value)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10194,10211],"text":"(Boolean(parseFloat(value)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":371,"column":27,"nodeType":"CallExpression","messageId":"conditionErrorNumber","endLine":371,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[10287,10302],"text":"(parseInt(value) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[10287,10302],"text":"(!Number.isNaN(parseInt(value)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10287,10302],"text":"(Boolean(parseInt(value)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":371,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":371,"endColumn":48},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":377,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":381,"endColumn":12},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getTotalTrades' has no 'await' expression.","line":437,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":437,"endColumn":23},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (334). Maximum allowed is 300.","line":463,"column":1,"nodeType":null,"messageId":"exceed","endLine":507,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":478,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":478,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[12876,12902],"text":"(byStrategy[trade.strategy] !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[12876,12902],"text":"(!Number.isNaN(byStrategy[trade.strategy]))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12876,12902],"text":"(Boolean(byStrategy[trade.strategy]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":479,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":479,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[12966,12997],"text":"(bySession[trade.sessionVersion] !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[12966,12997],"text":"(!Number.isNaN(bySession[trade.sessionVersion]))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12966,12997],"text":"(Boolean(bySession[trade.sessionVersion]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":500,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":500,"endColumn":42,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13535,13551],"text":"(Boolean(trade[fieldName]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":501,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":501,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[13587,13597],"text":"(stats[key] !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[13587,13597],"text":"(!Number.isNaN(stats[key]))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13587,13597],"text":"(Boolean(stats[key]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\n/**\n * Trade History Service with Dynamic Schema\n *\n * Manages permanent trade history in CSV format with automatic schema expansion.\n * - Append-only: never deletes data\n * - Dynamic schema: automatically adds new columns when new fields are detected\n * - Backward compatible: old records work with new schema (empty values for new fields)\n * - Auto-migration: expands CSV when new fields are added\n *\n * Usage:\n * ```typescript\n * const history = new TradeHistoryService(logger);\n * await history.appendTrade({\n *   ...coreFields,\n *   rsiEntry: 30.5,  // New field? Automatically added to schema!\n *   customIndicator: 'value'\n * });\n * ```\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { LoggerService } from '../types';\nimport { extractErrorMessage } from '../utils/error-helper';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n// Core fields (always present in every record)\nconst CORE_FIELDS = [\n  'timestamp',\n  'id',\n  'symbol',\n  'side',\n  'strategy',\n  'entryPrice',\n  'exitPrice',\n  'quantity',\n  'leverage',\n  'pnl',\n  'fees',\n  'netPnl',\n  'duration',\n  'exitType',\n  'confidence',\n  'virtualBalanceBefore',\n  'virtualBalanceAfter',\n  'sessionVersion',\n  'notes',\n];\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface TradeRecord {\n  // Core fields (required)\n  timestamp: string;\n  id: string;\n  symbol: string;\n  side: string;\n  strategy: string;\n  entryPrice: number;\n  exitPrice: number;\n  quantity: number;\n  leverage: number;\n  pnl: number;\n  fees: number;\n  netPnl: number;\n  duration: string;\n  exitType: string;\n  confidence: number;\n  virtualBalanceBefore: number;\n  virtualBalanceAfter: number;\n  sessionVersion: string;\n  notes: string;\n\n  // Dynamic fields (any additional indicators, conditions, etc)\n  [key: string]: unknown;\n}\n\n// ============================================================================\n// TRADE HISTORY SERVICE\n// ============================================================================\n\nexport class TradeHistoryService {\n  private csvPath: string;\n  private schemaPath: string;\n  private currentSchema: string[] = [];\n\n  constructor(\n    private logger: LoggerService,\n    private dataDir: string = './data',\n  ) {\n    this.csvPath = path.join(this.dataDir, 'trade-history.csv');\n    this.schemaPath = path.join(this.dataDir, 'csv-schema.json');\n    this.initialize();\n  }\n\n  /**\n   * Initialize CSV and schema\n   */\n  private initialize(): void {\n    if (!fs.existsSync(this.dataDir)) {\n      fs.mkdirSync(this.dataDir, { recursive: true });\n    }\n\n    // Load or create schema\n    this.currentSchema = this.loadSchema();\n\n    // Ensure CSV exists\n    if (!fs.existsSync(this.csvPath)) {\n      this.createCSV();\n    } else {\n      // Verify schema matches CSV header\n      this.verifyAndMigrateSchema();\n    }\n  }\n\n  /**\n   * Load schema from file\n   */\n  private loadSchema(): string[] {\n    try {\n      if (fs.existsSync(this.schemaPath)) {\n        const content = fs.readFileSync(this.schemaPath, 'utf-8');\n        const schema = JSON.parse(content);\n\n        this.logger.info('âœ… CSV schema loaded', {\n          fields: schema.length,\n          coreFields: CORE_FIELDS.length,\n          customFields: schema.length - CORE_FIELDS.length,\n        });\n\n        return schema;\n      }\n    } catch (error: unknown) {\n      this.logger.error('âŒ Failed to load schema', { error, errorMessage: extractErrorMessage(error) });\n    }\n\n    // Return core fields as default\n    return [...CORE_FIELDS];\n  }\n\n  /**\n   * Save schema to file\n   */\n  private saveSchema(schema: string[]): void {\n    try {\n      fs.writeFileSync(this.schemaPath, JSON.stringify(schema, null, 2), 'utf-8');\n\n      this.logger.debug('ðŸ“ Schema saved', { fields: schema.length });\n    } catch (error: unknown) {\n      this.logger.error('âŒ Failed to save schema', { error, errorMessage: extractErrorMessage(error) });\n    }\n  }\n\n  /**\n   * Create new CSV with current schema\n   */\n  private createCSV(): void {\n    const header = this.currentSchema.join(',');\n    fs.writeFileSync(this.csvPath, header + '\\n', 'utf-8');\n\n    this.logger.info('âœ… Trade history CSV created', {\n      path: this.csvPath,\n      fields: this.currentSchema.length,\n    });\n  }\n\n  /**\n   * Verify CSV header matches schema, migrate if needed\n   */\n  private verifyAndMigrateSchema(): void {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n');\n\n      if (lines.length === 0) {\n        this.createCSV();\n        return;\n      }\n\n      const existingHeader = lines[0].split(',').map((h) => h.trim());\n\n      // Check if schema has new fields\n      const newFields = this.currentSchema.filter((field) => !existingHeader.includes(field));\n\n      if (newFields.length > 0) {\n        this.logger.warn('ðŸ”„ CSV schema migration needed', {\n          newFields,\n          oldColumns: existingHeader.length,\n          newColumns: this.currentSchema.length,\n        });\n\n        this.migrateCSV(existingHeader, newFields);\n      }\n    } catch (error: unknown) {\n      this.logger.error('âŒ Failed to verify schema', { error, errorMessage: extractErrorMessage(error) });\n    }\n  }\n\n  /**\n   * Migrate CSV to new schema (add columns)\n   */\n  private migrateCSV(oldHeader: string[], newFields: string[]): void {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n').filter(Boolean);\n\n      // Create backup\n      const backupPath = this.csvPath + '.backup.' + Date.now();\n      fs.writeFileSync(backupPath, content, 'utf-8');\n\n      this.logger.info('ðŸ’¾ Backup created', { path: backupPath });\n\n      // Build new header\n      const newHeader = [...oldHeader, ...newFields];\n\n      // Rebuild CSV\n      const newLines: string[] = [newHeader.join(',')];\n\n      // Migrate each data line (add empty values for new fields)\n      for (let i = 1; i < lines.length; i++) {\n        const values = this.splitCSVLine(lines[i]);\n\n        // Add empty values for new fields\n        for (let j = 0; j < newFields.length; j++) {\n          values.push(''); // Empty value for new field\n        }\n\n        newLines.push(values.join(','));\n      }\n\n      // Write migrated CSV\n      fs.writeFileSync(this.csvPath, newLines.join('\\n') + '\\n', 'utf-8');\n\n      // Update schema\n      this.currentSchema = newHeader;\n      this.saveSchema(newHeader);\n\n      this.logger.info('âœ… CSV migrated successfully', {\n        addedFields: newFields,\n        totalRecords: lines.length - 1,\n        newColumns: newHeader.length,\n      });\n    } catch (error: unknown) {\n      this.logger.error('âŒ CSV migration failed', { error, errorMessage: extractErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Append trade with dynamic fields\n   */\n  async appendTrade(record: TradeRecord): Promise<void> {\n    try {\n      // Detect new fields in this record\n      const recordFields = Object.keys(record);\n      const newFields = recordFields.filter((field) => !this.currentSchema.includes(field));\n\n      if (newFields.length > 0) {\n        this.logger.info('ðŸ†• New fields detected', { fields: newFields });\n\n        // Add to schema\n        this.currentSchema.push(...newFields);\n        this.saveSchema(this.currentSchema);\n\n        // Migrate CSV to include new columns\n        this.verifyAndMigrateSchema();\n      }\n\n      // Build CSV row according to current schema\n      const values: string[] = [];\n\n      for (const field of this.currentSchema) {\n        const value = record[field];\n\n        if (value === undefined || value === null) {\n          values.push(''); // Empty for missing fields\n        } else if (typeof value === 'string') {\n          // Escape commas and quotes\n          const escaped = value.replace(/\"/g, '\"\"');\n          values.push(`\"${escaped}\"`);\n        } else {\n          values.push(String(value));\n        }\n      }\n\n      const csvLine = values.join(',');\n\n      // Append to CSV\n      fs.appendFileSync(this.csvPath, csvLine + '\\n', 'utf-8');\n\n      this.logger.debug('ðŸ“ Trade appended to history', {\n        id: record.id,\n        netPnl: record.netPnl,\n        fields: recordFields.length,\n        newFields: newFields.length,\n      });\n    } catch (error: unknown) {\n      this.logger.error('âŒ Failed to append trade', {\n        error,\n        errorMessage: extractErrorMessage(error),\n        id: record.id,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Read all trades with dynamic schema\n   */\n  async readAllTrades(): Promise<TradeRecord[]> {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n').filter(Boolean);\n\n      if (lines.length <= 1) {\n        return [];\n      }\n\n      const header = lines[0].split(',').map((h) => h.trim());\n      const trades: TradeRecord[] = [];\n\n      for (let i = 1; i < lines.length; i++) {\n        const row = this.parseCSVLine(lines[i], header);\n        if (row) {\n          trades.push(row);\n        }\n      }\n\n      return trades;\n    } catch (error: unknown) {\n      this.logger.error('âŒ Failed to read trades', { error, errorMessage: extractErrorMessage(error) });\n      return [];\n    }\n  }\n\n  /**\n   * Parse CSV line with dynamic schema\n   */\n  private parseCSVLine(line: string, header: string[]): TradeRecord | null {\n    try {\n      const values = this.splitCSVLine(line);\n\n      const record: Record<string, unknown> = {};\n\n      for (let i = 0; i < header.length; i++) {\n        const field = header[i];\n        const value = values[i] || '';\n\n        // Type conversion for known numeric fields\n        if (\n          [\n            'entryPrice',\n            'exitPrice',\n            'quantity',\n            'pnl',\n            'fees',\n            'netPnl',\n            'confidence',\n            'virtualBalanceBefore',\n            'virtualBalanceAfter',\n          ].includes(field)\n        ) {\n          record[field] = parseFloat(value) || 0;\n        } else if (field === 'leverage') {\n          record[field] = parseInt(value) || 10;\n        } else {\n          // Keep as string or try to parse as number for custom fields\n          const unquoted = value.replace(/^\"|\"$/g, '').replace(/\"\"/g, '\"');\n\n          // Try to parse as number if it looks like a number\n          if (!isNaN(Number(unquoted)) && unquoted !== '') {\n            record[field] = parseFloat(unquoted);\n          } else {\n            record[field] = unquoted;\n          }\n        }\n      }\n\n      return record as TradeRecord;\n    } catch (error: unknown) {\n      this.logger.warn('âš ï¸ Failed to parse CSV line', { line });\n      return null;\n    }\n  }\n\n  /**\n   * Split CSV line handling quoted values\n   */\n  private splitCSVLine(line: string): string[] {\n    const values: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          // Escaped quote\n          current += '\"';\n          i++;\n        } else {\n          // Toggle quotes\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        // End of value\n        values.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    // Add last value\n    values.push(current);\n\n    return values;\n  }\n\n  /**\n   * Get current schema\n   */\n  getCurrentSchema(): string[] {\n    return [...this.currentSchema];\n  }\n\n  /**\n   * Get total number of trades\n   */\n  async getTotalTrades(): Promise<number> {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n').filter(Boolean);\n      return Math.max(0, lines.length - 1); // Exclude header\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Get statistics from CSV\n   */\n  async getStatistics(): Promise<{\n    totalTrades: number;\n    totalPnL: number;\n    winRate: number;\n    avgPnL: number;\n    byStrategy: { [key: string]: number };\n    bySession: { [key: string]: number };\n  }> {\n    const trades = await this.readAllTrades();\n\n    if (trades.length === 0) {\n      return {\n        totalTrades: 0,\n        totalPnL: 0,\n        winRate: 0,\n        avgPnL: 0,\n        byStrategy: {},\n        bySession: {},\n      };\n    }\n\n    const wins = trades.filter((t) => t.netPnl > 0).length;\n    const totalPnL = trades.reduce((sum, t) => sum + t.netPnl, 0);\n\n    const byStrategy: { [key: string]: number } = {};\n    const bySession: { [key: string]: number } = {};\n\n    for (const trade of trades) {\n      byStrategy[trade.strategy] = (byStrategy[trade.strategy] || 0) + trade.netPnl;\n      bySession[trade.sessionVersion] = (bySession[trade.sessionVersion] || 0) + trade.netPnl;\n    }\n\n    return {\n      totalTrades: trades.length,\n      totalPnL,\n      winRate: (wins / trades.length) * PERCENT_MULTIPLIER,\n      avgPnL: totalPnL / trades.length,\n      byStrategy,\n      bySession,\n    };\n  }\n\n  /**\n   * Get statistics grouped by custom field\n   */\n  async getStatisticsByField(fieldName: string): Promise<{ [key: string]: number }> {\n    const trades = await this.readAllTrades();\n    const stats: { [key: string]: number } = {};\n\n    for (const trade of trades) {\n      const key = String(trade[fieldName] || 'unknown');\n      stats[key] = (stats[key] || 0) + trade.netPnl;\n    }\n\n    return stats;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\trading-journal.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LogLevel' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":76},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":38,"column":20,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":38,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1369,1377],"text":"(dataPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1369,1377],"text":"(dataPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1369,1377],"text":"(Boolean(dataPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":38,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":38,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1378,1380],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":47,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":47,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1676,1703],"text":"(tradeHistoryConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1676,1703],"text":"(tradeHistoryConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":48,"column":59,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":48,"endColumn":85,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[1765,1791],"text":"(tradeHistoryConfig.dataDir.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[1765,1791],"text":"(tradeHistoryConfig.dataDir !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1765,1791],"text":"(Boolean(tradeHistoryConfig.dataDir))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":51,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":51,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1857,1868],"text":"(baseDeposit != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1857,1868],"text":"(baseDeposit ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1857,1868],"text":"(Boolean(baseDeposit))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 121. Maximum allowed is 120.","line":52,"column":1,"nodeType":"Program","messageId":"max","endLine":52,"endColumn":122},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":52,"column":78,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":52,"endColumn":104,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[1968,1994],"text":"(tradeHistoryConfig.dataDir.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[1968,1994],"text":"(tradeHistoryConfig.dataDir !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1968,1994],"text":"(Boolean(tradeHistoryConfig.dataDir))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":55,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":55,"endColumn":40,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[2078,2078],"text":"void "},"desc":"Add void operator to ignore."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":67,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":67,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2315,2335],"text":"(this.virtualBalance == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":67,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":67,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2339,2357],"text":"(this.tradeHistory == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":88,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":88,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":139,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":139,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[4425,4435],"text":"(params.id.length === 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[4425,4435],"text":"(params.id === \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4425,4435],"text":"(!Boolean(params.id))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":189,"column":27,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":189,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5745,5785],"text":"((this.virtualBalance?.getCurrentBalance()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5745,5785],"text":"((this.virtualBalance?.getCurrentBalance()) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5745,5785],"text":"(Boolean((this.virtualBalance?.getCurrentBalance())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":189,"column":68,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":189,"endColumn":70,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5786,5788],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.0006.","line":203,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":203,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.0006.","line":204,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":204,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":209,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":209,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6467,6486],"text":"this.virtualBalance != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":213,"column":26,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":213,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6582,6622],"text":"((this.virtualBalance?.getCurrentBalance()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6582,6622],"text":"((this.virtualBalance?.getCurrentBalance()) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6582,6622],"text":"(Boolean((this.virtualBalance?.getCurrentBalance())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":213,"column":67,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":213,"endColumn":69,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6623,6625],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":216,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":216,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6689,6706],"text":"(this.tradeHistory != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":216,"column":30,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":216,"endColumn":62,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6710,6742],"text":"((this.tradeHistoryConfig?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6710,6742],"text":"((this.tradeHistoryConfig?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":217,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":217,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6764,6802],"text":"(trade.entryCondition.signal.marketData != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":217,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":217,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6803,6805],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":257,"column":23,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":257,"endColumn":47,"fix":{"range":[8285,8296],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":258,"column":23,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":258,"endColumn":47,"fix":{"range":[8364,8375],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":259,"column":30,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":259,"endColumn":54,"fix":{"range":[8450,8461],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":260,"column":32,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":260,"endColumn":56,"fix":{"range":[8547,8558],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":262,"column":26,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":262,"endColumn":54,"fix":{"range":[8681,8692],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":263,"column":27,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":263,"endColumn":55,"fix":{"range":[8772,8783],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":264,"column":26,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":264,"endColumn":54,"fix":{"range":[8863,8874],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":265,"column":26,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":265,"endColumn":54,"fix":{"range":[8953,8964],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":266,"column":29,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":266,"endColumn":57,"fix":{"range":[9046,9057],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":267,"column":28,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":267,"endColumn":56,"fix":{"range":[9141,9152],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":299,"column":14,"nodeType":"CallExpression","messageId":"conditionErrorString","endLine":299,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[10678,10721],"text":"(params.exitCondition.tpLevelsHit.join(', ').length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[10678,10721],"text":"(params.exitCondition.tpLevelsHit.join(', ') !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10678,10721],"text":"(Boolean(params.exitCondition.tpLevelsHit.join(', ')))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":355,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":355,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11964,11977],"text":"(t.realizedPnL != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11964,11977],"text":"(t.realizedPnL ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11964,11977],"text":"(Boolean(t.realizedPnL))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":356,"column":41,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":356,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12041,12054],"text":"(t.realizedPnL != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12041,12054],"text":"(t.realizedPnL ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12041,12054],"text":"(Boolean(t.realizedPnL))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":358,"column":55,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":358,"endColumn":68,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12134,12147],"text":"(t.realizedPnL != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12134,12147],"text":"(t.realizedPnL ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12134,12147],"text":"(Boolean(t.realizedPnL))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":358,"column":69,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":358,"endColumn":71,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[12148,12150],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":362,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":362,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12239,12274],"text":"((t.exitCondition?.holdingTimeMinutes) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12239,12274],"text":"((t.exitCondition?.holdingTimeMinutes) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12239,12274],"text":"(Boolean((t.exitCondition?.holdingTimeMinutes)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":362,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":362,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[12275,12277],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":384,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":384,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":385,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":385,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":388,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":388,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":390,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":390,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":400,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":400,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13331,13371],"text":"((this.virtualBalance?.getCurrentBalance()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[13331,13371],"text":"((this.virtualBalance?.getCurrentBalance()) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13331,13371],"text":"(Boolean((this.virtualBalance?.getCurrentBalance())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":400,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":400,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[13372,13374],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":414,"column":21,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":414,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13663,13673],"text":"(outputPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[13663,13673],"text":"(outputPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13663,13673],"text":"(Boolean(outputPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":414,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":414,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[13674,13676],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (398). Maximum allowed is 300.","line":424,"column":1,"nodeType":null,"messageId":"exceed","endLine":537,"endColumn":1},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 28. Maximum allowed is 10.","line":464,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":512,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":468,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":468,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14971,14985],"text":"(sig.marketData != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":468,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":468,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14986,14988],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":475,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":475,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15157,15199],"text":"((t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[15157,15199],"text":"((t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15157,15199],"text":"(Boolean((t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":475,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":475,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15200,15202],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":482,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":482,"endColumn":75,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15376,15440],"text":"(((md.rsi as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15376,15440],"text":"(((md.rsi as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15376,15440],"text":"(Boolean(((md.rsi as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":482,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":482,"endColumn":29,"fix":{"range":[15383,15394],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":483,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":483,"endColumn":80,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15458,15527],"text":"(((md.rsiEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15458,15527],"text":"(((md.rsiEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15458,15527],"text":"(Boolean(((md.rsiEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":483,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":483,"endColumn":34,"fix":{"range":[15470,15481],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":484,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":484,"endColumn":81,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15545,15615],"text":"(((md.rsiTrend1 as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15545,15615],"text":"(((md.rsiTrend1 as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15545,15615],"text":"(Boolean(((md.rsiTrend1 as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":484,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":484,"endColumn":35,"fix":{"range":[15558,15569],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":485,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":485,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15633,15695],"text":"(((md.ema as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15633,15695],"text":"(((md.ema as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15633,15695],"text":"(Boolean(((md.ema as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":485,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":485,"endColumn":29,"fix":{"range":[15640,15651],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":486,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":486,"endColumn":78,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15713,15780],"text":"(((md.emaEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15713,15780],"text":"(((md.emaEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15713,15780],"text":"(Boolean(((md.emaEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":486,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":486,"endColumn":34,"fix":{"range":[15725,15736],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":487,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":487,"endColumn":87,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15798,15874],"text":"(((md.distanceToLevel as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15798,15874],"text":"(((md.distanceToLevel as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15798,15874],"text":"(Boolean(((md.distanceToLevel as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":487,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":487,"endColumn":41,"fix":{"range":[15817,15828],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":488,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":488,"endColumn":85,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15892,15966],"text":"(((md.distanceToEma as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15892,15966],"text":"(((md.distanceToEma as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15892,15966],"text":"(Boolean(((md.distanceToEma as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":488,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":488,"endColumn":39,"fix":{"range":[15909,15920],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":489,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":489,"endColumn":83,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[15984,16056],"text":"(((md.volumeRatio as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[15984,16056],"text":"(((md.volumeRatio as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT)) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15984,16056],"text":"(Boolean(((md.volumeRatio as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":489,"column":12,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":489,"endColumn":37,"fix":{"range":[15999,16010],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":490,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":490,"endColumn":29,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16074,16092],"text":"(Boolean(md.swingHighsCount))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":491,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":491,"endColumn":28,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16110,16127],"text":"(Boolean(md.swingLowsCount))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":492,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":492,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16145,16153],"text":"(Boolean(md.trend))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":493,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":493,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16171,16179],"text":"(Boolean(md.trend))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":495,"column":27,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":495,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":496,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":496,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16276,16278],"text":"(ex != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":497,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":497,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16314,16360],"text":"((t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16314,16360],"text":"((t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16314,16360],"text":"(Boolean((t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":497,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":497,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16361,16363],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":498,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":498,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16378,16424],"text":"((ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16378,16424],"text":"((ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16378,16424],"text":"(Boolean((ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":498,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":498,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16425,16427],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":499,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":499,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16442,16475],"text":"((ex?.holdingTimeMinutes.toFixed(1)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16442,16475],"text":"((ex?.holdingTimeMinutes.toFixed(1)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16442,16475],"text":"(Boolean((ex?.holdingTimeMinutes.toFixed(1))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":499,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":499,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16476,16478],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":500,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":500,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16493,16518],"text":"((ex?.tpLevelsHit.join(';')) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16493,16518],"text":"((ex?.tpLevelsHit.join(';')) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16493,16518],"text":"(Boolean((ex?.tpLevelsHit.join(';'))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":500,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":500,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16519,16521],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":501,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":501,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16536,16556],"text":"((ex?.tpLevelsHitCount) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16536,16556],"text":"((ex?.tpLevelsHitCount) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16536,16556],"text":"(Boolean((ex?.tpLevelsHitCount)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":501,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":501,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16557,16559],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":502,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":502,"endColumn":25,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[16573,16587],"text":"((ex?.stoppedOut) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[16573,16587],"text":"((ex?.stoppedOut) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":502,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":502,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16588,16590],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":503,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":503,"endColumn":33,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[16608,16630],"text":"((ex?.slMovedToBreakeven) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[16608,16630],"text":"((ex?.slMovedToBreakeven) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":503,"column":34,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":503,"endColumn":36,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16631,16633],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":504,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":504,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[16651,16676],"text":"((ex?.trailingStopActivated) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[16651,16676],"text":"((ex?.trailingStopActivated) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":504,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":504,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16677,16679],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":505,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":505,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16697,16750],"text":"((ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16697,16750],"text":"((ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16697,16750],"text":"(Boolean((ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":505,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":505,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16751,16753],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":506,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":506,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16768,16823],"text":"((ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16768,16823],"text":"((ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16768,16823],"text":"(Boolean((ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":506,"column":67,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":506,"endColumn":69,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16824,16826],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":509,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":509,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16911,16921],"text":"(t.closedAt != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16911,16921],"text":"(t.closedAt ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16911,16921],"text":"(Boolean(t.closedAt))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":95,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":18,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, TIME_UNITS } from '../constants';\n/**\n * Trading Journal Service\n * Records all trades with complete entry/exit conditions for ML analysis\n *\n * Now integrated with:\n * - TradeHistoryService: permanent CSV storage with dynamic schema\n * - VirtualBalanceService: virtual balance tracking for compound interest\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { TradeRecord, EntryCondition, ExitCondition, PositionSide, LogLevel, LoggerService, TradeHistoryConfig } from '../types';\nimport { TradeHistoryService, TradeRecord as CSVTradeRecord } from './trade-history.service';\nimport { VirtualBalanceService } from './virtual-balance.service';\n\nconst JSON_INDENT = 2;\nconst DATA_DIR = 'data';\nconst JOURNAL_FILE = 'trade-journal.json';\nconst CSV_FILE = 'trade-journal.csv';\n\nexport class TradingJournalService {\n  private trades: Map<string, TradeRecord> = new Map();\n  private readonly journalPath: string;\n  private readonly dataDir: string;\n\n  // NEW: Permanent storage and virtual balance\n  private tradeHistory?: TradeHistoryService;\n  private virtualBalance?: VirtualBalanceService;\n  private sessionVersion: string = 'v2.6';\n\n  constructor(\n    private readonly logger: LoggerService,\n    dataPath?: string,\n    private tradeHistoryConfig?: TradeHistoryConfig,\n    private baseDeposit?: number,\n  ) {\n    this.dataDir = dataPath || path.join(process.cwd(), DATA_DIR);\n    this.journalPath = path.join(this.dataDir, JOURNAL_FILE);\n\n    // Create directory if not exists\n    if (!fs.existsSync(this.dataDir)) {\n      fs.mkdirSync(this.dataDir, { recursive: true });\n    }\n\n    // Initialize trade history (permanent CSV)\n    if (tradeHistoryConfig?.enabled) {\n      this.tradeHistory = new TradeHistoryService(logger, tradeHistoryConfig.dataDir || this.dataDir);\n\n      // Initialize virtual balance\n      if (baseDeposit && baseDeposit > 0) {\n        this.virtualBalance = new VirtualBalanceService(logger, baseDeposit, tradeHistoryConfig.dataDir || this.dataDir);\n\n        // Sync virtual balance from history on startup\n        this.syncVirtualBalanceAsync();\n      }\n    }\n\n    // Load existing journal\n    this.loadJournal();\n  }\n\n  /**\n   * Sync virtual balance from trade history (async)\n   */\n  private async syncVirtualBalanceAsync(): Promise<void> {\n    if (!this.virtualBalance || !this.tradeHistory) {\n      return;\n    }\n\n    try {\n      const allTrades = await this.tradeHistory.readAllTrades();\n      await this.virtualBalance.syncFromHistory(\n        allTrades.map(t => ({ id: t.id, netPnl: t.netPnl })),\n      );\n    } catch (error: unknown) {\n      this.logger.error('âŒ Failed to sync virtual balance', { error, errorMessage: error instanceof Error ? error.message : String(error) });\n    }\n  }\n\n  /**\n   * Load journal from file\n   */\n  private loadJournal(): void {\n    try {\n      if (fs.existsSync(this.journalPath)) {\n        const data = fs.readFileSync(this.journalPath, 'utf-8');\n        const entries: TradeRecord[] = JSON.parse(data);\n\n        for (const entry of entries) {\n          this.trades.set(entry.id, entry);\n        }\n\n        this.logger.info('ðŸ“– Trade journal loaded', {\n          entriesCount: this.trades.size,\n          path: this.journalPath,\n        });\n      } else {\n        this.logger.info('ðŸ“– Trade journal file not found, creating new', {\n          path: this.journalPath,\n        });\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error('âŒ Failed to load trade journal', { error: errorMsg });\n    }\n  }\n\n  /**\n   * Save journal to file\n   */\n  private saveJournal(): void {\n    try {\n      const entries = Array.from(this.trades.values());\n      const data = JSON.stringify(entries, null, JSON_INDENT);\n      fs.writeFileSync(this.journalPath, data, 'utf-8');\n\n      this.logger.debug('ðŸ’¾ Trade journal saved', {\n        entriesCount: entries.length,\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error('âŒ Failed to save trade journal', { error: errorMsg });\n    }\n  }\n\n  /**\n   * Record trade opening - simplified to serialize entire objects\n   */\n  recordTradeOpen(params: {\n    id: string;\n    symbol: string;\n    side: PositionSide;\n    entryPrice: number;\n    quantity: number;\n    leverage: number;\n    entryCondition: EntryCondition;\n  }): void {\n    if (!params.id || params.id.length === 0) {\n      throw new Error('Trade ID is required');\n    }\n\n    if (this.trades.has(params.id)) {\n      throw new Error(`Trade ${params.id} already exists`);\n    }\n\n    const trade: TradeRecord = {\n      id: params.id,\n      symbol: params.symbol,\n      side: params.side,\n      entryPrice: params.entryPrice,\n      quantity: params.quantity,\n      leverage: params.leverage,\n      entryCondition: params.entryCondition,\n      openedAt: Date.now(),\n      status: 'OPEN',\n    };\n\n    this.trades.set(params.id, trade);\n    this.saveJournal();\n\n    this.logger.info('ðŸ“ Trade entry recorded', {\n      id: trade.id,\n      symbol: trade.symbol,\n      side: trade.side,\n      entryPrice: trade.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\n      signal: params.entryCondition.signal.reason,\n      type: params.entryCondition.signal.type,\n      confidence: params.entryCondition.signal.confidence,\n    });\n  }\n\n  /**\n   * Record trade closing\n   */\n  recordTradeClose(params: {\n    id: string;\n    exitPrice: number;\n    exitCondition: ExitCondition;\n    realizedPnL: number;\n  }): void {\n    const trade = this.trades.get(params.id);\n\n    if (trade === undefined) {\n      throw new Error(`Trade ${params.id} not found`);\n    }\n\n    // Get virtual balance BEFORE update\n    const balanceBefore = this.virtualBalance?.getCurrentBalance() || 0;\n\n    // Update trade in memory\n    trade.exitPrice = params.exitPrice;\n    trade.exitCondition = params.exitCondition;\n    trade.realizedPnL = params.realizedPnL;\n    trade.closedAt = Date.now();\n    trade.status = 'CLOSED';\n\n    this.trades.set(params.id, trade);\n    this.saveJournal();\n\n    // Calculate fees (Bybit: 0.06% taker for market orders)\n    const positionValue = trade.quantity * trade.entryPrice;\n    const entryFee = positionValue * 0.0006; // 0.06% entry\n    const exitFee = positionValue * 0.0006; // 0.06% exit\n    const totalFees = entryFee + exitFee;\n    const netPnL = params.realizedPnL - totalFees;\n\n    // Update virtual balance with NET PnL\n    if (this.virtualBalance) {\n      this.virtualBalance.updateBalance(netPnL, params.id);\n    }\n\n    const balanceAfter = this.virtualBalance?.getCurrentBalance() || balanceBefore;\n\n    // Append to permanent CSV history\n    if (this.tradeHistory && this.tradeHistoryConfig?.enabled) {\n      const md = (trade.entryCondition.signal.marketData || {}) as Record<string, unknown>;\n      const duration = this.formatDuration(trade.closedAt - trade.openedAt);\n\n      const csvRecord: CSVTradeRecord = {\n        // Core fields\n        timestamp: new Date(trade.openedAt).toISOString(),\n        id: trade.id,\n        symbol: trade.symbol,\n        side: trade.side,\n        strategy: trade.entryCondition.signal.type,\n        entryPrice: trade.entryPrice,\n        exitPrice: params.exitPrice,\n        quantity: trade.quantity,\n        leverage: trade.leverage,\n        pnl: params.realizedPnL,\n        fees: totalFees,\n        netPnl: netPnL,\n        duration: duration,\n        exitType: params.exitCondition.exitType,\n        confidence: trade.entryCondition.signal.confidence,\n        virtualBalanceBefore: balanceBefore,\n        virtualBalanceAfter: balanceAfter,\n        sessionVersion: this.sessionVersion,\n        notes: trade.entryCondition.signal.reason,\n\n        // Dynamic indicator fields (from marketData)\n        rsi: md.rsi,\n        rsiEntry: md.rsiEntry,\n        rsiTrend1: md.rsiTrend1,\n        ema: md.ema,\n        emaEntry: md.emaEntry,\n        distanceToLevel: md.distanceToLevel,\n        distanceToEma: md.distanceToEma,\n        volumeRatio: md.volumeRatio,\n        swingHighsCount: md.swingHighsCount,\n        swingLowsCount: md.swingLowsCount,\n        trend: md.trend,\n        atr: md.atr,\n        btcCorrelation: md.btcCorrelation,\n        // NEW: Stochastic indicator data\n        stochasticK: (md.stochastic as unknown as Record<string, unknown>)?.k,\n        stochasticD: (md.stochastic as unknown as Record<string, unknown>)?.d,\n        stochasticOversold: (md.stochastic as unknown as Record<string, unknown>)?.isOversold,\n        stochasticOverbought: (md.stochastic as unknown as Record<string, unknown>)?.isOverbought,\n        // NEW: Bollinger Bands data\n        bollingerUpper: (md.bollingerBands as unknown as Record<string, unknown>)?.upper,\n        bollingerMiddle: (md.bollingerBands as unknown as Record<string, unknown>)?.middle,\n        bollingerLower: (md.bollingerBands as unknown as Record<string, unknown>)?.lower,\n        bollingerWidth: (md.bollingerBands as unknown as Record<string, unknown>)?.width,\n        bollingerPercentB: (md.bollingerBands as unknown as Record<string, unknown>)?.percentB,\n        bollingerSqueeze: (md.bollingerBands as unknown as Record<string, unknown>)?.isSqueeze,\n\n        // Exit condition details\n        exitReason: params.exitCondition.reason,\n        tpLevelsHit: params.exitCondition.tpLevelsHit.join(';'),\n        tpLevelsHitCount: params.exitCondition.tpLevelsHitCount,\n        stoppedOut: params.exitCondition.stoppedOut,\n        slMovedToBreakeven: params.exitCondition.slMovedToBreakeven,\n        trailingStopActivated: params.exitCondition.trailingStopActivated,\n        maxProfitPercent: params.exitCondition.maxProfitPercent,\n        maxDrawdownPercent: params.exitCondition.maxDrawdownPercent,\n        holdingTimeMinutes: params.exitCondition.holdingTimeMinutes,\n        pnlPercent: params.exitCondition.pnlPercent,\n      };\n\n      this.tradeHistory.appendTrade(csvRecord).catch((error: unknown) => {\n        this.logger.error('âŒ Failed to append to CSV history', {\n          error: error instanceof Error ? error.message : String(error),\n          tradeId: params.id,\n        });\n      });\n    }\n\n    this.logger.info('ðŸ“ Trade exit recorded', {\n      id: trade.id,\n      symbol: trade.symbol,\n      exitType: params.exitCondition.exitType,\n      realizedPnL: params.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n      netPnL: netPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n      fees: totalFees.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n      pnlPercent: params.exitCondition.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\n      holdingTime: params.exitCondition.holdingTimeMinutes.toFixed(1) + ' min',\n      tpHit: params.exitCondition.tpLevelsHit.join(', ') || 'none',\n      virtualBalance: balanceAfter.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n    });\n  }\n\n  /**\n   * Get trade by ID\n   */\n  getTrade(id: string): TradeRecord | undefined {\n    return this.trades.get(id);\n  }\n\n  /**\n   * Get all trades\n   */\n  getAllTrades(): TradeRecord[] {\n    return Array.from(this.trades.values());\n  }\n\n  /**\n   * Get open trades\n   */\n  getOpenTrades(): TradeRecord[] {\n    return this.getAllTrades().filter((t) => t.status === 'OPEN');\n  }\n\n  /**\n   * Get open position by symbol\n   * Used for restoring position state from WebSocket\n   */\n  getOpenPositionBySymbol(symbol: string): TradeRecord | undefined {\n    return this.getOpenTrades().find((t) => t.symbol === symbol);\n  }\n\n  /**\n   * Get closed trades\n   */\n  getClosedTrades(): TradeRecord[] {\n    return this.getAllTrades().filter((t) => t.status === 'CLOSED');\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): {\n    totalTrades: number;\n    openTrades: number;\n    closedTrades: number;\n    winningTrades: number;\n    losingTrades: number;\n    totalPnL: number;\n    averagePnL: number;\n    winRate: number;\n    averageHoldingTimeMinutes: number;\n    } {\n    const closed = this.getClosedTrades();\n    const winning = closed.filter((t) => t.realizedPnL && t.realizedPnL > 0);\n    const losing = closed.filter((t) => t.realizedPnL && t.realizedPnL <= 0);\n\n    const totalPnL = closed.reduce((sum, t) => sum + (t.realizedPnL || 0), 0);\n\n    const averageHoldingTime =\n      closed.reduce(\n        (sum, t) => sum + (t.exitCondition?.holdingTimeMinutes || 0),\n        0,\n      ) / (closed.length > 0 ? closed.length : 1);\n\n    return {\n      totalTrades: this.trades.size,\n      openTrades: this.getOpenTrades().length,\n      closedTrades: closed.length,\n      winningTrades: winning.length,\n      losingTrades: losing.length,\n      totalPnL,\n      averagePnL: closed.length > 0 ? totalPnL / closed.length : 0,\n      winRate: closed.length > 0 ? winning.length / closed.length : 0,\n      averageHoldingTimeMinutes: averageHoldingTime,\n    };\n  }\n\n  /**\n   * Format duration in human-readable format\n   */\n  private formatDuration(durationMs: number): string {\n    const minutes = Math.floor(durationMs / TIME_UNITS.MINUTE);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) {\n      return `${days}d ${hours % 24}h`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else {\n      return `${minutes}m`;\n    }\n  }\n\n  /**\n   * Get virtual balance (for compound interest calculation)\n   */\n  getVirtualBalance(): number {\n    return this.virtualBalance?.getCurrentBalance() || 0;\n  }\n\n  /**\n   * Get virtual balance service (for external access)\n   */\n  getVirtualBalanceService(): VirtualBalanceService | undefined {\n    return this.virtualBalance;\n  }\n\n  /**\n   * Export to CSV for ML analysis\n   */\n  exportToCSV(outputPath?: string): void {\n    const csvPath = outputPath || path.join(this.dataDir, CSV_FILE);\n\n    try {\n      const entries = Array.from(this.trades.values());\n\n      // CSV header\n      const header = [\n        'ID',\n        'Symbol',\n        'Side',\n        'Entry Price',\n        'Exit Price',\n        'Quantity',\n        'Leverage',\n        // Entry conditions\n        'Signal Type',\n        'Signal Reason',\n        'Confidence',\n        'RSI',\n        'RSI Entry',\n        'RSI Trend1',\n        'EMA',\n        'EMA Entry',\n        'Distance to Level %',\n        'Distance to EMA %',\n        'Volume Multiplier',\n        'Swing Highs',\n        'Swing Lows',\n        'Trend',\n        'Market Condition',\n        // Exit conditions\n        'Exit Type',\n        'Exit Reason',\n        'Realized PnL USDT',\n        'PnL %',\n        'Holding Time Min',\n        'TP Levels Hit',\n        'TP Count',\n        'Stopped Out',\n        'SL to Breakeven',\n        'Trailing Activated',\n        'Max Profit %',\n        'Max Drawdown %',\n        // Timestamps\n        'Opened At',\n        'Closed At',\n        'Status',\n      ].join(',');\n\n      // CSV rows - simplified to work with new structure\n      const rows = entries.map((t) => {\n        const ec = t.entryCondition;\n        const ex = t.exitCondition;\n        const sig = ec.signal;\n        const md = (sig.marketData || {}) as Record<string, unknown>;\n\n        return [\n          t.id,\n          t.symbol,\n          t.side,\n          t.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\n          t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE) || '',\n          t.quantity,\n          t.leverage,\n          // Entry - from Signal object\n          sig.type,\n          `\"${sig.reason}\"`,\n          sig.confidence,\n          (md.rsi as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT) || '',\n          (md.rsiEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT) || '',\n          (md.rsiTrend1 as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT) || '',\n          (md.ema as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE) || '',\n          (md.emaEntry as unknown as number)?.toFixed?.(DECIMAL_PLACES.PRICE) || '',\n          (md.distanceToLevel as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT) || '',\n          (md.distanceToEma as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT) || '',\n          (md.volumeRatio as unknown as number)?.toFixed?.(DECIMAL_PLACES.PERCENT) || '',\n          md.swingHighsCount || '',\n          md.swingLowsCount || '',\n          md.trend || '',\n          md.trend || '', // marketCondition\n          // Exit\n          ((ex?.exitType) != null) || '',\n          ex ? `\"${ex.reason}\"` : '',\n          t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          ex?.holdingTimeMinutes.toFixed(1) || '',\n          ex?.tpLevelsHit.join(';') || '',\n          ex?.tpLevelsHitCount || 0,\n          ex?.stoppedOut || false,\n          ex?.slMovedToBreakeven || false,\n          ex?.trailingStopActivated || false,\n          ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          // Timestamps\n          new Date(t.openedAt).toISOString(),\n          t.closedAt ? new Date(t.closedAt).toISOString() : '',\n          t.status,\n        ].join(',');\n      });\n\n      const csv = [header, ...rows].join('\\n');\n      fs.writeFileSync(csvPath, csv, 'utf-8');\n\n      this.logger.info('ðŸ“Š Trade journal exported to CSV', {\n        path: csvPath,\n        entries: entries.length,\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error('âŒ Failed to export trade journal to CSV', {\n        error: errorMsg,\n      });\n    }\n  }\n\n  /**\n   * Clear all trades (for testing)\n   */\n  clear(): void {\n    this.trades.clear();\n    this.saveJournal();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\trading-orchestrator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TakeProfit' is defined but never used. Allowed unused vars must match /^_/u.","line":32,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TrendFollowingConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":45,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LevelBasedConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":46,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CounterTrendConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":47,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":47,"endColumn":21},{"ruleId":"complexity","severity":1,"message":"Constructor has a complexity of 35. Maximum allowed is 10.","line":242,"column":14,"nodeType":"FunctionExpression","messageId":"complex","endLine":673,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":296,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":296,"endColumn":47,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[11704,11742],"text":"(config.indicators?.stochastic?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[11704,11742],"text":"(config.indicators?.stochastic?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":311,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":311,"endColumn":51,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12208,12250],"text":"(config.indicators?.bollingerBands?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12208,12250],"text":"(config.indicators?.bollingerBands?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":329,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":329,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12884,12912],"text":"(config.weightMatrix?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12884,12912],"text":"(config.weightMatrix?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":383,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":383,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[14949,14976],"text":"(config.whaleHunter?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[14949,14976],"text":"(config.whaleHunter?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (1423). Maximum allowed is 300.","line":389,"column":1,"nodeType":null,"messageId":"exceed","endLine":1875,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":414,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":414,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[15929,15962],"text":"(config.whaleHunterFollow?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[15929,15962],"text":"(config.whaleHunterFollow?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":451,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":451,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[17184,17217],"text":"(config.scalpingMicroWall?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[17184,17217],"text":"(config.scalpingMicroWall?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":475,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":475,"endColumn":43,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[17993,18027],"text":"(config.scalpingLimitOrder?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[17993,18027],"text":"(config.scalpingLimitOrder?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":495,"column":73,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":495,"endColumn":96,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18841,18865],"text":"(config.scalpingLadderTp == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":496,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":496,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[18925,18957],"text":"(config.scalpingLadderTp?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[18925,18957],"text":"(config.scalpingLadderTp?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":516,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":516,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[19740,19773],"text":"(config.scalpingTickDelta?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[19740,19773],"text":"(config.scalpingTickDelta?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":535,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":535,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[20417,20450],"text":"(config.scalpingOrderFlow?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[20417,20450],"text":"(config.scalpingOrderFlow?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":559,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":559,"endColumn":40,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[21306,21337],"text":"(config.btcConfirmation?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[21306,21337],"text":"(config.btcConfirmation?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":568,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":568,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[21647,21680],"text":"(config.fundingRateFilter?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[21647,21680],"text":"(config.fundingRateFilter?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":582,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":582,"endColumn":44,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[22323,22358],"text":"(config.flatMarketDetection?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[22323,22358],"text":"(config.flatMarketDetection?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":593,"column":29,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":593,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22915,22931],"text":"(fastEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":593,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":593,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[22932,22934],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":594,"column":34,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":594,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22975,22996],"text":"(smartBreakevenService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":594,"column":56,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":594,"endColumn":58,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[22997,22999],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":595,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":595,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23037,23055],"text":"(retestEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":595,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":595,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23056,23058],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":598,"column":33,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":598,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23150,23170],"text":"(deltaAnalyzerService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":598,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":598,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23171,23173],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":599,"column":38,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":599,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23218,23243],"text":"(orderbookImbalanceService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":599,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":599,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23244,23246],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":602,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":602,"endColumn":38,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[23326,23355],"text":"(config.volumeProfile?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[23326,23355],"text":"(config.volumeProfile?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":612,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":612,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23800,23818],"text":"(dailyLimitsService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":612,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":612,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23819,23821],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":613,"column":35,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":613,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23863,23885],"text":"(riskBasedSizingService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":613,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":613,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23886,23888],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":614,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":614,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23925,23942],"text":"(lossStreakService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":614,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":614,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23943,23945],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":615,"column":37,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":615,"endColumn":61,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23989,24013],"text":"(maxConcurrentRiskService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":615,"column":62,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":615,"endColumn":64,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[24014,24016],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":617,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":617,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24034,24055],"text":"this.fastEntryService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":625,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":625,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24335,24361],"text":"this.smartBreakevenService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":633,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":633,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24684,24707],"text":"this.retestEntryService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":636,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":636,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24860,24878],"text":"(config.retestEntry != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":641,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":641,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25066,25091],"text":"this.deltaAnalyzerService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":648,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":648,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25309,25332],"text":"this.dailyLimitsService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":656,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":656,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25640,25667],"text":"this.riskBasedSizingService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":664,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":664,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26001,26023],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'onCandleClosed' has a complexity of 60. Maximum allowed is 10.","line":698,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":1054,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":726,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":726,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28248,28268],"text":"this.currentContext == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":733,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":733,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28512,28527],"text":"currentPosition != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":736,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":758,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":736,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":736,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28704,28727],"text":"(this.bollingerIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":736,"column":42,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":736,"endColumn":89,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[28731,28778],"text":"((this.config.indicators?.bollingerBands?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[28731,28778],"text":"((this.config.indicators?.bollingerBands?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":737,"column":13,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":757,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":740,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":740,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[28983,29027],"text":"(this.config.indicators.bollingerBands.period !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[28983,29027],"text":"(!Number.isNaN(this.config.indicators.bollingerBands.period))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28983,29027],"text":"(Boolean(this.config.indicators.bollingerBands.period))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":740,"column":80,"nodeType":"Literal","messageId":"noMagic","endLine":740,"endColumn":82},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":741,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":752,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":746,"column":29,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":746,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[29307,29338],"text":"((this.currentContext?.atrPercent) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[29307,29338],"text":"(!Number.isNaN((this.currentContext?.atrPercent)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[29307,29338],"text":"(Boolean((this.currentContext?.atrPercent)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":763,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":796,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":763,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":763,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30114,30140],"text":"(this.smartBreakevenService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":763,"column":45,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":763,"endColumn":80,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[30144,30179],"text":"((this.config.smartBreakeven?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[30144,30179],"text":"((this.config.smartBreakeven?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":765,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":795,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":765,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":765,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30288,30293],"text":"(state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":765,"column":26,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":765,"endColumn":49,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[30312,30320],"text":"BreakevenMode.PRE_BE"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":766,"column":15,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":794,"endColumn":16},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 3.","line":768,"column":17,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":789,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":772,"column":60,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":772,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":783,"column":27,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":783,"endColumn":68,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31245,31286],"text":"this.positionManager.getCurrentPosition() != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":801,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":841,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":801,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":801,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32070,32093],"text":"(this.retestEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":801,"column":42,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":801,"endColumn":74,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[32097,32129],"text":"((this.config.retestEntry?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[32097,32129],"text":"((this.config.retestEntry?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":803,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":840,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":803,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":803,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32239,32243],"text":"zone != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":804,"column":15,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":839,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":809,"column":58,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":809,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":814,"column":39,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":814,"endColumn":48},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 3.","line":827,"column":17,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":834,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":827,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":827,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":853,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":853,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[34557,34572],"text":"confirmedSignal != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":872,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":872,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[35353,35364],"text":"marketData == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":881,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":881,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[35821,35844],"text":"(this.flatMarketDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":881,"column":40,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":881,"endColumn":59},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":882,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":896,"endColumn":12},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":886,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":893,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":886,"column":46,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":886,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":901,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":901,"endColumn":54,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[36675,36693],"text":"((flatResult?.isFlat) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[36675,36693],"text":"((flatResult?.isFlat) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":901,"column":58,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":901,"endColumn":101,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[36697,36740],"text":"((this.config.weightMatrix?.minConfidenceFlat) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[36697,36740],"text":"((this.config.weightMatrix?.minConfidenceFlat) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[36697,36740],"text":"(Boolean((this.config.weightMatrix?.minConfidenceFlat)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":903,"column":13,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":903,"endColumn":59,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[36810,36856],"text":"((this.config.weightMatrix?.minConfidenceToEnter) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[36810,36856],"text":"((this.config.weightMatrix?.minConfidenceToEnter) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[36810,36856],"text":"(Boolean((this.config.weightMatrix?.minConfidenceToEnter)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":903,"column":60,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":903,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[36857,36859],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":903,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":903,"endColumn":65},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":908,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":908,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[37027,37045],"text":"((flatResult?.isFlat) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[37027,37045],"text":"((flatResult?.isFlat) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":911,"column":19,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":911,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[37206,37224],"text":"((flatResult?.isFlat) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[37206,37224],"text":"((flatResult?.isFlat) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":926,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":926,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[37860,37874],"text":"(strategySignal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":926,"column":55,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":926,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[37902,37923],"text":"(strategySignal.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":939,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":963,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":939,"column":15,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":939,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[38615,38625],"text":"flatResult != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":940,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":962,"endColumn":14},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":971,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":997,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":971,"column":36,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":971,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[40248,40256],"text":"(keyLevel != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[40248,40256],"text":"(keyLevel ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[40248,40256],"text":"(Boolean(keyLevel))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":1007,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":1007,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[42000,42021],"text":"(strategySignal.reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[42000,42021],"text":"(strategySignal.reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[42000,42021],"text":"(Boolean(strategySignal.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1007,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1007,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[42022,42024],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1029,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1043,"endColumn":12},{"ruleId":"complexity","severity":1,"message":"Async method 'executeTrade' has a complexity of 56. Maximum allowed is 10.","line":1061,"column":29,"nodeType":"FunctionExpression","messageId":"complex","endLine":1399,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1071,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1071,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[44719,44742],"text":"this.dailyLimitsService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1082,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1082,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[45068,45090],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1101,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1101,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[45786,45809],"text":"(this.retestEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1101,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1101,"endColumn":70,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[45813,45845],"text":"((this.config.retestEntry?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[45813,45845],"text":"((this.config.retestEntry?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1104,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1136,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":1104,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":1104,"endColumn":40},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":1113,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1135,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":1116,"column":24,"nodeType":"TSAsExpression","messageId":"conditionErrorOther","endLine":1116,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1145,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1145,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47552,47568],"text":"(this.btcAnalyzer != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1145,"column":31,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1145,"endColumn":67,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[47572,47608],"text":"((this.config.btcConfirmation?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[47572,47608],"text":"((this.config.btcConfirmation?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1148,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1148,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47702,47713],"text":"(btcAnalysis != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1159,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1159,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48181,48192],"text":"btcAnalysis != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1170,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1170,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48563,48585],"text":"(this.fundingRateFilter != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1170,"column":37,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1170,"endColumn":75,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[48589,48627],"text":"((this.config.fundingRateFilter?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[48589,48627],"text":"((this.config.fundingRateFilter?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1177,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1177,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48952,48976],"text":"(filterResult.fundingRate != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[48952,48976],"text":"(filterResult.fundingRate ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[48952,48976],"text":"(Boolean(filterResult.fundingRate))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1186,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1186,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[49295,49319],"text":"(filterResult.fundingRate != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[49295,49319],"text":"(filterResult.fundingRate ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[49295,49319],"text":"(Boolean(filterResult.fundingRate))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":1194,"column":16,"nodeType":"TSAsExpression","messageId":"conditionErrorOther","endLine":1194,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1224,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1224,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[50621,50631],"text":"marketData != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1260,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1260,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51888,51908],"text":"(marketData.liquidity != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1298,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1298,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[53320,53341],"text":"(this.fastEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1298,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1298,"endColumn":66,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[53345,53375],"text":"((this.config.fastEntry?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[53345,53375],"text":"((this.config.fastEntry?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1304,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1359,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1304,"column":100,"nodeType":"Literal","messageId":"noMagic","endLine":1304,"endColumn":101},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":1308,"column":54,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":1308,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1313,"column":72,"nodeType":"Literal","messageId":"noMagic","endLine":1313,"endColumn":73},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":1326,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1358,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'remainingSize' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1329,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1329,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'partialQty' is defined but never used. Allowed unused args must match /^_/u.","line":1335,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":1335,"endColumn":34},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":1352,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1357,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1352,"column":19,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1352,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[55705,55712],"text":"partial != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1378,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1378,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[56747,56760],"text":"this.telegram != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1409,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1409,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[57867,57887],"text":"this.currentContext == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1415,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":1415,"endColumn":24},{"ruleId":"complexity","severity":1,"message":"Async method 'prepareMarketData' has a complexity of 35. Maximum allowed is 10.","line":1452,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":1686,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1456,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":1456,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1456,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":1456,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":1488,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":1488,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":1490,"column":28,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":1490,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":1491,"column":98,"nodeType":"Literal","messageId":"noMagic","endLine":1491,"endColumn":100},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1500,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1500,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[61836,61860],"text":"(this.stochasticIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1500,"column":39,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":1500,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[61864,61898],"text":"((this.config.indicators?.stochastic) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1512,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1526,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1534,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1534,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[63386,63409],"text":"(this.bollingerIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1534,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":1534,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[63413,63451],"text":"((this.config.indicators?.bollingerBands) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1537,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1553,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.5.","line":1542,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":1542,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":1543,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1543,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":1570,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1570,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.85.","line":1571,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":1571,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":1572,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":1572,"endColumn":39},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1576,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1596,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1604,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1604,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[66753,66778],"text":"(bollingerBands?.isSqueeze) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[66753,66778],"text":"(bollingerBands?.isSqueeze) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":1607,"column":54,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":1607,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1638,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1638,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[68205,68235],"text":"(this.orderbookImbalanceService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1638,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1638,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[68239,68260],"text":"(this.currentOrderbook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1670,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1670,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[69292,69313],"text":"(this.currentOrderbook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.9.","line":1697,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1697,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":1714,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":1714,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":1719,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":1719,"endColumn":34},{"ruleId":"complexity","severity":1,"message":"Async method 'analyzeBTC' has a complexity of 13. Maximum allowed is 10.","line":1738,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":1780,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1739,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1739,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[71481,71498],"text":"(this.btcAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1739,"column":31,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1739,"endColumn":67,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[71503,71539],"text":"((this.config.btcConfirmation?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[71502,71539],"text":"((this.config.btcConfirmation?.enabled) === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1750,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1750,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[71815,71836],"text":"(btcConfig.candleLimit !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[71815,71836],"text":"(!Number.isNaN(btcConfig.candleLimit))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[71815,71836],"text":"(Boolean(btcConfig.candleLimit))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1750,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":1750,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1753,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":1753,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1753,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1753,"endColumn":72,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[71903,71928],"text":"(btcConfig.lookbackCandles !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[71903,71928],"text":"(!Number.isNaN(btcConfig.lookbackCandles))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[71903,71928],"text":"(Boolean(btcConfig.lookbackCandles))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":1753,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":1753,"endColumn":78},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1755,"column":22,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":1755,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[72028,72046],"text":"((btcCandles?.length) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[72028,72046],"text":"(!Number.isNaN((btcCandles?.length)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[72028,72046],"text":"(Boolean((btcCandles?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1756,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1756,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[72074,72099],"text":"(btcConfig.lookbackCandles !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[72074,72099],"text":"(!Number.isNaN(btcConfig.lookbackCandles))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[72074,72099],"text":"(Boolean(btcConfig.lookbackCandles))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":1756,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":1756,"endColumn":52},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1763,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":1763,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[72266,72290],"text":"btcConfig.useCorrelation ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[72266,72290],"text":"btcConfig.useCorrelation === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1766,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1766,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[72397,72424],"text":"(btcConfig.correlationPeriod != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[72397,72424],"text":"(btcConfig.correlationPeriod ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[72397,72424],"text":"(Boolean(btcConfig.correlationPeriod))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1766,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1766,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[72425,72427],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1766,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1766,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1805,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1805,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[73695,73709],"text":"whaleStrategy == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1810,"column":11,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":1810,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[73818,73859],"text":"this.positionManager.getCurrentPosition() != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1815,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1815,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[73961,73981],"text":"this.currentContext == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1822,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1822,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[74297,74308],"text":"marketData == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1830,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1830,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[74555,74576],"text":"(strategySignal.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":1846,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":1846,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[75304,75325],"text":"(strategySignal.reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[75304,75325],"text":"(strategySignal.reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[75304,75325],"text":"(Boolean(strategySignal.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1846,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1846,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[75326,75328],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":153,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Trading Orchestrator\r\n *\r\n * The \"brain\" of the trading system. Coordinates:\r\n * - Context analysis (PRIMARY/TREND timeframes)\r\n * - Entry scanning (ENTRY timeframe)\r\n * - Trade execution\r\n *\r\n * Flow:\r\n * 1. PRIMARY candle closes â†’ Update context\r\n * 2. ENTRY candle closes â†’ Scan for entries using context\r\n * 3. Entry found â†’ Execute trade\r\n */\r\n\r\nimport {\r\n  TradingContext,\r\n  EntrySignal,\r\n  TimeframeRole,\r\n  Candle,\r\n  LoggerService,\r\n  SignalType,\r\n  Signal,\r\n  ContextFilteringMode,\r\n  StrategyMarketData,\r\n  SignalDirection,\r\n  BTCConfirmationConfig,\r\n  BTCAnalysis,\r\n  FundingRateFilterConfig,\r\n  SessionBasedSLConfig,\r\n  FlatMarketConfig,\r\n  TakeProfit,\r\n  SessionEntryCondition,\r\n  IndicatorSnapshot,\r\n  PatternSnapshot,\r\n  LevelSnapshot,\r\n  ContextSnapshot,\r\n  DailyLimitsConfig,\r\n  RiskBasedSizingConfig,\r\n  IStrategy,\r\n  OrderBook,\r\n  OrderbookLevel,\r\n  LossStreakConfig,\r\n  StrategiesConfig,\r\n  TrendFollowingConfig,\r\n  LevelBasedConfig,\r\n  CounterTrendConfig,\r\n  WhaleHunterConfig,\r\n  Config,\r\n  ScalpingMicroWallConfig,\r\n  ScalpingLimitOrderConfig,\r\n  ScalpingLadderTpConfig,\r\n  ScalpingTickDeltaConfig,\r\n  ScalpingOrderFlowConfig,\r\n  IndicatorsConfig,\r\n  FastEntryConfig,\r\n  SmartBreakevenConfig,\r\n  RetestConfig,\r\n  WeightMatrixConfig,\r\n  DeltaConfig,\r\n  OrderbookImbalanceConfig,\r\n  VolumeProfileConfig,\r\n} from '../types';\r\nimport { ContextAnalyzer } from '../analyzers/context.analyzer';\r\nimport { EntryScanner } from '../analyzers/entry.scanner';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { BybitService } from './bybit';\r\nimport { PositionManagerService } from './position-manager.service';\r\nimport { TelegramService } from './telegram.service';\r\nimport { StrategyCoordinator } from './strategy-coordinator.service';\r\nimport { TrendFollowingStrategy } from '../strategies/trend-following.strategy';\r\nimport { LevelBasedStrategy } from '../strategies/level-based.strategy';\r\nimport { CounterTrendStrategy } from '../strategies/counter-trend.strategy';\r\nimport { WhaleHunterStrategy } from '../strategies/whale-hunter.strategy';\r\nimport { WhaleHunterFollowStrategy } from '../strategies/whale-hunter-follow.strategy';\r\nimport { ScalpingMicroWallStrategy } from '../strategies/scalping-micro-wall.strategy';\r\nimport { ScalpingLimitOrderStrategy } from '../strategies/scalping-limit-order.strategy';\r\nimport { ScalpingLadderTpStrategy } from '../strategies/scalping-ladder-tp.strategy';\r\nimport { ScalpingTickDeltaStrategy } from '../strategies/scalping-tick-delta.strategy';\r\nimport { ScalpingOrderFlowStrategy } from '../strategies/scalping-order-flow.strategy';\r\nimport { WhaleDetectorService } from './whale-detector.service';\r\nimport { WhaleDetectorFollowService } from './whale-detector-follow.service';\r\nimport { MicroWallDetectorService } from './micro-wall-detector.service';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { RSIIndicator } from '../indicators/rsi.indicator';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { StochasticIndicator } from '../indicators/stochastic.indicator';\r\nimport { BollingerBandsIndicator } from '../indicators/bollinger.indicator';\r\nimport { LiquidityDetector } from '../analyzers/liquidity.detector';\r\nimport { DivergenceDetector } from '../analyzers/divergence.detector';\r\nimport { BTCAnalyzer } from '../analyzers/btc.analyzer';\r\nimport { BreakoutPredictor } from '../analyzers/breakout-predictor';\r\nimport { MultiTimeframeRSIAnalyzer } from '../analyzers/multi-timeframe-rsi.analyzer';\r\nimport { MultiTimeframeEMAAnalyzer } from '../analyzers/multi-timeframe-ema.analyzer';\r\nimport { TimeframeProvider } from '../providers/timeframe.provider';\r\nimport { FundingRateFilterService } from './funding-rate-filter.service';\r\nimport { FlatMarketDetector } from '../analyzers/flat-market.detector';\r\nimport { FastEntryService } from './fast-entry.service';\r\nimport { SmartBreakevenService } from './smart-breakeven.service';\r\nimport { RetestEntryService } from './retest-entry.service';\r\nimport { WeightMatrixCalculatorService } from './weight-matrix-calculator.service';\r\nimport { DeltaAnalyzerService } from './delta-analyzer.service';\r\nimport { OrderbookImbalanceService } from './orderbook-imbalance.service';\r\nimport { VolumeProfileService } from './volume-profile.service';\r\nimport { DailyLimitsService } from './daily-limits.service';\r\nimport { RiskBasedSizingService } from './risk-based-sizing.service';\r\nimport { LossStreakService } from './loss-streak.service';\r\nimport { MaxConcurrentRiskService } from './max-concurrent-risk.service';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface OrchestratorConfig {\r\n  // Context config (PRIMARY)\r\n  contextConfig: {\r\n    atrPeriod: number;\r\n    emaPeriod: number;\r\n    zigzagDepth: number;\r\n    minimumATR: number;\r\n    maximumATR: number;\r\n    maxEmaDistance: number;\r\n    filteringMode: ContextFilteringMode;\r\n  };\r\n  // Entry config (ENTRY)\r\n  entryConfig: {\r\n    rsiPeriod: number;\r\n    fastEmaPeriod: number;\r\n    slowEmaPeriod: number;\r\n    zigzagDepth: number;\r\n    rsiOversold: number;\r\n    rsiOverbought: number;\r\n    stopLossPercent: number;\r\n    takeProfits: Array<{ level: number; percent: number; sizePercent: number }>;\r\n    priceAction?: {\r\n      enabled: boolean;\r\n      requireLiquiditySweep?: boolean;\r\n      divergenceBoost?: number;\r\n      chochBoost?: number;\r\n      liquiditySweepBoost?: number;\r\n    };\r\n  };\r\n  // Strategies config (NEW - no more magic numbers!)\r\n  strategiesConfig?: StrategiesConfig;\r\n  // Position config\r\n  positionSizeUsdt: number;\r\n  leverage: number;\r\n  // BTC confirmation config\r\n  btcConfirmation?: BTCConfirmationConfig;\r\n  // Whale hunter config\r\n  whaleHunter?: WhaleHunterConfig;\r\n  levelBased?: Config;\r\n  whaleHunterFollow?: WhaleHunterConfig;\r\n  scalpingMicroWall?: ScalpingMicroWallConfig;\r\n  scalpingLimitOrder?: ScalpingLimitOrderConfig;\r\n  scalpingLadderTp?: ScalpingLadderTpConfig;\r\n  scalpingTickDelta?: ScalpingTickDeltaConfig;\r\n  scalpingOrderFlow?: ScalpingOrderFlowConfig;\r\n  // Funding rate filter config\r\n  fundingRateFilter?: FundingRateFilterConfig;\r\n  // Session-based SL config\r\n  sessionBasedSL?: SessionBasedSLConfig;\r\n  // Flat market detection config\r\n  flatMarketDetection?: FlatMarketConfig;\r\n  // Indicators config (for Stochastic and Bollinger Bands)\r\n  indicators?: IndicatorsConfig;\r\n  // Phase 1: Smart Entry & Breakeven config\r\n  fastEntry?: FastEntryConfig;\r\n  smartBreakeven?: SmartBreakevenConfig;\r\n  retestEntry?: RetestConfig;\r\n  // Phase 2: Weight Matrix config\r\n  weightMatrix?: WeightMatrixConfig;\r\n  // Phase 4: Market Data Enhancement config\r\n  delta?: DeltaConfig;\r\n  orderbookImbalance?: OrderbookImbalanceConfig;\r\n  volumeProfile?: VolumeProfileConfig;\r\n  // Phase 5: Risk Management config\r\n  dailyLimits?: DailyLimitsConfig;\r\n  riskBasedSizing?: RiskBasedSizingConfig;\r\n  lossStreak?: LossStreakConfig;\r\n  // System config\r\n  system: {\r\n    timeSyncIntervalMs: number;\r\n    timeSyncMaxFailures: number;\r\n  };\r\n  // EntryScanner fallback (default: true for backward compatibility)\r\n  enableEntryScannerFallback?: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// TRADING ORCHESTRATOR\r\n// ============================================================================\r\n\r\nexport class TradingOrchestrator {\r\n  private contextAnalyzer: ContextAnalyzer;\r\n  private entryScanner: EntryScanner;\r\n  private strategyCoordinator: StrategyCoordinator;\r\n  private currentContext: TradingContext | null = null;\r\n\r\n  // Multi-timeframe analyzers\r\n  private rsiAnalyzer: MultiTimeframeRSIAnalyzer;\r\n  private emaAnalyzer: MultiTimeframeEMAAnalyzer;\r\n\r\n  // Single-timeframe indicators (still needed for specific tasks)\r\n  private atrIndicator: ATRIndicator;\r\n  private zigzagIndicator: ZigZagIndicator;\r\n  private stochasticIndicator?: StochasticIndicator;\r\n  private bollingerIndicator?: BollingerBandsIndicator;\r\n  private liquidityDetector: LiquidityDetector;\r\n  private divergenceDetector: DivergenceDetector;\r\n  private breakoutPredictor: BreakoutPredictor;\r\n\r\n  // BTC confirmation\r\n  private btcAnalyzer: BTCAnalyzer | null = null;\r\n\r\n  // Funding rate filter\r\n  private fundingRateFilter: FundingRateFilterService | null = null;\r\n\r\n  // Flat market detector\r\n  private flatMarketDetector: FlatMarketDetector | null = null;\r\n\r\n  // Phase 1: Smart Entry & Breakeven services\r\n  private fastEntryService: FastEntryService | null = null;\r\n  private smartBreakevenService: SmartBreakevenService | null = null;\r\n  private retestEntryService: RetestEntryService | null = null;\r\n\r\n  // Phase 4: Market Data Enhancement services\r\n  private deltaAnalyzerService: DeltaAnalyzerService | null = null;\r\n  private orderbookImbalanceService: OrderbookImbalanceService | null = null;\r\n  private volumeProfileService: VolumeProfileService | null = null;\r\n\r\n  // Phase 5: Risk Management services\r\n  private dailyLimitsService: DailyLimitsService | null = null;\r\n  private riskBasedSizingService: RiskBasedSizingService | null = null;\r\n  private lossStreakService: LossStreakService | null = null;\r\n  private maxConcurrentRiskService: MaxConcurrentRiskService | null = null;\r\n\r\n  // Orderbook data (for whale detection)\r\n  private currentOrderbook: OrderBook | null = null;\r\n\r\n  constructor(\r\n    private config: OrchestratorConfig,\r\n    private candleProvider: CandleProvider,\r\n    private timeframeProvider: TimeframeProvider,\r\n    private bybitService: BybitService,\r\n    private positionManager: PositionManagerService,\r\n    private telegram: TelegramService | null,\r\n    private logger: LoggerService,\r\n    fastEntryService?: FastEntryService,\r\n    smartBreakevenService?: SmartBreakevenService,\r\n    retestEntryService?: RetestEntryService,\r\n    deltaAnalyzerService?: DeltaAnalyzerService,\r\n    orderbookImbalanceService?: OrderbookImbalanceService,\r\n    dailyLimitsService?: DailyLimitsService,\r\n    riskBasedSizingService?: RiskBasedSizingService,\r\n    lossStreakService?: LossStreakService,\r\n    maxConcurrentRiskService?: MaxConcurrentRiskService,\r\n  ) {\r\n    this.contextAnalyzer = new ContextAnalyzer(\r\n      config.contextConfig,\r\n      candleProvider,\r\n      logger,\r\n    );\r\n    this.entryScanner = new EntryScanner(\r\n      config.entryConfig,\r\n      candleProvider,\r\n      logger,\r\n    );\r\n\r\n    // Initialize multi-timeframe analyzers\r\n    this.rsiAnalyzer = new MultiTimeframeRSIAnalyzer(\r\n      timeframeProvider,\r\n      candleProvider,\r\n      logger,\r\n      config.entryConfig.rsiPeriod, // Use same period for all timeframes\r\n      true, // Enable caching\r\n    );\r\n    this.emaAnalyzer = new MultiTimeframeEMAAnalyzer(\r\n      timeframeProvider,\r\n      candleProvider,\r\n      logger,\r\n      config.entryConfig.fastEmaPeriod, // Fast EMA period\r\n      config.entryConfig.slowEmaPeriod, // Slow EMA period\r\n      true, // Enable caching\r\n    );\r\n\r\n    // Initialize single-timeframe indicators\r\n    this.atrIndicator = new ATRIndicator(config.contextConfig.atrPeriod);\r\n    this.zigzagIndicator = new ZigZagIndicator(config.entryConfig.zigzagDepth);\r\n    this.liquidityDetector = new LiquidityDetector(logger);\r\n    this.divergenceDetector = new DivergenceDetector(logger);\r\n    this.breakoutPredictor = new BreakoutPredictor(logger);\r\n\r\n    // Initialize Stochastic indicator if enabled\r\n    if (config.indicators?.stochastic?.enabled) {\r\n      const stochConfig = config.indicators.stochastic;\r\n      this.stochasticIndicator = new StochasticIndicator(\r\n        stochConfig.kPeriod,\r\n        stochConfig.dPeriod,\r\n        stochConfig.smooth,\r\n      );\r\n      logger.info('âœ… Stochastic indicator initialized', {\r\n        k: stochConfig.kPeriod,\r\n        d: stochConfig.dPeriod,\r\n        smooth: stochConfig.smooth,\r\n      });\r\n    }\r\n\r\n    // Initialize Bollinger Bands indicator if enabled\r\n    if (config.indicators?.bollingerBands?.enabled) {\r\n      const bbConfig = config.indicators.bollingerBands;\r\n      this.bollingerIndicator = new BollingerBandsIndicator(\r\n        bbConfig.period,\r\n        bbConfig.stdDev,\r\n      );\r\n      logger.info('âœ… Bollinger Bands indicator initialized', {\r\n        period: bbConfig.period,\r\n        stdDev: bbConfig.stdDev,\r\n        adaptiveParams: bbConfig.adaptiveParams,\r\n      });\r\n    }\r\n\r\n    // Initialize Strategy Coordinator\r\n    this.strategyCoordinator = new StrategyCoordinator(logger);\r\n\r\n    // Initialize Weight Matrix Calculator (Phase 2)\r\n    let weightMatrixCalculator: WeightMatrixCalculatorService | undefined;\r\n    if (config.weightMatrix?.enabled) {\r\n      weightMatrixCalculator = new WeightMatrixCalculatorService(config.weightMatrix, logger);\r\n      logger.info('âœ… Weight Matrix Calculator initialized', {\r\n        enabled: config.weightMatrix.enabled,\r\n        minConfidenceToEnter: config.weightMatrix.minConfidenceToEnter,\r\n        minConfidenceForReducedSize: config.weightMatrix.minConfidenceForReducedSize,\r\n      });\r\n    }\r\n\r\n    // Register strategies (sorted by priority automatically)\r\n    // Load strategy configs from parent config\r\n    const strategiesConfig = this.config.strategiesConfig!;\r\n\r\n    // ============================================================================\r\n    // TRADITIONAL STRATEGIES (LevelBased, TrendFollowing, CounterTrend)\r\n    // ============================================================================\r\n\r\n    if (strategiesConfig?.trendFollowing?.enabled) {\r\n      this.strategyCoordinator.registerStrategy(\r\n        new TrendFollowingStrategy(\r\n          strategiesConfig.trendFollowing,\r\n          logger,\r\n          weightMatrixCalculator,\r\n        ),\r\n      );\r\n      this.logger.info('ðŸ“Š Trend Following Strategy registered');\r\n    }\r\n\r\n    if (strategiesConfig?.levelBased?.enabled) {\r\n      this.strategyCoordinator.registerStrategy(\r\n        new LevelBasedStrategy(\r\n          strategiesConfig.levelBased,\r\n          logger,\r\n          weightMatrixCalculator,\r\n        ),\r\n      );\r\n      this.logger.info('ðŸ“Š Level Based Strategy registered');\r\n    }\r\n\r\n    if (strategiesConfig?.counterTrend?.enabled) {\r\n      this.strategyCoordinator.registerStrategy(\r\n        new CounterTrendStrategy(\r\n          strategiesConfig.counterTrend,\r\n          logger,\r\n          weightMatrixCalculator,\r\n        ),\r\n      );\r\n      this.logger.info('ðŸ“Š Counter Trend Strategy registered');\r\n    }\r\n\r\n    // ============================================================================\r\n    // WHALE STRATEGIES (WhaleHunter, WhaleHunterFollow)\r\n    // ============================================================================\r\n\r\n    if (config.whaleHunter?.enabled) {\r\n      const whaleDetector = new WhaleDetectorService(config.whaleHunter.detector, logger);\r\n\r\n      // OrderBookAnalyzer config (use from main config or defaults)\r\n      const orderbookConfig = {\r\n        enabled: true,\r\n        depth: 50,\r\n        wallThreshold: 0.1,\r\n        imbalanceThreshold: MULTIPLIERS.ONE_AND_HALF,\r\n        updateIntervalMs: 5000,\r\n      };\r\n      const orderbookAnalyzer = new OrderBookAnalyzer(orderbookConfig, logger);\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new WhaleHunterStrategy(\r\n          {\r\n            ...config.whaleHunter,\r\n            sessionBasedSL: config.sessionBasedSL,\r\n          },\r\n          whaleDetector,\r\n          orderbookAnalyzer,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸ‹ Whale Hunter Strategy registered', {\r\n        priority: config.whaleHunter.priority,\r\n        minConfidence: config.whaleHunter.minConfidence,\r\n      });\r\n    }\r\n\r\n    if (config.whaleHunterFollow?.enabled) {\r\n      const whaleDetectorFollow = new WhaleDetectorFollowService(\r\n        config.whaleHunterFollow.detector,\r\n        logger,\r\n      );\r\n\r\n      const orderbookConfig = {\r\n        enabled: true,\r\n        depth: 50,\r\n        wallThreshold: 0.1,\r\n        imbalanceThreshold: MULTIPLIERS.ONE_AND_HALF,\r\n        updateIntervalMs: 5000,\r\n      };\r\n      const orderbookAnalyzer = new OrderBookAnalyzer(orderbookConfig, logger);\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new WhaleHunterFollowStrategy(\r\n          {\r\n            ...config.whaleHunterFollow,\r\n            sessionBasedSL: config.sessionBasedSL,\r\n          },\r\n          whaleDetectorFollow,\r\n          orderbookAnalyzer,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸ‹ Whale Hunter Follow Strategy registered', {\r\n        priority: config.whaleHunterFollow.priority,\r\n        minConfidence: config.whaleHunterFollow.minConfidence,\r\n      });\r\n    }\r\n\r\n    // ============================================================================\r\n    // SCALPING STRATEGIES (MicroWall, TickDelta, LadderTp, LimitOrder, OrderFlow)\r\n    // ============================================================================\r\n\r\n    if (config.scalpingMicroWall?.enabled) {\r\n      this.logger.info('ðŸ“Š Registering Scalping Micro Wall Strategy...');\r\n\r\n      const microWallDetector = new MicroWallDetectorService(\r\n        config.scalpingMicroWall.detector,\r\n        logger,\r\n      );\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingMicroWallStrategy(\r\n          config.scalpingMicroWall,\r\n          microWallDetector,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸ“Š Scalping Micro Wall Strategy registered', {\r\n        priority: config.scalpingMicroWall.priority,\r\n        minConfidence: config.scalpingMicroWall.minConfidence,\r\n        takeProfitPercent: config.scalpingMicroWall.takeProfitPercent,\r\n        stopLossPercent: config.scalpingMicroWall.stopLossPercent,\r\n      });\r\n    }\r\n\r\n    if (config.scalpingLimitOrder?.enabled) {\r\n      this.logger.info('ðŸ’° Registering Scalping Limit Order Strategy (fee optimization wrapper)...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingLimitOrderStrategy(\r\n          config.scalpingLimitOrder,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸ’° Scalping Limit Order Strategy registered', {\r\n        priority: config.scalpingLimitOrder.priority,\r\n        baseSignalSource: config.scalpingLimitOrder.baseSignalSource,\r\n        timeoutMs: config.scalpingLimitOrder.executor.timeoutMs,\r\n        slippagePercent: config.scalpingLimitOrder.executor.slippagePercent,\r\n        feeSavings: '0.05% per trade',\r\n      });\r\n    }\r\n\r\n    // Register Scalping Ladder TP Strategy (if enabled)\r\n    this.logger.info(`ðŸ” DEBUG: Checking scalpingLadderTp - exists: ${!!config.scalpingLadderTp}, enabled: ${config.scalpingLadderTp?.enabled}`);\r\n    if (config.scalpingLadderTp?.enabled) {\r\n      this.logger.info('ðŸŽ¯ Registering Scalping Ladder TP Strategy (multi-level exit wrapper)...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingLadderTpStrategy(\r\n          config.scalpingLadderTp,\r\n          this.bybitService,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸŽ¯ Scalping Ladder TP Strategy registered', {\r\n        priority: config.scalpingLadderTp.priority,\r\n        baseSignalSource: config.scalpingLadderTp.baseSignalSource,\r\n        levels: config.scalpingLadderTp.ladderManager.levels.length,\r\n        tpLevels: config.scalpingLadderTp.ladderManager.levels.map((l: { pricePercent: number; closePercent: number }) => `${l.pricePercent}%`).join(', '),\r\n        rrRatio: '~1.26:1',\r\n      });\r\n    }\r\n\r\n    if (config.scalpingTickDelta?.enabled) {\r\n      this.logger.info('ðŸ“Š Registering Scalping Tick Delta Strategy...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingTickDeltaStrategy(\r\n          config.scalpingTickDelta,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸ“Š Scalping Tick Delta Strategy registered', {\r\n        priority: config.scalpingTickDelta.priority,\r\n        minDeltaRatio: config.scalpingTickDelta.analyzer.minDeltaRatio,\r\n        takeProfitPercent: config.scalpingTickDelta.takeProfitPercent,\r\n        stopLossPercent: config.scalpingTickDelta.stopLossPercent,\r\n        rrRatio: '2:1',\r\n      });\r\n    }\r\n\r\n    if (config.scalpingOrderFlow?.enabled) {\r\n      this.logger.info('ðŸ“Š Registering Scalping Order Flow Strategy...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingOrderFlowStrategy(\r\n          config.scalpingOrderFlow,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('ðŸ“Š Scalping Order Flow Strategy registered', {\r\n        priority: config.scalpingOrderFlow.priority,\r\n        aggressiveBuyThreshold: config.scalpingOrderFlow.analyzer.aggressiveBuyThreshold,\r\n        takeProfitPercent: config.scalpingOrderFlow.takeProfitPercent,\r\n        stopLossPercent: config.scalpingOrderFlow.stopLossPercent,\r\n        rrRatio: '2:1',\r\n      });\r\n    }\r\n\r\n    this.logger.info('âœ… Strategy Coordinator initialized', {\r\n      strategies: this.strategyCoordinator.getStrategies().map(s => s.name),\r\n    });\r\n\r\n    // Initialize BTC confirmation filter\r\n    if (config.btcConfirmation?.enabled) {\r\n      this.btcAnalyzer = new BTCAnalyzer(config.btcConfirmation, logger);\r\n      this.logger.info('BTC confirmation filter enabled', {\r\n        symbol: config.btcConfirmation.symbol,\r\n        timeframe: config.btcConfirmation.timeframe,\r\n      });\r\n    }\r\n\r\n    // Initialize funding rate filter\r\n    if (config.fundingRateFilter?.enabled) {\r\n      this.fundingRateFilter = new FundingRateFilterService(\r\n        config.fundingRateFilter,\r\n        async () => await bybitService.getFundingRate(),\r\n        logger,\r\n      );\r\n      this.logger.info('ðŸ’° Funding Rate Filter enabled', {\r\n        blockLongThreshold: (config.fundingRateFilter.blockLongThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n        blockShortThreshold: (config.fundingRateFilter.blockShortThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n        cacheTimeMs: config.fundingRateFilter.cacheTimeMs,\r\n      });\r\n    }\r\n\r\n    // Initialize flat market detector\r\n    if (config.flatMarketDetection?.enabled) {\r\n      this.flatMarketDetector = new FlatMarketDetector(config.flatMarketDetection, logger);\r\n      this.logger.info('ðŸ“Š Flat Market Detector enabled', {\r\n        flatThreshold: config.flatMarketDetection.flatThreshold,\r\n        emaThreshold: config.flatMarketDetection.emaThreshold,\r\n        atrThreshold: config.flatMarketDetection.atrThreshold,\r\n      });\r\n    }\r\n\r\n    // Initialize Phase 1 services (Smart Entry & Breakeven)\r\n    // Services are passed from bot.ts to ensure single instance shared with PositionManager\r\n    this.fastEntryService = fastEntryService || null;\r\n    this.smartBreakevenService = smartBreakevenService || null;\r\n    this.retestEntryService = retestEntryService || null;\r\n\r\n    // Phase 4: Market Data Enhancement services\r\n    this.deltaAnalyzerService = deltaAnalyzerService || null;\r\n    this.orderbookImbalanceService = orderbookImbalanceService || null;\r\n\r\n    // Initialize Volume Profile Service (PHASE 4 Feature 3)\r\n    if (config.volumeProfile?.enabled) {\r\n      this.volumeProfileService = new VolumeProfileService(config.volumeProfile, logger);\r\n      this.logger.info('ðŸ“Š Volume Profile Service initialized', {\r\n        lookbackCandles: config.volumeProfile.lookbackCandles,\r\n        valueAreaPercent: config.volumeProfile.valueAreaPercent,\r\n        priceTickSize: config.volumeProfile.priceTickSize,\r\n      });\r\n    }\r\n\r\n    // Phase 5: Risk Management services\r\n    this.dailyLimitsService = dailyLimitsService || null;\r\n    this.riskBasedSizingService = riskBasedSizingService || null;\r\n    this.lossStreakService = lossStreakService || null;\r\n    this.maxConcurrentRiskService = maxConcurrentRiskService || null;\r\n\r\n    if (this.fastEntryService) {\r\n      this.logger.info('âš¡ Fast Entry Service enabled', {\r\n        partialSizePercent: config.fastEntry?.partialSizePercent,\r\n        minBodyPercent: config.fastEntry?.minBodyPercent,\r\n        volumeMultiplier: config.fastEntry?.volumeMultiplier,\r\n      });\r\n    }\r\n\r\n    if (this.smartBreakevenService) {\r\n      this.logger.info('ðŸŽ¯ Smart Breakeven Service enabled', {\r\n        activationProfitPercent: config.smartBreakeven?.activationProfitPercent,\r\n        breakevenProfitPercent: config.smartBreakeven?.breakevenProfitPercent,\r\n        requireEMAHold: config.smartBreakeven?.requireEMAHold,\r\n      });\r\n    }\r\n\r\n    if (this.retestEntryService) {\r\n      this.logger.info('ðŸŽ¯ Retest Entry Service enabled', {\r\n        minImpulsePercent: config.retestEntry?.minImpulsePercent,\r\n        retestZone: config.retestEntry ? `${config.retestEntry.retestZoneFibStart}%-${config.retestEntry.retestZoneFibEnd}%` : 'N/A',\r\n        maxRetestWaitMs: config.retestEntry?.maxRetestWaitMs,\r\n      });\r\n    }\r\n\r\n    if (this.deltaAnalyzerService) {\r\n      this.logger.info('ðŸ“Š Delta Analyzer Service enabled (PHASE 4)', {\r\n        windowSizeMs: config.delta?.windowSizeMs,\r\n        minDeltaThreshold: config.delta?.minDeltaThreshold,\r\n      });\r\n    }\r\n\r\n    if (this.dailyLimitsService) {\r\n      this.logger.info('ðŸ›¡ï¸ Daily Limits Service enabled (PHASE 5)', {\r\n        maxDailyLossPercent: config.dailyLimits?.maxDailyLossPercent,\r\n        maxDailyProfitPercent: config.dailyLimits?.maxDailyProfitPercent,\r\n        resetTimeUTC: config.dailyLimits?.resetTimeUTC,\r\n      });\r\n    }\r\n\r\n    if (this.riskBasedSizingService) {\r\n      this.logger.info('ðŸ’° Risk-Based Sizing Service enabled (PHASE 5)', {\r\n        riskPerTradePercent: config.riskBasedSizing?.riskPerTradePercent,\r\n        minPositionSizeUsdt: config.riskBasedSizing?.minPositionSizeUsdt,\r\n        maxPositionSizeUsdt: config.riskBasedSizing?.maxPositionSizeUsdt,\r\n      });\r\n    }\r\n\r\n    if (this.lossStreakService) {\r\n      this.logger.info('ðŸ“‰ Loss Streak Service enabled (PHASE 5)', {\r\n        reductions: config.lossStreak?.reductions,\r\n        stopAfterLosses: config.lossStreak?.stopAfterLosses,\r\n      });\r\n    }\r\n\r\n    // Initialize context on startup (async)\r\n    void this.initializeContext();\r\n  }\r\n\r\n  /**\r\n   * Initialize context on startup\r\n   */\r\n  private async initializeContext(): Promise<void> {\r\n    try {\r\n      this.logger.info('ðŸ”„ Initializing trading context...');\r\n      this.currentContext = await this.contextAnalyzer.analyze();\r\n      this.logger.info('âœ… Trading context initialized', {\r\n        trend: this.currentContext.trend,\r\n        overallModifier: this.currentContext.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        warnings: this.currentContext.warnings,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize context', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle candle close event\r\n   * Called by Bot when candle closes on any timeframe\r\n   */\r\n  async onCandleClosed(role: TimeframeRole, candle: Candle): Promise<void> {\r\n    try {\r\n      // PRIMARY closed â†’ Update context\r\n      if (role === TimeframeRole.PRIMARY) {\r\n        this.logger.info('ðŸ“Š PRIMARY candle closed - updating context');\r\n        this.currentContext = await this.contextAnalyzer.analyze();\r\n\r\n        this.logger.info('Context updated', {\r\n          trend: this.currentContext.trend,\r\n          overallModifier: this.currentContext.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n          warnings: this.currentContext.warnings,\r\n        });\r\n      }\r\n\r\n      // ENTRY closed â†’ Scan for entry\r\n      if (role === TimeframeRole.ENTRY) {\r\n        // ðŸ• SYNC TIME before analysis (critical for preventing timestamp errors)\r\n        try {\r\n          await this.syncTimeWithExchange();\r\n        } catch (error) {\r\n          this.logger.warn('Time sync failed before analysis, continuing...', {\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n\r\n        this.logger.info('ðŸ” ENTRY candle closed - scanning for entry');\r\n\r\n        // Need context first\r\n        if (!this.currentContext) {\r\n          this.logger.warn('No context available yet, skipping entry scan');\r\n          return;\r\n        }\r\n\r\n        // Check if already in position\r\n        const currentPosition = this.positionManager.getCurrentPosition();\r\n        if (currentPosition) {\r\n          // Update BB trailing stop if enabled (BB.MD Section 3.3)\r\n          // BB indicator enabled is sufficient check (BB config contains enabled flag)\r\n          if (this.bollingerIndicator && this.config.indicators?.bollingerBands?.enabled) {\r\n            try {\r\n              // Get entry candles for BB calculation\r\n              const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n              const bbPeriod = this.config.indicators.bollingerBands.period || 20;\r\n              if (entryCandles.length >= bbPeriod) {\r\n                // Calculate current BB\r\n                const bb = this.bollingerIndicator.calculate(entryCandles);\r\n\r\n                // Get ATR (convert from percent to absolute value)\r\n                const atr = this.currentContext?.atrPercent\r\n                  ? (this.currentContext.atrPercent / PERCENT_MULTIPLIER) * candle.close\r\n                  : 0;\r\n\r\n                // Update BB trailing stop (method checks its own enabled flag)\r\n                await this.positionManager.updateBBTrailingStop(bb, atr, candle.close);\r\n              }\r\n            } catch (error) {\r\n              this.logger.warn('Failed to update BB trailing stop', {\r\n                error: error instanceof Error ? error.message : String(error),\r\n              });\r\n            }\r\n          }\r\n\r\n          // ====================================================================\r\n          // PHASE 1: Smart Breakeven - Update Pre-BE mode\r\n          // ====================================================================\r\n          if (this.smartBreakevenService && this.config.smartBreakeven?.enabled) {\r\n            const state = this.smartBreakevenService.getState(currentPosition.symbol);\r\n            if (state && state.mode === 'PRE_BE') {\r\n              try {\r\n                const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n                if (entryCandles.length >= PERCENTAGE_THRESHOLDS.LOW_MODERATE) {\r\n                  const emaFast = await this.emaAnalyzer.calculate(TimeframeRole.ENTRY);\r\n                  const ema20 = emaFast?.fast ?? 0;\r\n\r\n                  const recentVolumes = entryCandles.slice(-20).map(c => c.volume);\r\n                  const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n\r\n                  await this.smartBreakevenService.updateBreakeven(\r\n                    currentPosition,\r\n                    candle.close,\r\n                    ema20,\r\n                    candle.volume,\r\n                    avgVolume,\r\n                    async (newSL: number) => {\r\n                      await this.bybitService.updateStopLoss(newSL);\r\n                      if (this.positionManager.getCurrentPosition()) {\r\n                        this.positionManager.getCurrentPosition()!.stopLoss.price = newSL;\r\n                        this.positionManager.getCurrentPosition()!.stopLoss.updatedAt = Date.now();\r\n                      }\r\n                    },\r\n                  );\r\n                }\r\n              } catch (error) {\r\n                this.logger.warn('Failed to update smart breakeven', {\r\n                  error: error instanceof Error ? error.message : String(error),\r\n                });\r\n              }\r\n            }\r\n          }\r\n\r\n          // ====================================================================\r\n          // PHASE 1: Retest Entry - Check for retest entry\r\n          // ====================================================================\r\n          if (this.retestEntryService && this.config.retestEntry?.enabled) {\r\n            const zone = this.retestEntryService.getRetestZone(currentPosition.symbol);\r\n            if (zone) {\r\n              try {\r\n                const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n                const emaFast = await this.emaAnalyzer.calculate(TimeframeRole.ENTRY);\r\n                const ema20 = emaFast?.fast ?? 0;\r\n\r\n                const recentVolumes = entryCandles.slice(-20).map(c => c.volume);\r\n                const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n\r\n                // Get senior TF trend (TREND1)\r\n                const trend1Ema = await this.emaAnalyzer.calculate(TimeframeRole.TREND1);\r\n                const seniorTFTrend = trend1Ema\r\n                  ? (trend1Ema.fast > trend1Ema.slow ? 'UP' : trend1Ema.fast < trend1Ema.slow ? 'DOWN' : 'NEUTRAL')\r\n                  : 'NEUTRAL';\r\n\r\n                const retest = this.retestEntryService.checkRetest(\r\n                  currentPosition.symbol,\r\n                  candle.close,\r\n                  candle.volume,\r\n                  avgVolume,\r\n                  ema20,\r\n                  seniorTFTrend as 'UP' | 'DOWN' | 'NEUTRAL',\r\n                );\r\n\r\n                if (retest.shouldEnter && zone.originalSignal) {\r\n                  this.logger.info('âœ… Retest entry triggered - NOT executing (position already open)', {\r\n                    symbol: currentPosition.symbol,\r\n                    price: candle.close,\r\n                    reason: retest.reason,\r\n                  });\r\n                  this.retestEntryService.clearZone(currentPosition.symbol);\r\n                }\r\n              } catch (error) {\r\n                this.logger.warn('Failed to check retest entry', {\r\n                  error: error instanceof Error ? error.message : String(error),\r\n                });\r\n              }\r\n            }\r\n          }\r\n\r\n          this.logger.info('Already in position, skipping entry scan', {\r\n            positionId: currentPosition.id,\r\n          });\r\n          return;\r\n        }\r\n\r\n        // ========================================================================\r\n        // STEP 1: Check pending confirmations (candle close confirmation)\r\n        // ========================================================================\r\n        const confirmedSignal = this.positionManager.checkPendingConfirmations(candle.close);\r\n        if (confirmedSignal) {\r\n          this.logger.info(`âœ… Pending ${confirmedSignal.direction} confirmed - executing trade`);\r\n          const entrySignal: EntrySignal = {\r\n            shouldEnter: true,\r\n            direction: confirmedSignal.direction,\r\n            confidence: confirmedSignal.confidence,\r\n            entryPrice: confirmedSignal.price,\r\n            stopLoss: confirmedSignal.stopLoss,\r\n            takeProfits: confirmedSignal.takeProfits,\r\n            reason: confirmedSignal.reason + ' [CONFIRMED]',\r\n            timestamp: confirmedSignal.timestamp,\r\n          };\r\n          await this.executeTrade(entrySignal);\r\n          return; // Exit early\r\n        }\r\n\r\n        // Prepare market data for strategies\r\n        const marketData = await this.prepareMarketData();\r\n\r\n        if (!marketData) {\r\n          this.logger.warn('Failed to prepare market data, skipping entry scan');\r\n          return;\r\n        }\r\n\r\n        // ========================================================================\r\n        // FLAT MARKET DETECTION: Determine adaptive confidence threshold\r\n        // ========================================================================\r\n        let flatResult: { isFlat: boolean; confidence: number } | null = null;\r\n        if (this.flatMarketDetector && this.currentContext) {\r\n          try {\r\n            const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n            const primaryEma = await this.emaAnalyzer.calculate(TimeframeRole.PRIMARY);\r\n\r\n            if (primaryCandles.length > 0 && primaryEma) {\r\n              flatResult = this.flatMarketDetector.detect(\r\n                primaryCandles,\r\n                this.currentContext,\r\n                primaryEma.fast,\r\n                primaryEma.slow,\r\n              );\r\n            }\r\n          } catch (error) {\r\n            this.logger.warn('Flat market detection failed', { error });\r\n          }\r\n        }\r\n\r\n        // Calculate adaptive min confidence threshold\r\n        // Use minConfidenceFlat for flat markets, minConfidenceToEnter for trending\r\n        const minConfidenceValue = flatResult?.isFlat && this.config.weightMatrix?.minConfidenceFlat\r\n          ? this.config.weightMatrix.minConfidenceFlat\r\n          : this.config.weightMatrix?.minConfidenceToEnter || 50;\r\n\r\n        const minConfidence = minConfidenceValue / PERCENT_MULTIPLIER;\r\n\r\n        this.logger.info('ðŸŽ¯ Adaptive Confidence Threshold', {\r\n          marketType: flatResult?.isFlat ? 'FLAT' : 'TRENDING',\r\n          flatConfidence: flatResult?.confidence.toFixed(1) + '%',\r\n          minRequired: minConfidenceValue + '%',\r\n          source: flatResult?.isFlat ? 'minConfidenceFlat' : 'minConfidenceToEnter',\r\n        });\r\n\r\n        // ========================================================================\r\n        // USE STRATEGY COORDINATOR (FIRST VALID WINS)\r\n        // ========================================================================\r\n        this.logger.info('ðŸ“‹ Evaluating Strategies', {\r\n          strategies: this.strategyCoordinator.getStrategies().map(s => ({ name: s.name, priority: s.priority })),\r\n        });\r\n\r\n        const strategySignal = await this.strategyCoordinator.evaluateStrategies(\r\n          marketData,\r\n          minConfidence,\r\n        );\r\n\r\n        if (strategySignal && strategySignal.valid && strategySignal.signal) {\r\n          this.logger.info('âœ… STRATEGY SIGNAL FOUND!', {\r\n            strategy: strategySignal.strategyName,\r\n            priority: strategySignal.priority,\r\n            direction: strategySignal.signal.direction,\r\n            confidence: strategySignal.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n            reason: strategySignal.reason,\r\n          });\r\n\r\n          // ====================================================================\r\n          // FLAT MARKET DETECTION: Adjust TPs based on market conditions\r\n          // ====================================================================\r\n          // Reuse flatResult from earlier detection (line 662)\r\n          if (flatResult) {\r\n            if (flatResult.isFlat) {\r\n              // FLAT MARKET: Adjust to single TP (100% close at TP1 price)\r\n              const firstTP = strategySignal.signal.takeProfits[0];\r\n              strategySignal.signal.takeProfits = [{\r\n                level: 1,\r\n                price: firstTP.price,\r\n                sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Close 100% on TP1\r\n                percent: firstTP.percent,\r\n                hit: false,\r\n              }];\r\n\r\n              this.logger.info('âš¡ FLAT market - adjusted to single TP', {\r\n                confidence: flatResult.confidence.toFixed(1) + '%',\r\n                tpPrice: firstTP.price.toFixed(DECIMAL_PLACES.PRICE),\r\n                tpPercent: firstTP.percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n              });\r\n            } else {\r\n              // TRENDING MARKET: Keep multi-TP strategy\r\n              this.logger.info('ðŸ“ˆ TRENDING market - keeping multi-TP strategy', {\r\n                confidence: flatResult.confidence.toFixed(1) + '%',\r\n                tpCount: strategySignal.signal.takeProfits.length,\r\n              });\r\n            }\r\n          }\r\n\r\n          // ====================================================================\r\n          // Entry Confirmation: Check if confirmation is enabled for direction\r\n          // ====================================================================\r\n          const needsConfirmation = this.positionManager.isConfirmationEnabled(strategySignal.signal.direction);\r\n          const keyLevel = strategySignal.signal.marketData?.nearestLevel;\r\n\r\n          if (needsConfirmation && keyLevel) {\r\n            const levelType = strategySignal.signal.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n            this.logger.info(`â³ ${strategySignal.signal.direction} signal detected - adding to pending queue for candle confirmation`, {\r\n              direction: strategySignal.signal.direction,\r\n              [`${levelType}Level`]: keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n              currentPrice: strategySignal.signal.price.toFixed(DECIMAL_PLACES.PRICE),\r\n            });\r\n\r\n            const pendingId = this.positionManager.addPendingSignal(\r\n              strategySignal.signal,\r\n              keyLevel,\r\n            );\r\n\r\n            const confirmCondition = strategySignal.signal.direction === SignalDirection.LONG\r\n              ? 'Next 1m candle close above support'\r\n              : 'Next 1m candle close below resistance';\r\n\r\n            this.logger.info(`â³ ${strategySignal.signal.direction} signal added to pending queue`, {\r\n              pendingId,\r\n              direction: strategySignal.signal.direction,\r\n              [`${levelType}Level`]: keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n              waitingFor: confirmCondition,\r\n            });\r\n\r\n            return; // Exit early - signal pending confirmation\r\n          }\r\n\r\n          // Convert Strategy Signal to Entry Signal for execution (immediate entry)\r\n          const entrySignal: EntrySignal = {\r\n            shouldEnter: true,\r\n            direction: strategySignal.signal.direction,\r\n            confidence: strategySignal.signal.confidence,\r\n            entryPrice: strategySignal.signal.price,\r\n            stopLoss: strategySignal.signal.stopLoss,\r\n            takeProfits: strategySignal.signal.takeProfits,\r\n            reason: strategySignal.reason || strategySignal.strategyName,\r\n            timestamp: strategySignal.signal.timestamp,\r\n            strategyName: strategySignal.strategyName, // Preserve strategy name for journal\r\n          };\r\n\r\n          // Execute trade immediately (confirmation disabled or no key level)\r\n          this.logger.info(`âš¡ ${strategySignal.signal.direction} entering immediately (confirmation ${needsConfirmation ? 'needs key level' : 'disabled'})`);\r\n          await this.executeTrade(entrySignal, marketData);\r\n          return; // Exit early, strategy found\r\n        }\r\n\r\n        // ========================================================================\r\n        // FALLBACK: Use Entry Scanner (legacy)\r\n        // ========================================================================\r\n        // Check if fallback is enabled (default: true for backward compatibility)\r\n        const enableFallback = this.config.enableEntryScannerFallback !== false;\r\n\r\n        if (enableFallback) {\r\n          this.logger.info('ðŸ“Š No strategy signal - trying Entry Scanner (fallback)');\r\n\r\n          const entrySignal = await this.entryScanner.scan(this.currentContext);\r\n\r\n          if (entrySignal.shouldEnter) {\r\n            this.logger.info('âœ… ENTRY SCANNER SIGNAL FOUND! (fallback)', {\r\n              direction: entrySignal.direction,\r\n              confidence: entrySignal.confidence,\r\n              reason: entrySignal.reason,\r\n            });\r\n\r\n            // Execute trade\r\n            await this.executeTrade(entrySignal, marketData);\r\n          } else {\r\n            this.logger.info('âŒ No entry signal from any source', {\r\n              strategyCoordinator: 'no valid signal',\r\n              entryScanner: entrySignal.reason,\r\n            });\r\n          }\r\n        } else {\r\n          this.logger.debug('â­ï¸ EntryScanner fallback disabled - skipping legacy patterns analysis');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Error in orchestrator onCandleClosed', {\r\n        role,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute trade from entry signal\r\n   * @param entrySignal - Entry signal with trade details\r\n   * @param marketData - Market data for session stats (optional)\r\n   */\r\n  private async executeTrade(entrySignal: EntrySignal, marketData?: StrategyMarketData): Promise<void> {\r\n    try {\r\n      // PHASE 5: Check Emergency Kill-Switch\r\n      const fs = await import('fs');\r\n      if (fs.existsSync('data/STOP_TRADING')) {\r\n        this.logger.warn('â›” Trading halted by emergency kill-switch (data/STOP_TRADING exists)');\r\n        return;\r\n      }\r\n\r\n      // PHASE 5: Check Daily Limits\r\n      if (this.dailyLimitsService) {\r\n        const limitsCheck = this.dailyLimitsService.canTrade();\r\n        if (!limitsCheck.allowed) {\r\n          this.logger.warn('âŒ Trade blocked by daily limits (PHASE 5)', {\r\n            reason: limitsCheck.reason,\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      // PHASE 5: Check Loss Streak\r\n      if (this.lossStreakService) {\r\n        const streakCheck = this.lossStreakService.canTrade();\r\n        if (!streakCheck.allowed) {\r\n          this.logger.warn('âŒ Trade blocked by loss streak (PHASE 5)', {\r\n            reason: streakCheck.reason,\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      this.logger.info('ðŸš€ Executing trade...', {\r\n        direction: entrySignal.direction,\r\n        entry: entrySignal.entryPrice,\r\n        sl: entrySignal.stopLoss,\r\n      });\r\n\r\n      // ======================================================================\r\n      // PHASE 1: Check for missed impulse - Create retest zone\r\n      // ======================================================================\r\n      if (this.retestEntryService && this.config.retestEntry?.enabled) {\r\n        try {\r\n          const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n          if (entryCandles.length >= 10) {\r\n            const currentPrice = entryCandles[entryCandles.length - 1].close;\r\n            const symbol = this.bybitService['symbol'];\r\n            const impulse = this.retestEntryService.detectImpulse(\r\n              symbol,\r\n              currentPrice,\r\n              entryCandles,\r\n            );\r\n\r\n            if (impulse.hasImpulse) {\r\n              // Convert EntrySignal to Signal format\r\n              const signal: Signal = {\r\n                type: (entrySignal.strategyName as SignalType) || SignalType.LEVEL_BASED,\r\n                direction: entrySignal.direction,\r\n                price: entrySignal.entryPrice,\r\n                stopLoss: entrySignal.stopLoss,\r\n                takeProfits: entrySignal.takeProfits,\r\n                confidence: entrySignal.confidence,\r\n                reason: entrySignal.reason,\r\n                timestamp: entrySignal.timestamp,\r\n              };\r\n\r\n              this.retestEntryService.createRetestZone(\r\n                symbol,\r\n                signal,\r\n                impulse.impulseStart,\r\n                impulse.impulseEnd,\r\n              );\r\n\r\n              this.logger.info('â³ Impulse detected - waiting for retest (not entering immediately)');\r\n              return; // Don't enter immediately, wait for retest\r\n            }\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Failed to check for missed impulse', {\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n      }\r\n\r\n      // BTC confirmation check\r\n      if (this.btcAnalyzer && this.config.btcConfirmation?.enabled) {\r\n        const btcAnalysis = await this.analyzeBTC(entrySignal.direction);\r\n\r\n        if (btcAnalysis && !this.btcAnalyzer.shouldConfirm(btcAnalysis)) {\r\n          this.logger.info('âŒ BTC confirmation FAILED - signal blocked', {\r\n            direction: entrySignal.direction,\r\n            btcDirection: btcAnalysis.direction,\r\n            btcMomentum: btcAnalysis.momentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n            isAligned: btcAnalysis.isAligned,\r\n            reason: btcAnalysis.reason,\r\n          });\r\n          return; // Block trade\r\n        }\r\n\r\n        if (btcAnalysis) {\r\n          this.logger.info('âœ… BTC confirmation PASSED', {\r\n            direction: entrySignal.direction,\r\n            btcDirection: btcAnalysis.direction,\r\n            btcMomentum: btcAnalysis.momentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n            isAligned: btcAnalysis.isAligned,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Funding rate filter check\r\n      if (this.fundingRateFilter && this.config.fundingRateFilter?.enabled) {\r\n        const filterResult = await this.fundingRateFilter.checkSignal(entrySignal.direction);\r\n\r\n        if (!filterResult.allowed) {\r\n          this.logger.warn('ðŸš« Funding Rate Filter BLOCKED signal', {\r\n            direction: entrySignal.direction,\r\n            reason: filterResult.reason,\r\n            fundingRate: filterResult.fundingRate\r\n              ? (filterResult.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%'\r\n              : 'N/A',\r\n          });\r\n          return; // Block signal\r\n        }\r\n\r\n        this.logger.debug('âœ… Funding Rate Filter PASSED', {\r\n          direction: entrySignal.direction,\r\n          fundingRate: filterResult.fundingRate\r\n            ? (filterResult.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%'\r\n            : 'N/A',\r\n        });\r\n      }\r\n\r\n      // Convert EntrySignal to Signal format\r\n      const signal: Signal = {\r\n        type: (entrySignal.strategyName as SignalType) || SignalType.LEVEL_BASED,\r\n        direction: entrySignal.direction,\r\n        price: entrySignal.entryPrice,\r\n        stopLoss: entrySignal.stopLoss,\r\n        takeProfits: entrySignal.takeProfits,\r\n        confidence: entrySignal.confidence,\r\n        reason: entrySignal.reason,\r\n        timestamp: entrySignal.timestamp,\r\n      };\r\n\r\n      // Get account balance\r\n      const balance = await this.bybitService.getBalance();\r\n      this.logger.info('ðŸ’° Current balance', {\r\n        balance: balance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Calculate position size\r\n      const qty = this.calculatePositionSize(\r\n        signal.price,\r\n        balance,\r\n        this.config.positionSizeUsdt,\r\n      );\r\n\r\n      this.logger.info('ðŸ“ Position size calculated', {\r\n        qty,\r\n        value: (qty * signal.price).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Create entry snapshot for session stats (if marketData available)\r\n      let entrySnapshot: SessionEntryCondition | undefined;\r\n      if (marketData) {\r\n        // Extract indicators from marketData\r\n        const rsiAll = await this.rsiAnalyzer.calculateAll();\r\n        const emaAll = await this.emaAnalyzer.calculateAll();\r\n\r\n        const indicatorsEntry: IndicatorSnapshot = {\r\n          rsi: rsiAll.entry ?? 0,\r\n          ema20: emaAll.entry?.fast ?? 0,\r\n          ema50: emaAll.entry?.slow ?? 0,\r\n          atr: marketData.atr ?? 0,\r\n          volume: marketData.candles[marketData.candles.length - 1]?.volume ?? 0,\r\n        };\r\n\r\n        const indicatorsPrimary: IndicatorSnapshot = {\r\n          rsi: rsiAll.primary ?? 0,\r\n          ema20: emaAll.primary?.fast ?? 0,\r\n          ema50: emaAll.primary?.slow ?? 0,\r\n          atr: marketData.atr ?? 0,\r\n        };\r\n\r\n        const indicatorsTrend1: IndicatorSnapshot = {\r\n          rsi: rsiAll.trend1 ?? 0,\r\n          ema20: emaAll.trend1?.fast ?? 0,\r\n          ema50: emaAll.trend1?.slow ?? 0,\r\n          atr: marketData.atr ?? 0,\r\n        };\r\n\r\n        const patterns: PatternSnapshot = {\r\n          chartPattern: null, // TODO: Add chart pattern detection\r\n          engulfing: false,\r\n          triple: false,\r\n          triangle: false,\r\n          wedge: false,\r\n          flag: false,\r\n        };\r\n\r\n        const levels: LevelSnapshot | null = marketData.liquidity\r\n          ? {\r\n            nearestSupport: marketData.liquidity.nearestSupportZone?.priceLevel ?? signal.price,\r\n            nearestResistance: marketData.liquidity.nearestResistanceZone?.priceLevel ?? signal.price,\r\n            distanceToLevel: 0, // TODO: Calculate\r\n            levelStrength: marketData.liquidity.nearestSupportZone?.strength ?? 0,\r\n            touches: marketData.liquidity.nearestSupportZone?.touches ?? 0,\r\n          }\r\n          : null;\r\n\r\n        const context: ContextSnapshot = {\r\n          btcCorrelation: null, // TODO: Add BTC correlation\r\n          btcDirection: null,\r\n          fundingRate: null,\r\n          flatMarketScore: 0, // TODO: Add flat market score\r\n        };\r\n\r\n        entrySnapshot = {\r\n          signal: {\r\n            type: signal.type,\r\n            direction: signal.direction,\r\n            confidence: signal.confidence,\r\n            reason: signal.reason,\r\n          },\r\n          indicators: {\r\n            entry: indicatorsEntry,\r\n            primary: indicatorsPrimary,\r\n            trend1: indicatorsTrend1,\r\n          },\r\n          patterns,\r\n          levels,\r\n          context,\r\n        };\r\n      }\r\n\r\n      // ======================================================================\r\n      // PHASE 1: Fast Entry - Check for partial entry before candle close\r\n      // ======================================================================\r\n      if (this.fastEntryService && this.config.fastEntry?.enabled) {\r\n        try {\r\n          // Get current candle data\r\n          const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n          const trend1Candles = await this.candleProvider.getCandles(TimeframeRole.TREND1);\r\n\r\n          if (entryCandles.length >= PERCENTAGE_THRESHOLDS.LOW_MODERATE && trend1Candles.length >= 2) {\r\n            const currentCandle = entryCandles[entryCandles.length - 1];\r\n\r\n            // Calculate volume SMA\r\n            const recentVolumes = entryCandles.slice(-20).map((c) => c.volume);\r\n            const volumeSMA = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n\r\n            // Determine senior TF trend\r\n            const trend1Ema = trend1Candles[trend1Candles.length - 1];\r\n            const trend1EmaPrev = trend1Candles[trend1Candles.length - 2];\r\n            const seniorTFTrend: 'UP' | 'DOWN' | 'NEUTRAL' =\r\n              trend1Ema.close > trend1EmaPrev.close ? 'UP' : trend1Ema.close < trend1EmaPrev.close ? 'DOWN' : 'NEUTRAL';\r\n\r\n            // Check fast trigger conditions\r\n            const fastTrigger = this.fastEntryService.checkFastTrigger(\r\n              signal,\r\n              currentCandle,\r\n              currentCandle.volume,\r\n              volumeSMA,\r\n              seniorTFTrend,\r\n            );\r\n\r\n            if (fastTrigger) {\r\n              // Execute partial entry (40%)\r\n              const partialSize = qty * (this.config.fastEntry.partialSizePercent / PERCENT_MULTIPLIER);\r\n              const remainingSize = qty - partialSize;\r\n\r\n              const partial = await this.fastEntryService.executePartialEntry(\r\n                this.bybitService['symbol'],\r\n                signal,\r\n                qty,\r\n                async (partialQty) => {\r\n                  // Open partial position\r\n                  const partialPosition = await this.positionManager.openPosition(\r\n                    {\r\n                      ...signal,\r\n                      // Adjust for partial size (no need to change signal itself)\r\n                    },\r\n                    entrySnapshot,\r\n                  );\r\n\r\n                  return {\r\n                    orderId: partialPosition.id,\r\n                    avgPrice: partialPosition.entryPrice,\r\n                  };\r\n                },\r\n              );\r\n\r\n              if (partial) {\r\n                this.logger.info('âš¡ Fast Entry executed (40%), waiting for candle close to add remaining 60%');\r\n                // Note: Remaining 60% will be added by entry confirmation service\r\n                // TODO: Schedule confirmation check for remaining size\r\n                return; // Don't execute full entry immediately\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Failed to check Fast Entry conditions', {\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n          // Continue with standard entry if Fast Entry fails\r\n        }\r\n      }\r\n\r\n      // Open position (standard entry or Fast Entry fallback)\r\n      const position = await this.positionManager.openPosition(signal, entrySnapshot);\r\n\r\n      this.logger.info('âœ… Position opened successfully!', {\r\n        positionId: position.id,\r\n        side: position.side,\r\n        entry: position.entryPrice,\r\n      });\r\n\r\n      // Send Telegram notification\r\n      if (this.telegram) {\r\n        await this.telegram.sendTradeNotification({\r\n          type: 'ENTRY',\r\n          direction: signal.direction,\r\n          price: signal.price,\r\n          stopLoss: signal.stopLoss,\r\n          takeProfits: signal.takeProfits,\r\n          confidence: signal.confidence,\r\n          reason: signal.reason,\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to execute trade', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      // TODO: Send error notification via Telegram\r\n      // if (this.telegram) {\r\n      //   await this.telegram.sendMessage(...);\r\n      // }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare lightweight market data for Whale Hunter (scalping-optimized)\r\n   * Only includes: orderbook, current price, context (ATR, BTC analysis)\r\n   * Skips: RSI, EMA, liquidity, divergence, swing points (not needed for whale detection)\r\n   */\r\n  private async prepareMarketDataForWhale(orderbook: OrderBook): Promise<StrategyMarketData | null> {\r\n    try {\r\n      // Context is required for whale hunter (ATR%, BTC analysis)\r\n      if (!this.currentContext) {\r\n        return null;\r\n      }\r\n\r\n      // Get only ENTRY candles for current price (1 candle is enough)\r\n      const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n      if (!entryCandles || entryCandles.length < 1) {\r\n        return null;\r\n      }\r\n\r\n      const currentPrice = entryCandles[entryCandles.length - 1].close;\r\n      const currentTimestamp = entryCandles[entryCandles.length - 1].timestamp;\r\n\r\n      // Return minimal market data (only what whale hunter needs)\r\n      const marketData: StrategyMarketData = {\r\n        timestamp: currentTimestamp,\r\n        currentPrice,\r\n        candles: entryCandles, // Only ENTRY candles (for current price)\r\n        swingPoints: [], // Not needed for whale\r\n        rsi: 0, // Not needed for whale\r\n        rsiTrend1: undefined,\r\n        ema: { fast: 0, slow: 0 }, // Not needed for whale\r\n        emaTrend1: undefined,\r\n        atr: undefined, // Will use from context if needed\r\n        trend: this.currentContext.trend,\r\n        liquidity: undefined, // Not needed for whale\r\n        divergence: undefined, // Not needed for whale\r\n        orderbook, // CRITICAL: Fresh orderbook data\r\n        context: this.currentContext, // Contains ATR%, BTC analysis\r\n      };\r\n\r\n      return marketData;\r\n    } catch (error) {\r\n      this.logger.error('Error preparing whale market data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare market data for strategies\r\n   */\r\n  private async prepareMarketData(): Promise<StrategyMarketData | null> {\r\n    try {\r\n      // Get PRIMARY candles for swing points and market analysis (5m timeframe)\r\n      const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n      if (!primaryCandles || primaryCandles.length < 50) {\r\n        this.logger.warn('Not enough PRIMARY candles for market data');\r\n        return null;\r\n      }\r\n\r\n      const currentPrice = primaryCandles[primaryCandles.length - 1].close;\r\n      const currentTimestamp = primaryCandles[primaryCandles.length - 1].timestamp;\r\n\r\n      // Calculate indicators using MultiTimeframe analyzers\r\n      const rsiAll = await this.rsiAnalyzer.calculateAll();\r\n      const emaAll = await this.emaAnalyzer.calculateAll();\r\n      const atr = this.atrIndicator.calculate(primaryCandles);\r\n\r\n      // Extract PRIMARY timeframe data\r\n      const rsi = rsiAll.primary ?? 0;\r\n      const emaFast = emaAll.primary?.fast ?? 0;\r\n      const emaSlow = emaAll.primary?.slow ?? 0;\r\n\r\n      // Extract TREND1 (30m) timeframe data for higher timeframe confirmation\r\n      const rsiTrend1 = rsiAll.trend1;\r\n      const emaTrend1 = emaAll.trend1;\r\n\r\n      // Calculate swing points on PRIMARY timeframe (5m) for better signal quality\r\n      const { swingHighs, swingLows } = this.zigzagIndicator.findSwingPoints(primaryCandles);\r\n      const swingPoints = [...swingHighs, ...swingLows].sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n      // Liquidity analysis on PRIMARY candles\r\n      const liquidityAnalysis = this.liquidityDetector.analyze(swingPoints, primaryCandles, currentTimestamp);\r\n\r\n      // RSI history for divergence using PRIMARY candles\r\n      // Note: Using simple RSIIndicator for historical calculation\r\n      // MultiTimeframeRSIAnalyzer is for current candles only\r\n      const rsiIndicator = new RSIIndicator(14);\r\n      const rsiHistory = new Map<number, number>();\r\n      primaryCandles.slice(-20).forEach((candle, idx) => {\r\n        const candleRsi = rsiIndicator.calculate(primaryCandles.slice(0, primaryCandles.length - 20 + idx + 1));\r\n        rsiHistory.set(candle.timestamp, candleRsi);\r\n      });\r\n\r\n      // Divergence analysis\r\n      const divergence = this.divergenceDetector.detect(swingPoints, rsiHistory);\r\n\r\n      // Calculate Stochastic if enabled (on PRIMARY candles)\r\n      let stochastic: StrategyMarketData['stochastic'];\r\n      if (this.stochasticIndicator && this.config.indicators?.stochastic) {\r\n        try {\r\n          const result = this.stochasticIndicator.calculate(primaryCandles);\r\n          const { oversoldThreshold, overboughtThreshold } = this.config.indicators.stochastic;\r\n          stochastic = {\r\n            k: result.k,\r\n            d: result.d,\r\n            isOversold: result.k < oversoldThreshold,\r\n            isOverbought: result.k > overboughtThreshold,\r\n          };\r\n\r\n          // Log on INFO when extreme conditions\r\n          if (stochastic.isOversold || stochastic.isOverbought) {\r\n            this.logger.info('ðŸ“Š Stochastic EXTREME detected', {\r\n              k: result.k.toFixed(DECIMAL_PLACES.PERCENT),\r\n              d: result.d.toFixed(DECIMAL_PLACES.PERCENT),\r\n              condition: stochastic.isOversold ? 'OVERSOLD' : 'OVERBOUGHT',\r\n              threshold: stochastic.isOversold ? `<${oversoldThreshold}` : `>${overboughtThreshold}`,\r\n            });\r\n          } else {\r\n            this.logger.debug('Stochastic calculated for strategy', {\r\n              k: result.k.toFixed(DECIMAL_PLACES.PERCENT),\r\n              d: result.d.toFixed(DECIMAL_PLACES.PERCENT),\r\n              oversold: stochastic.isOversold,\r\n              overbought: stochastic.isOverbought,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Stochastic calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate Bollinger Bands if enabled\r\n      let bollingerBands: StrategyMarketData['bollingerBands'];\r\n      if (this.bollingerIndicator && this.config.indicators?.bollingerBands) {\r\n        try {\r\n          // Apply adaptive params if enabled and ATR available\r\n          if (this.config.indicators.bollingerBands.adaptiveParams && atr !== undefined) {\r\n            const adaptiveParams = this.bollingerIndicator.getAdaptiveParams(atr, currentPrice);\r\n            this.bollingerIndicator.applyAdaptiveParams(adaptiveParams);\r\n\r\n            // Determine volatility category from stdDev\r\n            const volatilityCategory = adaptiveParams.stdDev >= 2.5 ? 'HIGH'\r\n              : adaptiveParams.stdDev >= 2.0 ? 'MEDIUM'\r\n                : 'LOW';\r\n\r\n            // Log adaptive params on INFO (volatility-based adjustments are important)\r\n            this.logger.info('ðŸ”§ BB Adaptive Params Applied', {\r\n              volatility: volatilityCategory,\r\n              period: adaptiveParams.period,\r\n              stdDev: adaptiveParams.stdDev.toFixed(1),\r\n              atr: atr.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n            });\r\n          }\r\n\r\n          const result = this.bollingerIndicator.calculate(primaryCandles);\r\n          const isSqueeze = this.bollingerIndicator.isSqueeze(\r\n            this.config.indicators.bollingerBands.squeezeThreshold,\r\n          );\r\n\r\n          bollingerBands = {\r\n            upper: result.upper,\r\n            middle: result.middle,\r\n            lower: result.lower,\r\n            width: result.width,\r\n            percentB: result.percentB,\r\n            isSqueeze,\r\n          };\r\n\r\n          // Determine position within bands\r\n          const pricePosition = result.percentB <= 0.15 ? 'NEAR_LOWER'\r\n            : result.percentB >= 0.85 ? 'NEAR_UPPER'\r\n              : result.percentB >= 0.3 && result.percentB <= CONFIDENCE_THRESHOLDS.MODERATE ? 'MIDDLE_ZONE'\r\n                : 'NORMAL';\r\n\r\n          // Log on INFO when squeeze or near edges\r\n          if (isSqueeze || pricePosition === 'NEAR_LOWER' || pricePosition === 'NEAR_UPPER') {\r\n            this.logger.info('ðŸ“ˆ Bollinger Bands EVENT', {\r\n              upper: result.upper.toFixed(DECIMAL_PLACES.PRICE),\r\n              middle: result.middle.toFixed(DECIMAL_PLACES.PRICE),\r\n              lower: result.lower.toFixed(DECIMAL_PLACES.PRICE),\r\n              currentPrice: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n              width: result.width.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n              percentB: result.percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n              position: pricePosition,\r\n              squeeze: isSqueeze ? 'ðŸ”¥ YES' : 'no',\r\n            });\r\n          } else {\r\n            this.logger.debug('Bollinger Bands calculated for strategy', {\r\n              upper: result.upper.toFixed(DECIMAL_PLACES.PERCENT),\r\n              middle: result.middle.toFixed(DECIMAL_PLACES.PERCENT),\r\n              lower: result.lower.toFixed(DECIMAL_PLACES.PERCENT),\r\n              width: result.width.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n              percentB: result.percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n              squeeze: isSqueeze,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Bollinger Bands calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Predict breakout direction if BB squeeze detected (BB.MD Section 4.4)\r\n      let breakoutPrediction: StrategyMarketData['breakoutPrediction'];\r\n      if (bollingerBands?.isSqueeze) {\r\n        try {\r\n          // Calculate volume ratio on PRIMARY candles\r\n          const recentVolumes = primaryCandles.slice(-20).map(c => c.volume);\r\n          const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n          const currentVolume = primaryCandles[primaryCandles.length - 1].volume;\r\n          const volumeRatio = currentVolume / avgVolume;\r\n\r\n          const prediction = this.breakoutPredictor.predict(emaFast, emaSlow, rsi, volumeRatio);\r\n\r\n          breakoutPrediction = {\r\n            direction: prediction.direction,\r\n            confidence: prediction.confidence,\r\n            emaTrend: prediction.factors.emaTrend,\r\n            rsiMomentum: prediction.factors.rsiMomentum,\r\n            volumeStrength: prediction.factors.volumeStrength,\r\n          };\r\n\r\n          this.logger.info('ðŸ”® Breakout prediction generated', {\r\n            direction: prediction.direction,\r\n            confidence: prediction.confidence.toFixed(1) + '%',\r\n            reason: prediction.reason,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Breakout prediction failed', { error });\r\n        }\r\n      }\r\n\r\n      // Build market data with PRIMARY candles for strategy analysis\r\n      // PHASE 4: Delta Analysis\r\n      const deltaAnalysis = this.deltaAnalyzerService?.analyze();\r\n\r\n      // PHASE 4: Orderbook Imbalance Analysis\r\n      let imbalanceAnalysis;\r\n      if (this.orderbookImbalanceService && this.currentOrderbook) {\r\n        const normalizeLevel = (level: OrderbookLevel): [number, number] => {\r\n          if (Array.isArray(level)) {\r\n            return level as [number, number];\r\n          }\r\n          // level is object with price and size properties\r\n          const objLevel = level as { price: number; size: number };\r\n          return [objLevel.price, objLevel.size];\r\n        };\r\n\r\n        imbalanceAnalysis = this.orderbookImbalanceService.analyze({\r\n          bids: this.currentOrderbook.bids.map(normalizeLevel),\r\n          asks: this.currentOrderbook.asks.map(normalizeLevel),\r\n        });\r\n      }\r\n\r\n      const marketData: StrategyMarketData = {\r\n        timestamp: currentTimestamp,\r\n        currentPrice,\r\n        candles: primaryCandles,\r\n        swingPoints,\r\n        rsi,\r\n        rsiTrend1,\r\n        ema: {\r\n          fast: emaFast,\r\n          slow: emaSlow,\r\n        },\r\n        emaTrend1,\r\n        atr,\r\n        trend: this.currentContext!.trend,\r\n        liquidity: liquidityAnalysis,\r\n        divergence,\r\n        ...(this.currentOrderbook && { orderbook: this.currentOrderbook }), // Include orderbook if available\r\n        context: this.currentContext!,\r\n        stochastic,\r\n        bollingerBands,\r\n        breakoutPrediction,\r\n        deltaAnalysis, // PHASE 4: Buy/Sell pressure\r\n        imbalanceAnalysis, // PHASE 4: Bid/Ask pressure\r\n      };\r\n\r\n      return marketData;\r\n    } catch (error) {\r\n      this.logger.error('Error preparing market data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate position size\r\n   */\r\n  private calculatePositionSize(\r\n    price: number,\r\n    balance: number,\r\n    targetUsdt: number,\r\n  ): number {\r\n    // Use smaller of: target size or 90% of balance\r\n    const maxUsdt = Math.min(targetUsdt, balance * 0.9);\r\n    const qty = maxUsdt / price;\r\n\r\n    // Round to 2 decimals\r\n    return Math.floor(qty * PERCENT_MULTIPLIER) / PERCENT_MULTIPLIER;\r\n  }\r\n\r\n  /**\r\n   * Sync time with Bybit exchange\r\n   * CRITICAL: Prevents timestamp errors when opening positions\r\n   */\r\n  private async syncTimeWithExchange(): Promise<void> {\r\n    try {\r\n      const serverTime = await this.bybitService.getServerTime();\r\n      const localTime = Date.now();\r\n      const drift = localTime - serverTime;\r\n\r\n      if (Math.abs(drift) > 500) {\r\n        this.logger.warn('â° Clock drift detected', {\r\n          serverTime,\r\n          localTime,\r\n          driftMs: drift,\r\n          driftSec: (drift / 1000).toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      } else {\r\n        this.logger.debug('â° Time synced', { driftMs: drift });\r\n      }\r\n\r\n      // Store time offset in BybitService for timestamp correction\r\n      // This assumes BybitService has a timeOffset property\r\n      // For now, just log the drift - actual correction happens in SDK\r\n    } catch (error) {\r\n      this.logger.warn('Failed to sync time with exchange', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze BTC for signal confirmation\r\n   */\r\n  private async analyzeBTC(signalDirection: SignalDirection): Promise<BTCAnalysis | null> {\r\n    if (!this.btcAnalyzer || !this.config.btcConfirmation?.enabled) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const btcConfig = this.config.btcConfirmation;\r\n\r\n      // Fetch BTC candles directly from Bybit\r\n      const btcCandles = await this.bybitService.getCandles(\r\n        btcConfig.symbol,\r\n        btcConfig.timeframe,\r\n        btcConfig.candleLimit || 50,\r\n      );\r\n\r\n      if (!btcCandles || btcCandles.length < (btcConfig.lookbackCandles || 10)) {\r\n        this.logger.warn('Not enough BTC candles for analysis', {\r\n          available: btcCandles?.length || 0,\r\n          required: btcConfig.lookbackCandles || 10,\r\n        });\r\n        return null;\r\n      }\r\n\r\n      // Get altcoin candles for correlation (optional)\r\n      let altCandles: Candle[] | undefined;\r\n      if (btcConfig.useCorrelation) {\r\n        altCandles = await this.candleProvider.getCandles(\r\n          TimeframeRole.ENTRY,\r\n          btcConfig.correlationPeriod || 50,\r\n        );\r\n      }\r\n\r\n      // Analyze BTC\r\n      const analysis = this.btcAnalyzer.analyze(btcCandles, signalDirection, altCandles);\r\n\r\n      return analysis;\r\n    } catch (error) {\r\n      this.logger.error('BTC analysis failed', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle orderbook update from Public WebSocket\r\n   * Stores orderbook data for whale detection\r\n   */\r\n  onOrderbookUpdate(orderbook: OrderBook): void {\r\n    this.currentOrderbook = orderbook;\r\n    // Note: Orderbook updates are very frequent (~20-50ms), don't log\r\n  }\r\n\r\n  /**\r\n   * Check for Whale Hunter signals in real-time (called from bot.ts on orderbook updates)\r\n   * This bypasses the candle-close trigger for time-sensitive whale detection\r\n   *\r\n   * @param orderbook - Current orderbook snapshot\r\n   * @returns Promise<void> - Executes trade if whale signal found\r\n   */\r\n  async checkWhaleSignalRealtime(orderbook: OrderBook): Promise<void> {\r\n    try {\r\n      // Skip if no whale hunter strategy registered\r\n      const whaleStrategy = this.strategyCoordinator\r\n        .getStrategies()\r\n        .find(s => s.name === 'WHALE_HUNTER' || s.name === 'WHALE_HUNTER_FOLLOW');\r\n\r\n      if (!whaleStrategy) {\r\n        return; // Whale hunter not enabled\r\n      }\r\n\r\n      // Skip if already in position\r\n      if (this.positionManager.getCurrentPosition()) {\r\n        return; // Already in position\r\n      }\r\n\r\n      // Skip if context not ready\r\n      if (!this.currentContext) {\r\n        return; // Context not initialized yet\r\n      }\r\n\r\n      // Prepare lightweight market data for whale detection (scalping-optimized)\r\n      // Skips: RSI, EMA, liquidity, divergence - only orderbook + price + context\r\n      const marketData = await this.prepareMarketDataForWhale(orderbook);\r\n      if (!marketData) {\r\n        return; // Failed to prepare data\r\n      }\r\n\r\n      // Evaluate ONLY whale hunter strategies\r\n      const strategySignal = await whaleStrategy.evaluate(marketData);\r\n\r\n      // Check if valid signal\r\n      if (strategySignal.valid && strategySignal.signal) {\r\n        this.logger.info('ðŸ‹ WHALE SIGNAL DETECTED (real-time)!', {\r\n          strategy: strategySignal.strategyName,\r\n          direction: strategySignal.signal.direction,\r\n          confidence: strategySignal.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n          reason: strategySignal.reason,\r\n        });\r\n\r\n        // Convert to EntrySignal\r\n        const entrySignal: EntrySignal = {\r\n          shouldEnter: true,\r\n          direction: strategySignal.signal.direction,\r\n          confidence: strategySignal.signal.confidence,\r\n          entryPrice: strategySignal.signal.price,\r\n          stopLoss: strategySignal.signal.stopLoss,\r\n          takeProfits: strategySignal.signal.takeProfits,\r\n          reason: strategySignal.reason || strategySignal.strategyName,\r\n          timestamp: strategySignal.signal.timestamp,\r\n          strategyName: strategySignal.strategyName,\r\n        };\r\n\r\n        // Execute trade immediately (whale signals are time-critical!)\r\n        await this.executeTrade(entrySignal, marketData);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Error in real-time whale signal check', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current context (for monitoring/debugging)\r\n   */\r\n  getCurrentContext(): TradingContext | null {\r\n    return this.currentContext;\r\n  }\r\n  /**\r\n   * Get all registered strategies\r\n   */\r\n  getStrategies(): IStrategy[] {\r\n    return this.strategyCoordinator.getStrategies();\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\virtual-balance.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ErrorContext' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'extractErrorMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":133,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":133,"endColumn":69},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.","line":219,"column":21,"nodeType":"ConditionalExpression","messageId":"preferNullishOverTernary","endLine":219,"endColumn":85,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6623,6687],"text":"newBaseDeposit ?? this.baseDeposit"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'syncFromHistory' has no 'await' expression.","line":241,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":241,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":252,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":252,"endColumn":20}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\n/**\n * Virtual Balance Service\n *\n * Manages virtual trading balance independent from exchange balance.\n * Essential for:\n * - Demo mode: ignore huge demo balance (e.g., 49,614 USDT)\n * - Production: track bot's actual P&L separate from manual trades\n * - Compound interest: use bot's actual performance, not exchange balance\n *\n * State persisted to virtual-balance.json and synced on startup.\n *\n * Usage:\n * ```typescript\n * const vb = new VirtualBalanceService(logger, 50); // Start with 50 USDT\n * vb.updateBalance(+5.0, 'APEX_001'); // Add profit\n * const current = vb.getCurrentBalance(); // 55.0\n * ```\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { LoggerService, ValidatedVirtualBalanceState, ErrorContext } from '../types';\nimport { extractErrorMessage, createErrorContext } from '../utils/error-helper';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface VirtualBalanceState {\n  currentBalance: number; // Current virtual balance\n  baseDeposit: number; // Initial deposit (never changes)\n  lastUpdated: number; // Timestamp of last update\n  totalTrades: number; // Total number of trades\n  lastTradeId: string; // ID of last processed trade\n  totalProfit: number; // Total profit (currentBalance - baseDeposit)\n  allTimeHigh: number; // Highest balance achieved\n  allTimeLow: number; // Lowest balance achieved\n}\n\n// ============================================================================\n// VIRTUAL BALANCE SERVICE\n// ============================================================================\n\nexport class VirtualBalanceService {\n  private statePath: string;\n  private state: VirtualBalanceState;\n\n  constructor(\n    private logger: LoggerService,\n    private baseDeposit: number,\n    private dataDir: string = './data',\n  ) {\n    if (baseDeposit < 0) {\n      throw new Error('Base deposit cannot be negative');\n    }\n\n    this.statePath = path.join(this.dataDir, 'virtual-balance.json');\n    this.state = this.loadState();\n  }\n\n  /**\n   * Load state from file or initialize\n   */\n  private loadState(): VirtualBalanceState {\n    try {\n      if (fs.existsSync(this.statePath)) {\n        const content = fs.readFileSync(this.statePath, 'utf-8');\n        const state = JSON.parse(content) as ValidatedVirtualBalanceState;\n\n        // Update base deposit if changed in config\n        if (state.baseDeposit !== this.baseDeposit) {\n          this.logger.warn('âš ï¸ Base deposit changed in config', {\n            old: state.baseDeposit,\n            new: this.baseDeposit,\n            currentBalance: state.currentBalance,\n          });\n\n          // Option 1: Keep current balance, just update base reference\n          state.baseDeposit = this.baseDeposit;\n\n          // Recalculate profit\n          state.totalProfit = state.currentBalance - this.baseDeposit;\n        }\n\n        this.logger.info('âœ… Virtual balance loaded', {\n          balance: state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n          profit: state.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\n          trades: state.totalTrades,\n        });\n\n        return state;\n      }\n    } catch (error: unknown) {\n      const errorContext = createErrorContext(error);\n      this.logger.error('âŒ Failed to load virtual balance', {\n        error: errorContext.message,\n        timestamp: errorContext.timestamp,\n      });\n    }\n\n    // Initialize new state\n    const newState: VirtualBalanceState = {\n      currentBalance: this.baseDeposit,\n      baseDeposit: this.baseDeposit,\n      lastUpdated: Date.now(),\n      totalTrades: 0,\n      lastTradeId: '',\n      totalProfit: 0,\n      allTimeHigh: this.baseDeposit,\n      allTimeLow: this.baseDeposit,\n    };\n\n    this.saveState(newState);\n\n    this.logger.info('âœ… Virtual balance initialized', {\n      balance: newState.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      baseDeposit: this.baseDeposit.toFixed(DECIMAL_PLACES.PERCENT),\n    });\n\n    return newState;\n  }\n\n  /**\n   * Save state to file\n   */\n  private saveState(state: VirtualBalanceState): void {\n    try {\n      if (!fs.existsSync(this.dataDir)) {\n        fs.mkdirSync(this.dataDir, { recursive: true });\n      }\n\n      fs.writeFileSync(this.statePath, JSON.stringify(state, null, 2), 'utf-8');\n    } catch (error: unknown) {\n      const errorContext = createErrorContext(error);\n      this.logger.error('âŒ Failed to save virtual balance', {\n        error: errorContext.message,\n        timestamp: errorContext.timestamp,\n      });\n    }\n  }\n\n  /**\n   * Get current virtual balance\n   */\n  getCurrentBalance(): number {\n    return this.state.currentBalance;\n  }\n\n  /**\n   * Get base deposit\n   */\n  getBaseDeposit(): number {\n    return this.state.baseDeposit;\n  }\n\n  /**\n   * Get total profit (current - base)\n   */\n  getTotalProfit(): number {\n    return this.state.totalProfit;\n  }\n\n  /**\n   * Get profit percentage\n   */\n  getProfitPercent(): number {\n    if (this.state.baseDeposit === 0) {\n      return 0;\n    }\n    return (this.state.totalProfit / this.state.baseDeposit) * PERCENT_MULTIPLIER;\n  }\n\n  /**\n   * Get complete state\n   */\n  getState(): VirtualBalanceState {\n    return { ...this.state };\n  }\n\n  /**\n   * Update balance after trade\n   */\n  updateBalance(pnl: number, tradeId: string): void {\n    const oldBalance = this.state.currentBalance;\n\n    this.state.currentBalance += pnl;\n    this.state.lastUpdated = Date.now();\n    this.state.totalTrades++;\n    this.state.lastTradeId = tradeId;\n    this.state.totalProfit = this.state.currentBalance - this.state.baseDeposit;\n\n    // Update all-time highs/lows\n    if (this.state.currentBalance > this.state.allTimeHigh) {\n      this.state.allTimeHigh = this.state.currentBalance;\n    }\n    if (this.state.currentBalance < this.state.allTimeLow) {\n      this.state.allTimeLow = this.state.currentBalance;\n    }\n\n    this.saveState(this.state);\n\n    const emoji = pnl > 0 ? 'ðŸ’°' : pnl < 0 ? 'ðŸ“‰' : 'âž–';\n\n    this.logger.info(`${emoji} Virtual balance updated`, {\n      tradeId,\n      pnl: pnl.toFixed(DECIMAL_PLACES.PERCENT),\n      oldBalance: oldBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      newBalance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      profit: this.state.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\n      profitPercent: this.getProfitPercent().toFixed(DECIMAL_PLACES.PERCENT) + '%',\n    });\n  }\n\n  /**\n   * Reset balance to base deposit\n   */\n  reset(newBaseDeposit?: number): void {\n    const deposit = newBaseDeposit !== undefined ? newBaseDeposit : this.baseDeposit;\n\n    this.state.currentBalance = deposit;\n    this.state.baseDeposit = deposit;\n    this.state.lastUpdated = Date.now();\n    this.state.totalTrades = 0;\n    this.state.lastTradeId = '';\n    this.state.totalProfit = 0;\n    this.state.allTimeHigh = deposit;\n    this.state.allTimeLow = deposit;\n\n    this.saveState(this.state);\n\n    this.logger.warn('âš ï¸ Virtual balance RESET', {\n      balance: deposit.toFixed(DECIMAL_PLACES.PERCENT),\n    });\n  }\n\n  /**\n   * Sync balance from trade history (recalculate from scratch)\n   * Useful for fixing inconsistencies\n   */\n  async syncFromHistory(trades: Array<{ id: string; netPnl: number }>): Promise<void> {\n    let calculatedBalance = this.state.baseDeposit;\n    let lastTradeId = '';\n\n    for (const trade of trades) {\n      calculatedBalance += trade.netPnl;\n      lastTradeId = trade.id;\n    }\n\n    const diff = Math.abs(calculatedBalance - this.state.currentBalance);\n\n    if (diff > 0.01) {\n      // Threshold for floating point errors\n      this.logger.warn('âš ï¸ Balance mismatch detected, syncing from history', {\n        currentBalance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n        calculatedBalance: calculatedBalance.toFixed(DECIMAL_PLACES.PERCENT),\n        difference: diff.toFixed(DECIMAL_PLACES.PERCENT),\n      });\n\n      this.state.currentBalance = calculatedBalance;\n      this.state.totalProfit = calculatedBalance - this.state.baseDeposit;\n      this.state.totalTrades = trades.length;\n      this.state.lastTradeId = lastTradeId;\n      this.state.lastUpdated = Date.now();\n\n      // Update all-time highs/lows\n      if (calculatedBalance > this.state.allTimeHigh) {\n        this.state.allTimeHigh = calculatedBalance;\n      }\n      if (calculatedBalance < this.state.allTimeLow) {\n        this.state.allTimeLow = calculatedBalance;\n      }\n\n      this.saveState(this.state);\n\n      this.logger.info('âœ… Virtual balance synced from history', {\n        balance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n        profit: this.state.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\n        trades: this.state.totalTrades,\n      });\n    } else {\n      this.logger.debug('âœ… Virtual balance in sync with history', {\n        balance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\volume-profile.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":65,"column":26,"nodeType":"CallExpression","messageId":"conditionErrorNullableNumber","endLine":65,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2280,2305],"text":"(volumeMap.get(priceLevel) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2280,2305],"text":"(volumeMap.get(priceLevel) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2280,2305],"text":"(Boolean(volumeMap.get(priceLevel)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":65,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":65,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2306,2308],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 8.","line":134,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":45}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Volume Profile Service (PHASE 4 Feature 3)\r\n *\r\n * Calculates volume distribution across price levels to find:\r\n * - POC (Point of Control) = Price with highest volume\r\n * - VAH (Value Area High) = Top of 70% volume range\r\n * - VAL (Value Area Low) = Bottom of 70% volume range\r\n *\r\n * Use Cases:\r\n * - Support/Resistance levels (POC acts as magnet)\r\n * - Entry zones (near VAL for LONG, VAH for SHORT)\r\n * - Breakout targets (above VAH = bullish, below VAL = bearish)\r\n */\r\n\r\nimport { VolumeProfileConfig, VolumeProfileResult, VolumeNode, Candle, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// VOLUME PROFILE SERVICE\r\n// ============================================================================\r\n\r\nexport class VolumeProfileService {\r\n  constructor(\r\n    private config: VolumeProfileConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('VolumeProfileService initialized', {\r\n      enabled: config.enabled,\r\n      lookbackCandles: config.lookbackCandles,\r\n      valueAreaPercent: config.valueAreaPercent,\r\n      priceTickSize: config.priceTickSize,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculate volume profile from candles\r\n   * @param candles - Array of candles (oldest first)\r\n   * @returns Volume profile with POC, VAH, VAL\r\n   */\r\n  calculate(candles: Candle[]): VolumeProfileResult | null {\r\n    if (!this.config.enabled) {\r\n      return null;\r\n    }\r\n\r\n    if (candles.length === 0) {\r\n      this.logger.warn('Cannot calculate volume profile: no candles');\r\n      return null;\r\n    }\r\n\r\n    // Take last N candles\r\n    const lookback = Math.min(this.config.lookbackCandles, candles.length);\r\n    const relevantCandles = candles.slice(-lookback);\r\n\r\n    // Build volume distribution (price â†’ volume map)\r\n    const volumeMap = new Map<number, number>();\r\n\r\n    for (const candle of relevantCandles) {\r\n      // Get price levels within candle range\r\n      const priceLevels = this.getPriceLevels(candle);\r\n\r\n      // Distribute candle volume evenly across price levels\r\n      const volumePerLevel = candle.volume / priceLevels.length;\r\n\r\n      for (const priceLevel of priceLevels) {\r\n        const existing = volumeMap.get(priceLevel) || 0;\r\n        volumeMap.set(priceLevel, existing + volumePerLevel);\r\n      }\r\n    }\r\n\r\n    // Convert to nodes and sort by volume (descending)\r\n    const nodes: VolumeNode[] = Array.from(volumeMap.entries())\r\n      .map(([price, volume]) => ({ price, volume }))\r\n      .sort((a, b) => b.volume - a.volume);\r\n\r\n    if (nodes.length === 0) {\r\n      this.logger.warn('Cannot calculate volume profile: no volume nodes');\r\n      return null;\r\n    }\r\n\r\n    const totalVolume = nodes.reduce((sum, n) => sum + n.volume, 0);\r\n\r\n    // POC = price with highest volume\r\n    const poc = nodes[0].price;\r\n\r\n    // Value Area = range containing N% of total volume\r\n    const valueVolume = totalVolume * (this.config.valueAreaPercent / PERCENT_MULTIPLIER);\r\n    let accumulatedVolume = 0;\r\n    const valueNodes: VolumeNode[] = [];\r\n\r\n    for (const node of nodes) {\r\n      valueNodes.push(node);\r\n      accumulatedVolume += node.volume;\r\n      if (accumulatedVolume >= valueVolume) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // VAH/VAL = top/bottom of value area (sort by price)\r\n    const valuePrices = valueNodes.map((n) => n.price).sort((a, b) => a - b);\r\n    const val = valuePrices[0];\r\n    const vah = valuePrices[valuePrices.length - 1];\r\n\r\n    this.logger.debug('ðŸ“Š Volume Profile calculated', {\r\n      poc: poc.toFixed(DECIMAL_PLACES.PRICE),\r\n      vah: vah.toFixed(DECIMAL_PLACES.PRICE),\r\n      val: val.toFixed(DECIMAL_PLACES.PRICE),\r\n      totalVolume: totalVolume.toFixed(0),\r\n      nodesCount: nodes.length,\r\n    });\r\n\r\n    return {\r\n      poc,\r\n      vah,\r\n      val,\r\n      totalVolume,\r\n      nodes,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get price levels within candle range based on tick size\r\n   * @param candle - Candle to extract price levels from\r\n   * @returns Array of price levels\r\n   */\r\n  private getPriceLevels(candle: Candle): number[] {\r\n    const tickSize = this.config.priceTickSize;\r\n    const levels: number[] = [];\r\n\r\n    // Start from low and go to high by tick increments\r\n    let price = Math.floor(candle.low / tickSize) * tickSize;\r\n    const high = candle.high;\r\n\r\n    while (price <= high) {\r\n      levels.push(parseFloat(price.toFixed(8))); // Round to avoid floating point issues\r\n      price += tickSize;\r\n    }\r\n\r\n    // Fallback: if no levels generated (shouldn't happen), use close price\r\n    return levels.length > 0 ? levels : [candle.close];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\wall-tracker.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":54,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":54,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1958,1967],"text":"existing == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":103,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":103,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3202,3207],"text":"wall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":279,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":279,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":279,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":279,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":280,"column":87,"nodeType":"Literal","messageId":"noMagic","endLine":280,"endColumn":89},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":328,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":328,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9749,9753],"text":"(wall != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":336,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":336,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9950,9954],"text":"(wall != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":345,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":345,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10234,10239],"text":"wall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":359,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":359,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10630,10635],"text":"wall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.4.","line":372,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":372,"endColumn":84},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":378,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":378,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":383,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":383,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":398,"column":7,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":404,"endColumn":9,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11694,11915],"text":"(clusters.find((c: WallCluster) => {\r\n        if (c.side !== side) {\r\n          return false;\r\n        }\r\n        const [minPrice, maxPrice] = c.priceRange;\r\n        return price >= minPrice && price <= maxPrice;\r\n      }) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":404,"column":10,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":404,"endColumn":12,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[11916,11918],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Wall Tracker Service (PHASE 4)\r\n *\r\n * Tracks orderbook wall lifetime and detects spoofing/iceberg orders.\r\n *\r\n * Features:\r\n * - Wall lifetime tracking (how long walls stay in book)\r\n * - Spoofing detection (walls added then removed quickly <5s)\r\n * - Iceberg detection (rapid refills = hidden orders)\r\n * - Wall cluster analysis (multiple walls at same level)\r\n * - Wall absorption tracking (volume traded through wall)\r\n *\r\n * Use Cases:\r\n * - Filter fake walls (spoofing) vs real institutional walls\r\n * - Detect iceberg orders (large hidden orders)\r\n * - Identify strong support/resistance (wall clusters)\r\n */\r\n\r\nimport { WallTrackingConfig, WallEvent, WallLifetime, WallCluster, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst CLUSTER_PRICE_THRESHOLD_PERCENT = MULTIPLIERS.HALF; // Walls within 0.5% = cluster\r\nconst MIN_REFILLS_FOR_ICEBERG = 3; // 3+ refills = iceberg\r\nconst CLUSTER_MIN_WALLS = 2; // Minimum walls to form cluster\r\n\r\n// ============================================================================\r\n// WALL TRACKER SERVICE\r\n// ============================================================================\r\n\r\nexport class WallTrackerService {\r\n  private activeWalls: Map<string, WallLifetime> = new Map(); // key: `${side}_${price}`\r\n  private wallHistory: WallEvent[] = [];\r\n\r\n  constructor(\r\n    private config: WallTrackingConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect new wall in orderbook\r\n   */\r\n  detectWall(price: number, size: number, side: 'BID' | 'ASK'): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    const key = this.getKey(side, price);\r\n    const existing = this.activeWalls.get(key);\r\n\r\n    if (!existing) {\r\n      // New wall detected\r\n      const wall: WallLifetime = {\r\n        firstSeen: Date.now(),\r\n        lastSeen: Date.now(),\r\n        price,\r\n        side,\r\n        maxSize: size,\r\n        currentSize: size,\r\n        events: [\r\n          {\r\n            timestamp: Date.now(),\r\n            type: 'ADDED',\r\n            price,\r\n            size,\r\n            side,\r\n          },\r\n        ],\r\n        isSpoofing: false,\r\n        isIceberg: false,\r\n        absorbedVolume: 0,\r\n      };\r\n\r\n      this.activeWalls.set(key, wall);\r\n      this.addEvent(wall.events[0]);\r\n\r\n      // Note: Wall detection logging disabled to reduce spam\r\n      // this.logger.debug('ðŸ§± Wall detected (PHASE 4)', {\r\n      //   side,\r\n      //   price: price.toFixed(DECIMAL_PLACES.PRICE),\r\n      //   size: size.toFixed(DECIMAL_PLACES.PERCENT),\r\n      // });\r\n    } else {\r\n      // Wall still exists - update\r\n      this.updateWall(existing, size);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove wall from tracking (wall disappeared from orderbook)\r\n   */\r\n  removeWall(price: number, side: 'BID' | 'ASK'): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    const key = this.getKey(side, price);\r\n    const wall = this.activeWalls.get(key);\r\n\r\n    if (!wall) {\r\n      return; // Not tracked\r\n    }\r\n\r\n    const lifetime = Date.now() - wall.firstSeen;\r\n\r\n    // Check for spoofing (removed too quickly)\r\n    if (lifetime < this.config.spoofingThresholdMs) {\r\n      wall.isSpoofing = true;\r\n      /*this.logger.warn('âš ï¸ Spoofing detected (PHASE 4)', {\r\n        side,\r\n        price: price.toFixed(DECIMAL_PLACES.PRICE),\r\n        lifetime: `${lifetime}ms`,\r\n        size: wall.currentSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });*/\r\n    }\r\n\r\n    // Add REMOVED event\r\n    const event: WallEvent = {\r\n      timestamp: Date.now(),\r\n      type: 'REMOVED',\r\n      price,\r\n      size: wall.currentSize,\r\n      side,\r\n      reason: wall.isSpoofing ? 'spoofing' : 'filled_or_cancelled',\r\n    };\r\n\r\n    wall.events.push(event);\r\n    this.addEvent(event);\r\n\r\n    this.activeWalls.delete(key);\r\n\r\n    // Note: Wall removal logging disabled to reduce spam\r\n    // this.logger.debug('ðŸ§± Wall removed (PHASE 4)', {\r\n    //   side,\r\n    //   price: price.toFixed(DECIMAL_PLACES.PRICE),\r\n    //   lifetime: `${lifetime}ms`,\r\n    //   isSpoofing: wall.isSpoofing,\r\n    //   isIceberg: wall.isIceberg,\r\n    // });\r\n  }\r\n\r\n  /**\r\n   * Update existing wall (size changed)\r\n   */\r\n  private updateWall(wall: WallLifetime, newSize: number): void {\r\n    wall.lastSeen = Date.now();\r\n\r\n    // Check for absorption (size decreased)\r\n    if (newSize < wall.currentSize) {\r\n      const absorbed = wall.currentSize - newSize;\r\n      wall.absorbedVolume += absorbed;\r\n\r\n      const event: WallEvent = {\r\n        timestamp: Date.now(),\r\n        type: 'ABSORBED',\r\n        price: wall.price,\r\n        size: absorbed,\r\n        side: wall.side,\r\n      };\r\n\r\n      wall.events.push(event);\r\n      this.addEvent(event);\r\n    }\r\n\r\n    // Check for refill (size increased = iceberg)\r\n    if (newSize > wall.currentSize) {\r\n      const refilled = newSize - wall.currentSize;\r\n\r\n      const event: WallEvent = {\r\n        timestamp: Date.now(),\r\n        type: 'REFILLED',\r\n        price: wall.price,\r\n        size: refilled,\r\n        side: wall.side,\r\n      };\r\n\r\n      wall.events.push(event);\r\n      this.addEvent(event);\r\n\r\n      // Check for iceberg pattern (multiple refills)\r\n      const refillCount = wall.events.filter((e) => e.type === 'REFILLED').length;\r\n      if (refillCount >= MIN_REFILLS_FOR_ICEBERG && !wall.isIceberg) {\r\n        wall.isIceberg = true;\r\n        // Log only once when first detected (at exactly MIN_REFILLS_FOR_ICEBERG)\r\n        /*this.logger.info('ðŸ§Š Iceberg detected (PHASE 4)', {\r\n          side: wall.side,\r\n          price: wall.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          refills: refillCount,\r\n          totalSize: newSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });*/\r\n      }\r\n    }\r\n\r\n    wall.currentSize = newSize;\r\n    wall.maxSize = Math.max(wall.maxSize, newSize);\r\n  }\r\n\r\n  /**\r\n   * Detect wall clusters (multiple walls at similar prices)\r\n   */\r\n  detectClusters(): WallCluster[] {\r\n    if (!this.config.enabled) {\r\n      return [];\r\n    }\r\n\r\n    const clusters: WallCluster[] = [];\r\n\r\n    // Group walls by side\r\n    const bidWalls = Array.from(this.activeWalls.values()).filter((w) => w.side === 'BID');\r\n    const askWalls = Array.from(this.activeWalls.values()).filter((w) => w.side === 'ASK');\r\n\r\n    // Detect BID clusters\r\n    clusters.push(...this.findClustersInWalls(bidWalls, 'BID'));\r\n\r\n    // Detect ASK clusters\r\n    clusters.push(...this.findClustersInWalls(askWalls, 'ASK'));\r\n\r\n    return clusters;\r\n  }\r\n\r\n  /**\r\n   * Find clusters in array of walls\r\n   */\r\n  private findClustersInWalls(walls: WallLifetime[], side: 'BID' | 'ASK'): WallCluster[] {\r\n    if (walls.length < CLUSTER_MIN_WALLS) {\r\n      return [];\r\n    }\r\n\r\n    // Sort by price\r\n    const sorted = walls.sort((a, b) => a.price - b.price);\r\n    const clusters: WallCluster[] = [];\r\n    let currentCluster: WallLifetime[] = [sorted[0]];\r\n\r\n    for (let i = 1; i < sorted.length; i++) {\r\n      const wall = sorted[i];\r\n      const prevWall = sorted[i - 1];\r\n\r\n      // Check if wall is within cluster threshold\r\n      const priceDiff = Math.abs(wall.price - prevWall.price);\r\n      const threshold = prevWall.price * (CLUSTER_PRICE_THRESHOLD_PERCENT / PERCENT_MULTIPLIER);\r\n\r\n      if (priceDiff <= threshold) {\r\n        // Add to current cluster\r\n        currentCluster.push(wall);\r\n      } else {\r\n        // End current cluster, start new one\r\n        if (currentCluster.length >= CLUSTER_MIN_WALLS) {\r\n          clusters.push(this.createCluster(currentCluster, side));\r\n        }\r\n        currentCluster = [wall];\r\n      }\r\n    }\r\n\r\n    // Add last cluster\r\n    if (currentCluster.length >= CLUSTER_MIN_WALLS) {\r\n      clusters.push(this.createCluster(currentCluster, side));\r\n    }\r\n\r\n    return clusters;\r\n  }\r\n\r\n  /**\r\n   * Create cluster from walls\r\n   */\r\n  private createCluster(walls: WallLifetime[], side: 'BID' | 'ASK'): WallCluster {\r\n    const prices = walls.map((w) => w.price);\r\n    const minPrice = Math.min(...prices);\r\n    const maxPrice = Math.max(...prices);\r\n\r\n    const totalSize = walls.reduce((sum, w) => sum + w.currentSize, 0);\r\n    const totalLifetime = walls.reduce((sum, w) => sum + (Date.now() - w.firstSeen), 0);\r\n    const averageLifetime = totalLifetime / walls.length;\r\n\r\n    // Calculate strength (based on size and lifetime)\r\n    const avgSize = totalSize / walls.length;\r\n    const sizeStrength = Math.min(avgSize / 1000, 1) * 50; // 0-50 points\r\n    const lifetimeStrength = Math.min(averageLifetime / TIME_UNITS.FIVE_MINUTES, 1) * 50; // 0-50 points (5min max)\r\n    const strength = sizeStrength + lifetimeStrength;\r\n\r\n    return {\r\n      priceRange: [minPrice, maxPrice],\r\n      side,\r\n      wallCount: walls.length,\r\n      totalSize,\r\n      averageLifetime,\r\n      strength: Math.round(strength),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get active walls (for analysis)\r\n   */\r\n  getActiveWalls(): WallLifetime[] {\r\n    return Array.from(this.activeWalls.values());\r\n  }\r\n\r\n  /**\r\n   * Get wall history\r\n   */\r\n  getHistory(): WallEvent[] {\r\n    return this.wallHistory;\r\n  }\r\n\r\n  /**\r\n   * Clear all walls (reset)\r\n   */\r\n  clear(): void {\r\n    this.activeWalls.clear();\r\n    this.wallHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Get wall by price\r\n   */\r\n  getWall(price: number, side: 'BID' | 'ASK'): WallLifetime | undefined {\r\n    const key = this.getKey(side, price);\r\n    return this.activeWalls.get(key);\r\n  }\r\n\r\n  /**\r\n   * Check if wall is spoofing\r\n   */\r\n  isSpoofing(price: number, side: 'BID' | 'ASK'): boolean {\r\n    const wall = this.getWall(price, side);\r\n    return wall ? wall.isSpoofing : false;\r\n  }\r\n\r\n  /**\r\n   * Check if wall is iceberg\r\n   */\r\n  isIceberg(price: number, side: 'BID' | 'ASK'): boolean {\r\n    const wall = this.getWall(price, side);\r\n    return wall ? wall.isIceberg : false;\r\n  }\r\n\r\n  /**\r\n   * Check if wall is real (not spoofing and lived long enough)\r\n   * @returns true if wall is real and trustworthy\r\n   */\r\n  isWallReal(price: number, side: 'BID' | 'ASK'): boolean {\r\n    const wall = this.getWall(price, side);\r\n    if (!wall) {\r\n      return false;\r\n    }\r\n\r\n    const lifetime = Date.now() - wall.firstSeen;\r\n    return lifetime >= this.config.minLifetimeMs && !wall.isSpoofing;\r\n  }\r\n\r\n  /**\r\n   * Get wall strength score (0-1)\r\n   * Factors: lifetime, size stability, iceberg detection\r\n   */\r\n  getWallStrength(price: number, side: 'BID' | 'ASK'): number {\r\n    const wall = this.getWall(price, side);\r\n    if (!wall) {\r\n      return 0;\r\n    }\r\n\r\n    // Spoofing walls have zero strength\r\n    if (wall.isSpoofing) {\r\n      return 0;\r\n    }\r\n\r\n    let strength = 0;\r\n\r\n    // 1. Lifetime score (0-0.4)\r\n    const lifetime = Date.now() - wall.firstSeen;\r\n    const lifetimeScore = Math.min(lifetime / this.config.minLifetimeMs, 1.0) * 0.4;\r\n    strength += lifetimeScore;\r\n\r\n    // 2. Size stability score (0-0.3)\r\n    // High if current size is close to max size\r\n    const sizeRatio = wall.currentSize / wall.maxSize;\r\n    const sizeStability = sizeRatio * 0.3;\r\n    strength += sizeStability;\r\n\r\n    // 3. Iceberg bonus (0-0.3)\r\n    if (wall.isIceberg) {\r\n      strength += 0.3;\r\n    }\r\n\r\n    return Math.min(strength, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Get wall cluster at price level\r\n   * @returns cluster info or null if no cluster found\r\n   */\r\n  getClusterAt(price: number, side: 'BID' | 'ASK'): WallCluster | null {\r\n    const clusters = this.detectClusters();\r\n\r\n    // Find cluster containing this price (check if price is within cluster's price range)\r\n    return (\r\n      clusters.find((c: WallCluster) => {\r\n        if (c.side !== side) {\r\n          return false;\r\n        }\r\n        const [minPrice, maxPrice] = c.priceRange;\r\n        return price >= minPrice && price <= maxPrice;\r\n      }) || null\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generate unique key for wall\r\n   */\r\n  private getKey(side: 'BID' | 'ASK', price: number): string {\r\n    return `${side}_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n  }\r\n\r\n  /**\r\n   * Add event to history (with limit)\r\n   */\r\n  private addEvent(event: WallEvent): void {\r\n    this.wallHistory.push(event);\r\n\r\n    // Trim history to config limit\r\n    if (this.wallHistory.length > this.config.trackHistoryCount) {\r\n      this.wallHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get config (for testing)\r\n   */\r\n  getConfig(): WallTrackingConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\websocket-manager.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":89,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":89,"endColumn":42},{"ruleId":"complexity","severity":1,"message":"Method 'routeMessage' has a complexity of 13. Maximum allowed is 10.","line":311,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":375,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Method 'processPositionData' has a complexity of 11. Maximum allowed is 10.","line":391,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":434,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Method 'handleOrderExecution' has a complexity of 41. Maximum allowed is 10.","line":440,"column":31,"nodeType":"FunctionExpression","messageId":"complex","endLine":576,"endColumn":4},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (446). Maximum allowed is 300.","line":468,"column":1,"nodeType":null,"messageId":"exceed","endLine":665,"endColumn":1},{"ruleId":"complexity","severity":1,"message":"Method 'handleOrderUpdate' has a complexity of 17. Maximum allowed is 10.","line":581,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":640,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TIME_UNITS } from '../constants';\r\n/**\r\n * WebSocket Manager Service\r\n * Manages Bybit WebSocket connections and subscriptions\r\n *\r\n * Responsibilities:\r\n * 1. Connect to Bybit WebSocket V5\r\n * 2. Subscribe to Position updates\r\n * 3. Subscribe to Order execution updates\r\n * 4. Emit events when position opened/closed\r\n * 5. Handle reconnection and errors\r\n *\r\n * Single Responsibility: Real-time event streaming from exchange\r\n */\r\n\r\nimport WebSocket from 'ws';\r\nimport crypto from 'crypto';\r\nimport { EventEmitter } from 'events';\r\nimport {\r\n  ExchangeConfig,\r\n  Position,\r\n  PositionSide,\r\n  LoggerService,\r\n  PositionData,\r\n  OrderExecutionData,\r\n  OrderUpdateData,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst WS_BASE_URL = 'wss://stream.bybit.com/v5/private';\r\nconst WS_TESTNET_URL = 'wss://stream-testnet.bybit.com/v5/private';\r\nconst WS_DEMO_URL = 'wss://stream-demo.bybit.com/v5/private';\r\nconst PING_INTERVAL_MS = 20000;\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst MAX_RECONNECT_ATTEMPTS = 10;\r\nconst AUTH_EXPIRES_OFFSET_MS = 10000;\r\nconst POSITION_SIZE_ZERO = 0;\r\n\r\n// ============================================================================\r\n// WEBSOCKET EVENTS\r\n// ============================================================================\r\n\r\nexport interface PositionUpdateEvent {\r\n  symbol: string;\r\n  side: string;\r\n  size: string;\r\n  avgPrice: string;\r\n  leverage: string;\r\n  unrealisedPnl: string;\r\n}\r\n\r\nexport interface OrderExecutionEvent {\r\n  orderId: string;\r\n  symbol: string;\r\n  side: string;\r\n  orderStatus: string;\r\n  execQty: string;\r\n  execPrice: string;\r\n}\r\n\r\nexport interface OrderUpdateEvent {\r\n  orderId: string;\r\n  symbol: string;\r\n  orderType: string;\r\n  orderStatus: string;\r\n  avgPrice: string;\r\n  qty: string;\r\n  cumExecQty: string;\r\n}\r\n\r\n// ============================================================================\r\n// WEBSOCKET MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class WebSocketManagerService extends EventEmitter {\r\n  private ws: WebSocket | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts: number = 0;\r\n  private isConnecting: boolean = false;\r\n  private shouldReconnect: boolean = true;\r\n  private tpCounter: number = 0;\r\n  private lastCloseReason: 'SL' | 'TP' | 'TRAILING' | null = null; // Track last close reason for journal\r\n\r\n  // Event deduplication\r\n  private processedEvents = new Map<string, number>(); // eventKey â†’ timestamp\r\n  private readonly EVENT_CACHE_SIZE = 100;\r\n  private readonly EVENT_CACHE_TTL_MS = TIME_UNITS.MINUTE; // 1 minute\r\n\r\n  constructor(\r\n    private readonly config: ExchangeConfig,\r\n    private readonly symbol: string,\r\n    private readonly logger: LoggerService,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Connect to WebSocket and subscribe to updates\r\n   */\r\n  connect(): void {\r\n    if (this.isConnecting || (this.ws !== null && this.ws.readyState === WebSocket.OPEN)) {\r\n      return;\r\n    }\r\n\r\n    this.isConnecting = true;\r\n\r\n    // Select WebSocket URL based on mode\r\n    let wsUrl: string;\r\n    if (this.config.testnet) {\r\n      wsUrl = WS_TESTNET_URL;\r\n    } else if (this.config.demo) {\r\n      wsUrl = WS_DEMO_URL;\r\n    } else {\r\n      wsUrl = WS_BASE_URL;\r\n    }\r\n\r\n    this.logger.info('Connecting to WebSocket', { url: wsUrl, mode: this.config.demo ? 'DEMO' : this.config.testnet ? 'TESTNET' : 'MAINNET' });\r\n\r\n    this.ws = new WebSocket(wsUrl);\r\n\r\n    this.ws.on('open', () => {\r\n      this.isConnecting = false;\r\n      this.reconnectAttempts = 0;\r\n      this.authenticate();\r\n      this.startPing();\r\n      this.emit('connected');\r\n    });\r\n\r\n    this.ws.on('message', (data: WebSocket.Data) => {\r\n      let message: string;\r\n      if (typeof data === 'string') {\r\n        message = data;\r\n      } else if (Buffer.isBuffer(data)) {\r\n        message = data.toString('utf-8');\r\n      } else if (Array.isArray(data)) {\r\n        message = Buffer.concat(data).toString('utf-8');\r\n      } else {\r\n        return; // Ignore unknown data types\r\n      }\r\n      this.handleMessage(message);\r\n    });\r\n\r\n    this.ws.on('error', (error: Error) => {\r\n      this.emit('error', error);\r\n    });\r\n\r\n    this.ws.on('close', () => {\r\n      this.isConnecting = false;\r\n      this.stopPing();\r\n      this.emit('disconnected');\r\n\r\n      if (this.shouldReconnect && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n        this.reconnectAttempts++;\r\n        setTimeout(() => {\r\n          void this.connect();\r\n        }, RECONNECT_DELAY_MS);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Disconnect from WebSocket\r\n   */\r\n  disconnect(): void {\r\n    this.shouldReconnect = false;\r\n    this.stopPing();\r\n\r\n    if (this.ws !== null) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if WebSocket is connected\r\n   */\r\n  isConnected(): boolean {\r\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  /**\r\n   * Get last close reason (for determining exitType in journal)\r\n   */\r\n  getLastCloseReason(): 'SL' | 'TP' | 'TRAILING' | null {\r\n    return this.lastCloseReason;\r\n  }\r\n\r\n  /**\r\n   * Reset last close reason (called after position closes)\r\n   */\r\n  resetLastCloseReason(): void {\r\n    this.lastCloseReason = null;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Check if event is duplicate (already processed)\r\n   * @param eventType - Type of event (TP, SL, POSITION)\r\n   * @param orderId - Order ID\r\n   * @param timestamp - Event timestamp\r\n   * @returns true if duplicate, false if new event\r\n   */\r\n  private isDuplicateEvent(eventType: string, orderId: string, timestamp: number): boolean {\r\n    const eventKey = `${eventType}_${orderId}_${timestamp}`;\r\n\r\n    if (this.processedEvents.has(eventKey)) {\r\n      this.logger.debug('Duplicate event ignored', { eventKey });\r\n      return true;\r\n    }\r\n\r\n    // Store event\r\n    this.processedEvents.set(eventKey, Date.now());\r\n\r\n    // Cleanup old events if cache is too large\r\n    if (this.processedEvents.size > this.EVENT_CACHE_SIZE) {\r\n      const now = Date.now();\r\n      for (const [key, time] of this.processedEvents.entries()) {\r\n        if (now - time > this.EVENT_CACHE_TTL_MS) {\r\n          this.processedEvents.delete(key);\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Authenticate WebSocket connection\r\n   */\r\n  private authenticate(): void {\r\n    if (this.ws === null || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    const expires = Date.now() + AUTH_EXPIRES_OFFSET_MS;\r\n    const signature = crypto\r\n      .createHmac('sha256', this.config.apiSecret)\r\n      .update(`GET/realtime${expires}`)\r\n      .digest('hex');\r\n\r\n    const authMessage = {\r\n      op: 'auth',\r\n      args: [this.config.apiKey, expires.toString(), signature],\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(authMessage));\r\n  }\r\n\r\n  /**\r\n   * Subscribe to topics after authentication\r\n   */\r\n  private subscribe(): void {\r\n    if (this.ws === null || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    // Subscribe to position updates\r\n    const positionTopic = 'position';\r\n\r\n    // Subscribe to order execution (market orders)\r\n    const executionTopic = 'execution';\r\n\r\n    // Subscribe to order updates (conditional orders: TP/SL)\r\n    const orderTopic = 'order';\r\n\r\n    const subscribeMessage = {\r\n      op: 'subscribe',\r\n      args: [positionTopic, executionTopic, orderTopic],\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeMessage));\r\n    this.logger.info('Private WebSocket subscribed to topics', {\r\n      topics: [positionTopic, executionTopic, orderTopic],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle incoming WebSocket message\r\n   */\r\n  private handleMessage(data: string): void {\r\n    try {\r\n      // this.logger.debug('Data:', {\r\n      //    data: JSON.stringify(data)\r\n      // });\r\n      const message = JSON.parse(data) as {\r\n        success?: boolean;\r\n        op?: string;\r\n        topic?: string;\r\n        data?: unknown;\r\n      };\r\n\r\n      this.routeMessage(message);\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to parse message: ${String(error)}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Route message to appropriate handler\r\n   */\r\n  private routeMessage(message: {\r\n    success?: boolean;\r\n    op?: string;\r\n    topic?: string;\r\n    data?: unknown;\r\n  }): void {\r\n    // Log all incoming messages (DEBUG level)\r\n    /* this.logger.debug('Private WebSocket message received', {\r\n      op: message.op,\r\n      topic: message.topic,\r\n      success: message.success,\r\n      hasData: message.data !== undefined,\r\n    });\r\n*/\r\n    // Handle auth response\r\n    if (message.op === 'auth' && message.success === true) {\r\n      this.logger.info('Private WebSocket authenticated successfully');\r\n      this.subscribe();\r\n      return;\r\n    }\r\n\r\n    // Handle subscription confirmation\r\n    if (message.op === 'subscribe') {\r\n      if (message.success === true) {\r\n        this.logger.info('âœ… Bybit confirmed subscription', {\r\n          success: true,\r\n        });\r\n      } else {\r\n        this.logger.error('âŒ Bybit rejected subscription', {\r\n          success: message.success,\r\n          message,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle pong\r\n    if (message.op === 'pong') {\r\n      return;\r\n    }\r\n\r\n    // Handle topic messages\r\n    if (message.data === undefined || message.data === null) {\r\n      return;\r\n    }\r\n\r\n    const messageData = message.data;\r\n\r\n    // this.logger.debug('RECEIVE MESSAGE!!!!', {\r\n    //     data: JSON.stringify(message)\r\n    // });\r\n    if (message.topic === 'position') {\r\n      this.handlePositionUpdate(messageData as PositionData | PositionData[]);\r\n    } else if (message.topic === 'execution') {\r\n      this.logger.debug('Received execution topic event', {\r\n        executionCount: Array.isArray(messageData) ? messageData.length : 0,\r\n      });\r\n      this.handleOrderExecution(messageData as OrderExecutionData | OrderExecutionData[]);\r\n    } else if (message.topic === 'order') {\r\n      this.logger.debug('Received order topic event', {\r\n        orderCount: Array.isArray(messageData) ? messageData.length : 0,\r\n      });\r\n      this.handleOrderUpdate(messageData as OrderUpdateData | OrderUpdateData[]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle position update from WebSocket\r\n   */\r\n  private handlePositionUpdate(data: PositionData | PositionData[]): void {\r\n    const positions = Array.isArray(data) ? data : [data];\r\n\r\n    for (const pos of positions) {\r\n      this.processPositionData(pos);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process single position data\r\n   */\r\n  private processPositionData(pos: PositionData): void {\r\n    const posData = pos;\r\n\r\n    // Filter by our symbol\r\n    if (posData.symbol !== this.symbol) {\r\n      return;\r\n    }\r\n\r\n    const size = parseFloat(posData.size ?? '0');\r\n\r\n    // Position closed - reset TP counter\r\n    if (size === POSITION_SIZE_ZERO) {\r\n      this.logger.debug('Position closed - resetting TP counter', { previousCounter: this.tpCounter });\r\n      this.tpCounter = 0;\r\n      this.emit('positionClosed', { symbol: this.symbol });\r\n      return;\r\n    }\r\n\r\n    // Position opened or updated\r\n    const position: Position = {\r\n      id: `${this.symbol}_${posData.side ?? 'unknown'}`,\r\n      symbol: this.symbol,\r\n      side: posData.side === 'Buy' ? PositionSide.LONG : PositionSide.SHORT,\r\n      quantity: size,\r\n      entryPrice: parseFloat(posData.entryPrice ?? posData.avgPrice ?? '0'),\r\n      leverage: parseFloat(posData.leverage ?? '1'),\r\n      marginUsed: parseFloat(posData.positionIM ?? '0'), // Initial margin\r\n      stopLoss: {\r\n        price: 0,\r\n        initialPrice: 0,\r\n        isBreakeven: false,\r\n        isTrailing: false,\r\n        updatedAt: Date.now(),\r\n      },\r\n      takeProfits: [],\r\n      openedAt: Date.now(),\r\n      unrealizedPnL: parseFloat(posData.unrealisedPnl ?? '0'),\r\n      orderId: '',\r\n      reason: 'WebSocket position update',\r\n      status: 'OPEN', // Position from WebSocket is OPEN\r\n    };\r\n\r\n    this.emit('positionUpdate', position);\r\n  }\r\n\r\n  /**\r\n   * Handle order execution from WebSocket\r\n   * This is where TP/SL fills come through!\r\n   */\r\n  private handleOrderExecution(data: OrderExecutionData | OrderExecutionData[]): void {\r\n    const executions = Array.isArray(data) ? data : [data];\r\n\r\n    for (const exec of executions) {\r\n      const execData = exec;\r\n\r\n      // Log all executions for debugging\r\n      this.logger.debug('Processing execution event', {\r\n        orderId: execData.orderId,\r\n        symbol: execData.symbol,\r\n        execType: execData.execType,\r\n        stopOrderType: execData.stopOrderType,\r\n        orderType: execData.orderType,\r\n        createType: execData.createType,\r\n        execPrice: execData.execPrice,\r\n        execQty: execData.execQty,\r\n        closedSize: execData.closedSize,\r\n      });\r\n\r\n      // Filter by our symbol\r\n      if (execData.symbol !== this.symbol) {\r\n        continue;\r\n      }\r\n\r\n      // Detect Take Profit: stopOrderType=\"UNKNOWN\" + createType=\"CreateByUser\" + closedSize > 0\r\n      const closedSize = parseFloat(execData.closedSize ?? '0');\r\n      const isTakeProfit =\r\n        execData.stopOrderType === 'UNKNOWN' &&\r\n        execData.createType === 'CreateByUser' &&\r\n        closedSize > 0;\r\n\r\n      // Detect Stop Loss: stopOrderType=\"Stop\"\r\n      const isStopLoss = execData.stopOrderType === 'Stop';\r\n\r\n      // Detect Trailing Stop: stopOrderType=\"TrailingStop\" (should not happen in execution, but just in case)\r\n      const isTrailingStop = execData.stopOrderType === 'TrailingStop';\r\n\r\n      if (isTakeProfit) {\r\n        // Check for duplicate event\r\n        const eventKey = `${execData.orderId ?? 'unknown'}_${execData.execPrice ?? '0'}_${closedSize}`;\r\n        if (this.isDuplicateEvent('TP', eventKey, Date.now())) {\r\n          continue; // Skip duplicate\r\n        }\r\n\r\n        // Increment TP counter\r\n        this.tpCounter++;\r\n\r\n        this.logger.info(`ðŸŽ¯ TP${this.tpCounter} execution detected from WebSocket`, {\r\n          tpLevel: this.tpCounter,\r\n          orderId: execData.orderId,\r\n          execPrice: execData.execPrice,\r\n          execQty: execData.execQty,\r\n          closedSize: execData.closedSize,\r\n        });\r\n\r\n        // Track close reason for journal\r\n        this.lastCloseReason = 'TP';\r\n\r\n        this.emit('takeProfitFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          avgPrice: execData.execPrice ?? '0',\r\n          qty: execData.execQty ?? '0',\r\n          cumExecQty: execData.closedSize ?? execData.execQty ?? '0',\r\n        });\r\n      } else if (isStopLoss) {\r\n        // Check for duplicate event\r\n        const eventKey = `${execData.orderId ?? 'unknown'}_${execData.execPrice ?? '0'}`;\r\n        if (this.isDuplicateEvent('SL', eventKey, Date.now())) {\r\n          continue; // Skip duplicate\r\n        }\r\n\r\n        this.logger.info('ðŸ›‘ Stop Loss execution detected from WebSocket', {\r\n          orderId: execData.orderId,\r\n          execPrice: execData.execPrice,\r\n          execQty: execData.execQty,\r\n        });\r\n\r\n        // Reset TP counter\r\n        this.logger.debug('Stop Loss hit - resetting TP counter', { previousCounter: this.tpCounter });\r\n        this.tpCounter = 0;\r\n\r\n        // Track close reason for journal\r\n        this.lastCloseReason = 'SL';\r\n\r\n        this.emit('stopLossFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          avgPrice: execData.execPrice ?? '0',\r\n          qty: execData.execQty ?? '0',\r\n          cumExecQty: execData.closedSize ?? execData.execQty ?? '0',\r\n        });\r\n      } else if (isTrailingStop) {\r\n        // Check for duplicate event\r\n        const eventKey = `${execData.orderId ?? 'unknown'}_${execData.execPrice ?? '0'}`;\r\n        if (this.isDuplicateEvent('TRAILING', eventKey, Date.now())) {\r\n          continue; // Skip duplicate\r\n        }\r\n\r\n        this.logger.info('ðŸ“‰ Trailing Stop execution detected from WebSocket', {\r\n          orderId: execData.orderId,\r\n          execPrice: execData.execPrice,\r\n          execQty: execData.execQty,\r\n        });\r\n\r\n        // Reset TP counter\r\n        this.logger.debug('Trailing Stop hit - resetting TP counter', { previousCounter: this.tpCounter });\r\n        this.tpCounter = 0;\r\n\r\n        // Track close reason for journal\r\n        this.lastCloseReason = 'TRAILING';\r\n\r\n        this.emit('stopLossFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          avgPrice: execData.execPrice ?? '0',\r\n          qty: execData.execQty ?? '0',\r\n          cumExecQty: execData.closedSize ?? execData.execQty ?? '0',\r\n        });\r\n      } else {\r\n        // Regular order fill (market/limit entry) - reset TP counter for new position\r\n        this.logger.debug('Position entry execution - resetting TP counter', { previousCounter: this.tpCounter });\r\n        this.tpCounter = 0;\r\n\r\n        this.emit('orderFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          execQty: execData.execQty ?? '0',\r\n          execPrice: execData.execPrice ?? '0',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle order update from WebSocket (conditional orders: TP/SL)\r\n   */\r\n  private handleOrderUpdate(data: OrderUpdateData | OrderUpdateData[]): void {\r\n    const orders = Array.isArray(data) ? data : [data];\r\n\r\n    for (const order of orders) {\r\n      const orderData = order;\r\n\r\n      // Log all orders for debugging\r\n      this.logger.debug('Processing order update', {\r\n        orderId: orderData.orderId,\r\n        symbol: orderData.symbol,\r\n        status: orderData.orderStatus,\r\n        stopOrderType: orderData.stopOrderType,\r\n        avgPrice: orderData.avgPrice,\r\n      });\r\n\r\n      // Filter by our symbol\r\n      if (orderData.symbol !== this.symbol) {\r\n        continue;\r\n      }\r\n\r\n      // Only process filled orders\r\n      if (orderData.orderStatus !== 'Filled') {\r\n        continue;\r\n      }\r\n\r\n      // Check if this is a Take Profit order\r\n      const isTakeProfit = orderData.stopOrderType === 'TakeProfit';\r\n      const isStopLoss = orderData.stopOrderType === 'StopLoss';\r\n\r\n      if (isTakeProfit) {\r\n        this.logger.info('ðŸŽ¯ Take Profit detected from WebSocket', {\r\n          orderId: orderData.orderId,\r\n          avgPrice: orderData.avgPrice,\r\n          qty: orderData.cumExecQty,\r\n        });\r\n        this.emit('takeProfitFilled', {\r\n          orderId: orderData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: orderData.side ?? '',\r\n          avgPrice: orderData.avgPrice ?? '0',\r\n          qty: orderData.qty ?? '0',\r\n          cumExecQty: orderData.cumExecQty ?? '0',\r\n        });\r\n      } else if (isStopLoss) {\r\n        this.logger.info('ðŸ›‘ Stop Loss detected from WebSocket', {\r\n          orderId: orderData.orderId,\r\n          avgPrice: orderData.avgPrice,\r\n          qty: orderData.cumExecQty,\r\n        });\r\n        this.emit('stopLossFilled', {\r\n          orderId: orderData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: orderData.side ?? '',\r\n          avgPrice: orderData.avgPrice ?? '0',\r\n          qty: orderData.qty ?? '0',\r\n          cumExecQty: orderData.cumExecQty ?? '0',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start ping interval to keep connection alive\r\n   */\r\n  private startPing(): void {\r\n    this.stopPing();\r\n\r\n    this.pingInterval = setInterval(() => {\r\n      if (this.ws !== null && this.ws.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ op: 'ping' }));\r\n      }\r\n    }, PING_INTERVAL_MS);\r\n  }\r\n\r\n  /**\r\n   * Stop ping interval\r\n   */\r\n  private stopPing(): void {\r\n    if (this.pingInterval !== null) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\weight-matrix-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENTAGE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":47},{"ruleId":"complexity","severity":1,"message":"Method 'calculateScore' has a complexity of 41. Maximum allowed is 10.","line":46,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":271,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":313,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":313,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":315,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":315,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10880,10900],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10880,10900],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10880,10900],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":321,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":321,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11085,11100],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11085,11100],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11085,11100],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":323,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":323,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":327,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":327,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11282,11295],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11282,11295],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11282,11295],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":329,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":329,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":333,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":333,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11472,11487],"text":"(thresholds.weak != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11472,11487],"text":"(thresholds.weak ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11472,11487],"text":"(Boolean(thresholds.weak))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":335,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":335,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":362,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":362,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":364,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":364,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12321,12341],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12321,12341],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12321,12341],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":370,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":370,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12527,12542],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12527,12542],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12527,12542],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":372,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":372,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":376,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":376,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12725,12738],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12725,12738],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12725,12738],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":378,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":378,"endColumn":32},{"ruleId":"complexity","severity":1,"message":"Method 'calculateEMAScore' has a complexity of 11. Maximum allowed is 10.","line":396,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":444,"endColumn":4},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (777). Maximum allowed is 300.","line":417,"column":1,"nodeType":null,"messageId":"exceed","endLine":1037,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":419,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":419,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13909,13929],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[13909,13929],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13909,13929],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":425,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":425,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14149,14164],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14149,14164],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14149,14164],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":427,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":427,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":431,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":431,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14381,14394],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14381,14394],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14381,14394],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":433,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":433,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":463,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":463,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":465,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":465,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15536,15556],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15536,15556],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15536,15556],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":471,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":471,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15755,15770],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15755,15770],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15755,15770],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":473,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":473,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":477,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":477,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15966,15979],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15966,15979],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15966,15979],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":479,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":479,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":505,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":505,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16695,16715],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16695,16715],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16695,16715],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":511,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":511,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16924,16939],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16924,16939],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16924,16939],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":513,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":513,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":517,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":517,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17145,17158],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[17145,17158],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[17145,17158],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":519,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":519,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":545,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":545,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17896,17916],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[17896,17916],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[17896,17916],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":551,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":551,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18128,18143],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18128,18143],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18128,18143],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":553,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":553,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":557,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":557,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18352,18365],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18352,18365],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18352,18365],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":559,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":559,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":563,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":563,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18569,18584],"text":"(thresholds.weak != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18569,18584],"text":"(thresholds.weak ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18569,18584],"text":"(Boolean(thresholds.weak))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":565,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":565,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":594,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":594,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19556,19576],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19556,19576],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19556,19576],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":600,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":600,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19784,19799],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19784,19799],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19784,19799],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":602,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":602,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":606,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":606,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20004,20017],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[20004,20017],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[20004,20017],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":608,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":608,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":632,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":632,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20722,20742],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[20722,20742],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[20722,20742],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":638,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":638,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20949,20964],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[20949,20964],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[20949,20964],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":640,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":640,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":644,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":644,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21168,21181],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[21168,21181],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[21168,21181],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":646,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":646,"endColumn":32},{"ruleId":"complexity","severity":1,"message":"Method 'calculateImbalanceScore' has a complexity of 11. Maximum allowed is 10.","line":664,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":711,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":686,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":686,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22593,22613],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[22593,22613],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[22593,22613],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":692,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":692,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22825,22840],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[22825,22840],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[22825,22840],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":694,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":694,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":698,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":698,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23049,23062],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[23049,23062],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[23049,23062],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":700,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":700,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strength' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":722,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":722,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":724,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":724,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23793,23813],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[23793,23813],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[23793,23813],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":730,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":730,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23999,24014],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[23999,24014],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[23999,24014],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":732,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":732,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":736,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":736,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24197,24210],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[24197,24210],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[24197,24210],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":738,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":738,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":762,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":762,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24855,24875],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[24855,24875],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[24855,24875],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":768,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":768,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25091,25106],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[25091,25106],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[25091,25106],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":770,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":770,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":774,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":774,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25319,25332],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[25319,25332],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[25319,25332],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":776,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":776,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":780,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":780,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25540,25555],"text":"(thresholds.weak != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[25540,25555],"text":"(thresholds.weak ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[25540,25555],"text":"(Boolean(thresholds.weak))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":782,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":782,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":827,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":827,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26850,26870],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[26850,26870],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[26850,26870],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":833,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":833,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27072,27087],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[27072,27087],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27072,27087],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":835,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":835,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":839,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":839,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27286,27299],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[27286,27299],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27286,27299],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":841,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":841,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":865,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":865,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28002,28022],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[28002,28022],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28002,28022],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":871,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":871,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28223,28238],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[28223,28238],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28223,28238],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":873,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":873,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":877,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":877,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28436,28449],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[28436,28449],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28436,28449],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":879,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":879,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 90.","line":1016,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1016,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":1019,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":1019,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":1021,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":1021,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1022,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1022,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":1024,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":1024,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":1027,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":1027,"endColumn":32}],"suppressedMessages":[],"errorCount":82,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Weight Matrix Calculator Service\r\n *\r\n * Calculates signal confidence using gradient scoring instead of boolean filters.\r\n * Each indicator/factor contributes points based on thresholds (excellent/good/ok/weak).\r\n *\r\n * Example:\r\n * - RSI = 25 â†’ 15 pts (good)\r\n * - Volume = 1.8x avg â†’ 20 pts (good)\r\n * - Level touches = 4 â†’ 20 pts (excellent)\r\n * Total: 55 pts â†’ Confidence: 55%\r\n */\r\n\r\nimport {\r\n  WeightMatrixConfig,\r\n  WeightMatrixInput,\r\n  IndicatorWeight,\r\n  SignalScoreBreakdown,\r\n  SignalDirection,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// WEIGHT MATRIX CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class WeightMatrixCalculatorService {\r\n  constructor(\r\n    private config: WeightMatrixConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('WeightMatrixCalculatorService initialized', {\r\n      enabled: config.enabled,\r\n      minConfidenceToEnter: config.minConfidenceToEnter,\r\n      minConfidenceForReducedSize: config.minConfidenceForReducedSize,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculate signal score from market data\r\n   * @param input - Market data from analyzers/indicators\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns Score breakdown with confidence percentage\r\n   */\r\n  calculateScore(\r\n    input: WeightMatrixInput,\r\n    direction: SignalDirection,\r\n  ): SignalScoreBreakdown {\r\n    if (!this.config.enabled) {\r\n      // Weight matrix disabled - return perfect score\r\n      return {\r\n        totalScore: 100,\r\n        maxPossibleScore: 100,\r\n        confidence: 100,\r\n        contributions: {},\r\n      };\r\n    }\r\n\r\n    const contributions: SignalScoreBreakdown['contributions'] = {};\r\n    let totalScore = 0;\r\n    let maxPossibleScore = 0;\r\n\r\n    // 1. RSI\r\n    if (this.config.weights.rsi.enabled && input.rsi !== undefined) {\r\n      const score = this.calculateRSIScore(input.rsi, direction, this.config.weights.rsi);\r\n      contributions.rsi = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 2. Stochastic\r\n    if (this.config.weights.stochastic.enabled && input.stochastic !== undefined) {\r\n      const score = this.calculateStochasticScore(\r\n        input.stochastic,\r\n        direction,\r\n        this.config.weights.stochastic,\r\n      );\r\n      contributions.stochastic = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 3. EMA\r\n    if (this.config.weights.ema.enabled && input.ema !== undefined) {\r\n      const score = this.calculateEMAScore(input.ema, direction, this.config.weights.ema);\r\n      contributions.ema = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 4. Bollinger Bands\r\n    if (this.config.weights.bollingerBands.enabled && input.bollingerBands !== undefined) {\r\n      const score = this.calculateBollingerScore(\r\n        input.bollingerBands,\r\n        direction,\r\n        this.config.weights.bollingerBands,\r\n      );\r\n      contributions.bollingerBands = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 5. ATR\r\n    if (this.config.weights.atr.enabled && input.atr !== undefined) {\r\n      const score = this.calculateATRScore(input.atr, this.config.weights.atr);\r\n      contributions.atr = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 6. Volume\r\n    if (this.config.weights.volume.enabled && input.volume !== undefined) {\r\n      const score = this.calculateVolumeScore(input.volume, this.config.weights.volume);\r\n      contributions.volume = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 7. Delta (Buy/Sell pressure)\r\n    if (this.config.weights.delta.enabled && input.delta !== undefined) {\r\n      const score = this.calculateDeltaScore(input.delta, direction, this.config.weights.delta);\r\n      contributions.delta = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 8. Orderbook\r\n    if (this.config.weights.orderbook.enabled && input.orderbook !== undefined) {\r\n      const score = this.calculateOrderbookScore(input.orderbook, this.config.weights.orderbook);\r\n      contributions.orderbook = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 9. Imbalance (Bid/Ask pressure)\r\n    if (this.config.weights.imbalance.enabled && input.imbalance !== undefined) {\r\n      const score = this.calculateImbalanceScore(input.imbalance, direction, this.config.weights.imbalance);\r\n      contributions.imbalance = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 10. Level Strength\r\n    if (this.config.weights.levelStrength.enabled && input.levelStrength !== undefined) {\r\n      const score = this.calculateLevelStrengthScore(\r\n        input.levelStrength,\r\n        this.config.weights.levelStrength,\r\n      );\r\n      contributions.levelStrength = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 10. Level Distance\r\n    if (this.config.weights.levelDistance.enabled && input.levelDistance !== undefined) {\r\n      const score = this.calculateLevelDistanceScore(\r\n        input.levelDistance,\r\n        this.config.weights.levelDistance,\r\n      );\r\n      contributions.levelDistance = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 11. Swing Points\r\n    if (this.config.weights.swingPoints.enabled && input.swingPoints !== undefined) {\r\n      const score = this.calculateSwingPointsScore(\r\n        input.swingPoints,\r\n        this.config.weights.swingPoints,\r\n      );\r\n      contributions.swingPoints = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 12. Chart Patterns\r\n    if (this.config.weights.chartPatterns.enabled && input.chartPatterns !== undefined) {\r\n      const score = this.calculateChartPatternsScore(\r\n        input.chartPatterns,\r\n        this.config.weights.chartPatterns,\r\n      );\r\n      contributions.chartPatterns = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 13. Candle Patterns\r\n    if (this.config.weights.candlePatterns.enabled && input.candlePatterns !== undefined) {\r\n      const score = this.calculateCandlePatternsScore(\r\n        input.candlePatterns,\r\n        this.config.weights.candlePatterns,\r\n      );\r\n      contributions.candlePatterns = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 14. Senior TF Alignment\r\n    if (this.config.weights.seniorTFAlignment.enabled && input.seniorTFAlignment !== undefined) {\r\n      const score = this.calculateSeniorTFAlignmentScore(\r\n        input.seniorTFAlignment,\r\n        this.config.weights.seniorTFAlignment,\r\n      );\r\n      contributions.seniorTFAlignment = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 15. BTC Correlation\r\n    if (this.config.weights.btcCorrelation.enabled && input.btcCorrelation !== undefined) {\r\n      const score = this.calculateBTCCorrelationScore(\r\n        input.btcCorrelation,\r\n        this.config.weights.btcCorrelation,\r\n      );\r\n      contributions.btcCorrelation = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 16. TF Alignment (PHASE 6)\r\n    if (this.config.weights.tfAlignment.enabled && input.tfAlignmentScore !== undefined) {\r\n      const score = this.calculateTFAlignmentScore(\r\n        input.tfAlignmentScore,\r\n        this.config.weights.tfAlignment,\r\n      );\r\n      contributions.tfAlignment = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 17. Divergence\r\n    if (this.config.weights.divergence.enabled && input.divergence !== undefined) {\r\n      const score = this.calculateDivergenceScore(\r\n        input.divergence,\r\n        direction,\r\n        this.config.weights.divergence,\r\n      );\r\n      contributions.divergence = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 17. Liquidity Sweep\r\n    if (this.config.weights.liquiditySweep.enabled && input.liquiditySweep !== undefined) {\r\n      const score = this.calculateLiquiditySweepScore(\r\n        input.liquiditySweep,\r\n        this.config.weights.liquiditySweep,\r\n      );\r\n      contributions.liquiditySweep = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // Calculate confidence as decimal (0.0-1.0) - NOT percentage!\r\n    const confidence = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) : 0;\r\n\r\n    this.logger.debug('Signal score calculated', {\r\n      totalScore,\r\n      maxPossibleScore,\r\n      confidence: (confidence * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      factorsEvaluated: Object.keys(contributions).length,\r\n    });\r\n\r\n    return {\r\n      totalScore,\r\n      maxPossibleScore,\r\n      confidence,\r\n      contributions,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if signal confidence meets entry threshold\r\n   * @param confidence - Confidence percentage (0-100)\r\n   * @returns true if meets minimum threshold\r\n   */\r\n  shouldEnter(confidence: number): boolean {\r\n    return confidence >= this.config.minConfidenceToEnter;\r\n  }\r\n\r\n  /**\r\n   * Check if signal confidence meets reduced size threshold\r\n   * @param confidence - Confidence percentage (0-100)\r\n   * @returns true if meets reduced size threshold\r\n   */\r\n  shouldEnterWithReducedSize(confidence: number): boolean {\r\n    return (\r\n      confidence >= this.config.minConfidenceForReducedSize &&\r\n      confidence < this.config.minConfidenceToEnter\r\n    );\r\n  }\r\n\r\n  // ==========================================================================\r\n  // INDIVIDUAL FACTOR SCORING METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate RSI score\r\n   * LONG: Lower RSI = Higher score (oversold)\r\n   * SHORT: Higher RSI = Higher score (overbought)\r\n   */\r\n  private calculateRSIScore(\r\n    rsi: number,\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n\r\n    // For LONG: RSI < threshold = better\r\n    // For SHORT: RSI > (100 - threshold) = better\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const targetRSI = isLong ? rsi : 100 - rsi;\r\n\r\n    if (thresholds.excellent && targetRSI <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (excellent)`,\r\n      };\r\n    } else if (thresholds.good && targetRSI <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (good)`,\r\n      };\r\n    } else if (thresholds.ok && targetRSI <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (ok)`,\r\n      };\r\n    } else if (thresholds.weak && targetRSI <= thresholds.weak) {\r\n      return {\r\n        points: maxPoints * 0.25,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (weak)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `RSI ${rsi.toFixed(1)} (not extreme)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Stochastic score\r\n   * LONG: Lower %K = Higher score (oversold)\r\n   * SHORT: Higher %K = Higher score (overbought)\r\n   */\r\n  private calculateStochasticScore(\r\n    stochastic: { k: number; d: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { k } = stochastic;\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const targetK = isLong ? k : 100 - k;\r\n\r\n    if (thresholds.excellent && targetK <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Stoch %K ${k.toFixed(1)} (excellent)`,\r\n      };\r\n    } else if (thresholds.good && targetK <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Stoch %K ${k.toFixed(1)} (good)`,\r\n      };\r\n    } else if (thresholds.ok && targetK <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Stoch %K ${k.toFixed(1)} (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Stoch %K ${k.toFixed(1)} (not extreme)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate EMA score\r\n   * LONG: Price above EMA = Higher score\r\n   * SHORT: Price below EMA = Higher score\r\n   */\r\n  private calculateEMAScore(\r\n    ema: { fast: number; slow: number; price: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { fast, slow, price } = ema;\r\n\r\n    // Check EMA alignment\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const correctAlignment = isLong ? fast > slow && price > fast : fast < slow && price < fast;\r\n\r\n    if (!correctAlignment) {\r\n      return {\r\n        points: 0,\r\n        maxPoints,\r\n        reason: 'EMA not aligned',\r\n      };\r\n    }\r\n\r\n    // Calculate distance to EMA (%)\r\n    const distance = Math.abs((price - fast) / fast) * PERCENT_MULTIPLIER;\r\n\r\n    if (thresholds.excellent && distance <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && distance <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && distance <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (too far)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Bollinger Bands score\r\n   * LONG: Price near lower band (position < 30) = Higher score\r\n   * SHORT: Price near upper band (position > PERCENTAGE_THRESHOLDS.ULTRA_HIGH) = Higher score\r\n   */\r\n  private calculateBollingerScore(\r\n    bollingerBands: { position: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { position } = bollingerBands;\r\n\r\n    // Convert position to extremity (0-100)\r\n    // For LONG: lower position = higher extremity\r\n    // For SHORT: higher position = higher extremity\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const extremity = isLong ? 100 - position : position;\r\n\r\n    if (thresholds.excellent && extremity >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `BB position ${position.toFixed(1)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && extremity >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `BB position ${position.toFixed(1)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && extremity >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `BB position ${position.toFixed(1)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `BB position ${position.toFixed(1)}% (not extreme)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate ATR score\r\n   * Higher ATR = Higher volatility = Higher score\r\n   */\r\n  private calculateATRScore(\r\n    atr: { current: number; average: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { current, average } = atr;\r\n\r\n    const ratio = current / average;\r\n\r\n    if (thresholds.excellent && ratio >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (excellent)`,\r\n      };\r\n    } else if (thresholds.good && ratio >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (good)`,\r\n      };\r\n    } else if (thresholds.ok && ratio >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (low volatility)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Volume score\r\n   * Higher volume = Higher score\r\n   */\r\n  private calculateVolumeScore(\r\n    volume: { current: number; average: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { current, average } = volume;\r\n\r\n    const ratio = current / average;\r\n\r\n    if (thresholds.excellent && ratio >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (excellent)`,\r\n      };\r\n    } else if (thresholds.good && ratio >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (good)`,\r\n      };\r\n    } else if (thresholds.ok && ratio >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (ok)`,\r\n      };\r\n    } else if (thresholds.weak && ratio >= thresholds.weak) {\r\n      return {\r\n        points: maxPoints * 0.25,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (weak)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (too low)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Delta (Buy/Sell pressure) score\r\n   * LONG: Buy pressure > Sell = Higher score\r\n   * SHORT: Sell pressure > Buy = Higher score\r\n   */\r\n  private calculateDeltaScore(\r\n    delta: { buyPressure: number; sellPressure: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { buyPressure, sellPressure } = delta;\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const ratio = isLong ? buyPressure / sellPressure : sellPressure / buyPressure;\r\n\r\n    if (thresholds.excellent && ratio >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (excellent)`,\r\n      };\r\n    } else if (thresholds.good && ratio >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (good)`,\r\n      };\r\n    } else if (thresholds.ok && ratio >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Orderbook (wall strength) score\r\n   * Higher wall strength = Higher score\r\n   */\r\n  private calculateOrderbookScore(\r\n    orderbook: { wallStrength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { wallStrength } = orderbook;\r\n\r\n    if (thresholds.excellent && wallStrength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Wall strength ${wallStrength.toFixed(0)} (excellent)`,\r\n      };\r\n    } else if (thresholds.good && wallStrength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Wall strength ${wallStrength.toFixed(0)} (good)`,\r\n      };\r\n    } else if (thresholds.ok && wallStrength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Wall strength ${wallStrength.toFixed(0)} (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Wall strength ${wallStrength.toFixed(0)} (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Imbalance (Bid/Ask pressure) score\r\n   * For LONG: BID imbalance (buying pressure) = Higher score\r\n   * For SHORT: ASK imbalance (selling pressure) = Higher score\r\n   */\r\n  private calculateImbalanceScore(\r\n    imbalance: { direction: 'BID' | 'ASK' | 'NEUTRAL'; strength: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { direction: imbalanceDir, strength } = imbalance;\r\n\r\n    // Check alignment: LONG wants BID imbalance, SHORT wants ASK imbalance\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const aligned = (isLong && imbalanceDir === 'BID') || (!isLong && imbalanceDir === 'ASK');\r\n\r\n    // No score if imbalance direction doesn't match signal direction or is NEUTRAL\r\n    if (!aligned) {\r\n      return {\r\n        points: 0,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (not aligned)`,\r\n      };\r\n    }\r\n\r\n    // Score based on strength thresholds\r\n    if (thresholds.excellent && strength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && strength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && strength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Level Strength score\r\n   * More touches & bounces = Higher score\r\n   */\r\n  private calculateLevelStrengthScore(\r\n    levelStrength: { touches: number; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { touches, strength } = levelStrength;\r\n\r\n    if (thresholds.excellent && touches >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Level ${touches} touches (excellent)`,\r\n      };\r\n    } else if (thresholds.good && touches >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Level ${touches} touches (good)`,\r\n      };\r\n    } else if (thresholds.ok && touches >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Level ${touches} touches (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Level ${touches} touches (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Level Distance score\r\n   * Closer to level = Higher score\r\n   */\r\n  private calculateLevelDistanceScore(\r\n    levelDistance: { percent: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { percent } = levelDistance;\r\n\r\n    if (thresholds.excellent && percent <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (excellent)`,\r\n      };\r\n    } else if (thresholds.good && percent <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (good)`,\r\n      };\r\n    } else if (thresholds.ok && percent <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (ok)`,\r\n      };\r\n    } else if (thresholds.weak && percent <= thresholds.weak) {\r\n      return {\r\n        points: maxPoints * 0.25,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (weak)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (too far)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Swing Points score\r\n   * Higher quality swing = Higher score\r\n   */\r\n  private calculateSwingPointsScore(\r\n    swingPoints: { quality: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { quality } = swingPoints;\r\n\r\n    // Quality is 0-1, map to maxPoints\r\n    const points = quality * maxPoints;\r\n\r\n    return {\r\n      points,\r\n      maxPoints,\r\n      reason: `Swing quality ${(quality * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Chart Patterns score\r\n   * Stronger pattern = Higher score\r\n   */\r\n  private calculateChartPatternsScore(\r\n    chartPatterns: { type: string; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { type, strength } = chartPatterns;\r\n\r\n    if (thresholds.excellent && strength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Pattern ${type} ${strength.toFixed(0)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && strength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Pattern ${type} ${strength.toFixed(0)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && strength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Pattern ${type} ${strength.toFixed(0)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Pattern ${type} ${strength.toFixed(0)}% (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Candle Patterns score\r\n   * Stronger pattern = Higher score\r\n   */\r\n  private calculateCandlePatternsScore(\r\n    candlePatterns: { type: string; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { type, strength } = candlePatterns;\r\n\r\n    if (thresholds.excellent && strength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Candle ${type} ${strength.toFixed(0)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && strength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Candle ${type} ${strength.toFixed(0)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && strength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Candle ${type} ${strength.toFixed(0)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Candle ${type} ${strength.toFixed(0)}% (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Senior TF Alignment score\r\n   * Aligned with higher timeframe = Full points\r\n   */\r\n  private calculateSeniorTFAlignmentScore(\r\n    seniorTFAlignment: { aligned: boolean; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { aligned, strength } = seniorTFAlignment;\r\n\r\n    if (aligned) {\r\n      const points = maxPoints * strength;\r\n      return {\r\n        points,\r\n        maxPoints,\r\n        reason: `Senior TF aligned ${(strength * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: 'Senior TF not aligned',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate BTC Correlation score\r\n   * Aligned with BTC = Full points\r\n   */\r\n  private calculateBTCCorrelationScore(\r\n    btcCorrelation: { correlation: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { correlation } = btcCorrelation;\r\n\r\n    // Correlation is 0-1\r\n    const points = correlation * maxPoints;\r\n\r\n    return {\r\n      points,\r\n      maxPoints,\r\n      reason: `BTC correlation ${(correlation * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Divergence score\r\n   * LONG: Bullish divergence = Full points\r\n   * SHORT: Bearish divergence = Full points\r\n   */\r\n  private calculateDivergenceScore(\r\n    divergence: { type: string; strength: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { type, strength } = divergence;\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const correctType = (isLong && type === 'BULLISH') || (!isLong && type === 'BEARISH');\r\n\r\n    if (correctType) {\r\n      const points = maxPoints * strength;\r\n      return {\r\n        points,\r\n        maxPoints,\r\n        reason: `Divergence ${type} ${(strength * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Divergence ${type} (wrong direction)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Liquidity Sweep score\r\n   * Sweep detected = Full points\r\n   */\r\n  private calculateLiquiditySweepScore(\r\n    liquiditySweep: { detected: boolean; confidence: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { detected, confidence } = liquiditySweep;\r\n\r\n    if (detected) {\r\n      const points = maxPoints * confidence;\r\n      return {\r\n        points,\r\n        maxPoints,\r\n        reason: `Liquidity sweep ${(confidence * PERCENT_MULTIPLIER).toFixed(0)}% confidence`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: 'No liquidity sweep',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate TF Alignment score (PHASE 6)\r\n   * Higher alignment score = More points\r\n   *\r\n   * @param alignmentScore - Score from TFAlignmentService (0-100)\r\n   * @param weight - Weight configuration\r\n   * @returns Score breakdown\r\n   */\r\n  private calculateTFAlignmentScore(\r\n    alignmentScore: number,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n\r\n    // Use gradient scoring based on alignment score\r\n    let points = 0;\r\n\r\n    if (alignmentScore >= (thresholds.excellent ?? 90)) {\r\n      // Excellent: 90%+ alignment â†’ Full points\r\n      points = maxPoints;\r\n    } else if (alignmentScore >= (thresholds.good ?? 70)) {\r\n      // Good: 70-89% alignment â†’ 75% points\r\n      points = maxPoints * 0.75;\r\n    } else if (alignmentScore >= (thresholds.ok ?? 50)) {\r\n      // OK: 50-69% alignment â†’ 50% points\r\n      points = maxPoints * 0.5;\r\n    } else {\r\n      // Weak: <50% alignment â†’ 25% points\r\n      points = maxPoints * 0.25;\r\n    }\r\n\r\n    return {\r\n      points,\r\n      maxPoints,\r\n      reason: `TF Alignment ${alignmentScore.toFixed(0)}%`,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\whale-detector-follow.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TIME_UNITS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OrderBookWall' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":74},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":124,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":124,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.05.","line":162,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":29},{"ruleId":"complexity","severity":1,"message":"Method 'detectWallBreak' has a complexity of 11. Maximum allowed is 10.","line":191,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":276,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":317,"column":113,"nodeType":"Literal","messageId":"noMagic","endLine":317,"endColumn":117},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":349,"column":113,"nodeType":"Literal","messageId":"noMagic","endLine":349,"endColumn":117},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":372,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":372,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":385,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":385,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14461,14480],"text":"historicalSnapshot == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":436,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":436,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16665,16673],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":457,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":457,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17358,17366],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (386). Maximum allowed is 300.","line":462,"column":1,"nodeType":null,"messageId":"exceed","endLine":604,"endColumn":1},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'breakExpiryMs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":501,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":501,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":516,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":516,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":530,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":530,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":530,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":530,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":530,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":530,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":533,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":533,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":533,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":533,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":533,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":533,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":543,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":543,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":543,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":543,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":543,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":543,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 120000.","line":546,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":546,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":546,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":546,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":546,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":546,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":556,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":556,"endColumn":55}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Whale Detector Service - FOLLOW THE WHALE Strategy\r\n *\r\n * Philosophy: Trade WITH the whale (not against momentum)\r\n *\r\n * MODE 1: WALL_BREAK (Ð¿Ñ€Ð¾Ð±Ð¾Ð¹ ÑÑ‚ÐµÐ½Ñ‹)\r\n * - BID wall broken â†’ SHORT (whale sold = distribution phase)\r\n * - ASK wall broken â†’ LONG (whale bought = accumulation phase)\r\n *\r\n * MODE 2: WALL_DISAPPEARANCE (Ð¸ÑÑ‡ÐµÐ·Ð½Ð¾Ð²ÐµÐ½Ð¸Ðµ ÑÑ‚ÐµÐ½Ñ‹)\r\n * - Same as breakout version (reversal play)\r\n *\r\n * MODE 3: IMBALANCE_SPIKE (Ñ€ÐµÐ·ÐºÐ¸Ð¹ Ð´Ð¸ÑÐ±Ð°Ð»Ð°Ð½Ñ)\r\n * - Same as breakout version (immediate momentum)\r\n *\r\n * IMPORTANT: Requires WebSocket orderbook for real-time data\r\n * REST API polling is too slow for whale detection!\r\n */\r\n\r\nimport { LoggerService, SignalDirection, OrderBookAnalysis, OrderBookWall } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum WhaleDetectionMode {\r\n  WALL_BREAK = 'WALL_BREAK', // ÐŸÑ€Ð¾Ð±Ð¾Ð¹ ÑÑ‚ÐµÐ½Ñ‹\r\n  WALL_DISAPPEARANCE = 'WALL_DISAPPEARANCE', // Ð˜ÑÑ‡ÐµÐ·Ð½Ð¾Ð²ÐµÐ½Ð¸Ðµ ÑÑ‚ÐµÐ½Ñ‹\r\n  IMBALANCE_SPIKE = 'IMBALANCE_SPIKE', // Ð ÐµÐ·ÐºÐ¸Ð¹ Ð´Ð¸ÑÐ±Ð°Ð»Ð°Ð½Ñ\r\n}\r\n\r\nexport interface WhaleDetectorConfig {\r\n  modes: {\r\n    wallBreak: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 15%)\r\n      breakConfirmationMs: number; // Time to confirm break (e.g., 3000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 85)\r\n    };\r\n    wallDisappearance: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 20%)\r\n      minWallDuration: number; // Min time wall existed (e.g., TIME_UNITS.MINUTEms = 1min)\r\n      wallGoneThresholdMs: number; // Time without seeing wall = gone (e.g., 15000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 80)\r\n    };\r\n    imbalanceSpike: {\r\n      enabled: boolean;\r\n      minRatioChange: number; // Min ratio change (e.g., 1.5 = CONFIDENCE_THRESHOLDS.MODERATE% change)\r\n      detectionWindow: number; // Time window for spike (e.g., 10000ms = 10s)\r\n      maxConfidence: number; // Max confidence % (e.g., 90)\r\n    };\r\n  };\r\n  maxImbalanceHistory: number; // Max imbalance snapshots to keep (e.g., 20)\r\n  wallExpiryMs: number; // Time before wall is removed from tracking (e.g., TIME_UNITS.MINUTEms)\r\n  breakExpiryMs: number; // Time before broken wall can be re-detected (e.g., TIME_UNITS.FIVE_MINUTESms)\r\n}\r\n\r\nexport interface WhaleWall {\r\n  side: 'BID' | 'ASK';\r\n  price: number;\r\n  quantity: number;\r\n  percentOfTotal: number;\r\n  distance: number;\r\n  detectedAt: number;\r\n  lastSeenAt: number;\r\n}\r\n\r\nexport interface ImbalanceSnapshot {\r\n  ratio: number;\r\n  timestamp: number;\r\n  bidVolume: number;\r\n  askVolume: number;\r\n}\r\n\r\nexport interface WhaleSignal {\r\n  detected: boolean;\r\n  mode: WhaleDetectionMode | null;\r\n  direction: SignalDirection | null;\r\n  confidence: number; // 0-100\r\n  reason: string;\r\n  metadata: {\r\n    wall?: WhaleWall;\r\n    breakPrice?: number;\r\n    imbalanceChange?: number;\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// WHALE DETECTOR FOLLOW SERVICE\r\n// ============================================================================\r\n\r\nexport class WhaleDetectorFollowService {\r\n  // Mode 1: Wall tracking (for breaks and disappearances)\r\n  private trackedBidWalls: Map<number, WhaleWall> = new Map();\r\n  private trackedAskWalls: Map<number, WhaleWall> = new Map();\r\n\r\n  // Mode 2: Recently broken walls (to avoid re-detecting same break)\r\n  private recentlyBrokenWalls: Set<string> = new Set(); // \"BID_1.5000\" or \"ASK_1.5200\"\r\n\r\n  // Mode 3: Imbalance history (for spike detection)\r\n  private imbalanceHistory: ImbalanceSnapshot[] = [];\r\n\r\n  constructor(\r\n    private config: WhaleDetectorConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect whale activity from order book analysis\r\n   *\r\n   * @param analysis - Current order book analysis\r\n   * @param currentPrice - Current market price\r\n   * @returns Whale signal (detected or not)\r\n   */\r\n  detectWhale(analysis: OrderBookAnalysis, currentPrice: number): WhaleSignal {\r\n    // Update tracked data\r\n    this.updateTrackedWalls(analysis);\r\n    this.updateImbalanceHistory(analysis);\r\n    this.cleanupExpiredData();\r\n\r\n    // Log current orderbook state (every 10th call to avoid spam)\r\n    if (Math.random() < 0.1) {\r\n      this.logger.debug('ðŸ‹ Whale Detector FOLLOW State', {\r\n        trackedBids: this.trackedBidWalls.size,\r\n        trackedAsks: this.trackedAskWalls.size,\r\n        imbalanceHistory: this.imbalanceHistory.length,\r\n        currentRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        walls: analysis.walls.length,\r\n      });\r\n    }\r\n\r\n    // MODE 3: Imbalance Spike (highest priority - immediate action)\r\n    if (this.config.modes.imbalanceSpike.enabled) {\r\n      const spikeSignal = this.detectImbalanceSpike(analysis);\r\n      if (spikeSignal.detected) {\r\n        this.logWhaleDetection(spikeSignal);\r\n        return spikeSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 1: Wall Break (medium priority - momentum play)\r\n    if (this.config.modes.wallBreak.enabled) {\r\n      const breakSignal = this.detectWallBreak(currentPrice);\r\n      if (breakSignal.detected) {\r\n        this.logWhaleDetection(breakSignal);\r\n        return breakSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 2: Wall Disappearance (lower priority - reversal play)\r\n    if (this.config.modes.wallDisappearance.enabled) {\r\n      const disappearanceSignal = this.detectWallDisappearance();\r\n      if (disappearanceSignal.detected) {\r\n        this.logWhaleDetection(disappearanceSignal);\r\n        return disappearanceSignal;\r\n      }\r\n    }\r\n\r\n    // No whale detected - log summary (every 20th call)\r\n    if (Math.random() < 0.05) {\r\n      this.logger.debug('ðŸ‹ No whale activity (FOLLOW mode)', {\r\n        wallsDetected: analysis.walls.length,\r\n        imbalanceRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        imbalanceDirection: analysis.imbalance.direction,\r\n      });\r\n    }\r\n\r\n    return {\r\n      detected: false,\r\n      mode: null,\r\n      direction: null,\r\n      confidence: 0,\r\n      reason: 'No whale activity detected',\r\n      metadata: {},\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 1: WALL BREAK DETECTION (FOLLOW THE WHALE)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when price breaks through a large wall - FOLLOW WHALE logic\r\n   *\r\n   * Logic:\r\n   * - BID wall broken (price went below) â†’ SHORT signal (whale sold = distribution)\r\n   * - ASK wall broken (price went above) â†’ LONG signal (whale bought = accumulation)\r\n   */\r\n  private detectWallBreak(currentPrice: number): WhaleSignal {\r\n    const now = Date.now();\r\n    const confirmationMs = this.config.modes.wallBreak.breakConfirmationMs;\r\n\r\n    // Check if any BID walls were broken (price dropped below)\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now BELOW the wall\r\n      if (currentPrice < wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `BID_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - BID wall broken â†’ SHORT signal (FOLLOW WHALE)\r\n        // Logic: Whale SOLD through BID wall â†’ distribution phase â†’ price goes DOWN\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.SHORT,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `BID wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale SOLD, follow SHORT`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check if any ASK walls were broken (price rose above)\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now ABOVE the wall\r\n      if (currentPrice > wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `ASK_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - ASK wall broken â†’ LONG signal (FOLLOW WHALE)\r\n        // Logic: Whale BOUGHT through ASK wall â†’ accumulation phase â†’ price goes UP\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.LONG,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `ASK wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale BOUGHT, follow LONG`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 2: WALL DISAPPEARANCE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when a large wall suddenly disappears\r\n   *\r\n   * Logic:\r\n   * - BID wall disappears â†’ whale done accumulating â†’ SHORT signal (distribution next)\r\n   * - ASK wall disappears â†’ whale done distributing â†’ LONG signal (accumulation next)\r\n   */\r\n  private detectWallDisappearance(): WhaleSignal {\r\n    const now = Date.now();\r\n    const wallGoneThresholdMs = this.config.modes.wallDisappearance.wallGoneThresholdMs;\r\n\r\n    // Check BID walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - BID wall gone â†’ SHORT signal\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction: SignalDirection.SHORT,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason: `BID wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - Accumulation done, distribution likely`,\r\n          metadata: {\r\n            wall,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check ASK walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - ASK wall gone â†’ LONG signal\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction: SignalDirection.LONG,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason: `ASK wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - Distribution done, accumulation likely`,\r\n          metadata: {\r\n            wall,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 3: IMBALANCE SPIKE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect sudden bid/ask imbalance shift\r\n   *\r\n   * Logic:\r\n   * - Sudden increase in bid ratio â†’ LONG signal (buying pressure)\r\n   * - Sudden increase in ask ratio â†’ SHORT signal (selling pressure)\r\n   */\r\n  private detectImbalanceSpike(analysis: OrderBookAnalysis): WhaleSignal {\r\n    if (this.imbalanceHistory.length < 3) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const currentRatio = analysis.imbalance.ratio;\r\n    const detectionWindow = this.config.modes.imbalanceSpike.detectionWindow;\r\n    const now = Date.now();\r\n\r\n    // Get imbalance from N seconds ago\r\n    const historicalSnapshot = this.imbalanceHistory.find(\r\n      (snap) => now - snap.timestamp <= detectionWindow,\r\n    );\r\n\r\n    if (!historicalSnapshot) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const historicalRatio = historicalSnapshot.ratio;\r\n    const ratioChange = currentRatio / historicalRatio;\r\n\r\n    // Check for BULLISH spike (bid ratio increased)\r\n    if (ratioChange >= 1 + this.config.modes.imbalanceSpike.minRatioChange) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.LONG,\r\n        confidence: this.calculateSpikeConfidence(ratioChange),\r\n        reason: `BULLISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} â†’ ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, +${((ratioChange - 1) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Check for BEARISH spike (ask ratio increased = bid ratio decreased)\r\n    if (ratioChange <= 1 / (1 + this.config.modes.imbalanceSpike.minRatioChange)) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.SHORT,\r\n        confidence: this.calculateSpikeConfidence(1 / ratioChange),\r\n        reason: `BEARISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} â†’ ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, ${((1 - ratioChange) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Data Tracking\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Update tracked walls with current order book\r\n   */\r\n  private updateTrackedWalls(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    // Update BID walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'BID')) {\r\n      const existing = this.trackedBidWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedBidWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update ASK walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'ASK')) {\r\n      const existing = this.trackedAskWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedAskWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update imbalance history for spike detection\r\n   */\r\n  private updateImbalanceHistory(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    this.imbalanceHistory.push({\r\n      ratio: analysis.imbalance.ratio,\r\n      timestamp: now,\r\n      bidVolume: analysis.imbalance.bidVolume,\r\n      askVolume: analysis.imbalance.askVolume,\r\n    });\r\n\r\n    // Keep only recent history\r\n    if (this.imbalanceHistory.length > this.config.maxImbalanceHistory) {\r\n      this.imbalanceHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired data\r\n   */\r\n  private cleanupExpiredData(): void {\r\n    const now = Date.now();\r\n    const wallExpiryMs = this.config.wallExpiryMs;\r\n    const breakExpiryMs = this.config.breakExpiryMs;\r\n\r\n    // Remove old walls\r\n    for (const [price, wall] of this.trackedBidWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedBidWalls.delete(price);\r\n      }\r\n    }\r\n    for (const [price, wall] of this.trackedAskWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedAskWalls.delete(price);\r\n      }\r\n    }\r\n\r\n    // Remove old broken walls (allow re-detection after 5 min)\r\n    if (this.recentlyBrokenWalls.size > 100) {\r\n      this.recentlyBrokenWalls.clear(); // Prevent memory leak\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Confidence Calculation\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate confidence for wall break (0-100)\r\n   */\r\n  private calculateBreakConfidence(wall: WhaleWall): number {\r\n    // Factor: Wall size (bigger = higher confidence)\r\n    const sizeScore = Math.min((wall.percentOfTotal / 15) * 60, 60);\r\n\r\n    // Factor: Distance (closer break = higher confidence)\r\n    const distanceScore = Math.max(30 - wall.distance * 5, 10);\r\n\r\n    return Math.min(sizeScore + distanceScore, this.config.modes.wallBreak.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for wall disappearance (0-100)\r\n   */\r\n  private calculateDisappearanceConfidence(wall: WhaleWall, wallLifetime: number): number {\r\n    // Factor: Wall size\r\n    const sizeScore = Math.min((wall.percentOfTotal / 20) * 50, 50);\r\n\r\n    // Factor: Lifetime (longer = higher confidence)\r\n    const lifetimeScore = Math.min((wallLifetime / 120000) * 30, 30); // Max at 2 minutes\r\n\r\n    return Math.min(sizeScore + lifetimeScore, this.config.modes.wallDisappearance.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for imbalance spike (0-100)\r\n   */\r\n  private calculateSpikeConfidence(ratioChange: number): number {\r\n    // Larger spike = higher confidence\r\n    const confidence = Math.min((ratioChange - 1) * 50, this.config.modes.imbalanceSpike.maxConfidence);\r\n    return confidence;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Log whale detection\r\n   */\r\n  private logWhaleDetection(signal: WhaleSignal): void {\r\n    this.logger.info(`ðŸ‹ WHALE DETECTED [FOLLOW][${signal.mode}]`, {\r\n      direction: signal.direction,\r\n      confidence: `${signal.confidence.toFixed(0)}%`,\r\n      reason: signal.reason,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  getStats(): {\r\n    trackedWalls: { bids: number; asks: number };\r\n    recentBreaks: number;\r\n    imbalanceHistory: number;\r\n    } {\r\n    return {\r\n      trackedWalls: {\r\n        bids: this.trackedBidWalls.size,\r\n        asks: this.trackedAskWalls.size,\r\n      },\r\n      recentBreaks: this.recentlyBrokenWalls.size,\r\n      imbalanceHistory: this.imbalanceHistory.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all tracked data\r\n   */\r\n  clear(): void {\r\n    this.trackedBidWalls.clear();\r\n    this.trackedAskWalls.clear();\r\n    this.recentlyBrokenWalls.clear();\r\n    this.imbalanceHistory = [];\r\n    this.logger.debug('WhaleDetectorFollow data cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\whale-detector.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TIME_UNITS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":82,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":92},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OrderBookWall' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":74},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":137,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.05.","line":177,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":177,"endColumn":29},{"ruleId":"complexity","severity":1,"message":"Method 'detectWallBreak' has a complexity of 11. Maximum allowed is 10.","line":206,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":291,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Method 'detectWallDisappearance' has a complexity of 11. Maximum allowed is 10.","line":312,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":411,"endColumn":4},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":344,"column":23,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":344,"endColumn":25},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":391,"column":23,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":391,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":425,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":425,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":438,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":438,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15981,16000],"text":"historicalSnapshot == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (482). Maximum allowed is 300.","line":473,"column":1,"nodeType":null,"messageId":"exceed","endLine":759,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":489,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":489,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18185,18193],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":510,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":510,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18878,18886],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'breakExpiryMs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":554,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":554,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":569,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":569,"endColumn":44},{"ruleId":"complexity","severity":1,"message":"Method 'determineWallDisappearanceDirection' has a complexity of 18. Maximum allowed is 10.","line":588,"column":46,"nodeType":"FunctionExpression","messageId":"complex","endLine":674,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":601,"column":124,"nodeType":"Literal","messageId":"noMagic","endLine":601,"endColumn":128},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":613,"column":124,"nodeType":"Literal","messageId":"noMagic","endLine":613,"endColumn":128},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":626,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":626,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":634,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":634,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":642,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":642,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":656,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":656,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":670,"column":122,"nodeType":"Literal","messageId":"noMagic","endLine":670,"endColumn":126},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":685,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":685,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":685,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":685,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":685,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":685,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":688,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":688,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":688,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":688,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":688,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":688,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":698,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":698,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":698,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":698,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":698,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":698,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 120000.","line":701,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":701,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":701,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":701,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":701,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":701,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":711,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":711,"endColumn":55}],"suppressedMessages":[],"errorCount":32,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS, TIME_UNITS } from '../constants';\r\n/**\r\n * Whale Detector Service - Combined Approach\r\n *\r\n * Detects whale activity using 3 modes:\r\n *\r\n * MODE 1: WALL_BREAK (Ð¿Ñ€Ð¾Ð±Ð¾Ð¹ ÑÑ‚ÐµÐ½Ñ‹)\r\n * - Detects when price breaks through a large wall\r\n * - High momentum signal (stop-losses triggered)\r\n * - Entry: After break, on pullback\r\n *\r\n * MODE 2: WALL_DISAPPEARANCE (Ð¸ÑÑ‡ÐµÐ·Ð½Ð¾Ð²ÐµÐ½Ð¸Ðµ ÑÑ‚ÐµÐ½Ñ‹)\r\n * - Tracks walls that suddenly disappear\r\n * - Indicates whale completed accumulation/distribution\r\n * - Entry: After wall removed (whale done = reversal)\r\n *\r\n * MODE 3: IMBALANCE_SPIKE (Ñ€ÐµÐ·ÐºÐ¸Ð¹ Ð´Ð¸ÑÐ±Ð°Ð»Ð°Ð½Ñ)\r\n * - Detects sudden bid/ask imbalance shifts\r\n * - Indicates large player entering market\r\n * - Entry: Ride the momentum (highest priority)\r\n *\r\n * IMPORTANT: Requires WebSocket orderbook for real-time data\r\n * REST API polling is too slow for whale detection!\r\n */\r\n\r\nimport { LoggerService, SignalDirection, OrderBookAnalysis, OrderBookWall } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum WhaleDetectionMode {\r\n  WALL_BREAK = 'WALL_BREAK', // ÐŸÑ€Ð¾Ð±Ð¾Ð¹ ÑÑ‚ÐµÐ½Ñ‹\r\n  WALL_DISAPPEARANCE = 'WALL_DISAPPEARANCE', // Ð˜ÑÑ‡ÐµÐ·Ð½Ð¾Ð²ÐµÐ½Ð¸Ðµ ÑÑ‚ÐµÐ½Ñ‹\r\n  IMBALANCE_SPIKE = 'IMBALANCE_SPIKE', // Ð ÐµÐ·ÐºÐ¸Ð¹ Ð´Ð¸ÑÐ±Ð°Ð»Ð°Ð½Ñ\r\n}\r\n\r\nexport interface WhaleDetectorConfig {\r\n  modes: {\r\n    wallBreak: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 15%)\r\n      breakConfirmationMs: number; // Time to confirm break (e.g., 3000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 85)\r\n    };\r\n    wallDisappearance: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 20%)\r\n      minWallDuration: number; // Min time wall existed (e.g., TIME_UNITS.MINUTEms = 1min)\r\n      wallGoneThresholdMs: number; // Time without seeing wall = gone (e.g., 15000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 80)\r\n    };\r\n    imbalanceSpike: {\r\n      enabled: boolean;\r\n      minRatioChange: number; // Min ratio change (e.g., 1.5 = CONFIDENCE_THRESHOLDS.MODERATE% change)\r\n      detectionWindow: number; // Time window for spike (e.g., 10000ms = 10s)\r\n      maxConfidence: number; // Max confidence % (e.g., 90)\r\n    };\r\n  };\r\n  maxImbalanceHistory: number; // Max imbalance snapshots to keep (e.g., 20)\r\n  wallExpiryMs: number; // Time before wall is removed from tracking (e.g., TIME_UNITS.MINUTEms)\r\n  breakExpiryMs: number; // Time before broken wall can be re-detected (e.g., TIME_UNITS.FIVE_MINUTESms)\r\n}\r\n\r\nexport interface WhaleWall {\r\n  side: 'BID' | 'ASK';\r\n  price: number;\r\n  quantity: number;\r\n  percentOfTotal: number;\r\n  distance: number;\r\n  detectedAt: number;\r\n  lastSeenAt: number;\r\n}\r\n\r\nexport interface ImbalanceSnapshot {\r\n  ratio: number;\r\n  timestamp: number;\r\n  bidVolume: number;\r\n  askVolume: number;\r\n}\r\n\r\nexport interface WhaleSignal {\r\n  detected: boolean;\r\n  mode: WhaleDetectionMode | null;\r\n  direction: SignalDirection | null;\r\n  confidence: number; // 0-100\r\n  reason: string;\r\n  metadata: {\r\n    wall?: WhaleWall;\r\n    breakPrice?: number;\r\n    imbalanceChange?: number;\r\n    trendInverted?: boolean; // Whether signal was inverted due to strong trend\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// WHALE DETECTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class WhaleDetectorService {\r\n  // Mode 1: Wall tracking (for breaks and disappearances)\r\n  private trackedBidWalls: Map<number, WhaleWall> = new Map();\r\n  private trackedAskWalls: Map<number, WhaleWall> = new Map();\r\n\r\n  // Mode 2: Recently broken walls (to avoid re-detecting same break)\r\n  private recentlyBrokenWalls: Set<string> = new Set(); // \"BID_1.5000\" or \"ASK_1.5200\"\r\n\r\n  // Mode 3: Imbalance history (for spike detection)\r\n  private imbalanceHistory: ImbalanceSnapshot[] = [];\r\n\r\n  constructor(\r\n    private config: WhaleDetectorConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect whale activity from order book analysis\r\n   *\r\n   * @param analysis - Current order book analysis\r\n   * @param currentPrice - Current market price\r\n   * @param btcMomentum - BTC momentum (0-1, from BTCAnalysis)\r\n   * @param btcDirection - BTC direction ('UP'/'DOWN'/'NEUTRAL')\r\n   * @returns Whale signal (detected or not)\r\n   */\r\n  detectWhale(\r\n    analysis: OrderBookAnalysis,\r\n    currentPrice: number,\r\n    btcMomentum?: number,\r\n    btcDirection?: string,\r\n  ): WhaleSignal {\r\n    // Update tracked data\r\n    this.updateTrackedWalls(analysis);\r\n    this.updateImbalanceHistory(analysis);\r\n    this.cleanupExpiredData();\r\n\r\n    // Log current orderbook state (every 10th call to avoid spam)\r\n    if (Math.random() < 0.1) {\r\n      this.logger.debug('ðŸ‹ Whale Detector State', {\r\n        trackedBids: this.trackedBidWalls.size,\r\n        trackedAsks: this.trackedAskWalls.size,\r\n        imbalanceHistory: this.imbalanceHistory.length,\r\n        currentRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        walls: analysis.walls.length,\r\n        btcMomentum: btcMomentum?.toFixed(DECIMAL_PLACES.PERCENT),\r\n        btcDirection,\r\n      });\r\n    }\r\n\r\n    // MODE 3: Imbalance Spike (highest priority - immediate action)\r\n    if (this.config.modes.imbalanceSpike.enabled) {\r\n      const spikeSignal = this.detectImbalanceSpike(analysis);\r\n      if (spikeSignal.detected) {\r\n        this.logWhaleDetection(spikeSignal);\r\n        return spikeSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 1: Wall Break (medium priority - momentum play)\r\n    if (this.config.modes.wallBreak.enabled) {\r\n      const breakSignal = this.detectWallBreak(currentPrice);\r\n      if (breakSignal.detected) {\r\n        this.logWhaleDetection(breakSignal);\r\n        return breakSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 2: Wall Disappearance (lower priority - reversal play)\r\n    if (this.config.modes.wallDisappearance.enabled) {\r\n      const disappearanceSignal = this.detectWallDisappearance(btcMomentum, btcDirection);\r\n      if (disappearanceSignal.detected) {\r\n        this.logWhaleDetection(disappearanceSignal);\r\n        return disappearanceSignal;\r\n      }\r\n    }\r\n\r\n    // No whale detected - log summary (every 20th call)\r\n    if (Math.random() < 0.05) {\r\n      this.logger.debug('ðŸ‹ No whale activity', {\r\n        wallsDetected: analysis.walls.length,\r\n        imbalanceRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        imbalanceDirection: analysis.imbalance.direction,\r\n      });\r\n    }\r\n\r\n    return {\r\n      detected: false,\r\n      mode: null,\r\n      direction: null,\r\n      confidence: 0,\r\n      reason: 'No whale activity detected',\r\n      metadata: {},\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 1: WALL BREAK DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when price breaks through a large wall\r\n   *\r\n   * Logic:\r\n   * - BID wall broken (price went below) â†’ SHORT signal (momentum down)\r\n   * - ASK wall broken (price went above) â†’ LONG signal (momentum up)\r\n   */\r\n  private detectWallBreak(currentPrice: number): WhaleSignal {\r\n    const now = Date.now();\r\n    const confirmationMs = this.config.modes.wallBreak.breakConfirmationMs;\r\n\r\n    // Check if any BID walls were broken (price dropped below)\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now BELOW the wall\r\n      if (currentPrice < wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `BID_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - BID wall broken â†’ LONG signal\r\n        // Logic: BID wall absorbed selling pressure â†’ buyers push price UP\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.LONG,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `BID wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale absorbed sells, Momentum UP`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check if any ASK walls were broken (price rose above)\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now ABOVE the wall\r\n      if (currentPrice > wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `ASK_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - ASK wall broken â†’ SHORT signal\r\n        // Logic: ASK wall absorbed buying pressure â†’ sellers push price DOWN\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.SHORT,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `ASK wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale absorbed buys, Momentum DOWN`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 2: WALL DISAPPEARANCE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when a large wall suddenly disappears\r\n   *\r\n   * DEFAULT Logic (neutral market):\r\n   * - BID wall disappears â†’ whale done accumulating â†’ SHORT signal (distribution next)\r\n   * - ASK wall disappears â†’ whale done distributing â†’ LONG signal (accumulation next)\r\n   *\r\n   * TREND-AWARE Logic (strong trend):\r\n   * - In BEARISH market (BTC down): BID disappears â†’ SHORT continuation (whales not buying = more drop)\r\n   * - In BULLISH market (BTC up): ASK disappears â†’ LONG continuation (whales not selling = more pump)\r\n   * - Logic is INVERTED in strong trends to trade WITH the trend!\r\n   *\r\n   * @param btcMomentum - BTC momentum (0-1, undefined if not available)\r\n   * @param btcDirection - BTC direction ('UP'/'DOWN'/'NEUTRAL', undefined if not available)\r\n   */\r\n  private detectWallDisappearance(btcMomentum?: number, btcDirection?: string): WhaleSignal {\r\n    const now = Date.now();\r\n    const wallGoneThresholdMs = this.config.modes.wallDisappearance.wallGoneThresholdMs;\r\n\r\n    // Check BID walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - BID wall gone\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        // Determine signal direction based on market trend\r\n        const { direction, reason, trendInverted } = this.determineWallDisappearanceDirection(\r\n          'BID',\r\n          wallPrice,\r\n          wallLifetime,\r\n          btcMomentum,\r\n          btcDirection,\r\n        );\r\n\r\n        if (direction == null) {\r\n          // Signal blocked by trend filter\r\n          continue;\r\n        }\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason,\r\n          metadata: {\r\n            wall,\r\n            trendInverted,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check ASK walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - ASK wall gone\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        // Determine signal direction based on market trend\r\n        const { direction, reason, trendInverted } = this.determineWallDisappearanceDirection(\r\n          'ASK',\r\n          wallPrice,\r\n          wallLifetime,\r\n          btcMomentum,\r\n          btcDirection,\r\n        );\r\n\r\n        if (direction == null) {\r\n          // Signal blocked by trend filter\r\n          continue;\r\n        }\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason,\r\n          metadata: {\r\n            wall,\r\n            trendInverted,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 3: IMBALANCE SPIKE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect sudden bid/ask imbalance shift\r\n   *\r\n   * Logic:\r\n   * - Sudden increase in bid ratio â†’ LONG signal (buying pressure)\r\n   * - Sudden increase in ask ratio â†’ SHORT signal (selling pressure)\r\n   */\r\n  private detectImbalanceSpike(analysis: OrderBookAnalysis): WhaleSignal {\r\n    if (this.imbalanceHistory.length < 3) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const currentRatio = analysis.imbalance.ratio;\r\n    const detectionWindow = this.config.modes.imbalanceSpike.detectionWindow;\r\n    const now = Date.now();\r\n\r\n    // Get imbalance from N seconds ago\r\n    const historicalSnapshot = this.imbalanceHistory.find(\r\n      (snap) => now - snap.timestamp <= detectionWindow,\r\n    );\r\n\r\n    if (!historicalSnapshot) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const historicalRatio = historicalSnapshot.ratio;\r\n    const ratioChange = currentRatio / historicalRatio;\r\n\r\n    // Check for BULLISH spike (bid ratio increased)\r\n    if (ratioChange >= 1 + this.config.modes.imbalanceSpike.minRatioChange) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.LONG,\r\n        confidence: this.calculateSpikeConfidence(ratioChange),\r\n        reason: `BULLISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} â†’ ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, +${((ratioChange - 1) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Check for BEARISH spike (ask ratio increased = bid ratio decreased)\r\n    if (ratioChange <= 1 / (1 + this.config.modes.imbalanceSpike.minRatioChange)) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.SHORT,\r\n        confidence: this.calculateSpikeConfidence(1 / ratioChange),\r\n        reason: `BEARISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} â†’ ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, ${((1 - ratioChange) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Data Tracking\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Update tracked walls with current order book\r\n   */\r\n  private updateTrackedWalls(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    // Update BID walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'BID')) {\r\n      const existing = this.trackedBidWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedBidWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update ASK walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'ASK')) {\r\n      const existing = this.trackedAskWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedAskWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update imbalance history for spike detection\r\n   */\r\n  private updateImbalanceHistory(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    this.imbalanceHistory.push({\r\n      ratio: analysis.imbalance.ratio,\r\n      timestamp: now,\r\n      bidVolume: analysis.imbalance.bidVolume,\r\n      askVolume: analysis.imbalance.askVolume,\r\n    });\r\n\r\n    // Keep only recent history\r\n    if (this.imbalanceHistory.length > this.config.maxImbalanceHistory) {\r\n      this.imbalanceHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired data\r\n   */\r\n  private cleanupExpiredData(): void {\r\n    const now = Date.now();\r\n    const wallExpiryMs = this.config.wallExpiryMs;\r\n    const breakExpiryMs = this.config.breakExpiryMs;\r\n\r\n    // Remove old walls\r\n    for (const [price, wall] of this.trackedBidWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedBidWalls.delete(price);\r\n      }\r\n    }\r\n    for (const [price, wall] of this.trackedAskWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedAskWalls.delete(price);\r\n      }\r\n    }\r\n\r\n    // Remove old broken walls (allow re-detection after 5 min)\r\n    if (this.recentlyBrokenWalls.size > 100) {\r\n      this.recentlyBrokenWalls.clear(); // Prevent memory leak\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Trend-Aware Signal Direction\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Determine signal direction for WALL_DISAPPEARANCE based on market trend\r\n   *\r\n   * @param wallSide - Side of wall that disappeared ('BID' or 'ASK')\r\n   * @param wallPrice - Price level of wall\r\n   * @param wallLifetime - How long wall existed (ms)\r\n   * @param btcMomentum - BTC momentum (0-1, undefined if not available)\r\n   * @param btcDirection - BTC direction ('UP'/'DOWN'/'NEUTRAL', undefined if not available)\r\n   * @returns Object with direction, reason, and whether trend was inverted\r\n   */\r\n  private determineWallDisappearanceDirection(\r\n    wallSide: 'BID' | 'ASK',\r\n    wallPrice: number,\r\n    wallLifetime: number,\r\n    btcMomentum?: number,\r\n    btcDirection?: string,\r\n  ): { direction: SignalDirection | null; reason: string; trendInverted: boolean } {\r\n    // Default direction (neutral market logic)\r\n    const defaultDirection = wallSide === 'BID' ? SignalDirection.SHORT : SignalDirection.LONG;\r\n    const invertedDirection = wallSide === 'BID' ? SignalDirection.LONG : SignalDirection.SHORT;\r\n\r\n    // If BTC data not available, use default logic\r\n    if (btcMomentum === undefined || btcDirection === undefined) {\r\n      const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - ${\r\n        wallSide === 'BID' ? 'Accumulation done, distribution likely' : 'Distribution done, accumulation likely'\r\n      }`;\r\n      return { direction: defaultDirection, reason, trendInverted: false };\r\n    }\r\n\r\n    // Determine trend strength\r\n    const isStrongTrend = btcMomentum >= MULTIPLIERS.HALF; // Strong trend threshold\r\n    const isNeutralMarket = btcMomentum < PERCENTAGE_THRESHOLDS.MODERATE; // Neutral market threshold\r\n\r\n    // NEUTRAL MARKET: Use default logic\r\n    if (isNeutralMarket) {\r\n      const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - ${\r\n        wallSide === 'BID' ? 'Accumulation done, distribution likely' : 'Distribution done, accumulation likely'\r\n      } [NEUTRAL market]`;\r\n      return { direction: defaultDirection, reason, trendInverted: false };\r\n    }\r\n\r\n    // STRONG TREND: Apply trend-aware logic (INVERT direction to trade WITH trend)\r\n    if (isStrongTrend) {\r\n      const isBearishTrend = btcDirection === 'DOWN';\r\n      const isBullishTrend = btcDirection === 'UP';\r\n\r\n      // BID wall disappeared in BEARISH market â†’ INVERT to LONG (expect bounce)\r\n      if (wallSide === 'BID' && isBearishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BEARISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales not buying = potential SHORT-TERM BOUNCE â†’ LONG [INVERTED]`;\r\n        return { direction: invertedDirection, reason, trendInverted: true };\r\n      }\r\n\r\n      // ASK wall disappeared in BULLISH market â†’ INVERT to SHORT (expect pullback)\r\n      if (wallSide === 'ASK' && isBullishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BULLISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales not selling = potential SHORT-TERM PULLBACK â†’ SHORT [INVERTED]`;\r\n        return { direction: invertedDirection, reason, trendInverted: true };\r\n      }\r\n\r\n      // BID wall disappeared in BULLISH market â†’ Keep SHORT (continuation)\r\n      if (wallSide === 'BID' && isBullishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BULLISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales done accumulating â†’ continue UP (skip SHORT)`;\r\n        // Block this signal (it goes against trend)\r\n        this.logger.debug('âš ï¸ Wall disappearance signal BLOCKED (against strong trend)', {\r\n          wallSide,\r\n          btcDirection,\r\n          btcMomentum: btcMomentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n        return { direction: null, reason, trendInverted: false };\r\n      }\r\n\r\n      // ASK wall disappeared in BEARISH market â†’ Keep LONG (continuation)\r\n      if (wallSide === 'ASK' && isBearishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BEARISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales done distributing â†’ continue DOWN (skip LONG)`;\r\n        // Block this signal (it goes against trend)\r\n        this.logger.debug('âš ï¸ Wall disappearance signal BLOCKED (against strong trend)', {\r\n          wallSide,\r\n          btcDirection,\r\n          btcMomentum: btcMomentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n        return { direction: null, reason, trendInverted: false };\r\n      }\r\n    }\r\n\r\n    // MODERATE TREND (0.3 <= momentum < MULTIPLIERS.HALF): Use default logic with caution\r\n    const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - ${\r\n      wallSide === 'BID' ? 'Accumulation done, distribution likely' : 'Distribution done, accumulation likely'\r\n    } [MODERATE trend, BTC ${btcDirection}]`;\r\n    return { direction: defaultDirection, reason, trendInverted: false };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Confidence Calculation\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate confidence for wall break (0-100)\r\n   */\r\n  private calculateBreakConfidence(wall: WhaleWall): number {\r\n    // Factor: Wall size (bigger = higher confidence)\r\n    const sizeScore = Math.min((wall.percentOfTotal / 15) * 60, 60);\r\n\r\n    // Factor: Distance (closer break = higher confidence)\r\n    const distanceScore = Math.max(30 - wall.distance * 5, 10);\r\n\r\n    return Math.min(sizeScore + distanceScore, this.config.modes.wallBreak.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for wall disappearance (0-100)\r\n   */\r\n  private calculateDisappearanceConfidence(wall: WhaleWall, wallLifetime: number): number {\r\n    // Factor: Wall size\r\n    const sizeScore = Math.min((wall.percentOfTotal / 20) * 50, 50);\r\n\r\n    // Factor: Lifetime (longer = higher confidence)\r\n    const lifetimeScore = Math.min((wallLifetime / 120000) * 30, 30); // Max at 2 minutes\r\n\r\n    return Math.min(sizeScore + lifetimeScore, this.config.modes.wallDisappearance.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for imbalance spike (0-100)\r\n   */\r\n  private calculateSpikeConfidence(ratioChange: number): number {\r\n    // Larger spike = higher confidence\r\n    const confidence = Math.min((ratioChange - 1) * 50, this.config.modes.imbalanceSpike.maxConfidence);\r\n    return confidence;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Log whale detection\r\n   */\r\n  private logWhaleDetection(signal: WhaleSignal): void {\r\n    this.logger.info(`ðŸ‹ WHALE DETECTED [${signal.mode}]`, {\r\n      direction: signal.direction,\r\n      confidence: `${signal.confidence.toFixed(0)}%`,\r\n      reason: signal.reason,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  getStats(): {\r\n    trackedWalls: { bids: number; asks: number };\r\n    recentBreaks: number;\r\n    imbalanceHistory: number;\r\n    } {\r\n    return {\r\n      trackedWalls: {\r\n        bids: this.trackedBidWalls.size,\r\n        asks: this.trackedAskWalls.size,\r\n      },\r\n      recentBreaks: this.recentlyBrokenWalls.size,\r\n      imbalanceHistory: this.imbalanceHistory.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all tracked data\r\n   */\r\n  clear(): void {\r\n    this.trackedBidWalls.clear();\r\n    this.trackedAskWalls.clear();\r\n    this.recentlyBrokenWalls.clear();\r\n    this.imbalanceHistory = [];\r\n    this.logger.debug('WhaleDetector data cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
