/**
 * Flat Market Detector
 *
 * Multi-factor system to detect ranging/neutral markets with high confidence.
 * Used to switch between single-TP (flat) and multi-TP (trending) strategies.
 *
 * Detection uses 6 weighted factors:
 * - EMA Distance (20 points): Tight EMA convergence indicates flat
 * - ATR Volatility (20 points): Low volatility indicates consolidation
 * - Price Range (15 points): Narrow price range indicates range-bound
 * - ZigZag Pattern (20 points): Equal highs/lows indicate flat structure
 * - EMA Slope (15 points): Flat EMA slope indicates no directional bias
 * - Volume Distribution (10 points): Even volume indicates no directional flow
 *
 * Total confidence score: 0-100 points
 * - 80-100: High confidence FLAT â†’ use single TP @ 0.5%
 * - 50-79: Uncertain â†’ cautious multi-TP
 * - 0-49: Confident TREND â†’ full multi-TP
 */

import {
  Candle,
  TradingContext,
  FlatMarketConfig,
  FlatMarketResult,
  FlatMarketFactors,
  LoggerService,
} from '../types';

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_EMA_SCORE = 20; // Max points for EMA distance factor
const MAX_ATR_SCORE = 20; // Max points for ATR volatility factor
const MAX_RANGE_SCORE = 15; // Max points for price range factor
const MAX_ZIGZAG_SCORE = 20; // Max points for ZigZag pattern factor
const MAX_SLOPE_SCORE = 15; // Max points for EMA slope factor
const MAX_VOLUME_SCORE = 10; // Max points for volume distribution factor

const DEFAULT_RANGE_PERIOD = 20; // Candles to analyze for price range
const DEGREES_TO_RADIANS = Math.PI / 180; // Conversion factor

// ============================================================================
// FLAT MARKET DETECTOR
// ============================================================================

export class FlatMarketDetector {
  constructor(
    private readonly config: FlatMarketConfig,
    private readonly logger: LoggerService
  ) {}

  /**
   * Detect if market is in flat/ranging state
   * @param candles - Candles array (min 20 for range analysis)
   * @param context - Trading context (EMA, ATR, ZigZag data)
   * @returns Flat market result with confidence score
   */
  detect(candles: Candle[], context: TradingContext): FlatMarketResult {
    // Validate inputs
    if (candles.length < DEFAULT_RANGE_PERIOD) {
      this.logger.warn('Insufficient candles for flat market detection', {
        required: DEFAULT_RANGE_PERIOD,
        received: candles.length,
      });
      return this.noDetection('Insufficient data');
    }

    if (!context.ema?.ema20 || !context.ema?.ema50) {
      this.logger.warn('Missing EMA data for flat market detection');
      return this.noDetection('Missing EMA data');
    }

    if (!context.atr) {
      this.logger.warn('Missing ATR data for flat market detection');
      return this.noDetection('Missing ATR data');
    }

    // 1. EMA Distance (20 points)
    const emaScore = this.checkEMADistance(context);

    // 2. ATR Volatility (20 points)
    const atrScore = this.checkATRVolatility(context);

    // 3. Price Range (15 points)
    const rangeScore = this.checkPriceRange(candles, DEFAULT_RANGE_PERIOD);

    // 4. ZigZag Pattern (20 points)
    const zigzagScore = this.checkZigZagPattern(context);

    // 5. EMA Slope (15 points)
    const slopeScore = this.checkEMASlope(candles);

    // 6. Volume Distribution (10 points)
    const volumeScore = this.checkVolumeDistribution(candles);

    // Calculate total confidence
    const confidence = emaScore + atrScore + rangeScore + zigzagScore + slopeScore + volumeScore;

    // Decision: threshold or above = FLAT
    const isFlat = confidence >= this.config.flatThreshold;

    // Build explanation for logs
    const factors: FlatMarketFactors = {
      emaDistance: emaScore,
      atrVolatility: atrScore,
      priceRange: rangeScore,
      zigzagPattern: zigzagScore,
      emaSlope: slopeScore,
      volumeDistribution: volumeScore,
    };

    const explanation = this.buildExplanation(factors);

    this.logger.info(isFlat ? 'âš¡ FLAT market detected' : 'ðŸ“ˆ TRENDING market', {
      confidence: confidence.toFixed(1) + '%',
      threshold: this.config.flatThreshold + '%',
      decision: isFlat ? 'FLAT' : 'TREND',
    });

    this.logger.debug('Flat market factors breakdown', factors);

    return {
      isFlat,
      confidence,
      factors,
      explanation,
    };
  }

  // ==========================================================================
  // PRIVATE FACTOR CHECKS
  // ==========================================================================

  /**
   * Check EMA distance (convergence)
   * Tight EMA convergence (EMA20 â‰ˆ EMA50) indicates flat market
   * @param context - Trading context with EMA data
   * @returns Score 0-20 points
   */
  private checkEMADistance(context: TradingContext): number {
    const ema20 = context.ema!.ema20;
    const ema50 = context.ema!.ema50;

    // Calculate distance as percentage
    const distance = Math.abs(ema20 - ema50) / ema50;
    const distancePercent = distance * 100;

    // Score: 20 points if distance <= threshold, linear decrease to 0
    // Example: threshold 0.3%, distance 0.1% â†’ 20 pts, distance 0.6% â†’ 0 pts
    if (distancePercent <= this.config.emaThreshold) {
      return MAX_EMA_SCORE; // Perfect convergence
    }

    // Linear decrease: 20 * (1 - excess / threshold)
    const excess = distancePercent - this.config.emaThreshold;
    const score = MAX_EMA_SCORE * Math.max(0, 1 - excess / this.config.emaThreshold);

    return Math.round(score);
  }

  /**
   * Check ATR volatility (low volatility = flat)
   * Low ATR relative to price indicates consolidation
   * @param context - Trading context with ATR data
   * @returns Score 0-20 points
   */
  private checkATRVolatility(context: TradingContext): number {
    const atr = context.atr!;
    const currentPrice = context.candles[context.candles.length - 1].close;

    // Calculate ATR as percentage of price
    const atrPercent = (atr / currentPrice) * 100;

    // Score: 20 points if ATR <= threshold, linear decrease to 0
    // Example: threshold 1.5%, ATR 1.0% â†’ 20 pts, ATR 3.0% â†’ 0 pts
    if (atrPercent <= this.config.atrThreshold) {
      return MAX_ATR_SCORE; // Very low volatility
    }

    const excess = atrPercent - this.config.atrThreshold;
    const score = MAX_ATR_SCORE * Math.max(0, 1 - excess / this.config.atrThreshold);

    return Math.round(score);
  }

  /**
   * Check price range (narrow range = flat)
   * Narrow high-low range over period indicates range-bound market
   * @param candles - Candles array
   * @param period - Number of candles to analyze
   * @returns Score 0-15 points
   */
  private checkPriceRange(candles: Candle[], period: number): number {
    // Get last N candles
    const recentCandles = candles.slice(-period);
    if (recentCandles.length < period) {
      return 0; // Insufficient data
    }

    // Find highest high and lowest low
    const high = Math.max(...recentCandles.map((c) => c.high));
    const low = Math.min(...recentCandles.map((c) => c.low));
    const close = recentCandles[recentCandles.length - 1].close;

    // Calculate range as percentage of close
    const rangePercent = ((high - low) / close) * 100;

    // Score: 15 points if range <= threshold, linear decrease to 0
    // Example: threshold 1.0%, range 0.5% â†’ 15 pts, range 2.0% â†’ 0 pts
    if (rangePercent <= this.config.rangeThreshold) {
      return MAX_RANGE_SCORE; // Very tight range
    }

    const excess = rangePercent - this.config.rangeThreshold;
    const score = MAX_RANGE_SCORE * Math.max(0, 1 - excess / this.config.rangeThreshold);

    return Math.round(score);
  }

  /**
   * Check ZigZag pattern (Equal Highs/Lows = flat)
   * EH (Equal High) or EL (Equal Low) patterns indicate flat structure
   * @param context - Trading context with ZigZag data
   * @returns Score 0-20 points
   */
  private checkZigZagPattern(context: TradingContext): number {
    const structure = context.structure?.pattern;

    if (!structure) {
      return 0; // No ZigZag data
    }

    // Check for flat patterns (EH or EL)
    if (structure === 'EH' || structure === 'EL') {
      return MAX_ZIGZAG_SCORE; // Confirmed flat structure
    }

    // Check for weak trend patterns (might be forming flat)
    // Give partial credit if not strong trend
    const strongTrendPatterns = ['HH', 'HL', 'LL', 'LH'];
    if (!strongTrendPatterns.includes(structure)) {
      return Math.round(MAX_ZIGZAG_SCORE * 0.3); // Partial credit
    }

    return 0; // Strong trend pattern, not flat
  }

  /**
   * Check EMA slope (flat slope = no directional bias)
   * Flat EMA50 slope indicates no clear direction
   * @param candles - Candles array
   * @returns Score 0-15 points
   */
  private checkEMASlope(candles: Candle[]): number {
    const recentCandles = candles.slice(-10); // Last 10 candles for slope
    if (recentCandles.length < 10) {
      return 0; // Insufficient data
    }

    // Simple linear regression for EMA50 slope
    // Use close prices as proxy for EMA50 direction
    const prices = recentCandles.map((c) => c.close);
    const n = prices.length;

    let sumX = 0;
    let sumY = 0;
    let sumXY = 0;
    let sumX2 = 0;

    for (let i = 0; i < n; i++) {
      sumX += i;
      sumY += prices[i];
      sumXY += i * prices[i];
      sumX2 += i * i;
    }

    // Calculate slope (rise/run)
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

    // Convert slope to angle in degrees
    const angle = Math.atan(Math.abs(slope) * n) / DEGREES_TO_RADIANS;

    // Score: 15 points if angle <= threshold, linear decrease to 0
    // Example: threshold 5Â°, angle 2Â° â†’ 15 pts, angle 10Â° â†’ 0 pts
    if (angle <= this.config.slopeThreshold) {
      return MAX_SLOPE_SCORE; // Flat slope
    }

    const excess = angle - this.config.slopeThreshold;
    const score = MAX_SLOPE_SCORE * Math.max(0, 1 - excess / this.config.slopeThreshold);

    return Math.round(score);
  }

  /**
   * Check volume distribution (even volume = no directional flow)
   * Even buy/sell volume distribution indicates no directional bias
   * @param candles - Candles array
   * @returns Score 0-10 points
   */
  private checkVolumeDistribution(candles: Candle[]): number {
    const recentCandles = candles.slice(-DEFAULT_RANGE_PERIOD);
    if (recentCandles.length < DEFAULT_RANGE_PERIOD) {
      return 0; // Insufficient data
    }

    // Calculate bullish vs bearish volume
    let bullishVolume = 0;
    let bearishVolume = 0;

    for (const candle of recentCandles) {
      if (candle.close > candle.open) {
        bullishVolume += candle.volume;
      } else {
        bearishVolume += candle.volume;
      }
    }

    const totalVolume = bullishVolume + bearishVolume;
    if (totalVolume === 0) {
      return 0; // No volume data
    }

    // Calculate ratio (closer to 1.0 = more even distribution)
    const ratio = Math.min(bullishVolume, bearishVolume) / Math.max(bullishVolume, bearishVolume);

    // Score: 10 points if ratio >= 0.7 (fairly even), linear decrease
    // Example: ratio 0.9 â†’ 10 pts, ratio 0.5 â†’ 5 pts, ratio 0.0 â†’ 0 pts
    const score = MAX_VOLUME_SCORE * ratio;

    return Math.round(score);
  }

  // ==========================================================================
  // HELPER METHODS
  // ==========================================================================

  /**
   * Build human-readable explanation of detection factors
   * @param factors - Individual factor scores
   * @returns Explanation string for logs
   */
  private buildExplanation(factors: FlatMarketFactors): string {
    const lines: string[] = [];

    lines.push(`EMA Distance: ${factors.emaDistance}/${MAX_EMA_SCORE}`);
    lines.push(`ATR Volatility: ${factors.atrVolatility}/${MAX_ATR_SCORE}`);
    lines.push(`Price Range: ${factors.priceRange}/${MAX_RANGE_SCORE}`);
    lines.push(`ZigZag Pattern: ${factors.zigzagPattern}/${MAX_ZIGZAG_SCORE}`);
    lines.push(`EMA Slope: ${factors.emaSlope}/${MAX_SLOPE_SCORE}`);
    lines.push(`Volume: ${factors.volumeDistribution}/${MAX_VOLUME_SCORE}`);

    return lines.join(', ');
  }

  /**
   * Return default "no detection" result
   * Used when insufficient data or errors occur
   * @param reason - Reason for no detection
   * @returns FlatMarketResult with confidence 0
   */
  private noDetection(reason: string): FlatMarketResult {
    return {
      isFlat: false,
      confidence: 0,
      factors: {
        emaDistance: 0,
        atrVolatility: 0,
        priceRange: 0,
        zigzagPattern: 0,
        emaSlope: 0,
        volumeDistribution: 0,
      },
      explanation: `No detection: ${reason}`,
    };
  }
}
