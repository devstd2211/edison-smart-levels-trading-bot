/**
 * Flat Market Detector Tests
 *
 * Comprehensive unit tests for multi-factor flat market detection system.
 * Tests each factor independently and integration scenarios.
 */

import { FlatMarketDetector } from '../../analyzers/flat-market.detector';
import {
  Candle,
  TradingContext,
  FlatMarketConfig,
  LoggerService,
  LogLevel,
} from '../../types';

// ============================================================================
// TEST HELPERS
// ============================================================================

/**
 * Create test logger with minimal output
 */
function createTestLogger(): LoggerService {
  return new LoggerService(LogLevel.ERROR, './logs', false);
}

/**
 * Create default test config
 */
function createTestConfig(): FlatMarketConfig {
  return {
    enabled: true,
    flatThreshold: 80,
    emaThreshold: 0.3,
    atrThreshold: 1.5,
    rangeThreshold: 1.0,
    slopeThreshold: 5.0,
  };
}

/**
 * Create test candles with specified range
 */
function createTestCandles(count: number, basePrice: number, rangePercent: number): Candle[] {
  const candles: Candle[] = [];
  const range = basePrice * (rangePercent / 100);

  for (let i = 0; i < count; i++) {
    const variation = (Math.random() - 0.5) * range;
    const close = basePrice + variation;
    const open = close + (Math.random() - 0.5) * (range * 0.2);
    const high = Math.max(open, close) + Math.random() * (range * 0.1);
    const low = Math.min(open, close) - Math.random() * (range * 0.1);

    candles.push({
      timestamp: Date.now() + i * 60000,
      open,
      high,
      low,
      close,
      volume: 1000 + Math.random() * 500,
    });
  }

  return candles;
}

/**
 * Create test context with specified parameters
 */
function createTestContext(
  candles: Candle[],
  ema20: number,
  ema50: number,
  atr: number,
  zigzagPattern?: string
): TradingContext {
  return {
    timeframe: '5',
    candles,
    ema: {
      ema20,
      ema50,
      ema100: ema50,
      ema200: ema50,
      trend: 'NEUTRAL',
      distance: Math.abs(ema20 - ema50) / ema50,
    },
    atr,
    structure: zigzagPattern
      ? {
          pattern: zigzagPattern as any,
          isValid: true,
        }
      : undefined,
    bias: 'NEUTRAL',
  } as TradingContext;
}

// ============================================================================
// TESTS
// ============================================================================

describe('FlatMarketDetector', () => {
  let detector: FlatMarketDetector;
  let logger: LoggerService;
  let config: FlatMarketConfig;

  beforeEach(() => {
    logger = createTestLogger();
    config = createTestConfig();
    detector = new FlatMarketDetector(config, logger);
  });

  // ==========================================================================
  // EDGE CASES
  // ==========================================================================

  describe('Edge Cases', () => {
    it('should handle insufficient candles', () => {
      const candles = createTestCandles(5, 100, 0.5); // Only 5 candles, need 20
      const context = createTestContext(candles, 100, 100.1, 1.0);

      const result = detector.detect(candles, context);

      expect(result.isFlat).toBe(false);
      expect(result.confidence).toBe(0);
      expect(result.explanation).toContain('Insufficient data');
    });

    it('should handle missing EMA data', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100, 1.0);
      delete context.ema;

      const result = detector.detect(candles, context);

      expect(result.isFlat).toBe(false);
      expect(result.confidence).toBe(0);
      expect(result.explanation).toContain('Missing EMA data');
    });

    it('should handle missing ATR data', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0);
      delete context.atr;

      const result = detector.detect(candles, context);

      expect(result.isFlat).toBe(false);
      expect(result.confidence).toBe(0);
      expect(result.explanation).toContain('Missing ATR data');
    });
  });

  // ==========================================================================
  // EMA DISTANCE FACTOR (20 points)
  // ==========================================================================

  describe('EMA Distance Factor', () => {
    it('should give max score (20) for perfect EMA convergence', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100.0, 100.1, 1.0); // 0.1% distance

      const result = detector.detect(candles, context);

      expect(result.factors.emaDistance).toBe(20); // Perfect convergence
    });

    it('should give partial score for moderate EMA distance', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100.0, 100.4, 1.0); // 0.4% distance

      const result = detector.detect(candles, context);

      expect(result.factors.emaDistance).toBeGreaterThan(0);
      expect(result.factors.emaDistance).toBeLessThan(20);
    });

    it('should give zero score for wide EMA distance', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100.0, 102.0, 1.0); // 2.0% distance

      const result = detector.detect(candles, context);

      expect(result.factors.emaDistance).toBe(0); // Too wide
    });
  });

  // ==========================================================================
  // ATR VOLATILITY FACTOR (20 points)
  // ==========================================================================

  describe('ATR Volatility Factor', () => {
    it('should give max score (20) for low volatility', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0); // 1.0% ATR

      const result = detector.detect(candles, context);

      expect(result.factors.atrVolatility).toBe(20); // Low volatility
    });

    it('should give partial score for moderate volatility', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 2.0); // 2.0% ATR

      const result = detector.detect(candles, context);

      expect(result.factors.atrVolatility).toBeGreaterThan(0);
      expect(result.factors.atrVolatility).toBeLessThan(20);
    });

    it('should give zero score for high volatility', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 5.0); // 5.0% ATR

      const result = detector.detect(candles, context);

      expect(result.factors.atrVolatility).toBe(0); // High volatility
    });
  });

  // ==========================================================================
  // PRICE RANGE FACTOR (15 points)
  // ==========================================================================

  describe('Price Range Factor', () => {
    it('should give max score (15) for tight price range', () => {
      const candles = createTestCandles(30, 100, 0.5); // 0.5% range
      const context = createTestContext(candles, 100, 100.1, 1.0);

      const result = detector.detect(candles, context);

      expect(result.factors.priceRange).toBe(15); // Tight range
    });

    it('should give partial score for moderate price range', () => {
      const candles = createTestCandles(30, 100, 1.5); // 1.5% range
      const context = createTestContext(candles, 100, 100.1, 1.0);

      const result = detector.detect(candles, context);

      expect(result.factors.priceRange).toBeGreaterThan(0);
      expect(result.factors.priceRange).toBeLessThan(15);
    });

    it('should give zero score for wide price range', () => {
      const candles = createTestCandles(30, 100, 3.0); // 3.0% range
      const context = createTestContext(candles, 100, 100.1, 1.0);

      const result = detector.detect(candles, context);

      expect(result.factors.priceRange).toBe(0); // Wide range
    });
  });

  // ==========================================================================
  // ZIGZAG PATTERN FACTOR (20 points)
  // ==========================================================================

  describe('ZigZag Pattern Factor', () => {
    it('should give max score (20) for Equal High (EH) pattern', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0, 'EH');

      const result = detector.detect(candles, context);

      expect(result.factors.zigzagPattern).toBe(20); // Flat pattern
    });

    it('should give max score (20) for Equal Low (EL) pattern', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0, 'EL');

      const result = detector.detect(candles, context);

      expect(result.factors.zigzagPattern).toBe(20); // Flat pattern
    });

    it('should give zero score for strong trend patterns (HH, HL, LL, LH)', () => {
      const candles = createTestCandles(30, 100, 0.5);

      ['HH', 'HL', 'LL', 'LH'].forEach((pattern) => {
        const context = createTestContext(candles, 100, 100.1, 1.0, pattern);
        const result = detector.detect(candles, context);

        expect(result.factors.zigzagPattern).toBe(0); // Strong trend
      });
    });

    it('should handle missing ZigZag data', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0); // No ZigZag

      const result = detector.detect(candles, context);

      expect(result.factors.zigzagPattern).toBe(0); // No data
    });
  });

  // ==========================================================================
  // EMA SLOPE FACTOR (15 points)
  // ==========================================================================

  describe('EMA Slope Factor', () => {
    it('should give max score (15) for flat slope (horizontal candles)', () => {
      // Create candles with minimal vertical movement
      const candles: Candle[] = [];
      for (let i = 0; i < 30; i++) {
        candles.push({
          timestamp: Date.now() + i * 60000,
          open: 100,
          high: 100.05,
          low: 99.95,
          close: 100 + (Math.random() - 0.5) * 0.1, // Very flat
          volume: 1000,
        });
      }

      const context = createTestContext(candles, 100, 100.1, 1.0);
      const result = detector.detect(candles, context);

      expect(result.factors.emaSlope).toBeGreaterThan(10); // Should be high score for flat
    });

    it('should give lower score for steep slope (trending candles)', () => {
      // Create candles with strong uptrend
      const candles: Candle[] = [];
      for (let i = 0; i < 30; i++) {
        const price = 100 + i * 0.5; // Strong uptrend
        candles.push({
          timestamp: Date.now() + i * 60000,
          open: price,
          high: price + 0.2,
          low: price - 0.1,
          close: price + 0.1,
          volume: 1000,
        });
      }

      const context = createTestContext(candles, 100, 100.1, 1.0);
      const result = detector.detect(candles, context);

      expect(result.factors.emaSlope).toBeLessThan(10); // Should be low score for trend
    });
  });

  // ==========================================================================
  // VOLUME DISTRIBUTION FACTOR (10 points)
  // ==========================================================================

  describe('Volume Distribution Factor', () => {
    it('should give max score (10) for even buy/sell volume distribution', () => {
      // Create candles with balanced bullish/bearish
      const candles: Candle[] = [];
      for (let i = 0; i < 30; i++) {
        const isBullish = i % 2 === 0; // Alternate bullish/bearish
        candles.push({
          timestamp: Date.now() + i * 60000,
          open: isBullish ? 100 : 100.1,
          high: 100.2,
          low: 99.8,
          close: isBullish ? 100.1 : 100,
          volume: 1000,
        });
      }

      const context = createTestContext(candles, 100, 100.1, 1.0);
      const result = detector.detect(candles, context);

      expect(result.factors.volumeDistribution).toBeGreaterThan(8); // Should be high for even
    });

    it('should give low score for one-sided volume distribution', () => {
      // Create candles with all bullish
      const candles: Candle[] = [];
      for (let i = 0; i < 30; i++) {
        candles.push({
          timestamp: Date.now() + i * 60000,
          open: 100,
          high: 100.2,
          low: 99.9,
          close: 100.1, // All bullish
          volume: 1000,
        });
      }

      const context = createTestContext(candles, 100, 100.1, 1.0);
      const result = detector.detect(candles, context);

      expect(result.factors.volumeDistribution).toBeLessThan(5); // Should be low for one-sided
    });
  });

  // ==========================================================================
  // CONFIDENCE SCORING & THRESHOLDS
  // ==========================================================================

  describe('Confidence Scoring', () => {
    it('should detect FLAT market with high confidence (80%+)', () => {
      const candles = createTestCandles(30, 100, 0.5); // Tight range
      const context = createTestContext(
        candles,
        100.0, // EMA20
        100.1, // EMA50 (0.1% distance)
        1.0, // Low ATR
        'EH' // Flat pattern
      );

      const result = detector.detect(candles, context);

      expect(result.confidence).toBeGreaterThanOrEqual(80);
      expect(result.isFlat).toBe(true);
    });

    it('should detect TREND market with low confidence (<80%)', () => {
      const candles = createTestCandles(30, 100, 3.0); // Wide range
      const context = createTestContext(
        candles,
        100.0, // EMA20
        102.0, // EMA50 (2.0% distance)
        5.0, // High ATR
        'HH' // Trend pattern
      );

      const result = detector.detect(candles, context);

      expect(result.confidence).toBeLessThan(80);
      expect(result.isFlat).toBe(false);
    });

    it('should respect custom flatThreshold', () => {
      const customConfig: FlatMarketConfig = {
        ...config,
        flatThreshold: 50, // Lower threshold
      };
      const customDetector = new FlatMarketDetector(customConfig, logger);

      const candles = createTestCandles(30, 100, 1.0);
      const context = createTestContext(candles, 100, 100.5, 2.0);

      const result = customDetector.detect(candles, context);

      // With lower threshold, might detect as flat even with moderate scores
      if (result.confidence >= 50) {
        expect(result.isFlat).toBe(true);
      } else {
        expect(result.isFlat).toBe(false);
      }
    });
  });

  // ==========================================================================
  // EXPLANATION & RESULT FORMAT
  // ==========================================================================

  describe('Result Format', () => {
    it('should return properly formatted result', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0, 'EH');

      const result = detector.detect(candles, context);

      expect(result).toHaveProperty('isFlat');
      expect(result).toHaveProperty('confidence');
      expect(result).toHaveProperty('factors');
      expect(result).toHaveProperty('explanation');

      expect(typeof result.isFlat).toBe('boolean');
      expect(typeof result.confidence).toBe('number');
      expect(typeof result.explanation).toBe('string');
    });

    it('should include all factors in result', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0);

      const result = detector.detect(candles, context);

      expect(result.factors).toHaveProperty('emaDistance');
      expect(result.factors).toHaveProperty('atrVolatility');
      expect(result.factors).toHaveProperty('priceRange');
      expect(result.factors).toHaveProperty('zigzagPattern');
      expect(result.factors).toHaveProperty('emaSlope');
      expect(result.factors).toHaveProperty('volumeDistribution');
    });

    it('should generate explanation string', () => {
      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0);

      const result = detector.detect(candles, context);

      expect(result.explanation).toContain('EMA Distance');
      expect(result.explanation).toContain('ATR Volatility');
      expect(result.explanation).toContain('Price Range');
      expect(result.explanation).toContain('ZigZag Pattern');
      expect(result.explanation).toContain('EMA Slope');
      expect(result.explanation).toContain('Volume');
    });
  });

  // ==========================================================================
  // CONFIG VALIDATION
  // ==========================================================================

  describe('Configuration', () => {
    it('should use config thresholds for EMA distance', () => {
      const strictConfig: FlatMarketConfig = {
        ...config,
        emaThreshold: 0.1, // Very strict
      };
      const strictDetector = new FlatMarketDetector(strictConfig, logger);

      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.2, 1.0); // 0.2% distance

      const result = strictDetector.detect(candles, context);

      // Should get lower EMA score with strict threshold
      expect(result.factors.emaDistance).toBeLessThan(20);
    });

    it('should use config thresholds for ATR volatility', () => {
      const strictConfig: FlatMarketConfig = {
        ...config,
        atrThreshold: 0.5, // Very strict
      };
      const strictDetector = new FlatMarketDetector(strictConfig, logger);

      const candles = createTestCandles(30, 100, 0.5);
      const context = createTestContext(candles, 100, 100.1, 1.0); // 1.0% ATR

      const result = strictDetector.detect(candles, context);

      // Should get lower ATR score with strict threshold
      expect(result.factors.atrVolatility).toBeLessThan(20);
    });
  });
});
