/**
 * Backtest Engine V2
 *
 * Uses REAL bot classes for accurate simulation:
 * - LevelBasedStrategy, TrendFollowingStrategy, CounterTrendStrategy
 * - RSIAnalyzer, EMAAnalyzer, ATRIndicator
 * - ZigZagIndicator, LiquidityDetector
 * - StrategyCoordinator
 *
 * LIMITATIONS:
 * - FastEntry NOT supported (requires intra-candle simulation)
 * - SmartBreakeven NOT supported (requires position monitoring)
 * - RetestEntry NOT supported (requires time-based waiting)
 * - Backtest simulates only CLOSED candles (no partial fills)
 */

import * as fs from 'fs';
import * as path from 'path';
import { LoggerService, LogLevel, StrategyMarketData, SignalDirection, Candle, StrategySignal } from '../types';
import { LevelBasedStrategy } from '../strategies/level-based.strategy';
import { CONFIDENCE_THRESHOLDS, MULTIPLIERS, PERCENTAGE_THRESHOLDS, BACKTEST_CONSTANTS, ARRAY_SIZING, CALIBRATION_CONSTANTS, PERCENT_MULTIPLIER, INDICATOR_DEFAULTS, INTEGER_MULTIPLIERS, THRESHOLD_VALUES, DECIMAL_PLACES } from '../constants';
import { TrendFollowingStrategy } from '../strategies/trend-following.strategy';
import { CounterTrendStrategy } from '../strategies/counter-trend.strategy';
import { FractalBreakoutRetestStrategy } from '../strategies/fractal-breakout-retest.strategy';
import { WhaleHunterStrategy } from '../strategies/whale-hunter.strategy';
import { RSIIndicator } from '../indicators/rsi.indicator';
import { EMAIndicator } from '../indicators/ema.indicator';
import { ATRIndicator } from '../indicators/atr.indicator';
import { ZigZagIndicator } from '../indicators/zigzag.indicator';
import { LiquidityDetector } from '../analyzers/liquidity.detector';
import { DivergenceDetector } from '../analyzers/divergence.detector';
import { StochasticIndicator } from '../indicators/stochastic.indicator';
import { BollingerBandsIndicator } from '../indicators/bollinger.indicator';
import { EntryConfirmationManager, PendingEntry } from '../services/entry-confirmation.service';
import { ContextAnalyzer } from '../analyzers/context.analyzer';
import { EntryScanner } from '../analyzers/entry.scanner';
import { CandleProvider } from '../providers/candle.provider';
import { TimeframeRole, TradingContext, EntrySignal } from '../types';
import { WeightMatrixCalculatorService } from '../services/weight-matrix-calculator.service';
import { WhaleDetectorService } from '../services/whale-detector.service';
import { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';
import { WallTrackerService } from '../services/wall-tracker.service';
import { SqliteDataProvider } from './data-providers/sqlite.provider';
import { EntryRefinementConfig } from '../types/fractal-strategy.types';

// Scalping Strategies (Phase 1-5)
import { ScalpingMicroWallStrategy } from '../strategies/scalping-micro-wall.strategy';
import { ScalpingTickDeltaStrategy } from '../strategies/scalping-tick-delta.strategy';
import { ScalpingLadderTpStrategy } from '../strategies/scalping-ladder-tp.strategy';
import { ScalpingLimitOrderStrategy } from '../strategies/scalping-limit-order.strategy';
import { ScalpingOrderFlowStrategy } from '../strategies/scalping-order-flow.strategy';

// Scalping Strategy Services
import { MicroWallDetectorService } from '../services/micro-wall-detector.service';
import { TickDeltaAnalyzerService } from '../services/tick-delta-analyzer.service';
import { LadderTpManagerService } from '../services/ladder-tp-manager.service';
import { LimitOrderExecutorService } from '../services/limit-order-executor.service';
import { OrderFlowAnalyzerService } from '../services/order-flow-analyzer.service';

// PHASE 4: Risk services consolidated into RiskManager (ARCHIVED to src/archive/phase4-week1/)

// PHASE 6: Multi-Timeframe Services
import { TimeframeValidator } from '../utils/timeframe-validator';
import { VWAPIndicator } from '../indicators/vwap.indicator';
import { TFAlignmentService } from '../services/tf-alignment.service';

// ============================================================================
// MOCK CANDLE PROVIDER FOR BACKTEST
// ============================================================================

class MockCandleProvider {
  private candles1m: Candle[] = [];
  private candles5m: Candle[] = [];
  private candles15m: Candle[] = [];
  private currentTimestamp: number = 0;
  private logger: LoggerService;

  constructor(logger: LoggerService, symbol: string) {
    this.logger = logger;
  }

  setHistoricalData(candles1m: Candle[], candles5m: Candle[], candles15m: Candle[], currentTimestamp: number) {
    this.candles1m = candles1m;
    this.candles5m = candles5m;
    this.candles15m = candles15m;
    this.currentTimestamp = currentTimestamp;
  }

  async getCandles(role: TimeframeRole, limit?: number): Promise<Candle[]> {
    let candles: Candle[];

    switch (role) {
    case TimeframeRole.ENTRY:
      candles = this.candles1m.filter(c => c.timestamp <= this.currentTimestamp);
      break;
    case TimeframeRole.PRIMARY:
      candles = this.candles5m.filter(c => c.timestamp <= this.currentTimestamp);
      break;
    case TimeframeRole.TREND1:
      candles = this.candles15m.filter(c => c.timestamp <= this.currentTimestamp);
      break;
    default:
      candles = [];
    }

    if (limit) {
      return candles.slice(-limit);
    }
    return candles;
  }

  async getCurrentPrice(): Promise<number> {
    const recent = this.candles1m.filter(c => c.timestamp <= this.currentTimestamp);
    return recent.length > 0 ? recent[recent.length - 1].close : 0;
  }
}

// ============================================================================
// TYPES
// ============================================================================

export interface BacktestCandle {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

export interface BacktestConfig {
  symbol: string;
  initialBalance: number;
  positionSizeUsdt: number;
  leverage: number;
  takerFee: number;
  makerFee: number;

  // Real bot config
  config: any; // Full config.json (dev-only, flexible for backtest)
}

export interface BacktestTrade {
  entryTime: number;
  entryPrice: number;
  direction: SignalDirection;
  size: number;
  stopLoss: number;
  takeProfits: Array<{ level: number; price: number; closePercent: number }>;
  exitTime?: number;
  exitPrice?: number;
  exitReason?: string;
  pnl?: number;
  pnlPercent?: number;
  fees?: number;
  holding?: number;
  confidence?: number;
  strategyName?: string;
}

export interface BacktestResult {
  config: BacktestConfig;
  totalTrades: number;
  winningTrades: number;
  losingTrades: number;
  winRate: number;
  totalPnl: number;
  totalFees: number;
  netPnl: number;
  netPnlPercent: number;
  winLossRatio: number;
  profitFactor: number;
  avgWin: number;
  avgLoss: number;
  maxDrawdown: number;
  maxDrawdownPercent: number;
  sharpeRatio: number;
  avgHoldingTime: number;
  trades: BacktestTrade[];
  equityCurve: Array<{ time: number; balance: number }>;
}

// ============================================================================
// BACKTEST ENGINE V2
// ============================================================================

export class BacktestEngineV2 {
  private config: BacktestConfig;
  private logger: LoggerService;

  // Real bot components (multiple strategies like real bot)
  private strategies: Array<
    | LevelBasedStrategy
    | TrendFollowingStrategy
    | CounterTrendStrategy
    | FractalBreakoutRetestStrategy
    | WhaleHunterStrategy
    | ScalpingMicroWallStrategy
    | ScalpingTickDeltaStrategy
    | ScalpingLadderTpStrategy
    | ScalpingLimitOrderStrategy
    | ScalpingOrderFlowStrategy
  > = [];
  private rsiIndicator: RSIIndicator;
  private emaIndicator: EMAIndicator;
  private atrIndicator: ATRIndicator;
  private zigzagIndicator: ZigZagIndicator;
  private liquidityDetector: LiquidityDetector;
  private divergenceDetector: DivergenceDetector;
  private stochasticIndicator: StochasticIndicator;
  private bollingerIndicator: BollingerBandsIndicator;
  private entryConfirmation: EntryConfirmationManager;
  private wallTracker?: WallTrackerService; // PHASE 4: Wall tracking

  // Context and Entry Scanner (like live bot)
  private candleProvider: MockCandleProvider;
  private contextAnalyzer: ContextAnalyzer;
  private entryScanner: EntryScanner;
  private currentContext: TradingContext | null = null;

  // State
  private currentPosition: BacktestTrade | null = null;
  private currentIndex: number = 0;
  private trades: BacktestTrade[] = [];
  private balance: number;
  private equityCurve: Array<{ time: number; balance: number }> = [];
  private peakBalance: number;
  private maxDrawdown: number = 0;
  private pendingSignals: Map<string, { signal: StrategySignal; marketData: StrategyMarketData; atr: number }> = new Map();
  private weightMatrix: WeightMatrixCalculatorService | null = null;
  private dataProvider: SqliteDataProvider | null = null;

  // PHASE 4: Risk services consolidated into RiskManager (ARCHIVED to src/archive/phase4-week1/)
  private dailyLimitsService: any | null = null; // Consolidated into RiskManager
  private riskBasedSizingService: any | null = null; // Consolidated into RiskManager
  private lossStreakService: any | null = null; // Consolidated into RiskManager
  private maxConcurrentRiskService: any | null = null; // Consolidated into RiskManager

  // PHASE 6: Multi-Timeframe Services
  private vwapIndicator: VWAPIndicator | null = null;
  private tfAlignmentService: TFAlignmentService | null = null;

  constructor(config: BacktestConfig) {
    this.config = config;
    this.logger = new LoggerService(LogLevel.ERROR, './logs', false);
    this.balance = config.initialBalance;
    this.peakBalance = config.initialBalance;

    // Initialize Weight Matrix if enabled
    if (config.config.weightMatrix?.enabled) {
      this.weightMatrix = new WeightMatrixCalculatorService(config.config.weightMatrix, this.logger);
      this.logger.info('âœ… Weight Matrix enabled for backtest', {
        minConfidenceToEnter: config.config.weightMatrix.minConfidenceToEnter,
      });
    }

    // Initialize strategies (only if enabled) with Weight Matrix
    // PHASE 4: Support both old config format (strategies.*.enabled) and new format (entry.enabledStrategies)
    const enabledStrategies = (config.config as any).entry?.enabledStrategies || [];
    const hasLegacyStrategiesConfig = !!(config.config as any).strategies;

    console.log('\nðŸ” DEBUG BacktestEngineV2 constructor:');
    if (hasLegacyStrategiesConfig) {
      console.log(`  TrendFollowing enabled: ${(config.config as any).strategies.trendFollowing?.enabled}`);
      console.log(`  LevelBased enabled: ${(config.config as any).strategies.levelBased?.enabled}`);
      console.log(`  CounterTrend enabled: ${(config.config as any).strategies.counterTrend?.enabled}`);
    } else {
      console.log(`  PHASE 4 config format detected. Enabled strategies: [${enabledStrategies.join(', ')}]`);
    }
    console.log(`  FractalBreakoutRetest enabled: ${(config.config as any).strategies?.fractalBreakoutRetest?.enabled}`);
    console.log(`  EdgeReversals enabled: ${(config.config as any).edgeReversals?.enabled}\n`);

    // Check if trendFollowing should be enabled (from legacy or new config)
    const trendFollowingEnabled = hasLegacyStrategiesConfig
      ? (config.config as any).strategies.trendFollowing?.enabled === true
      : enabledStrategies.includes('trendFollowing');
    if (trendFollowingEnabled) {
      this.strategies.push(
        new TrendFollowingStrategy((config.config as any).strategies?.trendFollowing || {}, this.logger, this.weightMatrix || undefined),
      );
      console.log('  âœ… TrendFollowing strategy registered');
    }

    // Check if levelBased should be enabled (from legacy or new config)
    const levelBasedEnabled = hasLegacyStrategiesConfig
      ? (config.config as any).strategies.levelBased?.enabled === true
      : enabledStrategies.includes('levelBased');
    if (levelBasedEnabled) {
      this.strategies.push(
        new LevelBasedStrategy((config.config as any).strategies?.levelBased || {}, this.logger, this.weightMatrix || undefined),
      );
      console.log('  âœ… LevelBased strategy registered');
    }

    // Check if counterTrend should be enabled (from legacy or new config)
    const counterTrendEnabled = hasLegacyStrategiesConfig
      ? (config.config as any).strategies.counterTrend?.enabled === true
      : enabledStrategies.includes('counterTrend');
    if (counterTrendEnabled) {
      this.strategies.push(
        new CounterTrendStrategy((config.config as any).strategies?.counterTrend || {}, this.logger, this.weightMatrix || undefined),
      );
      console.log('  âœ… CounterTrend strategy registered');
    }

    // PHASE 4: Support FractalBreakoutRetest from legacy config only (not in new format)
    const fractalBreakoutEnabled = (config.config as any).strategies?.fractalBreakoutRetest?.enabled === true;
    if (fractalBreakoutEnabled) {
      // Initialize required dependencies for FractalBreakoutRetest
      const dailyLevelConfig = (config.config as any).strategies.fractalBreakoutRetest.dailyLevelConfig;
      const DailyLevelTracker = require('../analyzers/daily-level.tracker').DailyLevelTracker;
      const BreakoutDetector = require('../analyzers/breakout.detector').BreakoutDetector;
      const RetestPhaseAnalyzer = require('../analyzers/retest-phase.analyzer').RetestPhaseAnalyzer;
      const MarketStructureAnalyzer = require('../analyzers/market-structure.analyzer').MarketStructureAnalyzer;
      const EntryRefinementAnalyzer = require('../analyzers/entry-refinement.analyzer').EntryRefinementAnalyzer;
      const FractalSmcWeightingService = require('../services/fractal-smc-weighting.service').FractalSmcWeightingService;
      const MarketHealthMonitor = require('../services/market-health.monitor').MarketHealthMonitor;
      const VolumeAnalyzer = require('../analyzers/volume.analyzer').VolumeAnalyzer;
      const LiquidityDetector = require('../analyzers/liquidity.detector').LiquidityDetector;

      // Use DailyLevelTracker for standard Daily High/Low detection
      const dailyLevelTracker = new DailyLevelTracker(dailyLevelConfig, this.logger);
      const volumeAnalyzer = new VolumeAnalyzer();
      const breakoutDetector = new BreakoutDetector(dailyLevelConfig, this.logger);
      const retestAnalyzer = new RetestPhaseAnalyzer(dailyLevelConfig, this.logger);
      const marketStructureConfig = (config.config.analysisConfig as any)?.marketStructure || {
        chochAlignedBoost: 1.3,
        chochAgainstPenalty: 0.5,
        bosAlignedBoost: 1.1,
        noModification: 1.0,
      };
      const marketStructure = new MarketStructureAnalyzer(marketStructureConfig, this.logger);
      const entryRefinement = new EntryRefinementAnalyzer(
        config.config.strategies.fractalBreakoutRetest.entryRefinementConfig || {
          minVolumeConfirmationRatio: 0.9,
          pinBarBodyRatioThreshold: 0.3,
          wickRatioThreshold: 0.5,
          structureAlignmentMargin: 0.95,
          volatilityCheckRatio: 0.5,
          strongCandleBodyRatio: 0.6,
          minConditionsToConfirm: 2,
          localHighLowBars: 10
        },
        marketStructure,
        volumeAnalyzer,
        this.logger
      );
      const liquidityDetector = new LiquidityDetector((config.config.analysisConfig as any).liquidityDetector!, this.logger);

      // Create weighted signal config from fractal strategy config
      const weightedSignalConfig = {
        threshold: config.config.strategies.fractalBreakoutRetest.minCombinedScore || 70,
        highConfidenceThreshold: config.config.strategies.fractalBreakoutRetest.highConfidenceThreshold || 90,
        maxFractalScore: 125,
        maxSmcScore: 110
      };

      const weightingService = new FractalSmcWeightingService(weightedSignalConfig, this.logger);
      const healthMonitor = new MarketHealthMonitor(config.config.marketHealth || {}, this.logger);

      this.strategies.push(
        new FractalBreakoutRetestStrategy(
          config.config.strategies.fractalBreakoutRetest,
          dailyLevelTracker,
          breakoutDetector,
          retestAnalyzer,
          entryRefinement,
          volumeAnalyzer,
          weightingService,
          healthMonitor,
          this.logger
        ),
      );
      console.log('  âœ… FractalBreakoutRetest strategy registered');
    }

    // Initialize EdgeReversals Strategy (Session 79 edge discovery)
    if (config.config.edgeReversals?.enabled === true) {
      const EdgeReversalsStrategy = require('../strategies/edge-reversals.strategy').EdgeReversalsStrategy;
      this.strategies.push(
        new EdgeReversalsStrategy(config.config.edgeReversals, this.logger),
      );
      console.log('  âœ… EdgeReversals strategy registered');
    }

    // Initialize WhaleHunter Strategy (if enabled and orderbook available)
    if (config.config.whaleHunter?.enabled) {
      const whaleDetector = new WhaleDetectorService(config.config.whaleHunter.detector, this.logger);
      const orderbookConfig = {
        enabled: true,
        depth: INTEGER_MULTIPLIERS.FIFTY,
        wallThreshold: THRESHOLD_VALUES.TEN_PERCENT,
        imbalanceThreshold: MULTIPLIERS.ONE_AND_HALF,
        updateIntervalMs: INTEGER_MULTIPLIERS.FIVE_THOUSAND,
      };
      const orderbookAnalyzer = new OrderBookAnalyzer(orderbookConfig, this.logger);

      // Initialize WallTracker if enabled (PHASE 4)
      if (config.config.wallTracking?.enabled) {
        this.wallTracker = new WallTrackerService(config.config.wallTracking, this.logger);
        this.logger.info('ðŸ§± WallTracker enabled for backtest');
      }

      this.strategies.push(
        new WhaleHunterStrategy(
          {
            ...config.config.whaleHunter,
            sessionBasedSL: config.config.sessionBasedSL,
          },
          whaleDetector,
          orderbookAnalyzer,
          this.logger,
          this.wallTracker, // Pass WallTracker (optional)
        ),
      );

      this.logger.info('ðŸ‹ WhaleHunter enabled for backtest');
    }

    // Initialize Scalping Strategies (Phase 1-5)
    // Note: Scalping strategies require orderbook data
    if (config.config.scalpingMicroWall?.enabled) {
      const microWallDetector = new MicroWallDetectorService(
        config.config.scalpingMicroWall.detector,
        this.logger,
      );
      this.strategies.push(
        new ScalpingMicroWallStrategy(
          config.config.scalpingMicroWall,
          microWallDetector,
          this.logger,
        ),
      );
      console.log('  âœ… ScalpingMicroWall strategy registered');
    }

    if (config.config.scalpingTickDelta?.enabled) {
      // TickDelta uses internal analyzer - no external service needed
      this.strategies.push(
        new ScalpingTickDeltaStrategy(
          config.config.scalpingTickDelta,
          this.logger,
        ),
      );
      console.log('  âœ… ScalpingTickDelta strategy registered');
    }

    if (config.config.scalpingOrderFlow?.enabled) {
      // OrderFlow uses internal analyzer - no external service needed
      this.strategies.push(
        new ScalpingOrderFlowStrategy(
          config.config.scalpingOrderFlow,
          this.logger,
        ),
      );
      console.log('  âœ… ScalpingOrderFlow strategy registered');
    }

    // NOTE: LadderTp and LimitOrder are wrappers that require BybitService
    // They cannot be tested in backtest without mock BybitService
    if (config.config.scalpingLadderTp?.enabled) {
      console.log('  âš ï¸  ScalpingLadderTp skipped (requires BybitService for backtest)');
    }
    if (config.config.scalpingLimitOrder?.enabled) {
      console.log('  âš ï¸  ScalpingLimitOrder skipped (requires BybitService for backtest)');
    }

    // DEBUG: Log registered strategies
    console.log(`\nðŸŽ¯ Registered strategies: ${this.strategies.length}`);
    this.strategies.forEach((s, i) => {
      const sAny = s as unknown as Record<string, unknown>;
      const strategyName = sAny.name || sAny.constructor?.name || 'Unknown';
      const priority = sAny.priority || 'N/A';
      console.log(`  ${i + 1}. ${strategyName} (priority: ${priority})`);
    });
    console.log('');

    this.rsiIndicator = new RSIIndicator(INDICATOR_DEFAULTS.RSI_PERIOD);
    this.emaIndicator = new EMAIndicator(INDICATOR_DEFAULTS.EMA_FAST_PERIOD); // Fast EMA
    this.atrIndicator = new ATRIndicator(INDICATOR_DEFAULTS.ATR_PERIOD);
    // PHASE 4: Use ZigZag depth from indicators config (new format) or strategies (legacy format)
    const zigzagDepth = (config.config as any).indicators?.zigzagDepth ?? (config.config as any).strategies?.levelBased?.zigzagDepth ?? 12;
    this.zigzagIndicator = new ZigZagIndicator(zigzagDepth);

    // PHASE 4: Use defaults if analysisConfig not present (legacy sections)
    const liquidityConfig = (config.config as any).analysisConfig?.liquidityDetector || {
      minTouches: 2,
      priceTolerancePercent: 0.3,
      strengthThreshold: 0.6,
      lookbackCandles: 100,
    };
    this.liquidityDetector = new LiquidityDetector(liquidityConfig, this.logger);

    // PHASE 4: Use defaults if entryConfig not present
    const divergenceConfig = (config.config as any).entryConfig?.divergenceDetector || {
      rsiOverboughtLevel: 70,
      rsiOversoldLevel: 30,
      minDivergenceStrength: 0.3,
    };
    this.divergenceDetector = new DivergenceDetector(this.logger, divergenceConfig);
    this.stochasticIndicator = new StochasticIndicator({
      kPeriod: INDICATOR_DEFAULTS.STOCHASTIC_K_PERIOD,
      dPeriod: INDICATOR_DEFAULTS.STOCHASTIC_D_SMOOTHING,
      smooth: INDICATOR_DEFAULTS.STOCHASTIC_K_SMOOTHING,
    });
    this.bollingerIndicator = new BollingerBandsIndicator(INDICATOR_DEFAULTS.BOLLINGER_PERIOD, INDICATOR_DEFAULTS.BOLLINGER_STD_DEV);
    this.entryConfirmation = new EntryConfirmationManager(config.config.entryConfirmation, this.logger);

    // Initialize Context and Entry Scanner (like live bot)
    this.candleProvider = new MockCandleProvider(this.logger, config.symbol);

    // Validate contextConfig exists
    if (!config.config.contextConfig) {
      throw new Error('Missing contextConfig in config.json - required for backtest');
    }
    this.contextAnalyzer = new ContextAnalyzer(
      config.config.contextConfig,
      this.candleProvider as any,
      this.logger,
    );

    // Validate entryConfig exists
    if (!config.config.entryConfig) {
      throw new Error('Missing entryConfig in config.json - required for backtest');
    }
    this.entryScanner = new EntryScanner(
      {
        ...config.config.entryConfig,
        takeProfits: (config.config.strategies.levelBased?.takeProfits || []).map((tp: any) => ({
          level: tp.level,
          percent: tp.percent,
          sizePercent: tp.sizePercent,
        })),
      },
      this.candleProvider as any,
      this.logger,
    );

    // ======================================================================
    // PHASE 4: Risk services consolidated into RiskManager (ARCHIVED)
    // Legacy Phase 5 services moved to src/archive/phase4-week1/
    // ======================================================================
    this.logger.info('âœ… PHASE 4 RiskManager consolidates legacy Phase 5 risk services');

    // ======================================================================
    // PHASE 6: Initialize Multi-Timeframe Services
    // ======================================================================
    this.vwapIndicator = new VWAPIndicator();
    this.tfAlignmentService = new TFAlignmentService(
      config.config.tfAlignment || {
        enabled: true,
        rsiWeight: 30,
        emaWeight: 30,
        trendWeight: 40,
        minScore: 60,
      },
      this.logger,
    );
    this.logger.info('âœ… PHASE6 Multi-TF services initialized (VWAP + TF Alignment)');
  }

  /**
   * Run backtest on historical data
   */
  async run(
    candles1m: BacktestCandle[],
    candles5m: BacktestCandle[],
    candles15m: BacktestCandle[],
    dataProvider?: SqliteDataProvider,
  ): Promise<BacktestResult> {
    // Save dataProvider as instance field for orderbook loading
    this.dataProvider = dataProvider || null;

    console.log('ðŸš€ Starting backtest V2 (Real Bot Emulation)...');
    console.log(`ðŸ“Š Data: ${candles1m.length} 1m candles`);
    console.log(`ðŸ’° Initial balance: ${this.config.initialBalance} USDT`);
    if (this.dataProvider) {
      console.log('ðŸ“š Orderbook data: ENABLED (SQLite)');
    }

    let progress = 0;
    const progressInterval = Math.floor(candles1m.length / BACKTEST_CONSTANTS.PROGRESS_INTERVALS);

    // Process each 1m candle
    for (let i = 0; i < candles1m.length; i++) {
      const currentCandle = candles1m[i];

      // Show progress
      if (i % progressInterval === 0) {
        progress = Math.floor((i / candles1m.length) * PERCENT_MULTIPLIER);
        process.stdout.write(`\râ³ Progress: ${progress}%`);
      }

      // Get historical data up to current point
      const historicalCandles1m = this.getHistoricalCandles(candles1m, currentCandle.timestamp, BACKTEST_CONSTANTS.CANDLE_BATCH_SIZE);
      const historicalCandles5m = this.getHistoricalCandles(candles5m, currentCandle.timestamp, BACKTEST_CONSTANTS.CANDLE_BATCH_SIZE);
      const historicalCandles15m = this.getHistoricalCandles(candles15m, currentCandle.timestamp, BACKTEST_CONSTANTS.CANDLE_BATCH_SIZE);

      // Update CandleProvider (for ContextAnalyzer and EntryScanner)
      this.candleProvider.setHistoricalData(
        historicalCandles1m,
        historicalCandles5m,
        historicalCandles15m,
        currentCandle.timestamp,
      );

      // Update Context every candle (like live bot)
      if (historicalCandles5m.length >= CONFIDENCE_THRESHOLDS.MODERATE) {
        this.currentContext = await this.contextAnalyzer.analyze();
      }

      // Debug: Log position status every 500 candles
      if (i % BACKTEST_CONSTANTS.DEBUG_LOG_INTERVAL === 0) {
        console.log(`\n[STATUS] Candle ${i} @ ${new Date(currentCandle.timestamp).toISOString()}`);
        console.log(`  Position: ${this.currentPosition ? `OPEN (${this.currentPosition.direction} @ ${this.currentPosition.entryPrice.toFixed(DECIMAL_PLACES.PRICE)})` : 'CLOSED'}`);
        console.log(`  Context valid: ${this.currentContext?.isValidContext ?? 'not initialized'}`);
        console.log(`  Can check entry: ${!this.currentPosition && historicalCandles5m.length >= INTEGER_MULTIPLIERS.ONE_HUNDRED && historicalCandles15m.length >= CONFIDENCE_THRESHOLDS.MODERATE}`);
      }

      // Check pending confirmations (every candle)
      if (!this.currentPosition) {
        this.checkPendingConfirmations(currentCandle);
      }

      // Check exit conditions if in position
      if (this.currentPosition) {
        this.checkExit(currentCandle, historicalCandles5m, i);
      }

      // Check entry conditions if not in position
      if (!this.currentPosition && historicalCandles5m.length >= INTEGER_MULTIPLIERS.ONE_HUNDRED && historicalCandles15m.length >= CONFIDENCE_THRESHOLDS.MODERATE) {
        await this.checkEntry(currentCandle, historicalCandles5m, historicalCandles15m, i, candles1m);
      }

      // Update equity curve every 1000 candles
      if (i % INTEGER_MULTIPLIERS.ONE_THOUSAND === 0) {
        this.equityCurve.push({
          time: currentCandle.timestamp,
          balance: this.balance,
        });
      }
    }

    console.log('\râœ… Progress: 100%    ');

    // Close any open position at end
    if (this.currentPosition) {
      const lastCandle = candles1m[candles1m.length - 1];
      this.closePosition(lastCandle, lastCandle.close, 'END_OF_BACKTEST');
    }

    console.log(`âœ… Backtest complete! Total trades: ${this.trades.length}`);

    return this.calculateResults();
  }

  /**
   * Get historical candles up to timestamp
   */
  private getHistoricalCandles(
    candles: BacktestCandle[],
    timestamp: number,
    maxCount: number,
  ): Candle[] {
    const filtered = candles.filter((c) => c.timestamp <= timestamp);
    const sliced = filtered.slice(-maxCount);
    return sliced.map((c) => ({
      timestamp: c.timestamp,
      open: c.open,
      high: c.high,
      low: c.low,
      close: c.close,
      volume: c.volume,
    }));
  }

  /**
   * Check entry conditions using REAL strategy
   */
  private async checkEntry(
    currentCandle: BacktestCandle,
    historicalCandles5m: Candle[],
    historicalCandles15m: Candle[],
    candleIndex: number,
    candles1m: BacktestCandle[],
  ): Promise<void> {
    try {
      const currentPrice = currentCandle.close;

      // Load ticks for TickDelta if dataProvider available (get ticks from previous candle to current)
      let currentTicks: any[] = [];
      if (this.dataProvider && candleIndex > 0) {
        const prevCandleTime = candles1m[candleIndex - 1].timestamp;
        currentTicks = await this.dataProvider.loadTicks(
          this.config.symbol,
          prevCandleTime,
          currentCandle.timestamp,
        );
      }

      // Calculate RSI (PRIMARY 5m + TREND1 15m)
      const rsi = this.rsiIndicator.calculate(historicalCandles5m);
      const rsiTrend1 = this.rsiIndicator.calculate(historicalCandles15m);

      // Calculate EMA (PRIMARY 5m + TREND1 15m)
      const emaFast = this.emaIndicator.calculate(historicalCandles5m);
      const emaSlowIndicator = new EMAIndicator(INDICATOR_DEFAULTS.EMA_SLOW_PERIOD);
      const emaSlow = emaSlowIndicator.calculate(historicalCandles5m);
      const emaFastTrend1Indicator = new EMAIndicator(INDICATOR_DEFAULTS.EMA_FAST_PERIOD);
      const emaFastTrend1 = emaFastTrend1Indicator.calculate(historicalCandles15m);
      const emaSlowTrend1Indicator = new EMAIndicator(INDICATOR_DEFAULTS.EMA_SLOW_PERIOD);
      const emaSlowTrend1 = emaSlowTrend1Indicator.calculate(historicalCandles15m);

      // Calculate ATR
      const atr = this.atrIndicator.calculate(historicalCandles5m);

      // Check for undefined indicators (debug)
      if (candleIndex % BACKTEST_CONSTANTS.LARGE_DATA_THRESHOLD === 0) {
        const undefinedIndicators = [];
        if (rsi === undefined || isNaN(rsi)) {
          undefinedIndicators.push('RSI');
        }
        if (rsiTrend1 === undefined || isNaN(rsiTrend1)) {
          undefinedIndicators.push('RSI15m');
        }
        if (emaFast === undefined || isNaN(emaFast)) {
          undefinedIndicators.push('EMA_Fast');
        }
        if (emaSlow === undefined || isNaN(emaSlow)) {
          undefinedIndicators.push('EMA_Slow');
        }
        if (atr === undefined || isNaN(atr)) {
          undefinedIndicators.push('ATR');
        }

        if (undefinedIndicators.length > 0) {
          console.warn(`[WARNING] Candle ${candleIndex}: Undefined indicators: ${undefinedIndicators.join(', ')}`);
          console.warn(`  5m candles available: ${historicalCandles5m.length}, 15m: ${historicalCandles15m.length}`);
        }
      }

      // Find swing points
      const swingHighs = this.zigzagIndicator.findSwingHighs(historicalCandles5m);
      const swingLows = this.zigzagIndicator.findSwingLows(historicalCandles5m);
      const swingPoints = [...swingHighs, ...swingLows].sort((a, b) => a.timestamp - b.timestamp);

      // Detect liquidity (simplified - not critical for strategy)
      const liquidityAnalysis = undefined;

      // Detect divergence (simplified - not critical for strategy)
      const divergence = undefined;

      // Calculate Stochastic
      const stochasticRaw = this.stochasticIndicator.calculate(historicalCandles5m);
      const stochastic = {
        k: stochasticRaw.k,
        d: stochasticRaw.d,
        isOversold: stochasticRaw.k < INTEGER_MULTIPLIERS.TWENTY,
        isOverbought: stochasticRaw.k > INTEGER_MULTIPLIERS.EIGHTY,
      };

      // Calculate Bollinger Bands
      const bollingerRaw = this.bollingerIndicator.calculate(historicalCandles5m);
      const bollingerBands = {
        ...bollingerRaw,
        isSqueeze: bollingerRaw.width < INTEGER_MULTIPLIERS.TWO, // Simple squeeze detection
      };

      // Determine trend
      const trend = emaFast > emaSlow ? 'BULLISH' : emaFast < emaSlow ? 'BEARISH' : 'NEUTRAL';

      // Debug: Log market data every DEBUG_LOG_INTERVAL candles
      if (candleIndex % BACKTEST_CONSTANTS.DEBUG_LOG_INTERVAL === 0) {
        console.log(`\n[MARKET DATA] Candle ${candleIndex} @ ${new Date(currentCandle.timestamp).toISOString()}`);
        console.log(`  Price: ${currentPrice.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS)}`);
        console.log(`  RSI: ${rsi?.toFixed(BACKTEST_CONSTANTS.DEBUG_PERCENT_DECIMALS) ?? 'undefined'} / RSI15m: ${rsiTrend1?.toFixed(BACKTEST_CONSTANTS.DEBUG_PERCENT_DECIMALS) ?? 'undefined'}`);
        console.log(`  EMA: fast=${emaFast?.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS) ?? 'undefined'}, slow=${emaSlow?.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS) ?? 'undefined'}`);
        console.log(`  EMA15m: fast=${emaFastTrend1?.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS) ?? 'undefined'}, slow=${emaSlowTrend1?.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS) ?? 'undefined'}`);
        console.log(`  ATR: ${atr?.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS) ?? 'undefined'} (${atr ? ((atr / currentPrice) * PERCENT_MULTIPLIER).toFixed(BACKTEST_CONSTANTS.DEBUG_PERCENT_DECIMALS) : 'undefined'}%)`);
        console.log(`  Swings: ${swingPoints.length} (highs=${swingHighs.length}, lows=${swingLows.length})`);
        console.log(`  Swing details: highs=[${swingHighs.slice(0, BACKTEST_CONSTANTS.DEBUG_SWING_DETAILS_COUNT).map(s => s.price.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS)).join(', ')}...], lows=[${swingLows.slice(0, BACKTEST_CONSTANTS.DEBUG_SWING_DETAILS_COUNT).map(s => s.price.toFixed(BACKTEST_CONSTANTS.DEBUG_PRICE_DECIMALS)).join(', ')}...]`);
        console.log(`  Candles passed to strategies: ${historicalCandles5m.length}`);
        console.log(`  Trend: ${trend}`);
        console.log(`  Stochastic: k=${stochastic.k?.toFixed(BACKTEST_CONSTANTS.DEBUG_PERCENT_DECIMALS) ?? 'undefined'}, oversold=${stochastic.isOversold}, overbought=${stochastic.isOverbought}`);
        console.log(`  Context: ${this.currentContext ? `valid=${this.currentContext.isValidContext}, blockedBy=[${this.currentContext.blockedBy?.join(', ') ?? 'none'}]` : 'not initialized'}`);
      }

      // PHASE 6: Calculate VWAP
      const vwapValue = this.vwapIndicator ? this.vwapIndicator.calculate(historicalCandles5m) : MULTIPLIERS.NEUTRAL;
      const vwapData = vwapValue > MULTIPLIERS.NEUTRAL ? {
        value: vwapValue,
        distance: Math.abs(currentPrice - vwapValue),
        distancePercent: ((currentPrice - vwapValue) / vwapValue) * PERCENT_MULTIPLIER,
      } : undefined;

      // PHASE 6: Calculate TF Alignment (for both LONG and SHORT directions)
      // Only calculate if we have all required EMA values (trend1 15m data)
      let tfAlignmentData: any = undefined;
      if (this.tfAlignmentService && emaFastTrend1 !== undefined && emaSlowTrend1 !== undefined) {
        try {
          const emasData = {
            entry: { ema20: emaFast },
            primary: { ema20: emaFast, ema50: emaSlow },
            trend1: { ema20: emaFastTrend1, ema50: emaSlowTrend1 },
          };
          const longResult = this.tfAlignmentService.calculateAlignment('LONG', currentPrice, emasData);
          const shortResult = this.tfAlignmentService.calculateAlignment('SHORT', currentPrice, emasData);
          tfAlignmentData = { long: longResult, short: shortResult };
        } catch (err) {
          // Silently ignore TF Alignment errors - it's not critical for entry signals
          tfAlignmentData = undefined;
        }
      }

      // Build StrategyMarketData (same as real bot)
      const marketData: StrategyMarketData = {
        timestamp: currentCandle.timestamp,
        currentPrice,
        candles: historicalCandles5m,
        swingPoints,
        rsi,
        rsiTrend1,
        ema: { fast: emaFast, slow: emaSlow },
        emaTrend1: { fast: emaFastTrend1, slow: emaSlowTrend1 },
        atr,
        trend,
        liquidity: liquidityAnalysis,
        divergence,
        orderbook: this.dataProvider
          ? (await this.dataProvider.loadOrderbookForCandle(this.config.symbol, currentCandle.timestamp)) || undefined
          : undefined,
        context: {
          trend,
          momentum: rsi > INTEGER_MULTIPLIERS.FIFTY ? 'BULLISH' : 'BEARISH',
          volatility: atr > THRESHOLD_VALUES.TWO_PERCENT ? 'HIGH' : atr > THRESHOLD_VALUES.ONE_PERCENT ? 'MEDIUM' : 'LOW',
          timeframe: '5m',
        } as any,
        stochastic,
        bollingerBands,
        breakoutPrediction: undefined,
        // PHASE 6: Multi-Timeframe data
        tfAlignment: tfAlignmentData,
      };

      // Update WallTracker with orderbook data (if enabled)
      if (this.wallTracker && marketData.orderbook) {
        const orderbook = marketData.orderbook;

        // Feed bids to WallTracker
        if (orderbook.bids && Array.isArray(orderbook.bids)) {
          for (const bid of orderbook.bids.slice(MULTIPLIERS.NEUTRAL, INTEGER_MULTIPLIERS.TWENTY)) { // Top 20 bids
            const price = Number(Array.isArray(bid) ? bid[MULTIPLIERS.NEUTRAL] : (bid as any).price);
            const size = Number(Array.isArray(bid) ? bid[1] : ((bid as any).size || (bid as any).quantity));
            if (!isNaN(price) && !isNaN(size) && size > MULTIPLIERS.NEUTRAL) {
              this.wallTracker.detectWall(price, size, 'BID');
            }
          }
        }

        // Feed asks to WallTracker
        if (orderbook.asks && Array.isArray(orderbook.asks)) {
          for (const ask of orderbook.asks.slice(MULTIPLIERS.NEUTRAL, INTEGER_MULTIPLIERS.TWENTY)) { // Top 20 asks
            const price = Number(Array.isArray(ask) ? ask[MULTIPLIERS.NEUTRAL] : (ask as any).price);
            const size = Number(Array.isArray(ask) ? ask[1] : ((ask as any).size || (ask as any).quantity));
            if (!isNaN(price) && !isNaN(size) && size > MULTIPLIERS.NEUTRAL) {
              this.wallTracker.detectWall(price, size, 'ASK');
            }
          }
        }
      }

      // Evaluate ALL strategies (like real bot)
      const evaluations: StrategySignal[] = [];
      for (const strategy of this.strategies) {
        const strategyName = strategy.constructor.name;

        // Feed ticks to TickDelta strategies BEFORE evaluation
        if (strategyName.includes('TickDelta') && currentTicks.length > 0) {
          for (const tick of currentTicks) {
            (strategy as any).analyzer?.addTick?.({
              side: tick.side?.toUpperCase() === 'BUY' ? 'BUY' : 'SELL',
              price: tick.price,
              size: tick.size,
              timestamp: tick.timestamp,
            });
          }
        }

        // Debug: Log TickDelta strategy calls
        if (strategyName.includes('TickDelta') && candleIndex % INTEGER_MULTIPLIERS.ONE_HUNDRED === 0) {
          console.log(`\n[STRATEGY] Evaluating ${strategyName} at candle ${candleIndex} (${currentTicks.length} ticks)`);
        }

        const evaluation = await strategy.evaluate(marketData);

        // Debug: Log TickDelta results
        if (strategyName.includes('TickDelta')) {
          if (candleIndex % INTEGER_MULTIPLIERS.ONE_HUNDRED === 0) {
            console.log(`  [RESULT] valid=${evaluation.valid}, signal=${evaluation.signal?.direction}, confidence=${evaluation.signal?.confidence?.toFixed(BACKTEST_CONSTANTS.DEBUG_PERCENT_DECIMALS)}`);
          }

          // Log ALL signals from TickDelta (not just every 100)
          if (evaluation.valid && evaluation.signal && evaluation.signal.direction !== SignalDirection.HOLD) {
            console.log(`  âš¡ [SIGNAL] ${strategyName} @ candle ${candleIndex}: ${evaluation.signal.direction} (conf=${evaluation.signal.confidence?.toFixed(DECIMAL_PLACES.STRENGTH)})`);
          }
        }

        evaluations.push(evaluation);
      }

      // Pick best signal (highest priority, then highest confidence)
      let validSignals = evaluations
        .filter(e => e.valid && e.signal && e.signal.direction !== SignalDirection.HOLD)
        .sort((a, b) => {
          // Sort by priority (lower = higher priority)
          if (a.priority !== b.priority) {
            return a.priority - b.priority;
          }
          // Then by confidence
          return (b.signal?.confidence || 0) - (a.signal?.confidence || 0);
        });

      // Filter by Weight Matrix confidence threshold if enabled
      if (this.weightMatrix && this.config.config.weightMatrix?.enabled) {
        validSignals = validSignals.filter(signal => {
          const confidencePercent = (signal.signal?.confidence || MULTIPLIERS.NEUTRAL) * PERCENT_MULTIPLIER;
          const passesThreshold = this.weightMatrix!.shouldEnter(confidencePercent);
          if (!passesThreshold && candleIndex % BACKTEST_CONSTANTS.DEBUG_LOG_INTERVAL === 0) {
            this.logger.debug('âŒ Weight Matrix filtered out signal', {
              strategy: signal.strategyName,
              confidence: confidencePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',
              required: (this.config.config.weightMatrix?.minConfidenceToEnter ?? MULTIPLIERS.NEUTRAL) + '%',
            });
          }
          return passesThreshold;
        });
      }

      // Debug: Log evaluation result every 500 candles
      if (candleIndex % BACKTEST_CONSTANTS.DEBUG_LOG_INTERVAL === 0) {
        console.log(`[STRATEGIES] Evaluated=${evaluations.length}, Valid signals=${validSignals.length}`);
        evaluations.forEach(e => {
          const reasonPreview = e.reason ? (e.reason.length > INTEGER_MULTIPLIERS.EIGHTY ? e.reason.substring(MULTIPLIERS.NEUTRAL, INTEGER_MULTIPLIERS.EIGHTY) + '...' : e.reason) : 'N/A';
          console.log(`  - ${e.strategyName}: valid=${e.valid}, priority=${e.priority}, reason="${reasonPreview}"`);
        });
      }

      // Filter out LONG signals that don't have candle confirmation
      // Config: strategies.levelBased.entryConfirmation (REQUIRED - no fallbacks!)
      const confirmationConfig = this.config.config.strategies?.levelBased?.entryConfirmation;
      if (!confirmationConfig) {
        throw new Error('Missing strategies.levelBased.entryConfirmation in config - this is required!');
      }

      if (confirmationConfig.enabled !== false) {
        if (confirmationConfig.longBodyRatioMin === undefined) {
          throw new Error('Missing strategies.levelBased.entryConfirmation.longBodyRatioMin - required value!');
        }
        if (confirmationConfig.longWickRatioMax === undefined) {
          throw new Error('Missing strategies.levelBased.entryConfirmation.longWickRatioMax - required value!');
        }

        const bodyRatioMin = confirmationConfig.longBodyRatioMin;
        const wickRatioMax = confirmationConfig.longWickRatioMax;

        // Filter LONG signals by candle pattern
        validSignals = validSignals.filter(signal => {
          if (signal.signal?.direction === SignalDirection.LONG) {
            const wickRatio = (currentCandle.high - currentCandle.close) / (currentCandle.high - currentCandle.low || 1);
            const bodyRatio = Math.abs(currentCandle.close - currentCandle.open) / (currentCandle.high - currentCandle.low || 1);
            const hasConfirmation = bodyRatio > bodyRatioMin || wickRatio < wickRatioMax;

            if (!hasConfirmation) {
              console.log(`[SIGNAL BLOCKED] LONG at ${currentPrice} - No candle confirmation (body=${bodyRatio.toFixed(2)} < ${bodyRatioMin}, wick=${wickRatio.toFixed(2)} > ${wickRatioMax})`);
            }
            return hasConfirmation;
          }
          return true; // Keep SHORT and other signals
        });

        // Filter SHORT signals by candle pattern if configured
        if (confirmationConfig.shortBodyRatioMin !== undefined && confirmationConfig.shortWickRatioMin !== undefined) {
          const shortBodyMin = confirmationConfig.shortBodyRatioMin;
          const shortWickMin = confirmationConfig.shortWickRatioMin;

          validSignals = validSignals.filter(signal => {
            if (signal.signal?.direction === SignalDirection.SHORT) {
              const wickRatio = (currentCandle.close - currentCandle.low) / (currentCandle.high - currentCandle.low || 1);
              const bodyRatio = Math.abs(currentCandle.close - currentCandle.open) / (currentCandle.high - currentCandle.low || 1);
              const hasConfirmation = bodyRatio > shortBodyMin || wickRatio < shortWickMin;

              if (!hasConfirmation) {
                console.log(`[SIGNAL BLOCKED] SHORT at ${currentPrice} - No candle confirmation (body=${bodyRatio.toFixed(2)} < ${shortBodyMin}, wick=${wickRatio.toFixed(2)} > ${shortWickMin})`);
              }
              return hasConfirmation;
            }
            return true; // Keep LONG and other signals
          });
        }
      }

      const bestSignal = validSignals[0];  // Pick highest priority signal after filtering

      if (bestSignal) {
        const direction = bestSignal.signal!.direction;

        // Check if entry confirmation is enabled for this direction
        if (this.entryConfirmation.isEnabled(direction)) {
          // Add to pending - wait for next candle confirmation
          const pendingId = this.entryConfirmation.addPending({
            symbol: this.config.symbol,
            direction,
            keyLevel: currentPrice, // Use current price as key level
            detectedAt: currentCandle.timestamp,
            signalData: { signal: bestSignal, atr },
          });
          this.pendingSignals.set(pendingId, { signal: bestSignal, marketData, atr });
          console.log(`[SIGNAL PENDING] ${direction} at ${currentPrice}, waiting for confirmation (id: ${pendingId}) - strategy=${bestSignal.strategyName}`);
        } else {
          // Entry confirmation disabled - open immediately
          console.log(`[SIGNAL FOUND] ${direction} at ${currentPrice}, confidence=${bestSignal.signal?.confidence}, strategy=${bestSignal.strategyName}`);
          this.openPosition(
            currentCandle,
            direction,
            currentPrice,
            atr,
            bestSignal.signal!.confidence || MULTIPLIERS.HALF,
            bestSignal.strategyName,
          );
        }
      } else {
        // FALLBACK: Use Entry Scanner (like live bot)
        // Check every 10 candles instead of 100 for more frequent scanning
        if (this.currentContext && candleIndex % 10 === 0) {
          // Debug: Log scanner attempt
          if (candleIndex % 500 === 0) {
            console.log(`[ENTRY SCANNER] Attempting scan at candle ${candleIndex}`);
          }

          const entrySignal: EntrySignal = await this.entryScanner.scan(this.currentContext);

          // Debug: Log scanner result
          if (candleIndex % 500 === 0) {
            console.log(`  Scanner result: shouldEnter=${entrySignal.shouldEnter}, direction=${entrySignal.direction ?? 'N/A'}, confidence=${entrySignal.confidence?.toFixed(DECIMAL_PLACES.PERCENT) ?? 'N/A'}, reason="${entrySignal.reason ?? 'N/A'}"`);
          }

          if (entrySignal.shouldEnter) {
            const direction = entrySignal.direction;
            console.log(`[ENTRY SCANNER] ${direction} at ${currentPrice}, confidence=${entrySignal.confidence}, reason=${entrySignal.reason}`);

            // Check if entry confirmation is enabled
            if (this.entryConfirmation.isEnabled(direction)) {
              const pendingId = this.entryConfirmation.addPending({
                symbol: this.config.symbol,
                direction,
                keyLevel: currentPrice,
                detectedAt: currentCandle.timestamp,
                signalData: { entrySignal, atr },
              });
              this.pendingSignals.set(pendingId, { signal: { valid: true, signal: { direction, confidence: entrySignal.confidence }, strategyName: 'EntryScanner' } as any, marketData, atr });
              console.log(`[SCANNER PENDING] ${direction} at ${currentPrice}, waiting for confirmation (id: ${pendingId})`);
            } else {
              this.openPosition(
                currentCandle,
                direction,
                currentPrice,
                atr,
                entrySignal.confidence,
                'EntryScanner',
              );
            }
          }
        } else if (!this.currentContext && candleIndex % 500 === 0) {
          console.log('[ENTRY SCANNER] Skipped - context not initialized');
        }
      }
    } catch (error: unknown) {
      console.error(`\n[ERROR] Candle ${candleIndex} @ ${new Date(currentCandle.timestamp).toISOString()}:`);
      console.error(`  Message: ${error instanceof Error ? error.message : String(error)}`);
      console.error(`  Stack: ${error instanceof Error ? error.stack : 'No stack trace'}`);
      console.error(`  Price: ${currentCandle.close.toFixed(DECIMAL_PLACES.PRICE)}`);
      console.error(`  Historical data: 5m=${historicalCandles5m.length}, 15m=${historicalCandles15m.length} candles`);
    }
  }

  /**
   * Check pending entry confirmations on candle close
   */
  private checkPendingConfirmations(currentCandle: BacktestCandle): void {
    const allPending = this.entryConfirmation.getAllPending();

    for (const pending of allPending) {
      const closePrice = currentCandle.close;

      // Check confirmation
      const result = this.entryConfirmation.checkConfirmation(pending.id, closePrice);

      if (result.confirmed) {
        // Confirmation successful - open position
        const signalData = this.pendingSignals.get(pending.id);
        if (signalData) {
          console.log(`[CONFIRMED] ${pending.direction} at ${closePrice} - ${result.reason}`);
          this.openPosition(
            currentCandle,
            pending.direction,
            closePrice,
            signalData.atr,
            signalData.signal.signal?.confidence || 0.5,
            signalData.signal.strategyName,
          );
          this.pendingSignals.delete(pending.id);
        }
      } else {
        // Check if still pending (not removed by checkConfirmation)
        const stillPending = this.entryConfirmation.getAllPending().find(p => p.id === pending.id);
        if (!stillPending) {
          // Confirmation failed or expired - cleanup
          console.log(`[REJECTED] ${pending.direction} - ${result.reason}`);
          this.pendingSignals.delete(pending.id);
        }
      }
    }
  }

  /**
   * Open position
   */
  private openPosition(
    candle: BacktestCandle,
    direction: SignalDirection,
    entryPrice: number,
    atr: number,
    confidence: number,
    strategyName: string,
  ): void {
    // PHASE 5: Check Daily Limits
    if (this.dailyLimitsService) {
      const limitsCheck = this.dailyLimitsService.canTrade();
      if (!limitsCheck.allowed) {
        console.log(`âŒ Trade blocked by daily limits: ${limitsCheck.reason}`);
        return;
      }
    }

    // PHASE 5: Check Loss Streak
    if (this.lossStreakService) {
      const streakCheck = this.lossStreakService.canTrade();
      if (!streakCheck.allowed) {
        console.log(`âŒ Trade blocked by loss streak: ${streakCheck.reason}`);
        return;
      }
    }

    // Base position size
    let positionSizeUsdt = this.config.positionSizeUsdt;

    // Get SL multipliers from config - FIX: Use strategy-specific params instead of hardcoded levelBased
    let slMultiplier = 1.0;

    if (strategyName === 'ScalpingOrderFlow') {
      // For scalping strategies, use stopLossPercent directly as ATR multiplier
      // Config value 0.04 means 4% stop loss, used as ATR multiplier
      slMultiplier = this.config.config.scalpingOrderFlow?.stopLossPercent ?? 0.02;
    } else if (strategyName === 'ScalpingTickDelta') {
      slMultiplier = this.config.config.scalpingTickDelta?.stopLossPercent ?? 0.02;
    } else if (strategyName === 'ScalpingMicroWall') {
      slMultiplier = this.config.config.scalpingMicroWall?.stopLossPercent ?? 0.02;
    } else if (strategyName === 'ScalpingLadderTp') {
      slMultiplier = this.config.config.scalpingLadderTp?.stopLossPercent ?? 0.02;
    } else if (strategyName === 'ScalpingLimitOrder') {
      slMultiplier = this.config.config.scalpingLimitOrder?.stopLossPercent ?? 0.02;
    } else {
      // Default: use levelBased for other strategies (TrendFollowing, LevelBased, CounterTrend)
      slMultiplier =
        direction === SignalDirection.LONG
          ? this.config.config.strategies.levelBased.stopLossAtrMultiplierLong ??
            this.config.config.strategies.levelBased.stopLossAtrMultiplier ??
            1.0
          : this.config.config.strategies.levelBased.stopLossAtrMultiplier ?? 1.0;
    }

    // ATR is returned as percentage, convert to price distance
    const atrDistance = entryPrice * (atr / INTEGER_MULTIPLIERS.ONE_HUNDRED) * slMultiplier;

    const stopLoss =
      direction === SignalDirection.LONG
        ? entryPrice - atrDistance
        : entryPrice + atrDistance;

    // PHASE 5: Check Max Concurrent Risk
    /*if (this.maxConcurrentRiskService) {
      const positionRisk = MaxConcurrentRiskService.calculatePositionRisk(
        signal.symbol,
        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',
        entryPrice,
        stopLoss,
        positionSizeUsdt,
        this.balance
      );
      const riskCheck = this.maxConcurrentRiskService.canOpenPosition(this.balance, positionRisk);
      if (!riskCheck.allowed) {
        console.log(`âŒ Trade blocked by max concurrent risk: ${riskCheck.reason}`);
        return;
      }
    }
*/
    // PHASE 5: Apply Risk-Based Sizing (overrides base size)
    if (this.riskBasedSizingService) {
      positionSizeUsdt = this.riskBasedSizingService.calculatePositionSize(
        this.balance,
        entryPrice,
        stopLoss,
      );
      console.log(`  ðŸŽ¯ Risk-Based Sizing: ${this.config.positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT)} â†’ ${positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT)} USDT`);
    }

    // PHASE 5: Apply Loss Streak multiplier
    if (this.lossStreakService) {
      const multiplier = this.lossStreakService.getSizeMultiplier();
      const originalSize = positionSizeUsdt;
      positionSizeUsdt = positionSizeUsdt * multiplier;
      console.log(`  ðŸ”» Loss Streak (${this.lossStreakService.getConsecutiveLosses()} losses): ${(multiplier * INTEGER_MULTIPLIERS.ONE_HUNDRED).toFixed(0)}% â†’ ${originalSize.toFixed(DECIMAL_PLACES.PERCENT)} â†’ ${positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT)} USDT`);
    }

    const size = (positionSizeUsdt * this.config.leverage) / entryPrice;

    // Calculate take profits - FIX: Use strategy-specific params instead of hardcoded levelBased
    let takeProfits: any[] = [];

    if (strategyName === 'ScalpingOrderFlow') {
      // For scalping strategies with single TP, calculate based on takeProfitPercent
      const tpPercent = this.config.config.scalpingOrderFlow?.takeProfitPercent ?? 0.25;
      const tpPrice =
        direction === SignalDirection.LONG
          ? entryPrice * (1 + tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED)
          : entryPrice * (1 - tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);
      takeProfits = [
        {
          level: 1,
          price: tpPrice,
          closePercent: 1.0,
        },
      ];
    } else if (strategyName === 'ScalpingTickDelta') {
      const tpPercent = this.config.config.scalpingTickDelta?.takeProfitPercent ?? 0.25;
      const tpPrice =
        direction === SignalDirection.LONG
          ? entryPrice * (1 + tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED)
          : entryPrice * (1 - tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);
      takeProfits = [
        {
          level: 1,
          price: tpPrice,
          closePercent: 1.0,
        },
      ];
    } else if (strategyName === 'ScalpingMicroWall') {
      const tpPercent = this.config.config.scalpingMicroWall?.takeProfitPercent ?? 0.25;
      const tpPrice =
        direction === SignalDirection.LONG
          ? entryPrice * (1 + tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED)
          : entryPrice * (1 - tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);
      takeProfits = [
        {
          level: 1,
          price: tpPrice,
          closePercent: 1.0,
        },
      ];
    } else if (strategyName === 'ScalpingLadderTp') {
      const tpPercent = this.config.config.scalpingLadderTp?.takeProfitPercent ?? 0.25;
      const tpPrice =
        direction === SignalDirection.LONG
          ? entryPrice * (1 + tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED)
          : entryPrice * (1 - tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);
      takeProfits = [
        {
          level: 1,
          price: tpPrice,
          closePercent: 1.0,
        },
      ];
    } else if (strategyName === 'ScalpingLimitOrder') {
      const tpPercent = this.config.config.scalpingLimitOrder?.takeProfitPercent ?? 0.25;
      const tpPrice =
        direction === SignalDirection.LONG
          ? entryPrice * (1 + tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED)
          : entryPrice * (1 - tpPercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);
      takeProfits = [
        {
          level: 1,
          price: tpPrice,
          closePercent: 1.0,
        },
      ];
    } else {
      // Default: use levelBased multi-level TPs if available, otherwise single TP at 0.5%
      const levelBasedTPs = this.config.config.strategies.levelBased?.takeProfits;
      if (levelBasedTPs && levelBasedTPs.length > 0) {
        takeProfits = levelBasedTPs.map((tp: any) => {
          const priceMove = Math.abs(entryPrice - stopLoss) * tp.percent;
          const tpPrice =
            direction === SignalDirection.LONG
              ? entryPrice + priceMove
              : entryPrice - priceMove;
          return {
          level: tp.level,
          price: tpPrice,
          closePercent: tp.sizePercent,
        };
        });
      } else {
        // Fallback: single TP at 0.5% when levelBased TPs not available
        const tpPrice =
          direction === SignalDirection.LONG
            ? entryPrice * 1.005
            : entryPrice * 0.995;
        takeProfits = [{
          level: 1,
          price: tpPrice,
          closePercent: 1.0,
        }];
      }
    }

    // Calculate entry fee (use actual position size, not base size)
    const entryFee = positionSizeUsdt * this.config.takerFee;
    this.balance -= entryFee;

    this.currentPosition = {
      entryTime: candle.timestamp,
      entryPrice,
      direction,
      size,
      stopLoss,
      takeProfits,
      confidence,
      strategyName,
    };

    // PHASE 5: Register position with Max Concurrent Risk
    /* if (this.maxConcurrentRiskService) {
      const positionRisk = MaxConcurrentRiskService.calculatePositionRisk(
        signal.symbol,
        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',
        entryPrice,
        stopLoss,
        positionSizeUsdt, // Use final position size after all adjustments
        this.balance
      );
      this.maxConcurrentRiskService.addPosition(positionRisk);
    }
--*/
    console.log(`\n[POSITION OPENED] ${direction} @ ${entryPrice.toFixed(DECIMAL_PLACES.PRICE)}`);
    console.log(`  ATR: ${atr.toFixed(DECIMAL_PLACES.PRICE)} (${((atr / entryPrice) * INTEGER_MULTIPLIERS.ONE_HUNDRED).toFixed(DECIMAL_PLACES.PERCENT)}% of price)`);
    console.log(`  SL multiplier: ${slMultiplier}`);
    console.log(`  SL calculation: ${entryPrice.toFixed(DECIMAL_PLACES.PRICE)} ${direction === SignalDirection.LONG ? '-' : '+'} (${atr.toFixed(DECIMAL_PLACES.PRICE)} * ${slMultiplier}) = ${stopLoss.toFixed(DECIMAL_PLACES.PRICE)}`);
    console.log(`  SL: ${stopLoss.toFixed(DECIMAL_PLACES.PRICE)} (${((Math.abs(stopLoss - entryPrice) / entryPrice) * INTEGER_MULTIPLIERS.ONE_HUNDRED).toFixed(DECIMAL_PLACES.PERCENT)}% distance)`);
    console.log(`  TPs: ${takeProfits.map((tp: any, i: number) => `TP${i + 1}=${tp.price.toFixed(DECIMAL_PLACES.PRICE)}`).join(', ')}`);
    console.log(`  Strategy: ${strategyName}, Confidence: ${(confidence * INTEGER_MULTIPLIERS.ONE_HUNDRED).toFixed(0)}%`);
  }

  /**
   * Check exit conditions
   */
  private checkExit(candle: BacktestCandle, historicalCandles: Candle[], candleIndex: number): void {
    if (!this.currentPosition) {
      return;
    }

    const position = this.currentPosition;

    // Debug: Log exit check every 1000 candles
    if (candleIndex % 1000 === 0) {
      console.log(`\n[EXIT CHECK] Candle ${candleIndex} @ price ${candle.close.toFixed(DECIMAL_PLACES.PRICE)} (high=${candle.high.toFixed(DECIMAL_PLACES.PRICE)}, low=${candle.low.toFixed(DECIMAL_PLACES.PRICE)})`);
      console.log(`  Position: ${position.direction} @ ${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}`);
      console.log(`  SL: ${position.stopLoss.toFixed(DECIMAL_PLACES.PRICE)} | Current TPs: ${position.takeProfits.map((tp, i) => `TP${i + 1}=${tp.price.toFixed(DECIMAL_PLACES.PRICE)}`).join(', ')}`);
      if (position.direction === SignalDirection.SHORT) {
        console.log(`  SL check: candle.high (${candle.high.toFixed(DECIMAL_PLACES.PRICE)}) >= SL (${position.stopLoss.toFixed(DECIMAL_PLACES.PRICE)}) ? ${candle.high >= position.stopLoss}`);
        console.log(`  TP check: candle.low (${candle.low.toFixed(DECIMAL_PLACES.PRICE)}) <= TP1 (${position.takeProfits[0]?.price?.toFixed(DECIMAL_PLACES.PRICE) ?? 'none'}) ? ${position.takeProfits[0] ? candle.low <= position.takeProfits[0].price : 'no TP'}`);
      } else {
        console.log(`  SL check: candle.low (${candle.low.toFixed(DECIMAL_PLACES.PRICE)}) <= SL (${position.stopLoss.toFixed(DECIMAL_PLACES.PRICE)}) ? ${candle.low <= position.stopLoss}`);
        console.log(`  TP check: candle.high (${candle.high.toFixed(DECIMAL_PLACES.PRICE)}) >= TP1 (${position.takeProfits[0]?.price?.toFixed(DECIMAL_PLACES.PRICE) ?? 'none'}) ? ${position.takeProfits[0] ? candle.high >= position.takeProfits[0].price : 'no TP'}`);
      }
    }

    // Check stop loss FIRST
    if (position.direction === SignalDirection.LONG) {
      if (candle.low <= position.stopLoss) {
        console.log(`\n[STOP LOSS HIT] LONG @ ${candle.low.toFixed(DECIMAL_PLACES.PRICE)} (SL: ${position.stopLoss.toFixed(DECIMAL_PLACES.PRICE)})`);
        this.closePosition(candle, position.stopLoss, 'STOP_LOSS');
        return;
      }
    } else {
      if (candle.high >= position.stopLoss) {
        console.log(`\n[STOP LOSS HIT] SHORT @ ${candle.high.toFixed(DECIMAL_PLACES.PRICE)} (SL: ${position.stopLoss.toFixed(DECIMAL_PLACES.PRICE)})`);
        this.closePosition(candle, position.stopLoss, 'STOP_LOSS');
        return;
      }
    }

    // Check take profits
    for (let i = 0; i < position.takeProfits.length; i++) {
      const tp = position.takeProfits[i];
      let hit = false;

      if (position.direction === SignalDirection.LONG) {
        hit = candle.high >= tp.price;
      } else {
        hit = candle.low <= tp.price;
      }

      if (hit) {
        // Check if this is the LAST TP (should close entire remaining position)
        const isLastTP = position.takeProfits.length === 1;

        if (isLastTP) {
          // Close entire remaining position
          console.log(`[TP${i + 1} HIT - LAST TP] Closing entire remaining position @ ${tp.price.toFixed(DECIMAL_PLACES.PRICE)}`);
          this.closePosition(candle, tp.price, `TP${i + 1}`);
          return;
        } else {
          // Partial close
          console.log(`[TP${i + 1} HIT] Partial close ${tp.closePercent}% @ ${tp.price.toFixed(DECIMAL_PLACES.PRICE)}`);
          this.partialClose(candle, tp.price, tp.closePercent, `TP${i + 1}`);
          position.takeProfits.splice(i, 1);
          return;
        }
      }
    }
  }

  /**
   * Partial close position
   */
  private partialClose(
    candle: BacktestCandle,
    exitPrice: number,
    closePercent: number,
    reason: string,
  ): void {
    if (!this.currentPosition) {
      return;
    }

    const position = this.currentPosition;
    const closeSizeUsdt = this.config.positionSizeUsdt * (closePercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);
    const closeSize = position.size * (closePercent / INTEGER_MULTIPLIERS.ONE_HUNDRED);

    const priceDiff =
      position.direction === SignalDirection.LONG
        ? exitPrice - position.entryPrice
        : position.entryPrice - exitPrice;
    const pnl = (priceDiff / position.entryPrice) * closeSizeUsdt * this.config.leverage;

    const exitFee = closeSizeUsdt * this.config.makerFee;
    this.balance += pnl - exitFee;

    const holding = candle.timestamp - position.entryTime;
    this.trades.push({
      entryTime: position.entryTime,
      entryPrice: position.entryPrice,
      direction: position.direction,
      size: closeSize,
      stopLoss: position.stopLoss,
      takeProfits: [],
      exitTime: candle.timestamp,
      exitPrice,
      exitReason: reason,
      pnl,
      pnlPercent: (pnl / closeSizeUsdt) * INTEGER_MULTIPLIERS.ONE_HUNDRED,
      fees: exitFee + (this.config.positionSizeUsdt * (closePercent / INTEGER_MULTIPLIERS.ONE_HUNDRED) * this.config.takerFee),
      holding,
      confidence: Math.round((position.confidence || MULTIPLIERS.HALF) * INTEGER_MULTIPLIERS.ONE_HUNDRED),
      strategyName: position.strategyName,
    });

    position.size -= closeSize;
    this.config.positionSizeUsdt *= (INTEGER_MULTIPLIERS.ONE_HUNDRED - closePercent) / INTEGER_MULTIPLIERS.ONE_HUNDRED;
  }

  /**
   * Close position
   */
  private closePosition(
    candle: BacktestCandle,
    exitPrice: number,
    reason: string,
  ): void {
    if (!this.currentPosition) {
      return;
    }

    const position = this.currentPosition;

    const priceDiff =
      position.direction === SignalDirection.LONG
        ? exitPrice - position.entryPrice
        : position.entryPrice - exitPrice;
    const pnl = (priceDiff / position.entryPrice) * this.config.positionSizeUsdt * this.config.leverage;

    const exitFee = this.config.positionSizeUsdt * this.config.makerFee;
    this.balance += pnl - exitFee;

    if (this.balance > this.peakBalance) {
      this.peakBalance = this.balance;
    }
    const drawdown = this.peakBalance - this.balance;
    if (drawdown > this.maxDrawdown) {
      this.maxDrawdown = drawdown;
    }

    const holding = candle.timestamp - position.entryTime;
    this.trades.push({
      ...position,
      exitTime: candle.timestamp,
      exitPrice,
      exitReason: reason,
      pnl,
      pnlPercent: (pnl / this.config.positionSizeUsdt) * INTEGER_MULTIPLIERS.ONE_HUNDRED,
      fees: exitFee + (this.config.positionSizeUsdt * this.config.takerFee),
      holding,
      confidence: Math.round((position.confidence || MULTIPLIERS.HALF) * INTEGER_MULTIPLIERS.ONE_HUNDRED),
    });

    // PHASE 5: Update Daily Limits
    if (this.dailyLimitsService) {
      this.dailyLimitsService.onTradeClose(pnl, this.balance);
    }

    // PHASE 5: Record trade result for Loss Streak
    if (this.lossStreakService) {
      const isWin = pnl > 0;
      this.lossStreakService.recordTrade(isWin);
    }

    // PHASE 5: Remove position from Max Concurrent Risk
    if (this.maxConcurrentRiskService) {
      this.maxConcurrentRiskService.removePosition(this.config.config.exchange.symbol);
    }

    this.currentPosition = null;
  }

  /**
   * Calculate backtest results
   */
  private calculateResults(): BacktestResult {
    const winners = this.trades.filter((t) => (t.pnl || 0) > 0);
    const losers = this.trades.filter((t) => (t.pnl || 0) <= 0);

    const totalPnl = this.trades.reduce((sum, t) => sum + (t.pnl || 0), 0);
    const totalFees = this.trades.reduce((sum, t) => sum + (t.fees || 0), 0);
    const netPnl = this.balance - this.config.initialBalance;

    const winRate = this.trades.length > 0 ? (winners.length / this.trades.length) * INTEGER_MULTIPLIERS.ONE_HUNDRED : 0;

    const totalWin = winners.reduce((sum, t) => sum + (t.pnl || 0), 0);
    const totalLoss = Math.abs(losers.reduce((sum, t) => sum + (t.pnl || 0), 0));

    const avgWin = winners.length > 0 ? totalWin / winners.length : 0;
    const avgLoss = losers.length > 0 ? totalLoss / losers.length : 0;

    const winLossRatio = avgLoss > 0 ? avgWin / avgLoss : 0;
    const profitFactor = totalLoss > 0 ? totalWin / totalLoss : 0;

    const avgHoldingTime = this.trades.length > 0
      ? this.trades.reduce((sum, t) => sum + (t.holding || 0), 0) / this.trades.length
      : 0;

    const returns = this.trades.map((t) => (t.pnlPercent || 0) / INTEGER_MULTIPLIERS.ONE_HUNDRED);
    const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
    const stdDev = Math.sqrt(
      returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, INTEGER_MULTIPLIERS.TWO), 0) / returns.length,
    );
    const sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0;

    return {
      config: this.config,
      totalTrades: this.trades.length,
      winningTrades: winners.length,
      losingTrades: losers.length,
      winRate,
      totalPnl,
      totalFees,
      netPnl,
      netPnlPercent: (netPnl / this.config.initialBalance) * INTEGER_MULTIPLIERS.ONE_HUNDRED,
      winLossRatio,
      profitFactor,
      avgWin,
      avgLoss,
      maxDrawdown: this.maxDrawdown,
      maxDrawdownPercent: (this.maxDrawdown / this.config.initialBalance) * INTEGER_MULTIPLIERS.ONE_HUNDRED,
      sharpeRatio,
      avgHoldingTime,
      trades: this.trades,
      equityCurve: this.equityCurve,
    };
  }
}
