[{"filePath":"D:\\src\\Edison\\src\\__tests__\\market-structure.analyzer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\breakout-predictor.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":88,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":88,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":101,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":101,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":101,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":101,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":101,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":101,"endColumn":53},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -40.","line":102,"column":30,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":102,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":105,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":105,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":105,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":109,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":77}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BREAKOUT_CONSTANTS, CONFIDENCE_THRESHOLDS, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Breakout Direction Predictor (BB.MD Section 4.4)\r\n *\r\n * Predicts the direction of breakout after Bollinger Bands squeeze.\r\n * Uses 3 factors:\r\n * 1. EMA trend direction (fast vs slow)\r\n * 2. RSI momentum (bullish/bearish bias)\r\n * 3. Volume strength (accumulation indicator)\r\n *\r\n * Returns prediction with confidence score.\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum BreakoutDirection {\r\n  BULLISH = 'BULLISH',\r\n  BEARISH = 'BEARISH',\r\n  NEUTRAL = 'NEUTRAL',\r\n}\r\n\r\nexport interface BreakoutPrediction {\r\n  direction: BreakoutDirection;\r\n  confidence: number; // 0-100\r\n  factors: {\r\n    emaTrend: 'BULLISH' | 'BEARISH' | 'NEUTRAL'; // 40 points max\r\n    rsiMomentum: 'BULLISH' | 'BEARISH' | 'NEUTRAL'; // 30 points max\r\n    volumeStrength: 'HIGH' | 'MEDIUM' | 'LOW'; // 30 points max\r\n  };\r\n  reason: string;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst RSI_BULLISH_THRESHOLD = 55;\r\nconst RSI_BEARISH_THRESHOLD = 45;\r\nconst VOLUME_HIGH_THRESHOLD = BREAKOUT_CONSTANTS.SL_MULTIPLIER; // BREAKOUT_CONSTANTS.SL_MULTIPLIERx average\r\nconst VOLUME_MEDIUM_THRESHOLD = MULTIPLIERS.NEUTRAL; // 1.0x average\r\n\r\n// Point allocation\r\nconst EMA_POINTS = PERCENTAGE_THRESHOLDS.MODERATE_HIGH;\r\nconst RSI_POINTS = PERCENTAGE_THRESHOLDS.MODERATE;\r\nconst VOLUME_POINTS = PERCENTAGE_THRESHOLDS.MODERATE;\r\n\r\n// ============================================================================\r\n// BREAKOUT PREDICTOR\r\n// ============================================================================\r\n\r\nexport class BreakoutPredictor {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Predict breakout direction based on market conditions\r\n   *\r\n   * @param emaFast - Fast EMA value (e.g., EMA20)\r\n   * @param emaSlow - Slow EMA value (e.g., EMA50)\r\n   * @param rsi - RSI value (0-100)\r\n   * @param volumeRatio - Current volume / average volume\r\n   * @returns Breakout prediction with confidence\r\n   */\r\n  predict(\r\n    emaFast: number,\r\n    emaSlow: number,\r\n    rsi: number,\r\n    volumeRatio: number,\r\n  ): BreakoutPrediction {\r\n    // Factor 1: EMA Trend Direction (40 points)\r\n    const emaTrend = this.analyzeEmaTrend(emaFast, emaSlow);\r\n    const emaScore = emaTrend === 'BULLISH' ? EMA_POINTS : emaTrend === 'BEARISH' ? -EMA_POINTS : 0;\r\n\r\n    // Factor 2: RSI Momentum (30 points)\r\n    const rsiMomentum = this.analyzeRsiMomentum(rsi);\r\n    const rsiScore =\r\n      rsiMomentum === 'BULLISH' ? RSI_POINTS : rsiMomentum === 'BEARISH' ? -RSI_POINTS : 0;\r\n\r\n    // Factor 3: Volume Strength (30 points)\r\n    const volumeStrength = this.analyzeVolumeStrength(volumeRatio);\r\n    const volumeScore =\r\n      volumeStrength === 'HIGH'\r\n        ? VOLUME_POINTS\r\n        : volumeStrength === 'MEDIUM'\r\n          ? VOLUME_POINTS / 2\r\n          : 0;\r\n\r\n    // Total score: -100 to +100\r\n    const totalScore = emaScore + rsiScore + volumeScore;\r\n\r\n    // Determine direction and confidence\r\n    let direction: BreakoutDirection;\r\n    let confidence: number;\r\n\r\n    if (totalScore >= PERCENTAGE_THRESHOLDS.MODERATE_HIGH) {\r\n      // Strong bullish (40-100 points)\r\n      direction = BreakoutDirection.BULLISH;\r\n      confidence = Math.min(100, 50 + totalScore / 2); // 70-100% confidence\r\n    } else if (totalScore <= -40) {\r\n      // Strong bearish (-40 to -100 points)\r\n      direction = BreakoutDirection.BEARISH;\r\n      confidence = Math.min(100, 50 + Math.abs(totalScore) / 2); // 70-100% confidence\r\n    } else {\r\n      // Neutral (-39 to +39 points)\r\n      direction = BreakoutDirection.NEUTRAL;\r\n      confidence = CONFIDENCE_THRESHOLDS.MODERATE - Math.abs(totalScore) / 2; // Lower confidence for neutral\r\n    }\r\n\r\n    const reason = this.buildReason(emaTrend, rsiMomentum, volumeStrength, totalScore);\r\n\r\n    this.logger.info('üîÆ Breakout Direction Predicted', {\r\n      direction,\r\n      confidence: confidence.toFixed(1) + '%',\r\n      totalScore,\r\n      emaTrend,\r\n      rsiMomentum,\r\n      volumeStrength,\r\n    });\r\n\r\n    return {\r\n      direction,\r\n      confidence,\r\n      factors: {\r\n        emaTrend,\r\n        rsiMomentum,\r\n        volumeStrength,\r\n      },\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze EMA trend direction\r\n   */\r\n  private analyzeEmaTrend(emaFast: number, emaSlow: number): 'BULLISH' | 'BEARISH' | 'NEUTRAL' {\r\n    const diff = ((emaFast - emaSlow) / emaSlow) * PERCENT_MULTIPLIER;\r\n\r\n    if (diff > BREAKOUT_CONSTANTS.TP_MODERATE) {\r\n      // Fast > Slow by >BREAKOUT_CONSTANTS.TP_MODERATE%\r\n      return 'BULLISH';\r\n    } else if (diff < -BREAKOUT_CONSTANTS.TP_MODERATE) {\r\n      // Fast < Slow by >BREAKOUT_CONSTANTS.TP_MODERATE%\r\n      return 'BEARISH';\r\n    } else {\r\n      // EMAs too close\r\n      return 'NEUTRAL';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze RSI momentum\r\n   */\r\n  private analyzeRsiMomentum(rsi: number): 'BULLISH' | 'BEARISH' | 'NEUTRAL' {\r\n    if (rsi > RSI_BULLISH_THRESHOLD) {\r\n      return 'BULLISH';\r\n    } else if (rsi < RSI_BEARISH_THRESHOLD) {\r\n      return 'BEARISH';\r\n    } else {\r\n      return 'NEUTRAL';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze volume strength\r\n   */\r\n  private analyzeVolumeStrength(volumeRatio: number): 'HIGH' | 'MEDIUM' | 'LOW' {\r\n    if (volumeRatio >= VOLUME_HIGH_THRESHOLD) {\r\n      return 'HIGH';\r\n    } else if (volumeRatio >= VOLUME_MEDIUM_THRESHOLD) {\r\n      return 'MEDIUM';\r\n    } else {\r\n      return 'LOW';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build human-readable reason\r\n   */\r\n  private buildReason(\r\n    emaTrend: string,\r\n    rsiMomentum: string,\r\n    volumeStrength: string,\r\n    totalScore: number,\r\n  ): string {\r\n    const factors = [];\r\n\r\n    if (emaTrend === 'BULLISH') {\r\n      factors.push('EMA bullish trend');\r\n    } else if (emaTrend === 'BEARISH') {\r\n      factors.push('EMA bearish trend');\r\n    }\r\n\r\n    if (rsiMomentum === 'BULLISH') {\r\n      factors.push('RSI bullish momentum');\r\n    } else if (rsiMomentum === 'BEARISH') {\r\n      factors.push('RSI bearish momentum');\r\n    }\r\n\r\n    if (volumeStrength === 'HIGH') {\r\n      factors.push('high volume');\r\n    } else if (volumeStrength === 'MEDIUM') {\r\n      factors.push('medium volume');\r\n    }\r\n\r\n    if (factors.length === 0) {\r\n      return `Neutral market (score: ${totalScore})`;\r\n    }\r\n\r\n    return factors.join(' + ');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\btc.analyzer.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":77,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":77,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2433,2459],"text":"(this.config.useCorrelation ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2433,2459],"text":"(this.config.useCorrelation === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":77,"column":39,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":77,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2463,2473],"text":"(altCandles != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":21,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":89,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2629,2697],"text":"(this.correlationCalculator.calculate(btcCandles, altCandles, period) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":79,"column":90,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":79,"endColumn":92,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2698,2700],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":81,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":81,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2725,2736],"text":"correlation != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":156,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":156,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4926,4952],"text":"(this.config.useCorrelation ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4926,4952],"text":"(this.config.useCorrelation === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":156,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":156,"endColumn":59,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4956,4976],"text":"(analysis.correlation != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":190,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":190,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5801,5822],"text":"analysis.correlation == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":194,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":194,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5908,5941],"text":"(this.config.correlationThresholds != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":194,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":194,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5942,5944],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":305,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":305,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":305,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":305,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":308,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":308,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":308,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":308,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":311,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":311,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.2.","line":311,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":311,"endColumn":60},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":349,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":349,"endColumn":73}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BTC_ANALYZER_CONSTANTS, CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, MULTIPLIERS, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * BTC Analyzer\r\n *\r\n * Analyzes Bitcoin price movement to confirm altcoin signals.\r\n * Key metrics:\r\n * - Direction: UP/DOWN/NEUTRAL\r\n * - Momentum: strength of movement (0-1)\r\n * - Alignment: whether BTC supports the altcoin signal\r\n *\r\n * Fast and lightweight - optimized for speed.\r\n */\r\n\r\nimport {\r\n  Candle,\r\n  SignalDirection,\r\n  BTCConfirmationConfig,\r\n  LoggerService,\r\n  BTCDirection,\r\n  BTCAnalysis,\r\n} from '../types';\r\nimport { CorrelationCalculator, CorrelationResult } from './correlation.calculator';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\n// Re-export unified types from types.ts for backwards compatibility\r\nexport { BTCDirection, BTCAnalysis };\r\n\r\n// ============================================================================\r\n// BTC ANALYZER\r\n// ============================================================================\r\n\r\nexport class BTCAnalyzer {\r\n  private correlationCalculator: CorrelationCalculator;\r\n\r\n  constructor(\r\n    private config: BTCConfirmationConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.correlationCalculator = new CorrelationCalculator();\r\n  }\r\n\r\n  /**\r\n   * Analyze BTC movement for signal confirmation\r\n   *\r\n   * @param btcCandles - BTC candles (most recent last)\r\n   * @param signalDirection - Altcoin signal direction (LONG/SHORT)\r\n   * @param altCandles - Altcoin candles for correlation (optional)\r\n   * @returns BTC analysis result\r\n   */\r\n  analyze(\r\n    btcCandles: Candle[],\r\n    signalDirection: SignalDirection,\r\n    altCandles?: Candle[],\r\n  ): BTCAnalysis {\r\n    if (btcCandles.length < this.config.lookbackCandles) {\r\n      this.logger.warn('Not enough BTC candles for analysis', {\r\n        available: btcCandles.length,\r\n        required: this.config.lookbackCandles,\r\n      });\r\n\r\n      return {\r\n        direction: BTCDirection.NEUTRAL,\r\n        momentum: 0,\r\n        priceChange: 0,\r\n        consecutiveMoves: 0,\r\n        volumeRatio: 1,\r\n        isAligned: false,\r\n        reason: 'Insufficient BTC data',\r\n      };\r\n    }\r\n\r\n    // Calculate correlation if enabled and altcoin candles provided\r\n    let correlation: CorrelationResult | undefined;\r\n    if (this.config.useCorrelation && altCandles && altCandles.length > 0) {\r\n      const period = this.config.correlationPeriod ?? BTC_ANALYZER_CONSTANTS.DEFAULT_CORRELATION_PERIOD;\r\n      correlation = this.correlationCalculator.calculate(btcCandles, altCandles, period) || undefined;\r\n\r\n      if (correlation) {\r\n        this.logger.debug('BTC-Alt correlation calculated', {\r\n          coefficient: correlation.coefficient.toFixed(DECIMAL_PLACES.PERCENT),\r\n          strength: correlation.strength,\r\n          filterStrength: correlation.filterStrength,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Take last N candles\r\n    const lookbackCandles = btcCandles.slice(-this.config.lookbackCandles);\r\n    const currentPrice = lookbackCandles[lookbackCandles.length - 1].close;\r\n    const startPrice = lookbackCandles[0].close;\r\n\r\n    // 1. Calculate price change\r\n    const priceChange = ((currentPrice - startPrice) / startPrice) * PERCENT_MULTIPLIER;\r\n\r\n    // 2. Determine direction\r\n    const direction = this.determineDirection(priceChange);\r\n\r\n    // 3. Count consecutive moves\r\n    const consecutiveMoves = this.countConsecutiveMoves(lookbackCandles);\r\n\r\n    // 4. Calculate volume ratio\r\n    const volumeRatio = this.calculateVolumeRatio(lookbackCandles);\r\n\r\n    // 5. Calculate momentum (0-1)\r\n    const momentum = this.calculateMomentum(\r\n      priceChange,\r\n      consecutiveMoves,\r\n      volumeRatio,\r\n    );\r\n\r\n    // 6. Check alignment with signal\r\n    const isAligned = this.checkAlignment(direction, signalDirection);\r\n\r\n    // 7. Build reason\r\n    const reason = this.buildReason(\r\n      direction,\r\n      momentum,\r\n      priceChange,\r\n      consecutiveMoves,\r\n      isAligned,\r\n      signalDirection,\r\n    );\r\n\r\n    this.logger.debug('BTC analysis complete', {\r\n      direction,\r\n      momentum: momentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n      priceChange: priceChange.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      consecutiveMoves,\r\n      volumeRatio: volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      isAligned,\r\n    });\r\n\r\n    return {\r\n      direction,\r\n      momentum,\r\n      priceChange,\r\n      consecutiveMoves,\r\n      volumeRatio,\r\n      isAligned,\r\n      reason,\r\n      correlation,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if BTC passes the confirmation filter\r\n   *\r\n   * @param analysis - BTC analysis result\r\n   * @returns true if BTC confirms the signal\r\n   */\r\n  shouldConfirm(analysis: BTCAnalysis): boolean {\r\n    // If correlation is enabled, use dynamic thresholds\r\n    if (this.config.useCorrelation && analysis.correlation) {\r\n      return this.shouldConfirmWithCorrelation(analysis);\r\n    }\r\n\r\n    // Otherwise use fixed thresholds\r\n    return this.shouldConfirmFixed(analysis);\r\n  }\r\n\r\n  /**\r\n   * Check confirmation with fixed thresholds (no correlation)\r\n   */\r\n  private shouldConfirmFixed(analysis: BTCAnalysis): boolean {\r\n    // If alignment is not required, always pass\r\n    if (!this.config.requireAlignment) {\r\n      return true;\r\n    }\r\n\r\n    // Check alignment\r\n    if (!analysis.isAligned) {\r\n      return false;\r\n    }\r\n\r\n    // Check minimum momentum\r\n    if (analysis.momentum < this.config.minimumMomentum) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check confirmation with correlation-based adaptive thresholds\r\n   */\r\n  private shouldConfirmWithCorrelation(analysis: BTCAnalysis): boolean {\r\n    if (!analysis.correlation) {\r\n      return this.shouldConfirmFixed(analysis);\r\n    }\r\n\r\n    const thresholds = this.config.correlationThresholds || {\r\n      strict: CONFIDENCE_THRESHOLDS.MODERATE,\r\n      moderate: MULTIPLIERS.HALF,\r\n      weak: PERCENTAGE_THRESHOLDS.MODERATE,\r\n    };\r\n\r\n    const absCorrelation = Math.abs(analysis.correlation.coefficient);\r\n\r\n    // SKIP filter for very low correlation (<0.15)\r\n    if (absCorrelation < thresholds.weak) {\r\n      this.logger.debug('BTC filter SKIPPED due to very low correlation', {\r\n        correlation: absCorrelation.toFixed(DECIMAL_PLACES.PERCENT),\r\n        threshold: thresholds.weak,\r\n      });\r\n      return true; // Skip BTC filter - no correlation\r\n    }\r\n\r\n    // WEAK filter (<0.5) - also skip\r\n    // If correlation is weak, BTC and alt are not moving together\r\n    // Don't require alignment when there's weak correlation\r\n    if (absCorrelation < thresholds.moderate) {\r\n      this.logger.debug('BTC filter PASSED due to weak correlation', {\r\n        correlation: absCorrelation.toFixed(DECIMAL_PLACES.PERCENT),\r\n        threshold: thresholds.moderate,\r\n      });\r\n      return true; // Skip BTC filter - weak correlation\r\n    }\r\n\r\n    // MODERATE filter (alignment + reduced momentum)\r\n    if (absCorrelation < thresholds.strict) {\r\n      const reducedThreshold = this.config.minimumMomentum * BTC_ANALYZER_CONSTANTS.MOMENTUM_REDUCTION_FACTOR;\r\n      return analysis.isAligned && analysis.momentum >= reducedThreshold;\r\n    }\r\n\r\n    // STRICT filter (full requirements)\r\n    return this.shouldConfirmFixed(analysis);\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Determine BTC direction based on price change\r\n   */\r\n  private determineDirection(priceChange: number): BTCDirection {\r\n    const threshold = BTC_ANALYZER_CONSTANTS.NEUTRAL_THRESHOLD; // 0.1% threshold for neutral zone\r\n\r\n    if (priceChange > threshold) {\r\n      return BTCDirection.UP;\r\n    } else if (priceChange < -threshold) {\r\n      return BTCDirection.DOWN;\r\n    } else {\r\n      return BTCDirection.NEUTRAL;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Count consecutive candles in the same direction\r\n   */\r\n  private countConsecutiveMoves(candles: Candle[]): number {\r\n    let count = 0;\r\n    let lastDirection: 'up' | 'down' | null = null;\r\n\r\n    // Start from most recent candle and work backwards\r\n    for (let i = candles.length - 1; i >= 0; i--) {\r\n      const candle = candles[i];\r\n      const direction = candle.close > candle.open ? 'up' : 'down';\r\n\r\n      if (lastDirection === null) {\r\n        lastDirection = direction;\r\n        count = 1;\r\n      } else if (direction === lastDirection) {\r\n        count++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Calculate volume ratio (current vs average)\r\n   */\r\n  private calculateVolumeRatio(candles: Candle[]): number {\r\n    if (candles.length === 0) {\r\n      return 1;\r\n    }\r\n\r\n    const currentVolume = candles[candles.length - 1].volume;\r\n    const avgVolume =\r\n      candles.reduce((sum, c) => sum + c.volume, 0) / candles.length;\r\n\r\n    return avgVolume > 0 ? currentVolume / avgVolume : 1;\r\n  }\r\n\r\n  /**\r\n   * Calculate momentum score (0-1)\r\n   *\r\n   * Combines:\r\n   * - Price change magnitude\r\n   * - Consecutive moves\r\n   * - Volume strength\r\n   */\r\n  private calculateMomentum(\r\n    priceChange: number,\r\n    consecutiveMoves: number,\r\n    volumeRatio: number,\r\n  ): number {\r\n    // Price change component (0-0.5)\r\n    const priceScore = Math.min(Math.abs(priceChange) / 2, 0.5);\r\n\r\n    // Consecutive moves component (0-0.3)\r\n    const movesScore = Math.min(consecutiveMoves / 10, 0.3);\r\n\r\n    // Volume component (0-0.2)\r\n    const volumeScore = Math.min((volumeRatio - 1) / 5, 0.2);\r\n\r\n    return Math.min(priceScore + movesScore + volumeScore, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Check if BTC direction aligns with signal\r\n   */\r\n  private checkAlignment(\r\n    btcDirection: BTCDirection,\r\n    signalDirection: SignalDirection,\r\n  ): boolean {\r\n    if (signalDirection === SignalDirection.HOLD) {\r\n      return false;\r\n    }\r\n\r\n    if (btcDirection === BTCDirection.NEUTRAL) {\r\n      return false;\r\n    }\r\n\r\n    const isLong = signalDirection === SignalDirection.LONG;\r\n    const btcUp = btcDirection === BTCDirection.UP;\r\n\r\n    return isLong === btcUp;\r\n  }\r\n\r\n  /**\r\n   * Build human-readable reason\r\n   */\r\n  private buildReason(\r\n    direction: BTCDirection,\r\n    momentum: number,\r\n    priceChange: number,\r\n    consecutiveMoves: number,\r\n    isAligned: boolean,\r\n    signalDirection: SignalDirection,\r\n  ): string {\r\n    const momentumStr =\r\n      momentum >= CONFIDENCE_THRESHOLDS.LOW ? 'STRONG' : momentum >= 0.3 ? 'MODERATE' : 'WEAK';\r\n\r\n    const parts: string[] = [];\r\n\r\n    parts.push(`BTC ${direction}`);\r\n    parts.push(`${priceChange.toFixed(DECIMAL_PLACES.PERCENT)}%`);\r\n    parts.push(`${momentumStr} momentum (${(momentum * PERCENT_MULTIPLIER).toFixed(0)}%)`);\r\n    parts.push(`${consecutiveMoves} consecutive`);\r\n\r\n    if (isAligned) {\r\n      parts.push(`‚úÖ ALIGNED with ${signalDirection}`);\r\n    } else {\r\n      parts.push(`‚ùå NOT aligned with ${signalDirection}`);\r\n    }\r\n\r\n    return parts.join(', ');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\chart-patterns.detector.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":78,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":78,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -10.","line":124,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":124,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":127,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":132,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":132,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":135,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":135,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":136,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":136,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":137,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":160,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":160,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":163,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":163,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"Number constants declarations must use 'const'.","line":192,"column":22,"nodeType":"Literal","messageId":"useConst","endLine":192,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":224,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":224,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":229,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":229,"endColumn":23},{"ruleId":"max-len","severity":1,"message":"This line has a length of 165. Maximum allowed is 120.","line":232,"column":1,"nodeType":"Program","messageId":"max","endLine":232,"endColumn":166},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -10.","line":250,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":250,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":252,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":252,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":257,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":257,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":260,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":260,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":261,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":261,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":262,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":262,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":285,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":285,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":288,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":288,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"Number constants declarations must use 'const'.","line":317,"column":22,"nodeType":"Literal","messageId":"useConst","endLine":317,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":349,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":349,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":354,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":354,"endColumn":23},{"ruleId":"max-len","severity":1,"message":"This line has a length of 165. Maximum allowed is 120.","line":357,"column":1,"nodeType":"Program","messageId":"max","endLine":357,"endColumn":166},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -6.","line":375,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":375,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":377,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":377,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":382,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":382,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":385,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":385,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":402,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":402,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":402,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":402,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":404,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":404,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":406,"column":78,"nodeType":"Literal","messageId":"noMagic","endLine":406,"endColumn":81},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":411,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":411,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":411,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":411,"endColumn":46},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -6.","line":439,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":439,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":441,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":441,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":446,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":446,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":449,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":449,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":466,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":466,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":466,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":466,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":468,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":468,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":470,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":470,"endColumn":85},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":475,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":475,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":475,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":475,"endColumn":46},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (322). Maximum allowed is 300.","line":478,"column":1,"nodeType":null,"messageId":"exceed","endLine":506,"endColumn":1}],"suppressedMessages":[],"errorCount":43,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_BOUNDS, CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS, TIME_UNITS } from '../constants';\r\n/**\r\n * Chart Patterns Detector\r\n *\r\n * Detects classic chart patterns for improved reversal trading:\r\n * - Head & Shoulders (bearish reversal)\r\n * - Inverse Head & Shoulders (bullish reversal)\r\n * - Double Top/Bottom (reversal patterns)\r\n *\r\n * Uses ZigZag swing points to identify pattern structure.\r\n */\r\n\r\nimport { SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum ChartPatternType {\r\n  HEAD_AND_SHOULDERS = 'HEAD_AND_SHOULDERS',           // Bearish reversal\r\n  INVERSE_HEAD_AND_SHOULDERS = 'INVERSE_HEAD_AND_SHOULDERS', // Bullish reversal\r\n  DOUBLE_TOP = 'DOUBLE_TOP',                           // Bearish reversal\r\n  DOUBLE_BOTTOM = 'DOUBLE_BOTTOM',                     // Bullish reversal\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface ChartPattern {\r\n  type: ChartPatternType;\r\n  detected: boolean;\r\n  confidence: number;        // 0-100%\r\n  neckline: number;          // Entry level (breakout point)\r\n  target: number;            // Take profit level\r\n  stopLoss: number;          // Stop loss level\r\n  direction: 'LONG' | 'SHORT';\r\n  points: SwingPoint[];      // Pattern structure points\r\n  explanation: string;\r\n}\r\n\r\nexport interface ChartPatternConfig {\r\n  headTolerancePercent: number;     // Head vs shoulders height tolerance (default: 2%)\r\n  shoulderTolerancePercent: number; // Shoulders level tolerance (default: 3%)\r\n  necklineTolerancePercent: number; // Neckline level tolerance (default: 2%)\r\n  minPatternBars: number;            // Minimum bars for pattern (default: 20)\r\n  maxPatternBars: number;            // Maximum bars for pattern (default: 100)\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_CONFIG: ChartPatternConfig = {\r\n  headTolerancePercent: 2.0,\r\n  shoulderTolerancePercent: 3.0,\r\n  necklineTolerancePercent: 2.0,\r\n  minPatternBars: 20,\r\n  maxPatternBars: 100,\r\n};\r\n\r\n// ============================================================================\r\n// CHART PATTERNS DETECTOR\r\n// ============================================================================\r\n\r\nexport class ChartPatternsDetector {\r\n  private config: ChartPatternConfig;\r\n\r\n  constructor(\r\n    private logger: LoggerService,\r\n    config?: Partial<ChartPatternConfig>,\r\n  ) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n  }\r\n\r\n  /**\r\n   * Detect all chart patterns from swing points\r\n   * Returns the first detected pattern with highest confidence\r\n   */\r\n  detect(swingPoints: SwingPoint[]): ChartPattern {\r\n    if (swingPoints.length < 3) {\r\n      return this.noPattern('Not enough swing points (need 3+ for any pattern)');\r\n    }\r\n\r\n    // Try to detect patterns in order of reliability (complex patterns first)\r\n    const headAndShoulders = this.detectHeadAndShoulders(swingPoints);\r\n    if (headAndShoulders.detected) {\r\n      return headAndShoulders;\r\n    }\r\n\r\n    const inverseHeadAndShoulders = this.detectInverseHeadAndShoulders(swingPoints);\r\n    if (inverseHeadAndShoulders.detected) {\r\n      return inverseHeadAndShoulders;\r\n    }\r\n\r\n    const doubleTop = this.detectDoubleTop(swingPoints);\r\n    if (doubleTop.detected) {\r\n      return doubleTop;\r\n    }\r\n\r\n    const doubleBottom = this.detectDoubleBottom(swingPoints);\r\n    if (doubleBottom.detected) {\r\n      return doubleBottom;\r\n    }\r\n\r\n    return this.noPattern('No pattern detected');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HEAD & SHOULDERS (Bearish Reversal)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect Head & Shoulders pattern\r\n   *\r\n   * Structure (5 points):\r\n   *      Head (HIGH)\r\n   *     /      \\\r\n   *  LS (HIGH)  RS (HIGH)\r\n   *   \\          /\r\n   *    LV (LOW)  RV (LOW)  <- Neckline\r\n   *\r\n   * LS = Left Shoulder, LV = Left Valley\r\n   * RS = Right Shoulder, RV = Right Valley\r\n   */\r\n  detectHeadAndShoulders(swingPoints: SwingPoint[]): ChartPattern {\r\n    const recent = swingPoints.slice(-10); // Look at last 10 swing points\r\n\r\n    // Need at least 5 points: LS, LV, Head, RV, RS\r\n    if (recent.length < 5) {\r\n      return this.noPattern('Not enough points for H&S');\r\n    }\r\n\r\n    // Search for pattern: HIGH, LOW, HIGH (head), LOW, HIGH\r\n    for (let i = 0; i <= recent.length - 5; i++) {\r\n      const leftShoulder = recent[i];\r\n      const leftValley = recent[i + 1];\r\n      const head = recent[i + 2];\r\n      const rightValley = recent[i + 3];\r\n      const rightShoulder = recent[i + 4];\r\n\r\n      // Validate structure: HIGH -> LOW -> HIGH -> LOW -> HIGH\r\n      if (\r\n        leftShoulder.type !== SwingPointType.HIGH ||\r\n        leftValley.type !== SwingPointType.LOW ||\r\n        head.type !== SwingPointType.HIGH ||\r\n        rightValley.type !== SwingPointType.LOW ||\r\n        rightShoulder.type !== SwingPointType.HIGH\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Validate pattern geometry\r\n      const validation = this.validateHeadAndShoulders(\r\n        leftShoulder,\r\n        leftValley,\r\n        head,\r\n        rightValley,\r\n        rightShoulder,\r\n      );\r\n\r\n      if (validation.valid) {\r\n        const neckline = (leftValley.price + rightValley.price) / 2;\r\n        const patternHeight = head.price - neckline;\r\n        const target = neckline - patternHeight; // Project downward\r\n        const stopLoss = rightShoulder.price + (patternHeight * 0.1); // 10% above RS\r\n\r\n        return {\r\n          type: ChartPatternType.HEAD_AND_SHOULDERS,\r\n          detected: true,\r\n          confidence: validation.confidence,\r\n          neckline,\r\n          target,\r\n          stopLoss,\r\n          direction: 'SHORT',\r\n          points: [leftShoulder, leftValley, head, rightValley, rightShoulder],\r\n          explanation: `H&S: Head ${head.price.toFixed(DECIMAL_PLACES.PRICE)}, Shoulders ${leftShoulder.price.toFixed(DECIMAL_PLACES.PRICE)}/${rightShoulder.price.toFixed(DECIMAL_PLACES.PRICE)}, Neckline ${neckline.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return this.noPattern('No valid H&S pattern');\r\n  }\r\n\r\n  /**\r\n   * Validate Head & Shoulders geometry\r\n   */\r\n  private validateHeadAndShoulders(\r\n    ls: SwingPoint,\r\n    lv: SwingPoint,\r\n    head: SwingPoint,\r\n    rv: SwingPoint,\r\n    rs: SwingPoint,\r\n  ): { valid: boolean; confidence: number } {\r\n    let confidence = 100;\r\n\r\n    // 1. Head must be higher than both shoulders\r\n    if (head.price <= ls.price || head.price <= rs.price) {\r\n      return { valid: false, confidence: 0 };\r\n    }\r\n\r\n    const headVsLeftShoulder = ((head.price - ls.price) / ls.price) * PERCENT_MULTIPLIER;\r\n    const headVsRightShoulder = ((head.price - rs.price) / rs.price) * PERCENT_MULTIPLIER;\r\n\r\n    if (\r\n      headVsLeftShoulder < this.config.headTolerancePercent ||\r\n      headVsRightShoulder < this.config.headTolerancePercent\r\n    ) {\r\n      return { valid: false, confidence: 0 };\r\n    }\r\n\r\n    // 2. Shoulders should be approximately at same level (¬±3%)\r\n    const shoulderDiff = Math.abs((ls.price - rs.price) / ls.price) * PERCENT_MULTIPLIER;\r\n    if (shoulderDiff > this.config.shoulderTolerancePercent) {\r\n      confidence -= PERCENTAGE_THRESHOLDS.LOW_MODERATE;\r\n    }\r\n\r\n    // 3. Valleys (neckline) should be approximately at same level (¬±2%)\r\n    const necklineDiff = Math.abs((lv.price - rv.price) / lv.price) * PERCENT_MULTIPLIER;\r\n    if (necklineDiff > this.config.necklineTolerancePercent) {\r\n      confidence -= PERCENTAGE_THRESHOLDS.LOW_MODERATE;\r\n    }\r\n\r\n    // 4. Check pattern timespan (assuming 1m candles)\r\n    const patternMinutes = (rs.timestamp - ls.timestamp) / TIME_UNITS.MINUTE;\r\n    if (patternMinutes < this.config.minPatternBars || patternMinutes > this.config.maxPatternBars) {\r\n      confidence -= 10;\r\n    }\r\n\r\n    // 5. Symmetry bonus: if shoulders are very close in price\r\n    if (shoulderDiff < 1.0) {\r\n      confidence += 10;\r\n    }\r\n\r\n    return { valid: confidence >= CONFIDENCE_THRESHOLDS.MODERATE, confidence: Math.max(CONFIDENCE_BOUNDS.MINIMUM, Math.min(CONFIDENCE_BOUNDS.MAXIMUM, confidence)) };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // INVERSE HEAD & SHOULDERS (Bullish Reversal)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect Inverse Head & Shoulders pattern\r\n   *\r\n   * Structure (5 points):\r\n   *    LV (HIGH) RV (HIGH)  <- Neckline\r\n   *   /          \\\r\n   *  LS (LOW)    RS (LOW)\r\n   *     \\      /\r\n   *      Head (LOW)\r\n   */\r\n  detectInverseHeadAndShoulders(swingPoints: SwingPoint[]): ChartPattern {\r\n    const recent = swingPoints.slice(-10);\r\n\r\n    if (recent.length < 5) {\r\n      return this.noPattern('Not enough points for Inverse H&S');\r\n    }\r\n\r\n    // Search for pattern: LOW, HIGH, LOW (head), HIGH, LOW\r\n    for (let i = 0; i <= recent.length - 5; i++) {\r\n      const leftShoulder = recent[i];\r\n      const leftValley = recent[i + 1];\r\n      const head = recent[i + 2];\r\n      const rightValley = recent[i + 3];\r\n      const rightShoulder = recent[i + 4];\r\n\r\n      // Validate structure: LOW -> HIGH -> LOW -> HIGH -> LOW\r\n      if (\r\n        leftShoulder.type !== SwingPointType.LOW ||\r\n        leftValley.type !== SwingPointType.HIGH ||\r\n        head.type !== SwingPointType.LOW ||\r\n        rightValley.type !== SwingPointType.HIGH ||\r\n        rightShoulder.type !== SwingPointType.LOW\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Validate pattern geometry\r\n      const validation = this.validateInverseHeadAndShoulders(\r\n        leftShoulder,\r\n        leftValley,\r\n        head,\r\n        rightValley,\r\n        rightShoulder,\r\n      );\r\n\r\n      if (validation.valid) {\r\n        const neckline = (leftValley.price + rightValley.price) / 2;\r\n        const patternHeight = neckline - head.price;\r\n        const target = neckline + patternHeight; // Project upward\r\n        const stopLoss = rightShoulder.price - (patternHeight * 0.1); // 10% below RS\r\n\r\n        return {\r\n          type: ChartPatternType.INVERSE_HEAD_AND_SHOULDERS,\r\n          detected: true,\r\n          confidence: validation.confidence,\r\n          neckline,\r\n          target,\r\n          stopLoss,\r\n          direction: 'LONG',\r\n          points: [leftShoulder, leftValley, head, rightValley, rightShoulder],\r\n          explanation: `Inverse H&S: Head ${head.price.toFixed(DECIMAL_PLACES.PRICE)}, Shoulders ${leftShoulder.price.toFixed(DECIMAL_PLACES.PRICE)}/${rightShoulder.price.toFixed(DECIMAL_PLACES.PRICE)}, Neckline ${neckline.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return this.noPattern('No valid Inverse H&S pattern');\r\n  }\r\n\r\n  /**\r\n   * Validate Inverse Head & Shoulders geometry\r\n   */\r\n  private validateInverseHeadAndShoulders(\r\n    ls: SwingPoint,\r\n    lv: SwingPoint,\r\n    head: SwingPoint,\r\n    rv: SwingPoint,\r\n    rs: SwingPoint,\r\n  ): { valid: boolean; confidence: number } {\r\n    let confidence = 100;\r\n\r\n    // 1. Head must be lower than both shoulders\r\n    if (head.price >= ls.price || head.price >= rs.price) {\r\n      return { valid: false, confidence: 0 };\r\n    }\r\n\r\n    const headVsLeftShoulder = ((ls.price - head.price) / head.price) * PERCENT_MULTIPLIER;\r\n    const headVsRightShoulder = ((rs.price - head.price) / head.price) * PERCENT_MULTIPLIER;\r\n\r\n    if (\r\n      headVsLeftShoulder < this.config.headTolerancePercent ||\r\n      headVsRightShoulder < this.config.headTolerancePercent\r\n    ) {\r\n      return { valid: false, confidence: 0 };\r\n    }\r\n\r\n    // 2. Shoulders should be approximately at same level (¬±3%)\r\n    const shoulderDiff = Math.abs((ls.price - rs.price) / ls.price) * PERCENT_MULTIPLIER;\r\n    if (shoulderDiff > this.config.shoulderTolerancePercent) {\r\n      confidence -= PERCENTAGE_THRESHOLDS.LOW_MODERATE;\r\n    }\r\n\r\n    // 3. Valleys (neckline) should be approximately at same level (¬±2%)\r\n    const necklineDiff = Math.abs((lv.price - rv.price) / lv.price) * PERCENT_MULTIPLIER;\r\n    if (necklineDiff > this.config.necklineTolerancePercent) {\r\n      confidence -= PERCENTAGE_THRESHOLDS.LOW_MODERATE;\r\n    }\r\n\r\n    // 4. Check pattern timespan (assuming 1m candles)\r\n    const patternMinutes = (rs.timestamp - ls.timestamp) / TIME_UNITS.MINUTE;\r\n    if (patternMinutes < this.config.minPatternBars || patternMinutes > this.config.maxPatternBars) {\r\n      confidence -= 10;\r\n    }\r\n\r\n    // 5. Symmetry bonus\r\n    if (shoulderDiff < 1.0) {\r\n      confidence += 10;\r\n    }\r\n\r\n    return { valid: confidence >= CONFIDENCE_THRESHOLDS.MODERATE, confidence: Math.max(CONFIDENCE_BOUNDS.MINIMUM, Math.min(CONFIDENCE_BOUNDS.MAXIMUM, confidence)) };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // DOUBLE TOP (Bearish Reversal)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect Double Top pattern\r\n   *\r\n   * Structure (3 points):\r\n   *  Peak1  Peak2\r\n   *    |      |\r\n   *    |      |\r\n   *     \\    /\r\n   *      Valley  <- Neckline\r\n   */\r\n  detectDoubleTop(swingPoints: SwingPoint[]): ChartPattern {\r\n    const recent = swingPoints.slice(-6);\r\n\r\n    if (recent.length < 3) {\r\n      return this.noPattern('Not enough points for Double Top');\r\n    }\r\n\r\n    // Search for pattern: HIGH, LOW, HIGH\r\n    for (let i = 0; i <= recent.length - 3; i++) {\r\n      const peak1 = recent[i];\r\n      const valley = recent[i + 1];\r\n      const peak2 = recent[i + 2];\r\n\r\n      // Validate structure: HIGH -> LOW -> HIGH\r\n      if (\r\n        peak1.type !== SwingPointType.HIGH ||\r\n        valley.type !== SwingPointType.LOW ||\r\n        peak2.type !== SwingPointType.HIGH\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Validate: peaks at approximately same level (¬±2%)\r\n      const peakDiff = Math.abs((peak1.price - peak2.price) / peak1.price) * PERCENT_MULTIPLIER;\r\n      if (peakDiff > this.config.shoulderTolerancePercent) {\r\n        continue;\r\n      }\r\n\r\n      const confidence = 100 - peakDiff * 10; // Closer peaks = higher confidence\r\n      const neckline = valley.price;\r\n      const patternHeight = ((peak1.price + peak2.price) / 2) - neckline;\r\n      const target = neckline - patternHeight;\r\n      const stopLoss = Math.max(peak1.price, peak2.price) + (patternHeight * 0.1);\r\n\r\n      return {\r\n        type: ChartPatternType.DOUBLE_TOP,\r\n        detected: true,\r\n        confidence: Math.max(50, Math.min(100, confidence)),\r\n        neckline,\r\n        target,\r\n        stopLoss,\r\n        direction: 'SHORT',\r\n        points: [peak1, valley, peak2],\r\n        explanation: `Double Top: Peaks ${peak1.price.toFixed(DECIMAL_PLACES.PRICE)}/${peak2.price.toFixed(DECIMAL_PLACES.PRICE)}, Neckline ${neckline.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      };\r\n    }\r\n\r\n    return this.noPattern('No valid Double Top pattern');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // DOUBLE BOTTOM (Bullish Reversal)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect Double Bottom pattern\r\n   *\r\n   * Structure (3 points):\r\n   *      Peak  <- Neckline\r\n   *     /    \\\r\n   *    |      |\r\n   *    |      |\r\n   * Bottom1 Bottom2\r\n   */\r\n  detectDoubleBottom(swingPoints: SwingPoint[]): ChartPattern {\r\n    const recent = swingPoints.slice(-6);\r\n\r\n    if (recent.length < 3) {\r\n      return this.noPattern('Not enough points for Double Bottom');\r\n    }\r\n\r\n    // Search for pattern: LOW, HIGH, LOW\r\n    for (let i = 0; i <= recent.length - 3; i++) {\r\n      const bottom1 = recent[i];\r\n      const peak = recent[i + 1];\r\n      const bottom2 = recent[i + 2];\r\n\r\n      // Validate structure: LOW -> HIGH -> LOW\r\n      if (\r\n        bottom1.type !== SwingPointType.LOW ||\r\n        peak.type !== SwingPointType.HIGH ||\r\n        bottom2.type !== SwingPointType.LOW\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Validate: bottoms at approximately same level (¬±2%)\r\n      const bottomDiff = Math.abs((bottom1.price - bottom2.price) / bottom1.price) * PERCENT_MULTIPLIER;\r\n      if (bottomDiff > this.config.shoulderTolerancePercent) {\r\n        continue;\r\n      }\r\n\r\n      const confidence = 100 - bottomDiff * 10;\r\n      const neckline = peak.price;\r\n      const patternHeight = neckline - ((bottom1.price + bottom2.price) / 2);\r\n      const target = neckline + patternHeight;\r\n      const stopLoss = Math.min(bottom1.price, bottom2.price) - (patternHeight * 0.1);\r\n\r\n      return {\r\n        type: ChartPatternType.DOUBLE_BOTTOM,\r\n        detected: true,\r\n        confidence: Math.max(50, Math.min(100, confidence)),\r\n        neckline,\r\n        target,\r\n        stopLoss,\r\n        direction: 'LONG',\r\n        points: [bottom1, peak, bottom2],\r\n        explanation: `Double Bottom: Bottoms ${bottom1.price.toFixed(DECIMAL_PLACES.PRICE)}/${bottom2.price.toFixed(DECIMAL_PLACES.PRICE)}, Neckline ${neckline.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      };\r\n    }\r\n\r\n    return this.noPattern('No valid Double Bottom pattern');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY\r\n  // ==========================================================================\r\n\r\n  private noPattern(reason: string): ChartPattern {\r\n    return {\r\n      type: ChartPatternType.NONE,\r\n      detected: false,\r\n      confidence: 0,\r\n      neckline: 0,\r\n      target: 0,\r\n      stopLoss: 0,\r\n      direction: 'LONG',\r\n      points: [],\r\n      explanation: reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\context.analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MarketStructure' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Async method 'analyze' has a complexity of 15. Maximum allowed is 10.","line":66,"column":16,"nodeType":"FunctionExpression","messageId":"complex","endLine":204,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":71,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":71,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":71,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":71,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":109,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":109,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":114,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":114,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":114,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":114,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":122,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":122,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.8.","line":128,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":128,"endColumn":28}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Context Analyzer\r\n *\r\n * Analyzes higher timeframes (PRIMARY 5m, TREND 30m) to determine:\r\n * - Market trend and structure\r\n * - Trading filters (ATR, EMA distance)\r\n * - Whether context is valid for trading\r\n *\r\n * This provides the \"big picture\" context that filters entry signals.\r\n */\r\n\r\nimport {\r\n  TradingContext,\r\n  TrendBias,\r\n  MarketStructure,\r\n  TimeframeRole,\r\n  LoggerService,\r\n  ContextFilteringMode,\r\n} from '../types';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { EMAIndicator } from '../indicators/ema.indicator';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { MarketStructureAnalyzer } from './market-structure.analyzer';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface ContextConfig {\r\n  atrPeriod: number;\r\n  emaPeriod: number;\r\n  zigzagDepth: number;\r\n  minimumATR: number;\r\n  maximumATR: number;\r\n  maxEmaDistance: number; // Max % distance from EMA50\r\n  filteringMode: ContextFilteringMode; // HARD_BLOCK or WEIGHT_BASED\r\n}\r\n\r\n// ============================================================================\r\n// CONTEXT ANALYZER\r\n// ============================================================================\r\n\r\nexport class ContextAnalyzer {\r\n  private atr: ATRIndicator;\r\n  private ema50: EMAIndicator;\r\n  private zigzag: ZigZagIndicator;\r\n  private structureAnalyzer: MarketStructureAnalyzer;\r\n\r\n  constructor(\r\n    private config: ContextConfig,\r\n    private candleProvider: CandleProvider,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.atr = new ATRIndicator(config.atrPeriod);\r\n    this.ema50 = new EMAIndicator(config.emaPeriod);\r\n    this.zigzag = new ZigZagIndicator(config.zigzagDepth);\r\n    this.structureAnalyzer = new MarketStructureAnalyzer(logger);\r\n  }\r\n\r\n  /**\r\n   * Analyze trading context from PRIMARY timeframe\r\n   * Returns context that will be used to filter ENTRY signals\r\n   */\r\n  async analyze(): Promise<TradingContext> {\r\n    const timestamp = Date.now();\r\n\r\n    // Get PRIMARY candles\r\n    const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n    if (!primaryCandles || primaryCandles.length < 50) {\r\n      this.logger.warn('Not enough PRIMARY candles for context analysis', {\r\n        count: primaryCandles?.length ?? 0,\r\n      });\r\n      return this.invalidContext(timestamp, ['INSUFFICIENT_DATA']);\r\n    }\r\n\r\n    // Calculate indicators on PRIMARY\r\n    const atrPercent = this.atr.calculate(primaryCandles);\r\n    const ema50Value = this.ema50.calculate(primaryCandles);\r\n    const highs = this.zigzag.findSwingHighs(primaryCandles);\r\n    const lows = this.zigzag.findSwingLows(primaryCandles);\r\n\r\n    const currentPrice = primaryCandles[primaryCandles.length - 1].close;\r\n    const emaDistance = Math.abs((currentPrice - ema50Value) / ema50Value) * PERCENT_MULTIPLIER;\r\n\r\n    // Get market structure\r\n    const marketStructure = this.structureAnalyzer.identifyStructure(highs, lows);\r\n    const trend = this.structureAnalyzer.getTrendBias(highs, lows);\r\n\r\n    // Decision based on filtering mode\r\n    const filteringMode = this.config.filteringMode;\r\n    const warnings: string[] = [];\r\n    const blockedBy: string[] = [];\r\n    let isValidContext = true;\r\n\r\n    // ====================================================================\r\n    // WEIGHT-BASED MODE: Calculate modifiers\r\n    // ====================================================================\r\n    let atrModifier = 1.0;\r\n    let emaModifier = 1.0;\r\n    let trendModifier = 1.0;\r\n\r\n    if (filteringMode === ContextFilteringMode.WEIGHT_BASED) {\r\n      // ATR modifier (0.5 - 1.0)\r\n      if (atrPercent < this.config.minimumATR) {\r\n        // Too low volatility - reduce confidence\r\n        const ratio = atrPercent / this.config.minimumATR;\r\n        atrModifier = Math.max(0.5, ratio); // Min 0.5x\r\n        warnings.push(`Low volatility (ATR ${atrPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)`);\r\n      } else if (atrPercent > this.config.maximumATR) {\r\n        // Too high volatility - reduce confidence\r\n        const excess = (atrPercent - this.config.maximumATR) / this.config.maximumATR;\r\n        atrModifier = Math.max(0.5, 1.0 - excess * 0.5); // Max penalty 50%\r\n        warnings.push(`High volatility (ATR ${atrPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)`);\r\n      }\r\n\r\n      // EMA distance modifier (0.3 - 1.0)\r\n      if (emaDistance > this.config.maxEmaDistance) {\r\n        // Price too far from EMA - reduce confidence significantly\r\n        const excess = (emaDistance - this.config.maxEmaDistance) / this.config.maxEmaDistance;\r\n        emaModifier = Math.max(0.3, 1.0 - excess); // Min 0.3x\r\n        warnings.push(`Price far from EMA50 (${emaDistance.toFixed(DECIMAL_PLACES.PERCENT)}%)`);\r\n      }\r\n\r\n      // Trend modifier (based on market structure)\r\n      if (trend === TrendBias.NEUTRAL) {\r\n        trendModifier = 0.8; // Slightly reduce confidence in neutral market\r\n        warnings.push('Neutral trend');\r\n      }\r\n    }\r\n\r\n    // ====================================================================\r\n    // HARD_BLOCK MODE: Check hard constraints\r\n    // ====================================================================\r\n    if (filteringMode === ContextFilteringMode.HARD_BLOCK) {\r\n      // ATR check\r\n      if (atrPercent < this.config.minimumATR) {\r\n        blockedBy.push('ATR_TOO_LOW');\r\n        isValidContext = false;\r\n        warnings.push(`Low volatility (ATR ${atrPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)`);\r\n      } else if (atrPercent > this.config.maximumATR) {\r\n        blockedBy.push('ATR_TOO_HIGH');\r\n        isValidContext = false;\r\n        warnings.push(`High volatility (ATR ${atrPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)`);\r\n      }\r\n\r\n      // EMA distance check\r\n      if (emaDistance > this.config.maxEmaDistance) {\r\n        blockedBy.push('PRICE_TOO_FAR');\r\n        isValidContext = false;\r\n        warnings.push(`Price far from EMA50 (${emaDistance.toFixed(DECIMAL_PLACES.PERCENT)}%)`);\r\n      }\r\n\r\n      // Trend check (neutral trend = soft warning, not hard block)\r\n      if (trend === TrendBias.NEUTRAL) {\r\n        warnings.push('Neutral trend');\r\n      }\r\n\r\n      // Set modifiers to 0 if blocked (for consistency)\r\n      if (!isValidContext) {\r\n        atrModifier = 0;\r\n        emaModifier = 0;\r\n        trendModifier = 0;\r\n      }\r\n    }\r\n\r\n    // Overall modifier\r\n    const overallModifier = atrModifier * emaModifier * trendModifier;\r\n\r\n    this.logger.info('üìä Context Analysis', {\r\n      filteringMode,\r\n      atrPercent: atrPercent.toFixed(DECIMAL_PLACES.PERCENT),\r\n      ema50: ema50Value.toFixed(DECIMAL_PLACES.PRICE),\r\n      emaDistance: emaDistance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      trend,\r\n      marketStructure,\r\n      modifiers: {\r\n        atr: atrModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        ema: emaModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        trend: trendModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        overall: overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n      },\r\n      isValidContext,\r\n      blockedBy,\r\n      warnings,\r\n    });\r\n\r\n    return {\r\n      timestamp,\r\n      trend,\r\n      marketStructure,\r\n      atrPercent,\r\n      emaDistance,\r\n      ema50: ema50Value,\r\n      atrModifier,\r\n      emaModifier,\r\n      trendModifier,\r\n      overallModifier,\r\n      isValidContext,\r\n      blockedBy,\r\n      warnings,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Helper: return invalid context (insufficient data)\r\n   */\r\n  private invalidContext(timestamp: number, warnings: string[]): TradingContext {\r\n    return {\r\n      timestamp,\r\n      trend: TrendBias.NEUTRAL,\r\n      marketStructure: null,\r\n      atrPercent: 0,\r\n      emaDistance: 0,\r\n      ema50: 0,\r\n      atrModifier: 0,    // Zero modifier = effectively blocked\r\n      emaModifier: 0,\r\n      trendModifier: 0,\r\n      overallModifier: 0,\r\n      isValidContext: false,\r\n      blockedBy: ['INSUFFICIENT_DATA'],\r\n      warnings,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\correlation.calculator.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":156,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":156,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.4.","line":169,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":169,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.2.","line":171,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":171,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":192,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":192,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":208,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":208,"endColumn":74}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Correlation Calculator\r\n *\r\n * Calculates rolling Pearson correlation between BTC and altcoin price movements.\r\n * Used to dynamically adjust BTC filter strength based on correlation.\r\n *\r\n * High correlation (>0.7) ‚Üí Strict BTC filter\r\n * Medium correlation (0.4-0.7) ‚Üí Moderate BTC filter\r\n * Low correlation (<0.4) ‚Üí Weak/skip BTC filter\r\n */\r\n\r\nimport { Candle } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface CorrelationResult {\r\n  coefficient: number; // Pearson correlation coefficient (-1 to 1)\r\n  strength: 'STRONG' | 'MODERATE' | 'WEAK' | 'NONE'; // Correlation strength\r\n  filterStrength: 'STRICT' | 'MODERATE' | 'WEAK' | 'SKIP'; // Recommended filter strength\r\n  sampleSize: number; // Number of data points used\r\n  btcVolatility: number; // BTC price volatility (%)\r\n  altVolatility: number; // Altcoin price volatility (%)\r\n}\r\n\r\n// ============================================================================\r\n// CORRELATION CALCULATOR\r\n// ============================================================================\r\n\r\nexport class CorrelationCalculator {\r\n  /**\r\n   * Calculate Pearson correlation between BTC and altcoin\r\n   *\r\n   * @param btcCandles - BTC candles (must be same length as altCandles)\r\n   * @param altCandles - Altcoin candles (must be same length as btcCandles)\r\n   * @param period - Rolling window size (default 50)\r\n   * @returns Correlation result\r\n   */\r\n  calculate(\r\n    btcCandles: Candle[],\r\n    altCandles: Candle[],\r\n    period: number = CONFIDENCE_THRESHOLDS.MODERATE,\r\n  ): CorrelationResult | null {\r\n    // Validate inputs\r\n    if (btcCandles.length !== altCandles.length) {\r\n      return null;\r\n    }\r\n\r\n    if (btcCandles.length < period) {\r\n      return null;\r\n    }\r\n\r\n    // Take last N candles\r\n    const btcWindow = btcCandles.slice(-period);\r\n    const altWindow = altCandles.slice(-period);\r\n\r\n    // Calculate price changes (returns)\r\n    const btcReturns = this.calculateReturns(btcWindow);\r\n    const altReturns = this.calculateReturns(altWindow);\r\n\r\n    // Calculate Pearson correlation\r\n    const coefficient = this.pearsonCorrelation(btcReturns, altReturns);\r\n\r\n    // Determine strength\r\n    const strength = this.determineStrength(coefficient);\r\n\r\n    // Determine recommended filter strength\r\n    const filterStrength = this.determineFilterStrength(coefficient);\r\n\r\n    // Calculate volatilities\r\n    const btcVolatility = this.calculateVolatility(btcReturns);\r\n    const altVolatility = this.calculateVolatility(altReturns);\r\n\r\n    return {\r\n      coefficient,\r\n      strength,\r\n      filterStrength,\r\n      sampleSize: period,\r\n      btcVolatility,\r\n      altVolatility,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate price returns (percentage changes)\r\n   */\r\n  private calculateReturns(candles: Candle[]): number[] {\r\n    const returns: number[] = [];\r\n\r\n    for (let i = 1; i < candles.length; i++) {\r\n      const prevClose = candles[i - 1].close;\r\n      const currClose = candles[i].close;\r\n      const change = (currClose - prevClose) / prevClose;\r\n      returns.push(change);\r\n    }\r\n\r\n    return returns;\r\n  }\r\n\r\n  /**\r\n   * Calculate Pearson correlation coefficient\r\n   *\r\n   * Formula: r = Œ£[(x - xÃÑ)(y - »≥)] / ‚àö[Œ£(x - xÃÑ)¬≤ * Œ£(y - »≥)¬≤]\r\n   */\r\n  private pearsonCorrelation(x: number[], y: number[]): number {\r\n    if (x.length !== y.length || x.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const n = x.length;\r\n\r\n    // Calculate means\r\n    const xMean = x.reduce((sum, val) => sum + val, 0) / n;\r\n    const yMean = y.reduce((sum, val) => sum + val, 0) / n;\r\n\r\n    // Calculate components\r\n    let numerator = 0;\r\n    let xVariance = 0;\r\n    let yVariance = 0;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const xDiff = x[i] - xMean;\r\n      const yDiff = y[i] - yMean;\r\n\r\n      numerator += xDiff * yDiff;\r\n      xVariance += xDiff * xDiff;\r\n      yVariance += yDiff * yDiff;\r\n    }\r\n\r\n    // Calculate correlation\r\n    const denominator = Math.sqrt(xVariance * yVariance);\r\n\r\n    if (denominator === 0) {\r\n      return 0;\r\n    }\r\n\r\n    return numerator / denominator;\r\n  }\r\n\r\n  /**\r\n   * Calculate volatility (standard deviation of returns)\r\n   */\r\n  private calculateVolatility(returns: number[]): number {\r\n    if (returns.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const mean = returns.reduce((sum, val) => sum + val, 0) / returns.length;\r\n    const variance =\r\n      returns.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / returns.length;\r\n\r\n    return Math.sqrt(variance) * PERCENT_MULTIPLIER; // Convert to percentage\r\n  }\r\n\r\n  /**\r\n   * Determine correlation strength\r\n   */\r\n  private determineStrength(coefficient: number): 'STRONG' | 'MODERATE' | 'WEAK' | 'NONE' {\r\n    const abs = Math.abs(coefficient);\r\n\r\n    if (abs >= CONFIDENCE_THRESHOLDS.MODERATE) {\r\n      return 'STRONG';\r\n    } else if (abs >= 0.4) {\r\n      return 'MODERATE';\r\n    } else if (abs >= 0.2) {\r\n      return 'WEAK';\r\n    } else {\r\n      return 'NONE';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine recommended BTC filter strength based on correlation\r\n   */\r\n  private determineFilterStrength(\r\n    coefficient: number,\r\n  ): 'STRICT' | 'MODERATE' | 'WEAK' | 'SKIP' {\r\n    const abs = Math.abs(coefficient);\r\n\r\n    if (abs >= CONFIDENCE_THRESHOLDS.MODERATE) {\r\n      // High correlation - strict BTC filter required\r\n      return 'STRICT';\r\n    } else if (abs >= MULTIPLIERS.HALF) {\r\n      // Moderate correlation - moderate BTC filter\r\n      return 'MODERATE';\r\n    } else if (abs >= 0.3) {\r\n      // Low correlation - weak BTC filter\r\n      return 'WEAK';\r\n    } else {\r\n      // Very low/no correlation - skip BTC filter\r\n      return 'SKIP';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get human-readable description of correlation\r\n   */\r\n  getDescription(result: CorrelationResult): string {\r\n    const sign = result.coefficient >= 0 ? 'positive' : 'negative';\r\n    const absCoef = Math.abs(result.coefficient);\r\n\r\n    return `${result.strength} ${sign} correlation (r=${absCoef.toFixed(3)}) - Recommend ${result.filterStrength} BTC filter`;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\divergence.detector.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":53,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":53,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":53,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":53,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":69,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":69,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":76,"column":14,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":76,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":81,"column":14,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":81,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":84,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":84,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":97,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":97,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":223,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":223,"endColumn":53},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":226,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":226,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":229,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":229,"endColumn":49}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Divergence Detector\r\n *\r\n * Detects divergences between price action and RSI indicator.\r\n * Divergences are powerful reversal signals used by professional traders.\r\n *\r\n * Types of divergences:\r\n * - BULLISH: Price makes lower low, RSI makes higher low ‚Üí Potential reversal UP\r\n * - BEARISH: Price makes higher high, RSI makes lower high ‚Üí Potential reversal DOWN\r\n *\r\n * Based on classical technical analysis and momentum theory.\r\n */\r\n\r\nimport { SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum DivergenceType {\r\n  BULLISH = 'BULLISH',\r\n  BEARISH = 'BEARISH',\r\n  NONE = 'NONE',\r\n}\r\n\r\n/**\r\n * Divergence between price and RSI\r\n */\r\nexport interface Divergence {\r\n  type: DivergenceType;           // BULLISH, BEARISH, or NONE\r\n  strength: number;               // 0-1 (confidence in divergence)\r\n  pricePoints: [number, number];  // [old price, new price]\r\n  rsiPoints: [number, number];    // [old RSI, new RSI]\r\n  timePoints: [number, number];   // [old timestamp, new timestamp]\r\n}\r\n\r\n/**\r\n * RSI value with timestamp\r\n */\r\nexport interface RSIPoint {\r\n  value: number;\r\n  timestamp: number;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_DIVERGENCE_STRENGTH = 0.3;   // Minimum strength to report divergence\r\nconst PRICE_DIFF_THRESHOLD = 0.2;      // 0.2% - minimum price difference\r\nconst RSI_DIFF_THRESHOLD = 2;          // 2 points - minimum RSI difference\r\nconst MAX_TIME_BETWEEN_POINTS_MS = 24 * 60 * 60 * 1000; // 24 hours\r\n\r\n// ============================================================================\r\n// DIVERGENCE DETECTOR\r\n// ============================================================================\r\n\r\nexport class DivergenceDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect divergence from swing points and RSI values\r\n   */\r\n  detect(\r\n    swingPoints: SwingPoint[],\r\n    rsiValues: Map<number, number>, // timestamp -> RSI value\r\n  ): Divergence {\r\n    if (swingPoints.length < 2) {\r\n      return this.noDivergence();\r\n    }\r\n\r\n    // Get last two swing highs (for bearish divergence)\r\n    const lastTwoHighs = swingPoints\r\n      .filter(p => p.type === SwingPointType.HIGH)\r\n      .slice(-2);\r\n\r\n    // Get last two swing lows (for bullish divergence)\r\n    const lastTwoLows = swingPoints\r\n      .filter(p => p.type === SwingPointType.LOW)\r\n      .slice(-2);\r\n\r\n    // Check for bearish divergence (price HH, RSI LH)\r\n    if (lastTwoHighs.length === 2) {\r\n      const bearish = this.checkBearishDivergence(lastTwoHighs, rsiValues);\r\n      if (bearish.type !== DivergenceType.NONE) {\r\n        this.logger.debug('Bearish divergence detected', {\r\n          strength: bearish.strength,\r\n          pricePoints: bearish.pricePoints,\r\n          rsiPoints: bearish.rsiPoints,\r\n        });\r\n        return bearish;\r\n      }\r\n    }\r\n\r\n    // Check for bullish divergence (price LL, RSI HL)\r\n    if (lastTwoLows.length === 2) {\r\n      const bullish = this.checkBullishDivergence(lastTwoLows, rsiValues);\r\n      if (bullish.type !== DivergenceType.NONE) {\r\n        this.logger.debug('Bullish divergence detected', {\r\n          strength: bullish.strength,\r\n          pricePoints: bullish.pricePoints,\r\n          rsiPoints: bullish.rsiPoints,\r\n        });\r\n        return bullish;\r\n      }\r\n    }\r\n\r\n    return this.noDivergence();\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE HELPERS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check for bearish divergence (price HH, RSI LH)\r\n   */\r\n  private checkBearishDivergence(\r\n    swingHighs: SwingPoint[],\r\n    rsiValues: Map<number, number>,\r\n  ): Divergence {\r\n    const [old, recent] = swingHighs;\r\n\r\n    // Get RSI values at swing points\r\n    const oldRSI = rsiValues.get(old.timestamp);\r\n    const recentRSI = rsiValues.get(recent.timestamp);\r\n\r\n    if (oldRSI === undefined || recentRSI === undefined) {\r\n      return this.noDivergence();\r\n    }\r\n\r\n    // Check if time between points is not too large\r\n    if (recent.timestamp - old.timestamp > MAX_TIME_BETWEEN_POINTS_MS) {\r\n      return this.noDivergence();\r\n    }\r\n\r\n    // Bearish divergence: Price makes HH, RSI makes LH\r\n    const priceIsHigher = recent.price > old.price;\r\n    const rsiIsLower = recentRSI < oldRSI;\r\n\r\n    if (priceIsHigher && rsiIsLower) {\r\n      const priceDiff = Math.abs(recent.price - old.price) / old.price * PERCENT_MULTIPLIER;\r\n      const rsiDiff = Math.abs(recentRSI - oldRSI);\r\n\r\n      // Check if differences are significant\r\n      if (priceDiff >= PRICE_DIFF_THRESHOLD && rsiDiff >= RSI_DIFF_THRESHOLD) {\r\n        const strength = this.calculateStrength(priceDiff, rsiDiff);\r\n\r\n        if (strength >= MIN_DIVERGENCE_STRENGTH) {\r\n          return {\r\n            type: DivergenceType.BEARISH,\r\n            strength,\r\n            pricePoints: [old.price, recent.price],\r\n            rsiPoints: [oldRSI, recentRSI],\r\n            timePoints: [old.timestamp, recent.timestamp],\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.noDivergence();\r\n  }\r\n\r\n  /**\r\n   * Check for bullish divergence (price LL, RSI HL)\r\n   */\r\n  private checkBullishDivergence(\r\n    swingLows: SwingPoint[],\r\n    rsiValues: Map<number, number>,\r\n  ): Divergence {\r\n    const [old, recent] = swingLows;\r\n\r\n    // Get RSI values at swing points\r\n    const oldRSI = rsiValues.get(old.timestamp);\r\n    const recentRSI = rsiValues.get(recent.timestamp);\r\n\r\n    if (oldRSI === undefined || recentRSI === undefined) {\r\n      return this.noDivergence();\r\n    }\r\n\r\n    // Check if time between points is not too large\r\n    if (recent.timestamp - old.timestamp > MAX_TIME_BETWEEN_POINTS_MS) {\r\n      return this.noDivergence();\r\n    }\r\n\r\n    // Bullish divergence: Price makes LL, RSI makes HL\r\n    const priceIsLower = recent.price < old.price;\r\n    const rsiIsHigher = recentRSI > oldRSI;\r\n\r\n    if (priceIsLower && rsiIsHigher) {\r\n      const priceDiff = Math.abs(recent.price - old.price) / old.price * PERCENT_MULTIPLIER;\r\n      const rsiDiff = Math.abs(recentRSI - oldRSI);\r\n\r\n      // Check if differences are significant\r\n      if (priceDiff >= PRICE_DIFF_THRESHOLD && rsiDiff >= RSI_DIFF_THRESHOLD) {\r\n        const strength = this.calculateStrength(priceDiff, rsiDiff);\r\n\r\n        if (strength >= MIN_DIVERGENCE_STRENGTH) {\r\n          return {\r\n            type: DivergenceType.BULLISH,\r\n            strength,\r\n            pricePoints: [old.price, recent.price],\r\n            rsiPoints: [oldRSI, recentRSI],\r\n            timePoints: [old.timestamp, recent.timestamp],\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.noDivergence();\r\n  }\r\n\r\n  /**\r\n   * Calculate divergence strength (0-1)\r\n   */\r\n  private calculateStrength(priceDiffPercent: number, rsiDiff: number): number {\r\n    // Strength based on:\r\n    // 1. Price difference (larger = stronger)\r\n    // 2. RSI difference (larger = stronger)\r\n\r\n    // Normalize price diff (0-5% range)\r\n    const priceScore = Math.min(priceDiffPercent / 5, 1);\r\n\r\n    // Normalize RSI diff (0-20 points range)\r\n    const rsiScore = Math.min(rsiDiff / 20, 1);\r\n\r\n    // Average of both scores\r\n    const strength = (priceScore + rsiScore) / 2;\r\n\r\n    return Math.min(Math.max(strength, 0), 1); // Clamp to 0-1\r\n  }\r\n\r\n  /**\r\n   * Return \"no divergence\" result\r\n   */\r\n  private noDivergence(): Divergence {\r\n    return {\r\n      type: DivergenceType.NONE,\r\n      strength: 0,\r\n      pricePoints: [0, 0],\r\n      rsiPoints: [0, 0],\r\n      timePoints: [0, 0],\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\engulfing-pattern.detector.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":61,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":61,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":65,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":65,"endColumn":50},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":195,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":195,"endColumn":46},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":199,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":199,"endColumn":24}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Engulfing Pattern Detector\r\n *\r\n * Detects bullish and bearish engulfing candlestick patterns.\r\n * These are strong reversal signals when a candle's body completely\r\n * engulfs the previous candle's body.\r\n *\r\n * Bullish Engulfing:\r\n *  |‚ñë|     Red (bearish) candle\r\n * |‚ñì‚ñì‚ñì|    Green (bullish) candle ENGULFS red ‚Üí LONG signal\r\n *\r\n * Bearish Engulfing:\r\n *  |‚ñì|     Green (bullish) candle\r\n * |‚ñë‚ñë‚ñë|    Red (bearish) candle ENGULFS green ‚Üí SHORT signal\r\n */\r\n\r\nimport { Candle, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum EngulfingPatternType {\r\n  BULLISH_ENGULFING = 'BULLISH_ENGULFING',\r\n  BEARISH_ENGULFING = 'BEARISH_ENGULFING',\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface EngulfingPattern {\r\n  detected: boolean;\r\n  type: EngulfingPatternType;\r\n  direction: 'LONG' | 'SHORT';\r\n  confidence: number; // 0-100%\r\n  engulfingRatio: number; // How much bigger current body is (1.0 = same, 2.0 = 2x)\r\n  prevCandle: Candle;\r\n  currentCandle: Candle;\r\n  explanation: string;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BASE_CONFIDENCE = PERCENTAGE_THRESHOLDS.VERY_HIGH; // Base confidence for detected pattern\r\nconst MIN_ENGULFING_RATIO = MULTIPLIERS.NEUTRAL; // Current body must be at least same size as prev\r\n\r\n// ============================================================================\r\n// ENGULFING PATTERN DETECTOR\r\n// ============================================================================\r\n\r\nexport class EngulfingPatternDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect engulfing pattern from last 2 candles\r\n   * @param candles - Array of candles (minimum 2 required)\r\n   * @returns EngulfingPattern result\r\n   */\r\n  detect(candles: Candle[]): EngulfingPattern {\r\n    if (candles.length < 2) {\r\n      return this.noPattern('Not enough candles (need 2)');\r\n    }\r\n\r\n    const prevCandle = candles[candles.length - 2];\r\n    const currentCandle = candles[candles.length - 1];\r\n\r\n    // Try bullish engulfing\r\n    const bullishEngulfing = this.detectBullishEngulfing(prevCandle, currentCandle);\r\n    if (bullishEngulfing.detected) {\r\n      return bullishEngulfing;\r\n    }\r\n\r\n    // Try bearish engulfing\r\n    const bearishEngulfing = this.detectBearishEngulfing(prevCandle, currentCandle);\r\n    if (bearishEngulfing.detected) {\r\n      return bearishEngulfing;\r\n    }\r\n\r\n    return this.noPattern('No engulfing pattern detected');\r\n  }\r\n\r\n  /**\r\n   * Detect Bullish Engulfing\r\n   * Previous candle: bearish (close < open)\r\n   * Current candle: bullish (close > open) and ENGULFS previous\r\n   */\r\n  private detectBullishEngulfing(prev: Candle, current: Candle): EngulfingPattern {\r\n    // 1. Check previous candle is bearish\r\n    const prevIsBearish = prev.close < prev.open;\r\n    if (!prevIsBearish) {\r\n      return this.noPattern('Previous candle not bearish');\r\n    }\r\n\r\n    // 2. Check current candle is bullish\r\n    const currentIsBullish = current.close > current.open;\r\n    if (!currentIsBullish) {\r\n      return this.noPattern('Current candle not bullish');\r\n    }\r\n\r\n    // 3. Check engulfing: current body engulfs previous body\r\n    const prevBody = Math.abs(prev.close - prev.open);\r\n    const currentBody = Math.abs(current.close - current.open);\r\n\r\n    // Current open should be at or below previous close\r\n    // Current close should be at or above previous open\r\n    const engulfs = current.open <= prev.close && current.close >= prev.open;\r\n\r\n    if (!engulfs) {\r\n      return this.noPattern('Current candle does not engulf previous');\r\n    }\r\n\r\n    // 4. Calculate engulfing ratio\r\n    const engulfingRatio = currentBody / prevBody;\r\n    if (engulfingRatio < MIN_ENGULFING_RATIO) {\r\n      return this.noPattern(`Engulfing ratio too small: ${engulfingRatio.toFixed(DECIMAL_PLACES.PERCENT)}`);\r\n    }\r\n\r\n    // 5. Calculate confidence based on engulfing ratio\r\n    const confidence = this.calculateConfidence(engulfingRatio);\r\n\r\n    return {\r\n      detected: true,\r\n      type: EngulfingPatternType.BULLISH_ENGULFING,\r\n      direction: 'LONG',\r\n      confidence,\r\n      engulfingRatio,\r\n      prevCandle: prev,\r\n      currentCandle: current,\r\n      explanation: `Bullish Engulfing: ${engulfingRatio.toFixed(DECIMAL_PLACES.PERCENT)}x bigger, confidence ${confidence.toFixed(0)}%`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect Bearish Engulfing\r\n   * Previous candle: bullish (close > open)\r\n   * Current candle: bearish (close < open) and ENGULFS previous\r\n   */\r\n  private detectBearishEngulfing(prev: Candle, current: Candle): EngulfingPattern {\r\n    // 1. Check previous candle is bullish\r\n    const prevIsBullish = prev.close > prev.open;\r\n    if (!prevIsBullish) {\r\n      return this.noPattern('Previous candle not bullish');\r\n    }\r\n\r\n    // 2. Check current candle is bearish\r\n    const currentIsBearish = current.close < current.open;\r\n    if (!currentIsBearish) {\r\n      return this.noPattern('Current candle not bearish');\r\n    }\r\n\r\n    // 3. Check engulfing: current body engulfs previous body\r\n    const prevBody = Math.abs(prev.close - prev.open);\r\n    const currentBody = Math.abs(current.close - current.open);\r\n\r\n    // Current open should be at or above previous close\r\n    // Current close should be at or below previous open\r\n    const engulfs = current.open >= prev.close && current.close <= prev.open;\r\n\r\n    if (!engulfs) {\r\n      return this.noPattern('Current candle does not engulf previous');\r\n    }\r\n\r\n    // 4. Calculate engulfing ratio\r\n    const engulfingRatio = currentBody / prevBody;\r\n    if (engulfingRatio < MIN_ENGULFING_RATIO) {\r\n      return this.noPattern(`Engulfing ratio too small: ${engulfingRatio.toFixed(DECIMAL_PLACES.PERCENT)}`);\r\n    }\r\n\r\n    // 5. Calculate confidence based on engulfing ratio\r\n    const confidence = this.calculateConfidence(engulfingRatio);\r\n\r\n    return {\r\n      detected: true,\r\n      type: EngulfingPatternType.BEARISH_ENGULFING,\r\n      direction: 'SHORT',\r\n      confidence,\r\n      engulfingRatio,\r\n      prevCandle: prev,\r\n      currentCandle: current,\r\n      explanation: `Bearish Engulfing: ${engulfingRatio.toFixed(DECIMAL_PLACES.PERCENT)}x bigger, confidence ${confidence.toFixed(0)}%`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence based on engulfing ratio\r\n   * Bigger engulfing = higher confidence\r\n   */\r\n  private calculateConfidence(engulfingRatio: number): number {\r\n    // Base confidence: 60%\r\n    let confidence = BASE_CONFIDENCE;\r\n\r\n    // Bonus for larger engulfing\r\n    // 1.5x = +10%, 2.0x = +20%, 3.0x = +40%\r\n    const bonus = (engulfingRatio - 1.0) * 20;\r\n    confidence += bonus;\r\n\r\n    // Cap at 100%\r\n    return Math.min(100, confidence);\r\n  }\r\n\r\n  /**\r\n   * Return no pattern result\r\n   */\r\n  private noPattern(reason: string): EngulfingPattern {\r\n    return {\r\n      detected: false,\r\n      type: EngulfingPatternType.NONE,\r\n      direction: 'LONG',\r\n      confidence: 0,\r\n      engulfingRatio: 0,\r\n      prevCandle: {} as Candle,\r\n      currentCandle: {} as Candle,\r\n      explanation: reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\entry.scanner.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENTAGE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":60},{"ruleId":"complexity","severity":1,"message":"Async method 'scan' has a complexity of 72. Maximum allowed is 10.","line":90,"column":13,"nodeType":"FunctionExpression","messageId":"complex","endLine":481,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":115,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":115,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":115,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":115,"endColumn":50},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":141,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":141,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[5632,5664],"text":"((this.config.priceAction?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[5632,5664],"text":"((this.config.priceAction?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":163,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":163,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6562,6579],"text":"(liquidityAnalysis != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":167,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":167,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6727,6737],"text":"(divergence != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":188,"column":21,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":188,"endColumn":48,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7520,7529],"text":"TrendBias.BULLISH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":209,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":209,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":232,"column":21,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":232,"endColumn":48,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[9155,9164],"text":"TrendBias.BEARISH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":254,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":254,"endColumn":24},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":292,"column":55,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":292,"endColumn":85,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11808,11838],"text":"((liquidityAnalysis?.recentSweep) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":297,"column":22,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":297,"endColumn":48,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[12067,12073],"text":"SweepDirection.DOWN"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":298,"column":25,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":298,"endColumn":52,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[12118,12127],"text":"TrendBias.BULLISH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":299,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":299,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.80.","line":308,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":308,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":316,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":316,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[13004,13008],"text":"SweepDirection.UP"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":317,"column":25,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":317,"endColumn":52,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[13053,13062],"text":"TrendBias.BEARISH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":318,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":318,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.80.","line":328,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":328,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":363,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":363,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[14788,14820],"text":"(this.config.priceAction?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[14788,14820],"text":"(this.config.priceAction?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":365,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":365,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14862,14872],"text":"(divergence != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.10.","line":366,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":80},{"ruleId":"brace-style","severity":2,"message":"Closing curly brace does not appear on the same line as the subsequent block.","line":376,"column":9,"nodeType":"Punctuator","messageId":"nextLineClose","endLine":376,"endColumn":10},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":379,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":70},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":386,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":386,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15825,15840],"text":"(chochBos?.event) != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.10.","line":387,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":387,"endColumn":70},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":401,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":401,"endColumn":79},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":408,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":408,"endColumn":30},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (382). Maximum allowed is 300.","line":411,"column":1,"nodeType":null,"messageId":"exceed","endLine":505,"endColumn":1},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'blockedBy' is defined but never used. Allowed unused args must match /^_/u.","line":490,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":490,"endColumn":24}],"suppressedMessages":[],"errorCount":29,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Entry Scanner\r\n *\r\n * Analyzes ENTRY timeframe (1m) for precise entry signals.\r\n * Uses TradingContext from ContextAnalyzer as a filter.\r\n *\r\n * Logic:\r\n * 1. Check if context is valid\r\n * 2. Look for entry patterns on 1m (RSI, EMA, ZigZag, etc.)\r\n * 3. Generate entry signal with TP/SL levels\r\n */\r\n\r\nimport {\r\n  EntrySignal,\r\n  TradingContext,\r\n  SignalDirection,\r\n  TimeframeRole,\r\n  LoggerService,\r\n  TakeProfit,\r\n  SwingPoint,\r\n  CHoCHBoSDetection,\r\n  StructureDirection,\r\n} from '../types';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { RSIIndicator } from '../indicators/rsi.indicator';\r\nimport { EMAIndicator } from '../indicators/ema.indicator';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { LiquidityDetector, LiquidityAnalysis } from './liquidity.detector';\r\nimport { DivergenceDetector, Divergence, DivergenceType } from './divergence.detector';\r\nimport { MarketStructureAnalyzer } from './market-structure.analyzer';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface EntryScannerConfig {\r\n  rsiPeriod: number;\r\n  fastEmaPeriod: number;\r\n  slowEmaPeriod: number;\r\n  zigzagDepth: number;\r\n  rsiOversold: number; // RSI < this = oversold (potential LONG)\r\n  rsiOverbought: number; // RSI > this = overbought (potential SHORT)\r\n  stopLossPercent: number;\r\n  takeProfits: Array<{ level: number; percent: number; sizePercent: number }>;\r\n  // Price Action options\r\n  priceAction?: {\r\n    enabled: boolean;\r\n    requireLiquiditySweep?: boolean; // Require sweep for PA entries\r\n    divergenceBoost?: number; // Confidence boost for divergence (default: 0.10)\r\n    chochBoost?: number; // Confidence boost for CHoCH (default: 0.10)\r\n    liquiditySweepBoost?: number; // Confidence boost for sweep (default: PERCENTAGE_THRESHOLDS.VERY_LOW)\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// ENTRY SCANNER\r\n// ============================================================================\r\n\r\nexport class EntryScanner {\r\n  private rsi: RSIIndicator;\r\n  private emaFast: EMAIndicator;\r\n  private emaSlow: EMAIndicator;\r\n  private zigzag: ZigZagIndicator;\r\n  private liquidityDetector: LiquidityDetector;\r\n  private divergenceDetector: DivergenceDetector;\r\n  private structureAnalyzer: MarketStructureAnalyzer;\r\n\r\n  // RSI history for divergence detection (timestamp -> RSI value)\r\n  private rsiHistory: Map<number, number> = new Map();\r\n\r\n  constructor(\r\n    private config: EntryScannerConfig,\r\n    private candleProvider: CandleProvider,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.rsi = new RSIIndicator(config.rsiPeriod);\r\n    this.emaFast = new EMAIndicator(config.fastEmaPeriod);\r\n    this.emaSlow = new EMAIndicator(config.slowEmaPeriod);\r\n    this.zigzag = new ZigZagIndicator(config.zigzagDepth);\r\n    this.liquidityDetector = new LiquidityDetector(logger);\r\n    this.divergenceDetector = new DivergenceDetector(logger);\r\n    this.structureAnalyzer = new MarketStructureAnalyzer(logger);\r\n  }\r\n\r\n  /**\r\n   * Scan ENTRY timeframe for entry signal\r\n   * Returns entry signal if conditions met\r\n   */\r\n  async scan(context: TradingContext): Promise<EntrySignal> {\r\n    const timestamp = Date.now();\r\n\r\n    // Check for invalid context (works for both HARD_BLOCK and WEIGHT_BASED modes)\r\n    // In HARD_BLOCK: isValidContext = false means hard blocked\r\n    // In WEIGHT_BASED: overallModifier = 0 means effectively blocked\r\n    if (!context.isValidContext || context.overallModifier === 0) {\r\n      this.logger.info('‚ö†Ô∏è Context is invalid or blocked', {\r\n        isValidContext: context.isValidContext,\r\n        overallModifier: context.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        blockedBy: context.blockedBy,\r\n        warnings: context.warnings,\r\n      });\r\n      return this.noEntry(\r\n        timestamp,\r\n        context,\r\n        context.blockedBy.length > 0\r\n          ? `Blocked by: ${context.blockedBy.join(', ')}`\r\n          : 'Insufficient context data',\r\n        context.blockedBy,\r\n      );\r\n    }\r\n\r\n    // Get ENTRY candles (1m)\r\n    const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n    if (!entryCandles || entryCandles.length < 50) {\r\n      this.logger.warn('Not enough ENTRY candles for scanning', {\r\n        count: entryCandles?.length ?? 0,\r\n      });\r\n      return this.noEntry(timestamp, context, 'Insufficient ENTRY data', ['INSUFFICIENT_DATA']);\r\n    }\r\n\r\n    // Calculate indicators on ENTRY timeframe\r\n    const rsiValue = this.rsi.calculate(entryCandles);\r\n    const emaFastValue = this.emaFast.calculate(entryCandles);\r\n    const emaSlowValue = this.emaSlow.calculate(entryCandles);\r\n    const currentPrice = entryCandles[entryCandles.length - 1].close;\r\n    const currentTimestamp = entryCandles[entryCandles.length - 1].timestamp;\r\n\r\n    // Store RSI in history for divergence detection\r\n    this.rsiHistory.set(currentTimestamp, rsiValue);\r\n\r\n    // Calculate ZigZag swing points\r\n    const { swingHighs, swingLows } = this.zigzag.findSwingPoints(entryCandles);\r\n    const swingPoints: SwingPoint[] = [...swingHighs, ...swingLows].sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n    // Price Action analysis (if enabled)\r\n    let liquidityAnalysis: LiquidityAnalysis | null = null;\r\n    let divergence: Divergence | null = null;\r\n    let chochBos: CHoCHBoSDetection | null = null;\r\n\r\n    if (this.config.priceAction?.enabled && swingPoints.length > 0) {\r\n      // Liquidity analysis\r\n      liquidityAnalysis = this.liquidityDetector.analyze(swingPoints, entryCandles, currentTimestamp);\r\n\r\n      // Divergence detection\r\n      divergence = this.divergenceDetector.detect(swingPoints, this.rsiHistory);\r\n\r\n      // CHoCH/BoS detection (returns CHoCHBoSDetection with hasEvent, event properties)\r\n      const detection = this.structureAnalyzer.detectCHoCHBoS(\r\n        swingHighs,\r\n        swingLows,\r\n        currentPrice,\r\n      );\r\n      chochBos = detection.hasEvent ? detection : null;\r\n    }\r\n\r\n    this.logger.info('üîç Entry Scan', {\r\n      rsi: rsiValue.toFixed(DECIMAL_PLACES.PERCENT),\r\n      emaFast: emaFastValue.toFixed(DECIMAL_PLACES.PRICE),\r\n      emaSlow: emaSlowValue.toFixed(DECIMAL_PLACES.PRICE),\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      swingPoints: swingPoints.length,\r\n      ...(liquidityAnalysis && {\r\n        liquidityZones: liquidityAnalysis.zones.length,\r\n        recentSweep: liquidityAnalysis.recentSweep?.detected,\r\n      }),\r\n      ...(divergence && divergence.type !== DivergenceType.NONE && {\r\n        divergence: divergence.type,\r\n        divergenceStrength: divergence.strength.toFixed(DECIMAL_PLACES.PERCENT),\r\n      }),\r\n    });\r\n\r\n    // Entry logic: Two patterns\r\n    // Pattern 1: Classic Reversal (RSI oversold/overbought)\r\n    // Pattern 2: Liquidity Sweep Reversal (Price Action)\r\n\r\n    let direction = SignalDirection.HOLD;\r\n    let confidence = 0;\r\n    let reason = '';\r\n    let patternType = '';\r\n\r\n    // ========================================================================\r\n    // PATTERN 1: Classic Reversal (existing logic)\r\n    // ========================================================================\r\n\r\n    // Check LONG conditions\r\n    const longConditions = {\r\n      trendBullish: context.trend === 'BULLISH',\r\n      rsiOversold: rsiValue < this.config.rsiOversold,\r\n      emaFastAboveSlow: emaFastValue > emaSlowValue,\r\n    };\r\n\r\n    this.logger.info('üìä Pattern 1 - LONG Check', {\r\n      trend: context.trend,\r\n      rsi: rsiValue.toFixed(DECIMAL_PLACES.PERCENT),\r\n      rsiThreshold: this.config.rsiOversold,\r\n      emaFast: emaFastValue.toFixed(DECIMAL_PLACES.PRICE),\r\n      emaSlow: emaSlowValue.toFixed(DECIMAL_PLACES.PRICE),\r\n      conditions: longConditions,\r\n    });\r\n\r\n    // LONG: RSI oversold + Fast EMA > Slow EMA + Context trend is BULLISH\r\n    if (\r\n      longConditions.trendBullish &&\r\n      longConditions.rsiOversold &&\r\n      longConditions.emaFastAboveSlow\r\n    ) {\r\n      direction = SignalDirection.LONG;\r\n      confidence = 0.75; // Base confidence\r\n      patternType = 'CLASSIC_REVERSAL';\r\n      reason = `LONG: RSI oversold (${rsiValue.toFixed(DECIMAL_PLACES.PERCENT)}), EMA bullish crossover`;\r\n      this.logger.info('‚úÖ LONG Pattern 1 matched!', { confidence, reason });\r\n    } else {\r\n      const blockedBy = [];\r\n      if (!longConditions.trendBullish) {\r\n        blockedBy.push('TREND_NOT_BULLISH');\r\n      }\r\n      if (!longConditions.rsiOversold) {\r\n        blockedBy.push(`RSI_NOT_OVERSOLD(${rsiValue.toFixed(DECIMAL_PLACES.PERCENT)}>${this.config.rsiOversold})`);\r\n      }\r\n      if (!longConditions.emaFastAboveSlow) {\r\n        blockedBy.push('EMA_NOT_BULLISH');\r\n      }\r\n\r\n      if (blockedBy.length > 0) {\r\n        this.logger.info('‚ùå LONG Pattern 1 blocked', { blockedBy });\r\n      }\r\n    }\r\n\r\n    // Check SHORT conditions\r\n    const shortConditions = {\r\n      trendBearish: context.trend === 'BEARISH',\r\n      rsiOverbought: rsiValue > this.config.rsiOverbought,\r\n      emaFastBelowSlow: emaFastValue < emaSlowValue,\r\n    };\r\n\r\n    this.logger.info('üìä Pattern 1 - SHORT Check', {\r\n      trend: context.trend,\r\n      rsi: rsiValue.toFixed(DECIMAL_PLACES.PERCENT),\r\n      rsiThreshold: this.config.rsiOverbought,\r\n      emaFast: emaFastValue.toFixed(DECIMAL_PLACES.PRICE),\r\n      emaSlow: emaSlowValue.toFixed(DECIMAL_PLACES.PRICE),\r\n      conditions: shortConditions,\r\n    });\r\n\r\n    // SHORT: RSI overbought + Fast EMA < Slow EMA + Context trend is BEARISH\r\n    if (\r\n      direction === SignalDirection.HOLD && // Only if LONG didn't match\r\n      shortConditions.trendBearish &&\r\n      shortConditions.rsiOverbought &&\r\n      shortConditions.emaFastBelowSlow\r\n    ) {\r\n      direction = SignalDirection.SHORT;\r\n      confidence = 0.75; // Base confidence\r\n      patternType = 'CLASSIC_REVERSAL';\r\n      reason = `SHORT: RSI overbought (${rsiValue.toFixed(DECIMAL_PLACES.PERCENT)}), EMA bearish crossover`;\r\n      this.logger.info('‚úÖ SHORT Pattern 1 matched!', { confidence, reason });\r\n    } else if (direction === SignalDirection.HOLD) {\r\n      const blockedBy = [];\r\n      if (!shortConditions.trendBearish) {\r\n        blockedBy.push('TREND_NOT_BEARISH');\r\n      }\r\n      if (!shortConditions.rsiOverbought) {\r\n        blockedBy.push(`RSI_NOT_OVERBOUGHT(${rsiValue.toFixed(DECIMAL_PLACES.PERCENT)}<${this.config.rsiOverbought})`);\r\n      }\r\n      if (!shortConditions.emaFastBelowSlow) {\r\n        blockedBy.push('EMA_NOT_BEARISH');\r\n      }\r\n\r\n      if (blockedBy.length > 0) {\r\n        this.logger.info('‚ùå SHORT Pattern 1 blocked', { blockedBy });\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // PATTERN 2: Liquidity Sweep Reversal (Price Action - NEW!)\r\n    // ========================================================================\r\n    if (direction === SignalDirection.HOLD) {\r\n      const pattern2Enabled = this.config.priceAction?.enabled ?? false;\r\n      const hasSweep = liquidityAnalysis?.recentSweep?.detected ?? false;\r\n      const isFakeout = liquidityAnalysis?.recentSweep?.isFakeout ?? false;\r\n\r\n      this.logger.info('üìä Pattern 2 - Liquidity Sweep Check', {\r\n        enabled: pattern2Enabled,\r\n        hasSweep,\r\n        isFakeout,\r\n        sweepDirection: liquidityAnalysis?.recentSweep?.direction,\r\n        sweepPrice: liquidityAnalysis?.recentSweep?.sweepPrice?.toFixed(DECIMAL_PLACES.PRICE),\r\n        sweepStrength: liquidityAnalysis?.recentSweep?.strength?.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      if (pattern2Enabled && hasSweep && isFakeout && liquidityAnalysis?.recentSweep) {\r\n        const sweep = liquidityAnalysis.recentSweep;\r\n\r\n        // LONG: Downward sweep (support fakeout) + BULLISH trend + RSI not overbought\r\n        const longSweepConditions = {\r\n          sweepDown: sweep.direction === 'DOWN',\r\n          trendBullish: context.trend === 'BULLISH',\r\n          rsiNotOverbought: rsiValue < 70,\r\n        };\r\n\r\n        this.logger.info('üìä Pattern 2 - LONG Sweep Check', longSweepConditions);\r\n\r\n        if (longSweepConditions.sweepDown &&\r\n            longSweepConditions.trendBullish &&\r\n            longSweepConditions.rsiNotOverbought) {\r\n          direction = SignalDirection.LONG;\r\n          confidence = 0.80; // Higher base confidence for liquidity sweep!\r\n          patternType = 'LIQUIDITY_SWEEP';\r\n          reason = `LONG: Liquidity sweep fakeout at ${sweep.sweepPrice.toFixed(DECIMAL_PLACES.PRICE)}, RSI ${rsiValue.toFixed(DECIMAL_PLACES.PERCENT)}`;\r\n          this.logger.info('‚úÖ LONG Pattern 2 matched!', { confidence, reason });\r\n        }\r\n\r\n        // SHORT: Upward sweep (resistance fakeout) + BEARISH trend + RSI not oversold\r\n        const shortSweepConditions = {\r\n          sweepUp: sweep.direction === 'UP',\r\n          trendBearish: context.trend === 'BEARISH',\r\n          rsiNotOversold: rsiValue > 30,\r\n        };\r\n\r\n        this.logger.info('üìä Pattern 2 - SHORT Sweep Check', shortSweepConditions);\r\n\r\n        if (direction === SignalDirection.HOLD && // Only if LONG sweep didn't match\r\n            shortSweepConditions.sweepUp &&\r\n            shortSweepConditions.trendBearish &&\r\n            shortSweepConditions.rsiNotOversold) {\r\n          direction = SignalDirection.SHORT;\r\n          confidence = 0.80; // Higher base confidence for liquidity sweep!\r\n          patternType = 'LIQUIDITY_SWEEP';\r\n          reason = `SHORT: Liquidity sweep fakeout at ${sweep.sweepPrice.toFixed(DECIMAL_PLACES.PRICE)}, RSI ${rsiValue.toFixed(DECIMAL_PLACES.PERCENT)}`;\r\n          this.logger.info('‚úÖ SHORT Pattern 2 matched!', { confidence, reason });\r\n        }\r\n      } else {\r\n        const blockedBy = [];\r\n        if (!pattern2Enabled) {\r\n          blockedBy.push('PATTERN_2_DISABLED');\r\n        }\r\n        if (!hasSweep) {\r\n          blockedBy.push('NO_LIQUIDITY_SWEEP');\r\n        }\r\n        if (hasSweep && !isFakeout) {\r\n          blockedBy.push('SWEEP_NOT_FAKEOUT');\r\n        }\r\n\r\n        if (blockedBy.length > 0) {\r\n          this.logger.info('‚ùå Pattern 2 blocked', { blockedBy });\r\n        }\r\n      }\r\n    }\r\n\r\n    // No pattern found\r\n    if (direction === SignalDirection.HOLD) {\r\n      return this.noEntry(timestamp, context, 'No entry pattern found', ['NO_ENTRY_PATTERN']);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Apply Price Action boosts to confidence\r\n    // ========================================================================\r\n\r\n    let priceActionBoosts = 0;\r\n    const boostDetails: string[] = [];\r\n\r\n    if (this.config.priceAction?.enabled) {\r\n      // Divergence boost\r\n      if (divergence && divergence.type !== DivergenceType.NONE) {\r\n        const divergenceBoost = this.config.priceAction.divergenceBoost ?? 0.10;\r\n\r\n        // Check if divergence aligns with signal direction\r\n        if (\r\n          (direction === SignalDirection.LONG && divergence.type === DivergenceType.BULLISH) ||\r\n          (direction === SignalDirection.SHORT && divergence.type === DivergenceType.BEARISH)\r\n        ) {\r\n          const boost = divergenceBoost * divergence.strength;\r\n          priceActionBoosts += boost;\r\n          boostDetails.push(`Divergence: +${(boost * PERCENT_MULTIPLIER).toFixed(1)}%`);\r\n        }\r\n        // Penalty if divergence opposes signal\r\n        else {\r\n          const penalty = divergenceBoost * divergence.strength * 0.5;\r\n          priceActionBoosts -= penalty;\r\n          boostDetails.push(`Divergence conflict: -${(penalty * PERCENT_MULTIPLIER).toFixed(1)}%`);\r\n        }\r\n      }\r\n\r\n      // CHoCH/BoS boost\r\n      if (chochBos?.event) {\r\n        const chochBoost = this.config.priceAction.chochBoost ?? 0.10;\r\n\r\n        // Check if CHoCH aligns with signal direction\r\n        if (\r\n          (direction === SignalDirection.LONG && chochBos.event.direction === StructureDirection.BULLISH) ||\r\n          (direction === SignalDirection.SHORT && chochBos.event.direction === StructureDirection.BEARISH)\r\n        ) {\r\n          priceActionBoosts += chochBoost;\r\n          boostDetails.push(`${chochBos.event.type}: +${(chochBoost * PERCENT_MULTIPLIER).toFixed(1)}%`);\r\n        }\r\n      }\r\n\r\n      // Liquidity sweep boost (already in base confidence, but log it)\r\n      if (patternType === 'LIQUIDITY_SWEEP') {\r\n        const sweepBoost = this.config.priceAction.liquiditySweepBoost ?? 0.15;\r\n        boostDetails.push(`Liquidity Sweep: +${(sweepBoost * PERCENT_MULTIPLIER).toFixed(1)}% (in base)`);\r\n      }\r\n    }\r\n\r\n    // Apply boosts to confidence\r\n    confidence += priceActionBoosts;\r\n    confidence = Math.max(0.3, Math.min(1.0, confidence)); // Clamp to 0.3-1.0\r\n\r\n    // Apply context modifiers to confidence (weight-based system)\r\n    const finalConfidence = confidence * context.overallModifier;\r\n\r\n    this.logger.info('üìà Confidence calculation', {\r\n      patternType,\r\n      baseConfidence: (confidence - priceActionBoosts).toFixed(DECIMAL_PLACES.PERCENT),\r\n      priceActionBoosts: priceActionBoosts > 0 ? `+${priceActionBoosts.toFixed(DECIMAL_PLACES.PERCENT)}` : priceActionBoosts.toFixed(DECIMAL_PLACES.PERCENT),\r\n      boostDetails: boostDetails.length > 0 ? boostDetails : undefined,\r\n      adjustedConfidence: confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      contextModifier: context.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n      finalConfidence: finalConfidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      warnings: context.warnings,\r\n    });\r\n\r\n    // Check minimum confidence threshold\r\n    const MIN_CONFIDENCE = MULTIPLIERS.HALF; // Can be configurable\r\n    if (finalConfidence < MIN_CONFIDENCE) {\r\n      this.logger.info('‚ùå Entry blocked by low confidence', {\r\n        finalConfidence: finalConfidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n        minRequired: MIN_CONFIDENCE,\r\n        warnings: context.warnings,\r\n      });\r\n      return this.noEntry(\r\n        timestamp,\r\n        context,\r\n        `Low confidence: ${finalConfidence.toFixed(DECIMAL_PLACES.PERCENT)} < ${MIN_CONFIDENCE}`,\r\n        ['LOW_CONFIDENCE'],\r\n      );\r\n    }\r\n\r\n    // Calculate TP/SL\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const stopLoss = isLong\r\n      ? currentPrice * (1 - this.config.stopLossPercent / PERCENT_MULTIPLIER)\r\n      : currentPrice * (1 + this.config.stopLossPercent / PERCENT_MULTIPLIER);\r\n\r\n    const takeProfits: TakeProfit[] = this.config.takeProfits.map(tp => ({\r\n      level: tp.level,\r\n      price: isLong\r\n        ? currentPrice * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n        : currentPrice * (1 - tp.percent / PERCENT_MULTIPLIER),\r\n      sizePercent: tp.sizePercent,\r\n      percent: tp.percent,\r\n      hit: false,\r\n    }));\r\n\r\n    this.logger.info('‚úÖ Entry signal found!', {\r\n      direction,\r\n      patternType,\r\n      baseConfidence: (confidence - priceActionBoosts).toFixed(DECIMAL_PLACES.PERCENT),\r\n      priceActionBoosts: priceActionBoosts !== 0 ? `${priceActionBoosts > 0 ? '+' : ''}${priceActionBoosts.toFixed(DECIMAL_PLACES.PERCENT)}` : undefined,\r\n      adjustedConfidence: confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      finalConfidence: finalConfidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      modifier: context.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n      reason,\r\n      entryPrice: currentPrice,\r\n      stopLoss,\r\n      warnings: context.warnings,\r\n    });\r\n\r\n    return {\r\n      timestamp,\r\n      shouldEnter: true,\r\n      direction,\r\n      confidence: finalConfidence, // Use modified confidence\r\n      reason,\r\n      entryPrice: currentPrice,\r\n      stopLoss,\r\n      takeProfits,\r\n      context,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Helper: return no entry signal\r\n   */\r\n  private noEntry(\r\n    timestamp: number,\r\n    context: TradingContext,\r\n    reason: string,\r\n    blockedBy: string[],\r\n  ): EntrySignal {\r\n    return {\r\n      timestamp,\r\n      shouldEnter: false,\r\n      direction: SignalDirection.HOLD,\r\n      confidence: 0,\r\n      reason,\r\n      entryPrice: 0,\r\n      stopLoss: 0,\r\n      takeProfits: [],\r\n      context,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\flag-pattern.detector.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SwingPointType' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":36},{"ruleId":"complexity","severity":1,"message":"Method 'detect' has a complexity of 12. Maximum allowed is 10.","line":49,"column":9,"nodeType":"FunctionExpression","messageId":"complex","endLine":101,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":50,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -10.","line":54,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":54,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":58,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":58,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1805,1816],"text":"poleResult == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":66,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":66,"endColumn":33},{"ruleId":"max-len","severity":1,"message":"This line has a length of 134. Maximum allowed is 120.","line":70,"column":1,"nodeType":"Program","messageId":"max","endLine":70,"endColumn":135},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":83,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":83,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":83,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":83,"endColumn":110},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.03.","line":86,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":87,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":94,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":94,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":122,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":122,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":126,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":90},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.6.","line":127,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":40}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS, TIME_UNITS } from '../constants';\r\n/**\r\n * Flag/Pennant Pattern Detector\r\n *\r\n * Detects flag and pennant continuation patterns.\r\n * Both patterns consist of: strong move (flagpole) + consolidation (flag/pennant).\r\n *\r\n * Bull Flag:\r\n *      |  ___     Strong upward move (pole)\r\n *      | |   |    + rectangular consolidation (flag)\r\n *      | |___|    ‚Üí LONG on break\r\n *\r\n * Pennant:\r\n *      |  /\\      Strong move (pole)\r\n *      | /  \\     + triangular consolidation (pennant)\r\n *      |/____\\    ‚Üí Direction = pole direction\r\n */\r\n\r\nimport { SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\nexport enum FlagPatternType {\r\n  BULL_FLAG = 'BULL_FLAG',\r\n  BEAR_FLAG = 'BEAR_FLAG',\r\n  BULL_PENNANT = 'BULL_PENNANT',\r\n  BEAR_PENNANT = 'BEAR_PENNANT',\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface FlagPattern {\r\n  detected: boolean;\r\n  type: FlagPatternType;\r\n  direction: 'LONG' | 'SHORT';\r\n  confidence: number;\r\n  poleHeight: number;\r\n  target: number;\r\n  stopLoss: number;\r\n  consolidationPoints: SwingPoint[];\r\n  explanation: string;\r\n}\r\n\r\nconst BASE_CONFIDENCE = CONFIDENCE_THRESHOLDS.MODERATE;\r\nconst MIN_POLE_HEIGHT_PERCENT = 2.0; // Pole must be strong (2%+ move)\r\nconst MAX_CONSOLIDATION_BARS = PERCENTAGE_THRESHOLDS.VERY_HIGH; // Consolidation should be brief\r\nconst MIN_CONSOLIDATION_BARS = 10;\r\n\r\nexport class FlagPatternDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  detect(swingPoints: SwingPoint[]): FlagPattern {\r\n    if (swingPoints.length < 6) {\r\n      return this.noPattern('Not enough swing points');\r\n    }\r\n\r\n    const recent = swingPoints.slice(-10);\r\n\r\n    // Detect flagpole (strong directional move)\r\n    const poleResult = this.detectPole(recent);\r\n    if (!poleResult) {\r\n      return this.noPattern('No strong flagpole detected');\r\n    }\r\n\r\n    const { direction, poleHeight, poleStart, poleEnd } = poleResult;\r\n\r\n    // Detect consolidation after pole\r\n    const consolidation = recent.slice(recent.indexOf(poleEnd) + 1);\r\n    if (consolidation.length < 3) {\r\n      return this.noPattern('No consolidation after pole');\r\n    }\r\n\r\n    const consolidationMinutes = (consolidation[consolidation.length - 1].timestamp - consolidation[0].timestamp) / TIME_UNITS.MINUTE;\r\n    if (consolidationMinutes < MIN_CONSOLIDATION_BARS || consolidationMinutes > MAX_CONSOLIDATION_BARS) {\r\n      return this.noPattern('Consolidation timespan invalid');\r\n    }\r\n\r\n    // Check if consolidation is rectangular (flag) or triangular (pennant)\r\n    const isTriangular = this.isTriangularConsolidation(consolidation);\r\n    const type = direction === 'LONG'\r\n      ? (isTriangular ? FlagPatternType.BULL_PENNANT : FlagPatternType.BULL_FLAG)\r\n      : (isTriangular ? FlagPatternType.BEAR_PENNANT : FlagPatternType.BEAR_FLAG);\r\n\r\n    const currentPrice = consolidation[consolidation.length - 1].price;\r\n    const target = direction === 'LONG' ? currentPrice + poleHeight : currentPrice - poleHeight;\r\n    const stopLoss = direction === 'LONG' ? currentPrice - poleHeight * 0.3 : currentPrice + poleHeight * 0.3;\r\n\r\n    let confidence = BASE_CONFIDENCE;\r\n    if (poleHeight / poleStart.price > 0.03) {\r\n      confidence += 10;\r\n    } // Strong pole bonus\r\n\r\n    return {\r\n      detected: true,\r\n      type,\r\n      direction,\r\n      confidence: Math.min(100, confidence),\r\n      poleHeight,\r\n      target,\r\n      stopLoss,\r\n      consolidationPoints: consolidation,\r\n      explanation: `${type}: pole ${poleHeight.toFixed(DECIMAL_PLACES.PERCENT)}, consolidation ${consolidation.length} points`,\r\n    };\r\n  }\r\n\r\n  private detectPole(points: SwingPoint[]): { direction: 'LONG' | 'SHORT'; poleHeight: number; poleStart: SwingPoint; poleEnd: SwingPoint } | null {\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n      const start = points[i];\r\n      const end = points[i + 1];\r\n      const heightPercent = Math.abs((end.price - start.price) / start.price) * PERCENT_MULTIPLIER;\r\n\r\n      if (heightPercent >= MIN_POLE_HEIGHT_PERCENT) {\r\n        return {\r\n          direction: end.price > start.price ? 'LONG' : 'SHORT',\r\n          poleHeight: Math.abs(end.price - start.price),\r\n          poleStart: start,\r\n          poleEnd: end,\r\n        };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private isTriangularConsolidation(points: SwingPoint[]): boolean {\r\n    if (points.length < 4) {\r\n      return false;\r\n    }\r\n    const firstRange = Math.abs(points[1].price - points[0].price);\r\n    const lastRange = Math.abs(points[points.length - 1].price - points[points.length - 2].price);\r\n    return lastRange < firstRange * 0.6; // Range narrowing = triangular\r\n  }\r\n\r\n  private noPattern(reason: string): FlagPattern {\r\n    return {\r\n      detected: false,\r\n      type: FlagPatternType.NONE,\r\n      direction: 'LONG',\r\n      confidence: 0,\r\n      poleHeight: 0,\r\n      target: 0,\r\n      stopLoss: 0,\r\n      consolidationPoints: [],\r\n      explanation: reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\flat-market.detector.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CONFIDENCE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 180.","line":44,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":44,"endColumn":41},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":220,"column":25,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":220,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":238,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":238,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -10.","line":251,"column":41,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":251,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":252,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":252,"endColumn":34}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Flat Market Detector\r\n *\r\n * Multi-factor system to detect ranging/neutral markets with high confidence.\r\n * Used to switch between single-TP (flat) and multi-TP (trending) strategies.\r\n *\r\n * Detection uses 6 weighted factors:\r\n * - EMA Distance (20 points): Tight EMA convergence indicates flat\r\n * - ATR Volatility (20 points): Low volatility indicates consolidation\r\n * - Price Range (15 points): Narrow price range indicates range-bound\r\n * - ZigZag Pattern (20 points): Equal highs/lows indicate flat structure\r\n * - EMA Slope (15 points): Flat EMA slope indicates no directional bias\r\n * - Volume Distribution (10 points): Even volume indicates no directional flow\r\n *\r\n * Total confidence score: 0-100 points\r\n * - 80-100: High confidence FLAT ‚Üí use single TP @ 0.5%\r\n * - 50-79: Uncertain ‚Üí cautious multi-TP\r\n * - 0-49: Confident TREND ‚Üí full multi-TP\r\n */\r\n\r\nimport {\r\n  Candle,\r\n  TradingContext,\r\n  MarketStructure,\r\n  FlatMarketConfig,\r\n  FlatMarketResult,\r\n  FlatMarketFactors,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_EMA_SCORE = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // Max points for EMA distance factor\r\nconst MAX_ATR_SCORE = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // Max points for ATR volatility factor\r\nconst MAX_RANGE_SCORE = 15; // Max points for price range factor\r\nconst MAX_ZIGZAG_SCORE = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // Max points for ZigZag pattern factor\r\nconst MAX_SLOPE_SCORE = 15; // Max points for EMA slope factor\r\nconst MAX_VOLUME_SCORE = 10; // Max points for volume distribution factor\r\n\r\nconst DEFAULT_RANGE_PERIOD = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // Candles to analyze for price range\r\nconst DEGREES_TO_RADIANS = Math.PI / 180; // Conversion factor\r\n\r\n// ============================================================================\r\n// FLAT MARKET DETECTOR\r\n// ============================================================================\r\n\r\nexport class FlatMarketDetector {\r\n  constructor(\r\n    private readonly config: FlatMarketConfig,\r\n    private readonly logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect if market is in flat/ranging state\r\n   * @param candles - Candles array (min 20 for range analysis)\r\n   * @param context - Trading context (from ContextAnalyzer)\r\n   * @param ema20 - EMA20 value\r\n   * @param ema50 - EMA50 value (from context)\r\n   * @returns Flat market result with confidence score\r\n   */\r\n  detect(\r\n    candles: Candle[],\r\n    context: TradingContext,\r\n    ema20: number,\r\n    ema50: number,\r\n  ): FlatMarketResult {\r\n    // Validate inputs\r\n    if (candles.length < DEFAULT_RANGE_PERIOD) {\r\n      this.logger.warn('Insufficient candles for flat market detection', {\r\n        required: DEFAULT_RANGE_PERIOD,\r\n        received: candles.length,\r\n      });\r\n      return this.noDetection('Insufficient data');\r\n    }\r\n\r\n    // 1. EMA Distance (20 points)\r\n    const emaScore = this.checkEMADistance(ema20, ema50);\r\n\r\n    // 2. ATR Volatility (20 points)\r\n    const atrScore = this.checkATRVolatility(context.atrPercent);\r\n\r\n    // 3. Price Range (15 points)\r\n    const rangeScore = this.checkPriceRange(candles, DEFAULT_RANGE_PERIOD);\r\n\r\n    // 4. ZigZag Pattern (20 points)\r\n    const zigzagScore = this.checkZigZagPattern(context.marketStructure);\r\n\r\n    // 5. EMA Slope (15 points)\r\n    const slopeScore = this.checkEMASlope(candles);\r\n\r\n    // 6. Volume Distribution (10 points)\r\n    const volumeScore = this.checkVolumeDistribution(candles);\r\n\r\n    // Calculate total confidence\r\n    const confidence = emaScore + atrScore + rangeScore + zigzagScore + slopeScore + volumeScore;\r\n\r\n    // Decision: threshold or above = FLAT\r\n    const isFlat = confidence >= this.config.flatThreshold;\r\n\r\n    // Build explanation for logs\r\n    const factors: FlatMarketFactors = {\r\n      emaDistance: emaScore,\r\n      atrVolatility: atrScore,\r\n      priceRange: rangeScore,\r\n      zigzagPattern: zigzagScore,\r\n      emaSlope: slopeScore,\r\n      volumeDistribution: volumeScore,\r\n    };\r\n\r\n    const explanation = this.buildExplanation(factors);\r\n\r\n    this.logger.info(isFlat ? '‚ö° FLAT market detected' : 'üìà TRENDING market', {\r\n      confidence: confidence.toFixed(1) + '%',\r\n      threshold: this.config.flatThreshold + '%',\r\n      decision: isFlat ? 'FLAT' : 'TREND',\r\n    });\r\n\r\n    this.logger.debug('Flat market factors breakdown', factors as unknown as Record<string, unknown>);\r\n\r\n    return {\r\n      isFlat,\r\n      confidence,\r\n      factors,\r\n      explanation,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE FACTOR CHECKS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Check EMA distance (convergence)\r\n   * Tight EMA convergence (EMA20 ‚âà EMA50) indicates flat market\r\n   * @param ema20 - EMA20 value\r\n   * @param ema50 - EMA50 value\r\n   * @returns Score 0-20 points\r\n   */\r\n  private checkEMADistance(ema20: number, ema50: number): number {\r\n    // Calculate distance as percentage\r\n    const distance = Math.abs(ema20 - ema50) / ema50;\r\n    const distancePercent = distance * PERCENT_MULTIPLIER;\r\n\r\n    // Score: 20 points if distance <= threshold, linear decrease to 0\r\n    // Example: threshold 0.3%, distance 0.1% ‚Üí 20 pts, distance 0.6% ‚Üí 0 pts\r\n    if (distancePercent <= this.config.emaThreshold) {\r\n      return MAX_EMA_SCORE; // Perfect convergence\r\n    }\r\n\r\n    // Linear decrease: 20 * (1 - excess / threshold)\r\n    const excess = distancePercent - this.config.emaThreshold;\r\n    const score = MAX_EMA_SCORE * Math.max(0, 1 - excess / this.config.emaThreshold);\r\n\r\n    return Math.round(score);\r\n  }\r\n\r\n  /**\r\n   * Check ATR volatility (low volatility = flat)\r\n   * Low ATR relative to price indicates consolidation\r\n   * @param atrPercent - ATR as percentage of price (from TradingContext)\r\n   * @returns Score 0-20 points\r\n   */\r\n  private checkATRVolatility(atrPercent: number): number {\r\n    // Score: 20 points if ATR <= threshold, linear decrease to 0\r\n    // Example: threshold 1.5%, ATR 1.0% ‚Üí 20 pts, ATR 3.0% ‚Üí 0 pts\r\n    if (atrPercent <= this.config.atrThreshold) {\r\n      return MAX_ATR_SCORE; // Very low volatility\r\n    }\r\n\r\n    const excess = atrPercent - this.config.atrThreshold;\r\n    const score = MAX_ATR_SCORE * Math.max(0, 1 - excess / this.config.atrThreshold);\r\n\r\n    return Math.round(score);\r\n  }\r\n\r\n  /**\r\n   * Check price range (narrow range = flat)\r\n   * Narrow high-low range over period indicates range-bound market\r\n   * @param candles - Candles array\r\n   * @param period - Number of candles to analyze\r\n   * @returns Score 0-15 points\r\n   */\r\n  private checkPriceRange(candles: Candle[], period: number): number {\r\n    // Get last N candles\r\n    const recentCandles = candles.slice(-period);\r\n    if (recentCandles.length < period) {\r\n      return 0; // Insufficient data\r\n    }\r\n\r\n    // Find highest high and lowest low\r\n    const high = Math.max(...recentCandles.map((c) => c.high));\r\n    const low = Math.min(...recentCandles.map((c) => c.low));\r\n    const close = recentCandles[recentCandles.length - 1].close;\r\n\r\n    // Calculate range as percentage of close\r\n    const rangePercent = ((high - low) / close) * PERCENT_MULTIPLIER;\r\n\r\n    // Score: 15 points if range <= threshold, linear decrease to 0\r\n    // Example: threshold 1.0%, range 0.5% ‚Üí 15 pts, range 2.0% ‚Üí 0 pts\r\n    if (rangePercent <= this.config.rangeThreshold) {\r\n      return MAX_RANGE_SCORE; // Very tight range\r\n    }\r\n\r\n    const excess = rangePercent - this.config.rangeThreshold;\r\n    const score = MAX_RANGE_SCORE * Math.max(0, 1 - excess / this.config.rangeThreshold);\r\n\r\n    return Math.round(score);\r\n  }\r\n\r\n  /**\r\n   * Check ZigZag pattern (Equal Highs/Lows = flat)\r\n   * EH (Equal High) or EL (Equal Low) patterns indicate flat structure\r\n   * @param marketStructure - Market structure from TradingContext\r\n   * @returns Score 0-20 points\r\n   */\r\n  private checkZigZagPattern(marketStructure: MarketStructure | null): number {\r\n    if (marketStructure == null) {\r\n      return 0; // No ZigZag data\r\n    }\r\n\r\n    // Check for flat patterns (EH or EL)\r\n    if (marketStructure === MarketStructure.EQUAL_HIGH || marketStructure === MarketStructure.EQUAL_LOW) {\r\n      return MAX_ZIGZAG_SCORE; // Confirmed flat structure\r\n    }\r\n\r\n    // Check for weak trend patterns (might be forming flat)\r\n    // Give partial credit if not strong trend\r\n    const strongTrendPatterns = [\r\n      MarketStructure.HIGHER_HIGH,\r\n      MarketStructure.HIGHER_LOW,\r\n      MarketStructure.LOWER_LOW,\r\n      MarketStructure.LOWER_HIGH,\r\n    ];\r\n    if (!strongTrendPatterns.includes(marketStructure)) {\r\n      return Math.round(MAX_ZIGZAG_SCORE * 0.3); // Partial credit\r\n    }\r\n\r\n    return 0; // Strong trend pattern, not flat\r\n  }\r\n\r\n  /**\r\n   * Check EMA slope (flat slope = no directional bias)\r\n   * Flat EMA50 slope indicates no clear direction\r\n   * @param candles - Candles array\r\n   * @returns Score 0-15 points\r\n   */\r\n  private checkEMASlope(candles: Candle[]): number {\r\n    const recentCandles = candles.slice(-10); // Last 10 candles for slope\r\n    if (recentCandles.length < 10) {\r\n      return 0; // Insufficient data\r\n    }\r\n\r\n    // Simple linear regression for EMA50 slope\r\n    // Use close prices as proxy for EMA50 direction\r\n    const prices = recentCandles.map((c) => c.close);\r\n    const n = prices.length;\r\n\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n    let sumXY = 0;\r\n    let sumX2 = 0;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      sumX += i;\r\n      sumY += prices[i];\r\n      sumXY += i * prices[i];\r\n      sumX2 += i * i;\r\n    }\r\n\r\n    // Calculate slope (rise/run)\r\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\r\n\r\n    // Convert slope to angle in degrees\r\n    const angle = Math.atan(Math.abs(slope) * n) / DEGREES_TO_RADIANS;\r\n\r\n    // Score: 15 points if angle <= threshold, linear decrease to 0\r\n    // Example: threshold 5¬∞, angle 2¬∞ ‚Üí 15 pts, angle 10¬∞ ‚Üí 0 pts\r\n    if (angle <= this.config.slopeThreshold) {\r\n      return MAX_SLOPE_SCORE; // Flat slope\r\n    }\r\n\r\n    const excess = angle - this.config.slopeThreshold;\r\n    const score = MAX_SLOPE_SCORE * Math.max(0, 1 - excess / this.config.slopeThreshold);\r\n\r\n    return Math.round(score);\r\n  }\r\n\r\n  /**\r\n   * Check volume distribution (even volume = no directional flow)\r\n   * Even buy/sell volume distribution indicates no directional bias\r\n   * @param candles - Candles array\r\n   * @returns Score 0-10 points\r\n   */\r\n  private checkVolumeDistribution(candles: Candle[]): number {\r\n    const recentCandles = candles.slice(-DEFAULT_RANGE_PERIOD);\r\n    if (recentCandles.length < DEFAULT_RANGE_PERIOD) {\r\n      return 0; // Insufficient data\r\n    }\r\n\r\n    // Calculate bullish vs bearish volume\r\n    let bullishVolume = 0;\r\n    let bearishVolume = 0;\r\n\r\n    for (const candle of recentCandles) {\r\n      if (candle.close > candle.open) {\r\n        bullishVolume += candle.volume;\r\n      } else {\r\n        bearishVolume += candle.volume;\r\n      }\r\n    }\r\n\r\n    const totalVolume = bullishVolume + bearishVolume;\r\n    if (totalVolume === 0) {\r\n      return 0; // No volume data\r\n    }\r\n\r\n    // Calculate ratio (closer to 1.0 = more even distribution)\r\n    const ratio = Math.min(bullishVolume, bearishVolume) / Math.max(bullishVolume, bearishVolume);\r\n\r\n    // Score: 10 points if ratio >= CONFIDENCE_THRESHOLDS.MODERATE (fairly even), linear decrease\r\n    // Example: ratio 0.9 ‚Üí 10 pts, ratio 0.5 ‚Üí 5 pts, ratio 0.0 ‚Üí 0 pts\r\n    const score = MAX_VOLUME_SCORE * ratio;\r\n\r\n    return Math.round(score);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Build human-readable explanation of detection factors\r\n   * @param factors - Individual factor scores\r\n   * @returns Explanation string for logs\r\n   */\r\n  private buildExplanation(factors: FlatMarketFactors): string {\r\n    const lines: string[] = [];\r\n\r\n    lines.push(`EMA Distance: ${factors.emaDistance}/${MAX_EMA_SCORE}`);\r\n    lines.push(`ATR Volatility: ${factors.atrVolatility}/${MAX_ATR_SCORE}`);\r\n    lines.push(`Price Range: ${factors.priceRange}/${MAX_RANGE_SCORE}`);\r\n    lines.push(`ZigZag Pattern: ${factors.zigzagPattern}/${MAX_ZIGZAG_SCORE}`);\r\n    lines.push(`EMA Slope: ${factors.emaSlope}/${MAX_SLOPE_SCORE}`);\r\n    lines.push(`Volume: ${factors.volumeDistribution}/${MAX_VOLUME_SCORE}`);\r\n\r\n    return lines.join(', ');\r\n  }\r\n\r\n  /**\r\n   * Return default \"no detection\" result\r\n   * Used when insufficient data or errors occur\r\n   * @param reason - Reason for no detection\r\n   * @returns FlatMarketResult with confidence 0\r\n   */\r\n  private noDetection(reason: string): FlatMarketResult {\r\n    return {\r\n      isFlat: false,\r\n      confidence: 0,\r\n      factors: {\r\n        emaDistance: 0,\r\n        atrVolatility: 0,\r\n        priceRange: 0,\r\n        zigzagPattern: 0,\r\n        emaSlope: 0,\r\n        volumeDistribution: 0,\r\n      },\r\n      explanation: `No detection: ${reason}`,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\liquidity.detector.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 7.","line":73,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":73,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":73,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":73,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":73,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":125,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":125,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":127,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":139,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":139,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5266,5277],"text":"sweepCandle != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":156,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":156,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5921,5932],"text":"sweepCandle != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":216,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":216,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7722,7734],"text":"existingZone != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":260,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":260,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":333,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":333,"endColumn":41}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Liquidity Detector\r\n *\r\n * Detects liquidity zones (support/resistance levels where stop losses cluster)\r\n * and liquidity sweeps (false breakouts designed to trigger stops).\r\n *\r\n * Key concepts:\r\n * - Liquidity Zone: Price level with multiple swing points (stops cluster here)\r\n * - Liquidity Sweep: Price briefly breaks a zone to trigger stops, then reverses\r\n * - Fakeout: Sweep followed by quick reversal (strong signal)\r\n *\r\n * Based on Smart Money Concepts (SMC) and institutional trading patterns.\r\n */\r\n\r\nimport { Candle, SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum LiquidityZoneType {\r\n  SUPPORT = 'SUPPORT',\r\n  RESISTANCE = 'RESISTANCE',\r\n}\r\n\r\nexport enum SweepDirection {\r\n  UP = 'UP',\r\n  DOWN = 'DOWN',\r\n}\r\n\r\n/**\r\n * Liquidity zone - price level where stops cluster\r\n */\r\nexport interface LiquidityZone {\r\n  price: number;                    // Price level\r\n  type: LiquidityZoneType;          // SUPPORT or RESISTANCE\r\n  touches: number;                  // Number of swing points at this level\r\n  strength: number;                 // 0-1 (based on touches and recency)\r\n  lastTouch: number;                // Timestamp of last touch\r\n  swingPoints: SwingPoint[];        // Swing points that created this zone\r\n}\r\n\r\n/**\r\n * Liquidity sweep - false breakout to trigger stops\r\n */\r\nexport interface LiquiditySweep {\r\n  detected: boolean;                // Was a sweep detected?\r\n  sweepPrice: number;               // Price where sweep occurred\r\n  zonePrice: number;                // Original zone price that was swept\r\n  direction: SweepDirection;        // UP or DOWN\r\n  isFakeout: boolean;               // Did price reverse after sweep?\r\n  strength: number;                 // 0-1 (confidence in sweep)\r\n  timestamp: number;                // When sweep occurred\r\n}\r\n\r\n/**\r\n * Liquidity analysis result\r\n */\r\nexport interface LiquidityAnalysis {\r\n  zones: LiquidityZone[];           // All detected zones\r\n  strongZones: LiquidityZone[];     // High-strength zones only\r\n  recentSweep: LiquiditySweep | null; // Most recent sweep (if any)\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PRICE_TOLERANCE_PERCENT = 0.3;  // 0.3% - swing points within this range are same zone\r\nconst MIN_TOUCHES_FOR_ZONE = 2;       // Minimum swing points to form a zone\r\nconst STRONG_ZONE_STRENGTH = CONFIDENCE_THRESHOLDS.LOW;     // Strength threshold for \"strong\" zones\r\nconst MAX_ZONE_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days - zones older than this are ignored\r\nconst SWEEP_TOLERANCE_PERCENT = MULTIPLIERS.HALF;  // 0.5% - how far beyond zone is a sweep\r\nconst FAKEOUT_REVERSAL_PERCENT = 0.3; // 0.3% - reversal needed to confirm fakeout\r\nconst RECENT_TOUCHES_WEIGHT = CONFIDENCE_THRESHOLDS.MODERATE;    // Weight for recent touches in strength calculation\r\nconst OLD_TOUCHES_WEIGHT = 0.3;       // Weight for old touches\r\n\r\n// ============================================================================\r\n// LIQUIDITY DETECTOR\r\n// ============================================================================\r\n\r\nexport class LiquidityDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect liquidity zones from swing points\r\n   */\r\n  detectZones(swingPoints: SwingPoint[], currentTime: number = Date.now()): LiquidityZone[] {\r\n    if (swingPoints.length < MIN_TOUCHES_FOR_ZONE) {\r\n      return [];\r\n    }\r\n\r\n    // Group swing points by price level (with tolerance)\r\n    const zones = this.groupSwingPointsIntoZones(swingPoints);\r\n\r\n    // Calculate strength for each zone\r\n    const zonesWithStrength = zones.map(zone =>\r\n      this.calculateZoneStrength(zone, currentTime),\r\n    );\r\n\r\n    // Filter out weak/old zones\r\n    const validZones = zonesWithStrength.filter(zone =>\r\n      zone.touches >= MIN_TOUCHES_FOR_ZONE &&\r\n      (currentTime - zone.lastTouch) <= MAX_ZONE_AGE_MS,\r\n    );\r\n\r\n    // Sort by strength (strongest first)\r\n    validZones.sort((a, b) => b.strength - a.strength);\r\n\r\n    this.logger.debug('Liquidity zones detected', {\r\n      totalZones: validZones.length,\r\n      strongZones: validZones.filter(z => z.strength >= STRONG_ZONE_STRENGTH).length,\r\n    });\r\n\r\n    return validZones;\r\n  }\r\n\r\n  /**\r\n   * Detect liquidity sweep (false breakout)\r\n   */\r\n  detectSweep(\r\n    candles: Candle[],\r\n    zones: LiquidityZone[],\r\n    lookbackCandles: number = 10,\r\n  ): LiquiditySweep | null {\r\n    if (candles.length < 2 || zones.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const recentCandles = candles.slice(-lookbackCandles);\r\n    const latestCandle = candles[candles.length - 1];\r\n\r\n    // Check each zone for potential sweep\r\n    for (const zone of zones) {\r\n      // Check for upward sweep (resistance break)\r\n      if (zone.type === LiquidityZoneType.RESISTANCE) {\r\n        const sweepCandle = this.findSweepCandle(recentCandles, zone.price, true);\r\n        if (sweepCandle) {\r\n          const isFakeout = this.isFakeout(sweepCandle, latestCandle, zone.price, true);\r\n          return {\r\n            detected: true,\r\n            sweepPrice: sweepCandle.high,\r\n            zonePrice: zone.price,\r\n            direction: SweepDirection.UP,\r\n            isFakeout,\r\n            strength: this.calculateSweepStrength(zone, isFakeout),\r\n            timestamp: sweepCandle.timestamp,\r\n          };\r\n        }\r\n      }\r\n\r\n      // Check for downward sweep (support break)\r\n      if (zone.type === LiquidityZoneType.SUPPORT) {\r\n        const sweepCandle = this.findSweepCandle(recentCandles, zone.price, false);\r\n        if (sweepCandle) {\r\n          const isFakeout = this.isFakeout(sweepCandle, latestCandle, zone.price, false);\r\n          return {\r\n            detected: true,\r\n            sweepPrice: sweepCandle.low,\r\n            zonePrice: zone.price,\r\n            direction: SweepDirection.DOWN,\r\n            isFakeout,\r\n            strength: this.calculateSweepStrength(zone, isFakeout),\r\n            timestamp: sweepCandle.timestamp,\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Analyze liquidity (zones + sweeps)\r\n   */\r\n  analyze(\r\n    swingPoints: SwingPoint[],\r\n    candles: Candle[],\r\n    currentTime: number = Date.now(),\r\n  ): LiquidityAnalysis {\r\n    const zones = this.detectZones(swingPoints, currentTime);\r\n    const strongZones = zones.filter(z => z.strength >= STRONG_ZONE_STRENGTH);\r\n    const recentSweep = this.detectSweep(candles, zones);\r\n\r\n    this.logger.debug('Liquidity analysis complete', {\r\n      totalZones: zones.length,\r\n      strongZones: strongZones.length,\r\n      sweepDetected: recentSweep !== null,\r\n      sweepIsFakeout: recentSweep?.isFakeout ?? false,\r\n    });\r\n\r\n    return {\r\n      zones,\r\n      strongZones,\r\n      recentSweep,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE HELPERS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Group swing points into zones based on price proximity\r\n   */\r\n  private groupSwingPointsIntoZones(swingPoints: SwingPoint[]): LiquidityZone[] {\r\n    const zones: LiquidityZone[] = [];\r\n\r\n    for (const point of swingPoints) {\r\n      // Find existing zone within tolerance\r\n      const existingZone = zones.find(zone =>\r\n        this.isPriceInZone(point.price, zone.price),\r\n      );\r\n\r\n      if (existingZone) {\r\n        // Add to existing zone\r\n        existingZone.swingPoints.push(point);\r\n        existingZone.touches++;\r\n        existingZone.lastTouch = Math.max(existingZone.lastTouch, point.timestamp);\r\n        // Update zone price to average\r\n        existingZone.price = this.calculateAveragePrice(existingZone.swingPoints);\r\n      } else {\r\n        // Create new zone\r\n        zones.push({\r\n          price: point.price,\r\n          type: point.type === SwingPointType.HIGH ? LiquidityZoneType.RESISTANCE : LiquidityZoneType.SUPPORT,\r\n          touches: 1,\r\n          strength: 0, // Will be calculated later\r\n          lastTouch: point.timestamp,\r\n          swingPoints: [point],\r\n        });\r\n      }\r\n    }\r\n\r\n    return zones;\r\n  }\r\n\r\n  /**\r\n   * Check if price is within zone tolerance\r\n   */\r\n  private isPriceInZone(price: number, zonePrice: number): boolean {\r\n    const tolerance = zonePrice * (PRICE_TOLERANCE_PERCENT / PERCENT_MULTIPLIER);\r\n    return Math.abs(price - zonePrice) <= tolerance;\r\n  }\r\n\r\n  /**\r\n   * Calculate average price from swing points\r\n   */\r\n  private calculateAveragePrice(swingPoints: SwingPoint[]): number {\r\n    const sum = swingPoints.reduce((acc, point) => acc + point.price, 0);\r\n    return sum / swingPoints.length;\r\n  }\r\n\r\n  /**\r\n   * Calculate zone strength (0-1)\r\n   */\r\n  private calculateZoneStrength(zone: LiquidityZone, currentTime: number): LiquidityZone {\r\n    // Factor 1: Number of touches (more = stronger)\r\n    const touchScore = Math.min(zone.touches / 5, 1); // Cap at 5 touches = MULTIPLIERS.NEUTRAL\r\n\r\n    // Factor 2: Recency (newer = stronger)\r\n    const ageMs = currentTime - zone.lastTouch;\r\n    const recencyScore = Math.max(0, 1 - (ageMs / MAX_ZONE_AGE_MS));\r\n\r\n    // Combine factors\r\n    const strength = (touchScore * RECENT_TOUCHES_WEIGHT) + (recencyScore * OLD_TOUCHES_WEIGHT);\r\n\r\n    return {\r\n      ...zone,\r\n      strength: Math.min(Math.max(strength, 0), 1), // Clamp to 0-1\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find candle that swept a zone\r\n   */\r\n  private findSweepCandle(\r\n    candles: Candle[],\r\n    zonePrice: number,\r\n    isUpwardSweep: boolean,\r\n  ): Candle | null {\r\n    const sweepThreshold = zonePrice * (1 + (isUpwardSweep ? 1 : -1) * SWEEP_TOLERANCE_PERCENT / PERCENT_MULTIPLIER);\r\n\r\n    for (let i = candles.length - 1; i >= 0; i--) {\r\n      const candle = candles[i];\r\n\r\n      if (isUpwardSweep) {\r\n        // Upward sweep: high breaks above resistance\r\n        if (candle.high >= sweepThreshold) {\r\n          return candle;\r\n        }\r\n      } else {\r\n        // Downward sweep: low breaks below support\r\n        if (candle.low <= sweepThreshold) {\r\n          return candle;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if sweep is a fakeout (reversal after break)\r\n   */\r\n  private isFakeout(\r\n    sweepCandle: Candle,\r\n    latestCandle: Candle,\r\n    zonePrice: number,\r\n    isUpwardSweep: boolean,\r\n  ): boolean {\r\n    const reversalThreshold = zonePrice * (FAKEOUT_REVERSAL_PERCENT / PERCENT_MULTIPLIER);\r\n\r\n    if (isUpwardSweep) {\r\n      // Upward sweep fakeout: price broke up but now closed back below zone\r\n      return latestCandle.close < (zonePrice - reversalThreshold);\r\n    } else {\r\n      // Downward sweep fakeout: price broke down but now closed back above zone\r\n      return latestCandle.close > (zonePrice + reversalThreshold);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sweep strength (0-1)\r\n   */\r\n  private calculateSweepStrength(zone: LiquidityZone, isFakeout: boolean): number {\r\n    // Base strength from zone strength\r\n    let strength = zone.strength;\r\n\r\n    // Boost if fakeout (strong reversal signal)\r\n    if (isFakeout) {\r\n      strength = Math.min(strength * 1.5, 1.0); // 50% boost, capped at 1.0\r\n    }\r\n\r\n    return strength;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\market-structure.analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Candle' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StructurePoint' is defined but never used. Allowed unused vars must match /^_/u.","line":40,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":25},{"ruleId":"complexity","severity":1,"message":"Method 'identifyStructure' has a complexity of 11. Maximum allowed is 10.","line":63,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":99,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":65,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":65,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":65,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":65,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":70,"column":37,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":70,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":71,"column":35,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":71,"endColumn":37},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":74,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":74,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":86,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":110,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":110,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":114,"column":37,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":114,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":115,"column":35,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":115,"endColumn":37},{"ruleId":"complexity","severity":1,"message":"Method 'detectCHoCHBoS' has a complexity of 15. Maximum allowed is 10.","line":236,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":341,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":243,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":243,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":243,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":243,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":255,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":255,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":256,"column":51,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":256,"endColumn":53},{"ruleId":"brace-style","severity":2,"message":"Closing curly brace does not appear on the same line as the subsequent block.","line":272,"column":7,"nodeType":"Punctuator","messageId":"nextLineClose","endLine":272,"endColumn":8},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":290,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":290,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":290,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":290,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9057,9066],"text":"(newEvent == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -2.","line":291,"column":48,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":291,"endColumn":50},{"ruleId":"brace-style","severity":2,"message":"Closing curly brace does not appear on the same line as the subsequent block.","line":307,"column":7,"nodeType":"Punctuator","messageId":"nextLineClose","endLine":307,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":325,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":325,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10345,10353],"text":"newEvent != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'type' is defined but never used. Allowed unused args must match /^_/u.","line":349,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":349,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Method 'calculateConfidenceModifier' has a complexity of 14. Maximum allowed is 10.","line":365,"column":38,"nodeType":"FunctionExpression","messageId":"complex","endLine":395,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":369,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":369,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11580,11586],"text":"(event == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":369,"column":20,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":369,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.3.","line":383,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":383,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":385,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":385,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.1.","line":389,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":389,"endColumn":19}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Market Structure Analyzer\r\n *\r\n * Analyzes swing points from ZigZag to identify market structure patterns:\r\n * - HH (Higher High) - bullish trend\r\n * - HL (Higher Low) - bullish pullback\r\n * - LH (Lower High) - bearish pullback\r\n * - LL (Lower Low) - bearish trend\r\n * - EH (Equal High) - flat/consolidation\r\n * - EL (Equal Low) - flat/consolidation\r\n *\r\n * This analyzer works with data from ZigZagIndicator and provides\r\n * structural interpretation for trading strategies.\r\n */\r\n\r\nimport {\r\n  SwingPoint,\r\n  SwingPointType,\r\n  MarketStructure,\r\n  TrendBias,\r\n  StructureEvent,\r\n  StructureEventType,\r\n  StructureDirection,\r\n  CHoCHBoSDetection,\r\n  Candle,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst EQUAL_THRESHOLD = 0.001; // 0.1% - threshold for considering prices equal\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface StructurePoint {\r\n  price: number;\r\n  timestamp: number;\r\n  type: SwingPointType;\r\n}\r\n\r\n// ============================================================================\r\n// MARKET STRUCTURE ANALYZER\r\n// ============================================================================\r\n\r\nexport class MarketStructureAnalyzer {\r\n  private currentTrend: TrendBias = TrendBias.NEUTRAL;\r\n  private lastStructureEvent: StructureEvent | null = null;\r\n\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Identify market structure by comparing swing points\r\n   *\r\n   * @param highs - Swing high points from ZigZag\r\n   * @param lows - Swing low points from ZigZag\r\n   * @returns Market structure pattern\r\n   */\r\n  identifyStructure(highs: SwingPoint[], lows: SwingPoint[]): MarketStructure | null {\r\n    // Need at least 2 points to identify structure\r\n    if (highs.length < 2 && lows.length < 2) {\r\n      return null;\r\n    }\r\n\r\n    // Get recent points\r\n    const recentHighs = highs.slice(-2);\r\n    const recentLows = lows.slice(-2);\r\n\r\n    // Determine what structure we can identify\r\n    if (recentHighs.length >= 2) {\r\n      const [prev, current] = recentHighs;\r\n\r\n      if (this.isHigherHigh(current, prev)) {\r\n        return MarketStructure.HIGHER_HIGH;\r\n      } else if (this.isLowerHigh(current, prev)) {\r\n        return MarketStructure.LOWER_HIGH;\r\n      } else if (this.isEqualHigh(current, prev)) {\r\n        return MarketStructure.EQUAL_HIGH;\r\n      }\r\n    }\r\n\r\n    if (recentLows.length >= 2) {\r\n      const [prev, current] = recentLows;\r\n\r\n      if (this.isHigherLow(current, prev)) {\r\n        return MarketStructure.HIGHER_LOW;\r\n      } else if (this.isLowerLow(current, prev)) {\r\n        return MarketStructure.LOWER_LOW;\r\n      } else if (this.isEqualLow(current, prev)) {\r\n        return MarketStructure.EQUAL_LOW;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get last pattern (combination of structure)\r\n   *\r\n   * @param highs - Swing high points\r\n   * @param lows - Swing low points\r\n   * @returns Pattern string\r\n   */\r\n  getLastPattern(highs: SwingPoint[], lows: SwingPoint[]): 'HH_HL' | 'LH_LL' | 'FLAT' | null {\r\n    // Need at least 2 highs and 2 lows\r\n    if (highs.length < 2 || lows.length < 2) {\r\n      return null;\r\n    }\r\n\r\n    const recentHighs = highs.slice(-2);\r\n    const recentLows = lows.slice(-2);\r\n\r\n    const [prevHigh, currentHigh] = recentHighs;\r\n    const [prevLow, currentLow] = recentLows;\r\n\r\n    // Check for HH_HL (bullish trend)\r\n    const hasHH = this.isHigherHigh(currentHigh, prevHigh);\r\n    const hasHL = this.isHigherLow(currentLow, prevLow);\r\n\r\n    if (hasHH && hasHL) {\r\n      return 'HH_HL';\r\n    }\r\n\r\n    // Check for LH_LL (bearish trend)\r\n    const hasLH = this.isLowerHigh(currentHigh, prevHigh);\r\n    const hasLL = this.isLowerLow(currentLow, prevLow);\r\n\r\n    if (hasLH && hasLL) {\r\n      return 'LH_LL';\r\n    }\r\n\r\n    // Check for FLAT\r\n    const hasEH = this.isEqualHigh(currentHigh, prevHigh);\r\n    const hasEL = this.isEqualLow(currentLow, prevLow);\r\n\r\n    if (hasEH || hasEL) {\r\n      return 'FLAT';\r\n    }\r\n\r\n    // Mixed structure - unclear\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get trend bias from structure\r\n   *\r\n   * @param highs - Swing high points\r\n   * @param lows - Swing low points\r\n   * @returns Trend bias\r\n   */\r\n  getTrendBias(highs: SwingPoint[], lows: SwingPoint[]): TrendBias {\r\n    const pattern = this.getLastPattern(highs, lows);\r\n\r\n    switch (pattern) {\r\n    case 'HH_HL':\r\n      return TrendBias.BULLISH;\r\n    case 'LH_LL':\r\n      return TrendBias.BEARISH;\r\n    case 'FLAT':\r\n      return TrendBias.NEUTRAL;\r\n    default:\r\n      return TrendBias.NEUTRAL;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Structure Identification\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if current high is higher than previous high\r\n   */\r\n  private isHigherHigh(current: SwingPoint, previous: SwingPoint): boolean {\r\n    return current.price > previous.price * (1 + EQUAL_THRESHOLD);\r\n  }\r\n\r\n  /**\r\n   * Check if current low is higher than previous low\r\n   */\r\n  private isHigherLow(current: SwingPoint, previous: SwingPoint): boolean {\r\n    return current.price > previous.price * (1 + EQUAL_THRESHOLD);\r\n  }\r\n\r\n  /**\r\n   * Check if current high is lower than previous high\r\n   */\r\n  private isLowerHigh(current: SwingPoint, previous: SwingPoint): boolean {\r\n    return current.price < previous.price * (1 - EQUAL_THRESHOLD);\r\n  }\r\n\r\n  /**\r\n   * Check if current low is lower than previous low\r\n   */\r\n  private isLowerLow(current: SwingPoint, previous: SwingPoint): boolean {\r\n    return current.price < previous.price * (1 - EQUAL_THRESHOLD);\r\n  }\r\n\r\n  /**\r\n   * Check if current high is equal to previous high\r\n   */\r\n  private isEqualHigh(current: SwingPoint, previous: SwingPoint): boolean {\r\n    return (\r\n      Math.abs(current.price - previous.price) / previous.price <= EQUAL_THRESHOLD\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if current low is equal to previous low\r\n   */\r\n  private isEqualLow(current: SwingPoint, previous: SwingPoint): boolean {\r\n    return (\r\n      Math.abs(current.price - previous.price) / previous.price <= EQUAL_THRESHOLD\r\n    );\r\n  }\r\n\r\n  // ============================================================================\r\n  // CHoCH/BoS DETECTION\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect CHoCH (Change of Character) and BoS (Break of Structure) events\r\n   *\r\n   * CHoCH - trend reversal (breaking previous swing)\r\n   * BoS - trend continuation (breaking current swing)\r\n   *\r\n   * @param highs - Swing high points\r\n   * @param lows - Swing low points\r\n   * @param currentPrice - Current market price\r\n   * @param signalDirection - Direction of potential trade signal\r\n   * @returns Detection result with confidence modifier\r\n   */\r\n  detectCHoCHBoS(\r\n    highs: SwingPoint[],\r\n    lows: SwingPoint[],\r\n    currentPrice: number,\r\n    signalDirection?: 'LONG' | 'SHORT',\r\n  ): CHoCHBoSDetection {\r\n    // Need at least 2 swing points to detect structure events\r\n    if (highs.length < 2 && lows.length < 2) {\r\n      return {\r\n        hasEvent: false,\r\n        event: null,\r\n        currentTrend: this.currentTrend,\r\n        confidenceModifier: MULTIPLIERS.NEUTRAL,\r\n      };\r\n    }\r\n\r\n    let newEvent: StructureEvent | null = null;\r\n\r\n    // Check for bullish CHoCH/BoS (uptrend events)\r\n    if (highs.length >= 2) {\r\n      const [prevHigh, currentHigh] = highs.slice(-2);\r\n\r\n      // CHoCH BULLISH: price breaks above previous high during downtrend\r\n      if (\r\n        this.currentTrend === TrendBias.BEARISH &&\r\n        currentPrice > prevHigh.price\r\n      ) {\r\n        newEvent = {\r\n          type: StructureEventType.CHoCH,\r\n          direction: StructureDirection.BULLISH,\r\n          price: currentPrice,\r\n          timestamp: Date.now(),\r\n          strength: this.calculateEventStrength(currentPrice, prevHigh.price, 'break'),\r\n        };\r\n        this.currentTrend = TrendBias.BULLISH;\r\n        this.logger.debug('CHoCH BULLISH detected', { event: newEvent });\r\n      }\r\n      // BoS BULLISH: price breaks above current high during uptrend\r\n      else if (\r\n        this.currentTrend === TrendBias.BULLISH &&\r\n        currentPrice > currentHigh.price\r\n      ) {\r\n        newEvent = {\r\n          type: StructureEventType.BoS,\r\n          direction: StructureDirection.BULLISH,\r\n          price: currentPrice,\r\n          timestamp: Date.now(),\r\n          strength: this.calculateEventStrength(currentPrice, currentHigh.price, 'break'),\r\n        };\r\n        this.logger.debug('BoS BULLISH detected', { event: newEvent });\r\n      }\r\n    }\r\n\r\n    // Check for bearish CHoCH/BoS (downtrend events)\r\n    if (lows.length >= 2 && !newEvent) {\r\n      const [prevLow, currentLow] = lows.slice(-2);\r\n\r\n      // CHoCH BEARISH: price breaks below previous low during uptrend\r\n      if (\r\n        this.currentTrend === TrendBias.BULLISH &&\r\n        currentPrice < prevLow.price\r\n      ) {\r\n        newEvent = {\r\n          type: StructureEventType.CHoCH,\r\n          direction: StructureDirection.BEARISH,\r\n          price: currentPrice,\r\n          timestamp: Date.now(),\r\n          strength: this.calculateEventStrength(currentPrice, prevLow.price, 'break'),\r\n        };\r\n        this.currentTrend = TrendBias.BEARISH;\r\n        this.logger.debug('CHoCH BEARISH detected', { event: newEvent });\r\n      }\r\n      // BoS BEARISH: price breaks below current low during downtrend\r\n      else if (\r\n        this.currentTrend === TrendBias.BEARISH &&\r\n        currentPrice < currentLow.price\r\n      ) {\r\n        newEvent = {\r\n          type: StructureEventType.BoS,\r\n          direction: StructureDirection.BEARISH,\r\n          price: currentPrice,\r\n          timestamp: Date.now(),\r\n          strength: this.calculateEventStrength(currentPrice, currentLow.price, 'break'),\r\n        };\r\n        this.logger.debug('BoS BEARISH detected', { event: newEvent });\r\n      }\r\n    }\r\n\r\n    // Update last event if new event detected\r\n    if (newEvent) {\r\n      this.lastStructureEvent = newEvent;\r\n    }\r\n\r\n    // Calculate confidence modifier based on event alignment with signal\r\n    const confidenceModifier = this.calculateConfidenceModifier(\r\n      this.lastStructureEvent,\r\n      signalDirection,\r\n    );\r\n\r\n    return {\r\n      hasEvent: newEvent !== null,\r\n      event: newEvent,\r\n      currentTrend: this.currentTrend,\r\n      confidenceModifier,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate event strength (0-1) based on break distance\r\n   */\r\n  private calculateEventStrength(\r\n    currentPrice: number,\r\n    brokenLevel: number,\r\n    type: 'break',\r\n  ): number {\r\n    const distance = Math.abs(currentPrice - brokenLevel) / brokenLevel;\r\n    // Normalize: 0.1% = 0.1, 1% = MULTIPLIERS.NEUTRAL\r\n    return Math.min(distance * PERCENT_MULTIPLIER, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence modifier based on CHoCH/BoS alignment with signal\r\n   *\r\n   * From specs:\r\n   * - CHoCH in favor: +30% (+0.3)\r\n   * - CHoCH against: -40 to -50% (-0.4 to -0.5)\r\n   * - BoS in favor: +10% (+0.1)\r\n   * - BoS neutral/against: no penalty\r\n   */\r\n  private calculateConfidenceModifier(\r\n    event: StructureEvent | null,\r\n    signalDirection?: 'LONG' | 'SHORT',\r\n  ): number {\r\n    if (!event || !signalDirection) {\r\n      return 1.0; // No modification\r\n    }\r\n\r\n    const isAligned =\r\n      (signalDirection === 'LONG' && event.direction === StructureDirection.BULLISH) ||\r\n      (signalDirection === 'SHORT' && event.direction === StructureDirection.BEARISH);\r\n\r\n    const isAgainst =\r\n      (signalDirection === 'LONG' && event.direction === StructureDirection.BEARISH) ||\r\n      (signalDirection === 'SHORT' && event.direction === StructureDirection.BULLISH);\r\n\r\n    if (event.type === StructureEventType.CHoCH) {\r\n      if (isAligned) {\r\n        return 1.3; // +30% boost\r\n      } else if (isAgainst) {\r\n        return 0.5; // -50% penalty\r\n      }\r\n    } else if (event.type === StructureEventType.BoS) {\r\n      if (isAligned) {\r\n        return 1.1; // +10% boost\r\n      }\r\n      // BoS against signal: no penalty (trend continuation is less critical)\r\n    }\r\n\r\n    return 1.0; // No modification\r\n  }\r\n\r\n  /**\r\n   * Get current trend\r\n   */\r\n  getCurrentTrend(): TrendBias {\r\n    return this.currentTrend;\r\n  }\r\n\r\n  /**\r\n   * Get last structure event\r\n   */\r\n  getLastStructureEvent(): StructureEvent | null {\r\n    return this.lastStructureEvent;\r\n  }\r\n\r\n  /**\r\n   * Reset trend tracking (useful for testing)\r\n   */\r\n  resetTrend(): void {\r\n    this.currentTrend = TrendBias.NEUTRAL;\r\n    this.lastStructureEvent = null;\r\n  }\r\n\r\n  /**\r\n   * Set current trend (for testing)\r\n   */\r\n  setTrend(trend: TrendBias): void {\r\n    this.currentTrend = trend;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\multi-timeframe-ema.analyzer.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 9.","line":52,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 21.","line":53,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":140,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":140,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4440,4454],"text":"(fastIndicator == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":140,"column":28,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":140,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4458,4472],"text":"(slowIndicator == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Multi-Timeframe EMA Analyzer\r\n *\r\n * Calculates Fast and Slow EMA across multiple timeframes using TimeframeProvider and CandleProvider.\r\n * Supports optional caching of EMA values on candle close.\r\n * Detects EMA crossovers for trend identification.\r\n */\r\n\r\nimport { TimeframeRole, LoggerService } from '../types';\r\nimport { TimeframeProvider } from '../providers/timeframe.provider';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { EMAIndicator } from '../indicators/ema.indicator';\r\n\r\nexport interface EMAValues {\r\n  fast: number;\r\n  slow: number;\r\n}\r\n\r\nexport interface MultiTimeframeEMA {\r\n  entry?: EMAValues; // ENTRY timeframe EMA\r\n  primary: EMAValues; // PRIMARY timeframe EMA (required)\r\n  trend1?: EMAValues; // TREND1 timeframe EMA\r\n  trend2?: EMAValues; // TREND2 timeframe EMA\r\n  context?: EMAValues; // CONTEXT timeframe EMA\r\n}\r\n\r\nexport enum CrossoverType {\r\n  BULLISH = 'BULLISH', // Fast crosses above slow\r\n  BEARISH = 'BEARISH', // Fast crosses below slow\r\n  NONE = 'NONE', // No crossover\r\n}\r\n\r\nexport interface EMACrossover {\r\n  type: CrossoverType;\r\n  fast: number;\r\n  slow: number;\r\n  difference: number; // fast - slow\r\n}\r\n\r\nexport class MultiTimeframeEMAAnalyzer {\r\n  private fastIndicators: Map<TimeframeRole, EMAIndicator> = new Map();\r\n  private slowIndicators: Map<TimeframeRole, EMAIndicator> = new Map();\r\n  private emaCache: Map<TimeframeRole, EMAValues> = new Map();\r\n  private lastCacheUpdate: Map<TimeframeRole, number> = new Map();\r\n  private cacheEnabled: boolean;\r\n\r\n  constructor(\r\n    private timeframeProvider: TimeframeProvider,\r\n    private candleProvider: CandleProvider,\r\n    private logger: LoggerService,\r\n    private fastPeriod: number = 9,\r\n    private slowPeriod: number = 21,\r\n    cacheEnabled: boolean = false,\r\n  ) {\r\n    if (fastPeriod >= slowPeriod) {\r\n      throw new Error(`Fast period (${fastPeriod}) must be less than slow period (${slowPeriod})`);\r\n    }\r\n\r\n    this.cacheEnabled = cacheEnabled;\r\n    this.initializeIndicators();\r\n  }\r\n\r\n  /**\r\n   * Initialize EMA indicators for all enabled timeframes\r\n   */\r\n  private initializeIndicators(): void {\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role] of timeframes) {\r\n      const fastIndicator = new EMAIndicator(this.fastPeriod);\r\n      const slowIndicator = new EMAIndicator(this.slowPeriod);\r\n\r\n      this.fastIndicators.set(role, fastIndicator);\r\n      this.slowIndicators.set(role, slowIndicator);\r\n      this.lastCacheUpdate.set(role, 0);\r\n\r\n      this.logger.debug(`Initialized EMA indicators for ${role}`, {\r\n        fastPeriod: this.fastPeriod,\r\n        slowPeriod: this.slowPeriod,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate EMA for all enabled timeframes\r\n   */\r\n  async calculateAll(): Promise<MultiTimeframeEMA> {\r\n    const result: MultiTimeframeEMA = {\r\n      primary: { fast: 0, slow: 0 }, // Will be set below\r\n    };\r\n\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role] of timeframes) {\r\n      try {\r\n        const ema = await this.calculate(role);\r\n        this.assignEMAToResult(result, role, ema);\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n        this.logger.warn(`Failed to calculate EMA for ${role}`, {\r\n          error: errorMsg,\r\n        });\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate EMA for a specific timeframe\r\n   */\r\n  async calculate(role: TimeframeRole): Promise<EMAValues> {\r\n    // Check cache first (if enabled)\r\n    if (this.cacheEnabled) {\r\n      const cachedEMA = this.emaCache.get(role);\r\n      if (cachedEMA !== undefined) {\r\n        this.logger.debug(`Using cached EMA for ${role}`, {\r\n          fast: cachedEMA.fast,\r\n          slow: cachedEMA.slow,\r\n        });\r\n        return cachedEMA;\r\n      }\r\n    }\r\n\r\n    // Get candles for this timeframe\r\n    const candles = await this.candleProvider.getCandles(role);\r\n\r\n    // Need enough candles for slow EMA\r\n    if (candles.length < this.slowPeriod) {\r\n      throw new Error(\r\n        `Not enough candles for EMA calculation on ${role}. Need ${this.slowPeriod}, got ${candles.length}`,\r\n      );\r\n    }\r\n\r\n    // Get indicators for this timeframe\r\n    const fastIndicator = this.fastIndicators.get(role);\r\n    const slowIndicator = this.slowIndicators.get(role);\r\n\r\n    if (!fastIndicator || !slowIndicator) {\r\n      throw new Error(`EMA indicators not found for ${role}`);\r\n    }\r\n\r\n    // Calculate EMAs\r\n    const fast = fastIndicator.calculate(candles);\r\n    const slow = slowIndicator.calculate(candles);\r\n\r\n    const emaValues: EMAValues = { fast, slow };\r\n\r\n    // Cache the result (if enabled)\r\n    if (this.cacheEnabled) {\r\n      this.emaCache.set(role, emaValues);\r\n      this.lastCacheUpdate.set(role, Date.now());\r\n    }\r\n\r\n    this.logger.debug(`Calculated EMA for ${role}`, {\r\n      fast: fast.toFixed(DECIMAL_PLACES.PERCENT),\r\n      slow: slow.toFixed(DECIMAL_PLACES.PERCENT),\r\n      candles: candles.length,\r\n    });\r\n\r\n    return emaValues;\r\n  }\r\n\r\n  /**\r\n   * Detect EMA crossover for a specific timeframe\r\n   */\r\n  async detectCrossover(role: TimeframeRole): Promise<EMACrossover> {\r\n    const emaValues = await this.calculate(role);\r\n\r\n    const difference = emaValues.fast - emaValues.slow;\r\n    let type = CrossoverType.NONE;\r\n\r\n    if (emaValues.fast > emaValues.slow) {\r\n      type = CrossoverType.BULLISH;\r\n    } else if (emaValues.fast < emaValues.slow) {\r\n      type = CrossoverType.BEARISH;\r\n    }\r\n\r\n    return {\r\n      type,\r\n      fast: emaValues.fast,\r\n      slow: emaValues.slow,\r\n      difference,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect crossovers for all timeframes\r\n   */\r\n  async detectAllCrossovers(): Promise<Map<TimeframeRole, EMACrossover>> {\r\n    const crossovers = new Map<TimeframeRole, EMACrossover>();\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role] of timeframes) {\r\n      try {\r\n        const crossover = await this.detectCrossover(role);\r\n        crossovers.set(role, crossover);\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n        this.logger.warn(`Failed to detect crossover for ${role}`, {\r\n          error: errorMsg,\r\n        });\r\n      }\r\n    }\r\n\r\n    return crossovers;\r\n  }\r\n\r\n  /**\r\n   * Update EMA cache when a candle closes\r\n   * (Only works if caching is enabled)\r\n   */\r\n  onCandleClosed(role: TimeframeRole): void {\r\n    if (!this.cacheEnabled) {\r\n      return;\r\n    }\r\n\r\n    // Invalidate cache for this timeframe\r\n    this.emaCache.delete(role);\r\n\r\n    this.logger.debug(`EMA cache invalidated for ${role} (candle closed)`);\r\n  }\r\n\r\n  /**\r\n   * Assign EMA values to the correct field in result object\r\n   */\r\n  private assignEMAToResult(\r\n    result: MultiTimeframeEMA,\r\n    role: TimeframeRole,\r\n    ema: EMAValues,\r\n  ): void {\r\n    switch (role) {\r\n    case TimeframeRole.ENTRY:\r\n      result.entry = ema;\r\n      break;\r\n    case TimeframeRole.PRIMARY:\r\n      result.primary = ema;\r\n      break;\r\n    case TimeframeRole.TREND1:\r\n      result.trend1 = ema;\r\n      break;\r\n    case TimeframeRole.TREND2:\r\n      result.trend2 = ema;\r\n      break;\r\n    case TimeframeRole.CONTEXT:\r\n      result.context = ema;\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached EMA values for a timeframe (if available)\r\n   */\r\n  getCached(role: TimeframeRole): EMAValues | undefined {\r\n    if (!this.cacheEnabled) {\r\n      return undefined;\r\n    }\r\n\r\n    return this.emaCache.get(role);\r\n  }\r\n\r\n  /**\r\n   * Clear all cached EMA values\r\n   */\r\n  clearCache(): void {\r\n    this.emaCache.clear();\r\n    this.lastCacheUpdate.clear();\r\n    this.logger.debug('EMA cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getCacheStats(): {\r\n    enabled: boolean;\r\n    size: number;\r\n    timeframes: string[];\r\n    } {\r\n    return {\r\n      enabled: this.cacheEnabled,\r\n      size: this.emaCache.size,\r\n      timeframes: Array.from(this.emaCache.keys()).map((r) => r.toString()),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get EMA periods configuration\r\n   */\r\n  getConfig(): { fastPeriod: number; slowPeriod: number } {\r\n    return {\r\n      fastPeriod: this.fastPeriod,\r\n      slowPeriod: this.slowPeriod,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\multi-timeframe-rsi.analyzer.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":32,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":32,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":107,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":107,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3389,3399],"text":"indicator == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Multi-Timeframe RSI Analyzer\r\n *\r\n * Calculates RSI across multiple timeframes using TimeframeProvider and CandleProvider.\r\n * Supports optional caching of RSI values on candle close.\r\n */\r\n\r\nimport { TimeframeRole, LoggerService } from '../types';\r\nimport { TimeframeProvider } from '../providers/timeframe.provider';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { RSIIndicator } from '../indicators/rsi.indicator';\r\n\r\nexport interface MultiTimeframeRSI {\r\n  entry?: number; // ENTRY timeframe RSI\r\n  primary: number; // PRIMARY timeframe RSI (required)\r\n  trend1?: number; // TREND1 timeframe RSI\r\n  trend2?: number; // TREND2 timeframe RSI\r\n  context?: number; // CONTEXT timeframe RSI\r\n}\r\n\r\nexport class MultiTimeframeRSIAnalyzer {\r\n  private rsiIndicators: Map<TimeframeRole, RSIIndicator> = new Map();\r\n  private rsiCache: Map<TimeframeRole, number> = new Map();\r\n  private lastCacheUpdate: Map<TimeframeRole, number> = new Map();\r\n  private cacheEnabled: boolean;\r\n\r\n  constructor(\r\n    private timeframeProvider: TimeframeProvider,\r\n    private candleProvider: CandleProvider,\r\n    private logger: LoggerService,\r\n    private rsiPeriod: number = 14,\r\n    cacheEnabled: boolean = false,\r\n  ) {\r\n    this.cacheEnabled = cacheEnabled;\r\n    this.initializeIndicators();\r\n  }\r\n\r\n  /**\r\n   * Initialize RSI indicators for all enabled timeframes\r\n   */\r\n  private initializeIndicators(): void {\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role] of timeframes) {\r\n      const indicator = new RSIIndicator(this.rsiPeriod);\r\n      this.rsiIndicators.set(role, indicator);\r\n      this.lastCacheUpdate.set(role, 0);\r\n\r\n      this.logger.debug(`Initialized RSI indicator for ${role}`, {\r\n        period: this.rsiPeriod,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate RSI for all enabled timeframes\r\n   */\r\n  async calculateAll(): Promise<MultiTimeframeRSI> {\r\n    const result: MultiTimeframeRSI = {\r\n      primary: 0, // Will be set below\r\n    };\r\n\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role] of timeframes) {\r\n      try {\r\n        const rsi = await this.calculate(role);\r\n        this.assignRSIToResult(result, role, rsi);\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n        this.logger.warn(`Failed to calculate RSI for ${role}`, {\r\n          error: errorMsg,\r\n        });\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate RSI for a specific timeframe\r\n   */\r\n  async calculate(role: TimeframeRole): Promise<number> {\r\n    // Check cache first (if enabled)\r\n    if (this.cacheEnabled) {\r\n      const cachedRSI = this.rsiCache.get(role);\r\n      if (cachedRSI !== undefined) {\r\n        this.logger.debug(`Using cached RSI for ${role}`, { rsi: cachedRSI });\r\n        return cachedRSI;\r\n      }\r\n    }\r\n\r\n    // Get candles for this timeframe\r\n    const candles = await this.candleProvider.getCandles(role);\r\n\r\n    if (candles.length < this.rsiPeriod + 1) {\r\n      throw new Error(\r\n        `Not enough candles for RSI calculation on ${role}. Need ${\r\n          this.rsiPeriod + 1\r\n        }, got ${candles.length}`,\r\n      );\r\n    }\r\n\r\n    // Get indicator for this timeframe\r\n    const indicator = this.rsiIndicators.get(role);\r\n    if (!indicator) {\r\n      throw new Error(`RSI indicator not found for ${role}`);\r\n    }\r\n\r\n    // Calculate RSI\r\n    const rsi = indicator.calculate(candles);\r\n\r\n    // Cache the result (if enabled)\r\n    if (this.cacheEnabled) {\r\n      this.rsiCache.set(role, rsi);\r\n      this.lastCacheUpdate.set(role, Date.now());\r\n    }\r\n\r\n    this.logger.debug(`Calculated RSI for ${role}`, {\r\n      rsi: rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      candles: candles.length,\r\n    });\r\n\r\n    return rsi;\r\n  }\r\n\r\n  /**\r\n   * Update RSI cache when a candle closes\r\n   * (Only works if caching is enabled)\r\n   */\r\n  onCandleClosed(role: TimeframeRole): void {\r\n    if (!this.cacheEnabled) {\r\n      return;\r\n    }\r\n\r\n    // Invalidate cache for this timeframe\r\n    this.rsiCache.delete(role);\r\n\r\n    this.logger.debug(`RSI cache invalidated for ${role} (candle closed)`);\r\n  }\r\n\r\n  /**\r\n   * Assign RSI value to the correct field in result object\r\n   */\r\n  private assignRSIToResult(\r\n    result: MultiTimeframeRSI,\r\n    role: TimeframeRole,\r\n    rsi: number,\r\n  ): void {\r\n    switch (role) {\r\n    case TimeframeRole.ENTRY:\r\n      result.entry = rsi;\r\n      break;\r\n    case TimeframeRole.PRIMARY:\r\n      result.primary = rsi;\r\n      break;\r\n    case TimeframeRole.TREND1:\r\n      result.trend1 = rsi;\r\n      break;\r\n    case TimeframeRole.TREND2:\r\n      result.trend2 = rsi;\r\n      break;\r\n    case TimeframeRole.CONTEXT:\r\n      result.context = rsi;\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached RSI value for a timeframe (if available)\r\n   */\r\n  getCached(role: TimeframeRole): number | undefined {\r\n    if (!this.cacheEnabled) {\r\n      return undefined;\r\n    }\r\n\r\n    return this.rsiCache.get(role);\r\n  }\r\n\r\n  /**\r\n   * Clear all cached RSI values\r\n   */\r\n  clearCache(): void {\r\n    this.rsiCache.clear();\r\n    this.lastCacheUpdate.clear();\r\n    this.logger.debug('RSI cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getCacheStats(): {\r\n    enabled: boolean;\r\n    size: number;\r\n    timeframes: string[];\r\n    } {\r\n    return {\r\n      enabled: this.cacheEnabled,\r\n      size: this.rsiCache.size,\r\n      timeframes: Array.from(this.rsiCache.keys()).map((r) => r.toString()),\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\orderbook.analyzer.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":146,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":146,"endColumn":44},{"ruleId":"prefer-const","severity":2,"message":"'strongest' is never reassigned. Use 'const' instead.","line":223,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":223,"endColumn":18,"fix":{"range":[7501,7527],"text":"const strongest = levels[0];"}},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":301,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":301,"endColumn":30}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Order Book Analyzer\r\n *\r\n * Analyzes order book depth to detect:\r\n * - Bid/Ask imbalance (buying vs selling pressure)\r\n * - Walls (large orders that can block price movement)\r\n * - Support/Resistance zones from order book\r\n *\r\n * Single Responsibility: Analyze order book data ONLY\r\n * Does NOT make trading decisions - only provides analysis\r\n */\r\n\r\nimport {\r\n  LoggerService,\r\n  OrderbookLevel,\r\n  OrderBookWall,\r\n  OrderBookImbalance,\r\n  OrderBookAnalysis,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\n// Re-export unified types from types.ts for backwards compatibility\r\nexport type { OrderbookLevel, OrderBookWall, OrderBookImbalance, OrderBookAnalysis };\r\n\r\nexport interface OrderBookData {\r\n  bids: OrderbookLevel[]; // Buy orders (price descending)\r\n  asks: OrderbookLevel[]; // Sell orders (price ascending)\r\n  timestamp: number;\r\n}\r\n\r\nexport interface OrderBookConfig {\r\n  enabled: boolean;\r\n  depth: number; // Number of levels to analyze\r\n  wallThreshold: number; // Min % of total volume to be considered a wall\r\n  imbalanceThreshold: number; // Min ratio to be considered bullish/bearish\r\n  updateIntervalMs: number; // How often to fetch order book\r\n}\r\n\r\n// ============================================================================\r\n// ORDER BOOK ANALYZER\r\n// ============================================================================\r\n\r\nexport class OrderBookAnalyzer {\r\n  constructor(\r\n    private config: OrderBookConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Analyze order book data\r\n   *\r\n   * @param orderBook - Order book data (bids/asks)\r\n   * @param currentPrice - Current market price\r\n   * @param symbol - Trading pair symbol (default: 'UNKNOWN')\r\n   * @returns Order book analysis\r\n   */\r\n  analyze(orderBook: OrderBookData, currentPrice: number, symbol: string = 'UNKNOWN'): OrderBookAnalysis {\r\n    // Calculate imbalance (buying vs selling pressure)\r\n    const imbalance = this.calculateImbalance(orderBook);\r\n\r\n    // Detect walls (large orders)\r\n    const walls = this.detectWalls(orderBook, currentPrice);\r\n\r\n    // Find strongest levels\r\n    const strongestBid = this.findStrongestLevel(orderBook.bids);\r\n    const strongestAsk = this.findStrongestLevel(orderBook.asks);\r\n\r\n    // Calculate spread\r\n    const spread = this.calculateSpread(orderBook, currentPrice);\r\n\r\n    // Depth info\r\n    const depth = {\r\n      bid: orderBook.bids.length,\r\n      ask: orderBook.asks.length,\r\n    };\r\n\r\n    /* this.logger.debug('Order book analyzed', {\r\n      imbalance: `${imbalance.direction} (ratio: ${imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT)})`,\r\n      walls: walls.length,\r\n      spread: `${spread.toFixed(DECIMAL_PLACES.PRICE)}%`,\r\n      depth: `${depth.bid} bids / ${depth.ask} asks`,\r\n    });\r\n*/\r\n    return {\r\n      timestamp: orderBook.timestamp,\r\n      orderBook: {\r\n        symbol,\r\n        timestamp: orderBook.timestamp,\r\n        bids: orderBook.bids,\r\n        asks: orderBook.asks,\r\n        updateId: 0, // Not available in analyzer context\r\n      },\r\n      imbalance,\r\n      walls,\r\n      strongestBid,\r\n      strongestAsk,\r\n      spread,\r\n      depth,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE HELPERS\r\n  // ============================================================================\r\n\r\n  private extractPrice(level: OrderbookLevel): number {\r\n    return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n  }\r\n\r\n  private extractQuantity(level: OrderbookLevel): number {\r\n    return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Imbalance\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate bid/ask imbalance\r\n   */\r\n  private calculateImbalance(orderBook: OrderBookData): OrderBookImbalance {\r\n    // Sum all bid volumes\r\n    const bidVolume = orderBook.bids.reduce((sum, level) => sum + this.extractQuantity(level), 0);\r\n\r\n    // Sum all ask volumes\r\n    const askVolume = orderBook.asks.reduce((sum, level) => sum + this.extractQuantity(level), 0);\r\n\r\n    // Calculate ratio (bid / ask)\r\n    const ratio = askVolume > 0 ? bidVolume / askVolume : 0;\r\n\r\n    // Determine direction\r\n    let direction: 'BULLISH' | 'BEARISH' | 'NEUTRAL' = 'NEUTRAL';\r\n    if (ratio >= this.config.imbalanceThreshold) {\r\n      direction = 'BULLISH'; // More buying pressure\r\n    } else if (ratio <= 1 / this.config.imbalanceThreshold) {\r\n      direction = 'BEARISH'; // More selling pressure\r\n    }\r\n\r\n    // Calculate strength (0-1)\r\n    // Strength increases as ratio deviates from 1.0\r\n    const deviation = Math.abs(ratio - 1.0);\r\n    const strength = Math.min(deviation / 2, 1.0);\r\n\r\n    return {\r\n      bidVolume,\r\n      askVolume,\r\n      ratio,\r\n      direction,\r\n      strength,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Walls\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect walls (large orders)\r\n   */\r\n  private detectWalls(orderBook: OrderBookData, currentPrice: number): OrderBookWall[] {\r\n    const walls: OrderBookWall[] = [];\r\n\r\n    // Calculate total volumes\r\n    const totalBidVolume = orderBook.bids.reduce((sum, level) => sum + this.extractQuantity(level), 0);\r\n    const totalAskVolume = orderBook.asks.reduce((sum, level) => sum + this.extractQuantity(level), 0);\r\n\r\n    // Check bid walls\r\n    for (const bid of orderBook.bids) {\r\n      const bidPrice = this.extractPrice(bid);\r\n      const bidQty = this.extractQuantity(bid);\r\n      const percentOfTotal = (bidQty / totalBidVolume) * PERCENT_MULTIPLIER;\r\n      if (percentOfTotal >= this.config.wallThreshold * PERCENT_MULTIPLIER) {\r\n        const distance = ((currentPrice - bidPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n        walls.push({\r\n          side: 'BID',\r\n          price: bidPrice,\r\n          quantity: bidQty,\r\n          percentOfTotal,\r\n          distance,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check ask walls\r\n    for (const ask of orderBook.asks) {\r\n      const askPrice = this.extractPrice(ask);\r\n      const askQty = this.extractQuantity(ask);\r\n      const percentOfTotal = (askQty / totalAskVolume) * PERCENT_MULTIPLIER;\r\n      if (percentOfTotal >= this.config.wallThreshold * PERCENT_MULTIPLIER) {\r\n        const distance = ((askPrice - currentPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n        walls.push({\r\n          side: 'ASK',\r\n          price: askPrice,\r\n          quantity: askQty,\r\n          percentOfTotal,\r\n          distance,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Sort by distance from current price\r\n    walls.sort((a, b) => a.distance - b.distance);\r\n\r\n    return walls;\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Levels\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find strongest level (highest size)\r\n   */\r\n  private findStrongestLevel(levels: OrderbookLevel[]): OrderbookLevel | null {\r\n    if (levels.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    let strongest = levels[0];\r\n    let strongestQty = this.extractQuantity(strongest);\r\n    let strongestPrice = this.extractPrice(strongest);\r\n\r\n    for (const level of levels) {\r\n      const qty = this.extractQuantity(level);\r\n      const price = this.extractPrice(level);\r\n      if (qty > strongestQty) {\r\n        strongestQty = qty;\r\n        strongestPrice = price;\r\n      }\r\n    }\r\n\r\n    return { price: strongestPrice, size: strongestQty };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Spread\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate spread (best bid - best ask)\r\n   */\r\n  private calculateSpread(orderBook: OrderBookData, currentPrice: number): number {\r\n    if (orderBook.bids.length === 0 || orderBook.asks.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const bestBid = this.extractPrice(orderBook.bids[0]); // Highest bid\r\n    const bestAsk = this.extractPrice(orderBook.asks[0]); // Lowest ask\r\n\r\n    const spread = ((bestAsk - bestBid) / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n    return spread;\r\n  }\r\n\r\n  // ============================================================================\r\n  // UTILITY METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get human-readable summary\r\n   */\r\n  getSummary(analysis: OrderBookAnalysis): string {\r\n    const parts: string[] = [];\r\n\r\n    // Imbalance\r\n    parts.push(\r\n      `Imbalance: ${analysis.imbalance.direction} (${(analysis.imbalance.strength * PERCENT_MULTIPLIER).toFixed(0)}% strength)`,\r\n    );\r\n\r\n    // Walls\r\n    if (analysis.walls.length > 0) {\r\n      const nearestWall = analysis.walls[0];\r\n      parts.push(\r\n        `Nearest wall: ${nearestWall.side} @ ${nearestWall.price.toFixed(DECIMAL_PLACES.PERCENT)} (${nearestWall.distance.toFixed(DECIMAL_PLACES.PERCENT)}% away)`,\r\n      );\r\n    } else {\r\n      parts.push('No walls detected');\r\n    }\r\n\r\n    // Spread\r\n    parts.push(`Spread: ${analysis.spread.toFixed(DECIMAL_PLACES.PRICE)}%`);\r\n\r\n    return parts.join(' | ');\r\n  }\r\n\r\n  /**\r\n   * Check if there's a wall blocking the path\r\n   *\r\n   * @param analysis - Order book analysis\r\n   * @param direction - Trade direction (LONG/SHORT)\r\n   * @param maxDistance - Max distance to check (% from current price)\r\n   * @returns True if wall is blocking\r\n   */\r\n  hasBlockingWall(\r\n    analysis: OrderBookAnalysis,\r\n    direction: 'LONG' | 'SHORT',\r\n    maxDistance: number = 2.0,\r\n  ): boolean {\r\n    for (const wall of analysis.walls) {\r\n      // For LONG: check ASK walls above current price\r\n      if (direction === 'LONG' && wall.side === 'ASK' && wall.distance <= maxDistance) {\r\n        return true;\r\n      }\r\n\r\n      // For SHORT: check BID walls below current price\r\n      if (direction === 'SHORT' && wall.side === 'BID' && wall.distance <= maxDistance) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\pattern-analyzer.helper.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Constructor has a complexity of 13. Maximum allowed is 10.","line":90,"column":14,"nodeType":"FunctionExpression","messageId":"complex","endLine":140,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":102,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":102,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4422,4439],"text":"(this.strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4422,4439],"text":"(this.strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4422,4439],"text":"(Boolean(this.strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":109,"column":50,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":109,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4696,4713],"text":"(this.strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4696,4713],"text":"(this.strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4696,4713],"text":"(Boolean(this.strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":116,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":116,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4957,4974],"text":"(this.strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4957,4974],"text":"(this.strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4957,4974],"text":"(Boolean(this.strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":123,"column":48,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":123,"endColumn":65,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5226,5243],"text":"(this.strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5226,5243],"text":"(this.strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5226,5243],"text":"(Boolean(this.strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":130,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":130,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5483,5500],"text":"(this.strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5483,5500],"text":"(this.strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5483,5500],"text":"(Boolean(this.strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":137,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":137,"endColumn":61,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5736,5753],"text":"(this.strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5736,5753],"text":"(this.strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5736,5753],"text":"(Boolean(this.strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'analyzePatterns' has a complexity of 45. Maximum allowed is 10.","line":148,"column":18,"nodeType":"FunctionExpression","messageId":"complex","endLine":372,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":158,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":158,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6551,6577],"text":"(this.chartPatternsDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":158,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":158,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":190,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":190,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7916,7945],"text":"(this.engulfingPatternDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":190,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":190,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":223,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":223,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9416,9442],"text":"(this.triplePatternDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":223,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":223,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":256,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":256,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10863,10891],"text":"(this.trianglePatternDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":256,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":256,"endColumn":64},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":290,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":290,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12394,12419],"text":"(this.wedgePatternDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":290,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":290,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":324,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":324,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13887,13911],"text":"(this.flagPatternDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":324,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":324,"endColumn":60}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Pattern Analyzer Helper\r\n *\r\n * Centralized wrapper for all chart pattern detectors.\r\n * Provides a single method to analyze all patterns and return confidence/reason updates.\r\n *\r\n * Benefits:\r\n * - Eliminates code duplication across strategies\r\n * - Centralized logging\r\n * - Easy to add new patterns\r\n * - Consistent confidence boosts\r\n */\r\n\r\nimport { Candle, SwingPoint, SignalDirection, LoggerService } from '../types';\r\nimport { ChartPatternsDetector } from './chart-patterns.detector';\r\nimport { EngulfingPatternDetector } from './engulfing-pattern.detector';\r\nimport { TriplePatternDetector } from './triple-pattern.detector';\r\nimport { TrianglePatternDetector } from './triangle-pattern.detector';\r\nimport { WedgePatternDetector } from './wedge-pattern.detector';\r\nimport { FlagPatternDetector } from './flag-pattern.detector';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface PatternAnalyzerConfig {\r\n  enableChartPatterns?: boolean; // Head & Shoulders, Double Top/Bottom\r\n  enableEngulfingPattern?: boolean; // Bullish/Bearish Engulfing\r\n  enableTriplePattern?: boolean; // Triple Top/Bottom\r\n  enableTrianglePattern?: boolean; // Ascending/Descending/Symmetrical Triangle\r\n  enableWedgePattern?: boolean; // Rising/Falling Wedge\r\n  enableFlagPattern?: boolean; // Bull/Bear Flag\r\n\r\n  // Confidence boosts (customizable per strategy)\r\n  chartPatternBoost?: number; // Default: PERCENTAGE_THRESHOLDS.VERY_LOW\r\n  engulfingBoost?: number; // Default: 0.10\r\n  tripleBoost?: number; // Default: PERCENTAGE_THRESHOLDS.VERY_LOW\r\n  triangleBoost?: number; // Default: 0.10\r\n  wedgeBoost?: number; // Default: 0.10\r\n  flagBoost?: number; // Default: PERCENTAGE_THRESHOLDS.VERY_LOW (continuation pattern)\r\n}\r\n\r\nexport interface PatternAnalysisInput {\r\n  candles: Candle[]; // For engulfing pattern\r\n  swingPoints: SwingPoint[]; // For chart patterns\r\n  direction: SignalDirection; // Signal direction to match\r\n  trend: 'BULLISH' | 'BEARISH' | 'NEUTRAL'; // For triangle/wedge patterns\r\n  strategyName: string; // For logging (e.g., \"TrendFollowing\")\r\n}\r\n\r\nexport interface PatternAnalysisResult {\r\n  confidenceBoost: number; // Total confidence boost from all patterns\r\n  reasonAdditions: string; // String to append to reason (e.g., \" + DOUBLE_BOTTOM + BULL_FLAG\")\r\n  patternsDetected: string[]; // Array of detected pattern names\r\n}\r\n\r\n// ============================================================================\r\n// DEFAULT CONFIG\r\n// ============================================================================\r\n\r\nconst DEFAULT_CONFIG: Required<PatternAnalyzerConfig> = {\r\n  enableChartPatterns: false,\r\n  enableEngulfingPattern: false,\r\n  enableTriplePattern: false,\r\n  enableTrianglePattern: false,\r\n  enableWedgePattern: false,\r\n  enableFlagPattern: false,\r\n  chartPatternBoost: PERCENTAGE_THRESHOLDS.VERY_LOW,\r\n  engulfingBoost: 0.10,\r\n  tripleBoost: PERCENTAGE_THRESHOLDS.VERY_LOW,\r\n  triangleBoost: 0.10,\r\n  wedgeBoost: 0.10,\r\n  flagBoost: PERCENTAGE_THRESHOLDS.VERY_LOW,\r\n};\r\n\r\n// ============================================================================\r\n// PATTERN ANALYZER HELPER\r\n// ============================================================================\r\n\r\nexport class PatternAnalyzerHelper {\r\n  private config: Required<PatternAnalyzerConfig>;\r\n  private chartPatternsDetector: ChartPatternsDetector | null = null;\r\n  private engulfingPatternDetector: EngulfingPatternDetector | null = null;\r\n  private triplePatternDetector: TriplePatternDetector | null = null;\r\n  private trianglePatternDetector: TrianglePatternDetector | null = null;\r\n  private wedgePatternDetector: WedgePatternDetector | null = null;\r\n  private flagPatternDetector: FlagPatternDetector | null = null;\r\n\r\n  constructor(\r\n    config: PatternAnalyzerConfig,\r\n    private logger: LoggerService,\r\n    private strategyName?: string, // Optional: for logging context\r\n  ) {\r\n    // Merge with defaults\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n\r\n    // Initialize enabled detectors\r\n    if (this.config.enableChartPatterns) {\r\n      this.chartPatternsDetector = new ChartPatternsDetector(logger);\r\n      this.logger.info(\r\n        `üìä Chart Patterns Detector enabled${this.strategyName ? ` for ${this.strategyName}` : ''}`,\r\n      );\r\n    }\r\n\r\n    if (this.config.enableEngulfingPattern) {\r\n      this.engulfingPatternDetector = new EngulfingPatternDetector(logger);\r\n      this.logger.info(\r\n        `üïØÔ∏è Engulfing Pattern Detector enabled${this.strategyName ? ` for ${this.strategyName}` : ''}`,\r\n      );\r\n    }\r\n\r\n    if (this.config.enableTriplePattern) {\r\n      this.triplePatternDetector = new TriplePatternDetector(logger);\r\n      this.logger.info(\r\n        `üî∫ Triple Pattern Detector enabled${this.strategyName ? ` for ${this.strategyName}` : ''}`,\r\n      );\r\n    }\r\n\r\n    if (this.config.enableTrianglePattern) {\r\n      this.trianglePatternDetector = new TrianglePatternDetector(logger);\r\n      this.logger.info(\r\n        `üî∫ Triangle Pattern Detector enabled${this.strategyName ? ` for ${this.strategyName}` : ''}`,\r\n      );\r\n    }\r\n\r\n    if (this.config.enableWedgePattern) {\r\n      this.wedgePatternDetector = new WedgePatternDetector(logger);\r\n      this.logger.info(\r\n        `üìê Wedge Pattern Detector enabled${this.strategyName ? ` for ${this.strategyName}` : ''}`,\r\n      );\r\n    }\r\n\r\n    if (this.config.enableFlagPattern) {\r\n      this.flagPatternDetector = new FlagPatternDetector(logger);\r\n      this.logger.info(\r\n        `üö© Flag Pattern Detector enabled${this.strategyName ? ` for ${this.strategyName}` : ''}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze all enabled patterns and return confidence boost + reason additions\r\n   *\r\n   * @param input - Pattern analysis input data\r\n   * @returns Pattern analysis result with confidence boost and reason additions\r\n   */\r\n  analyzePatterns(input: PatternAnalysisInput): PatternAnalysisResult {\r\n    let confidenceBoost = 0;\r\n    const reasonParts: string[] = [];\r\n    const patternsDetected: string[] = [];\r\n\r\n    const { candles, swingPoints, direction, trend, strategyName } = input;\r\n\r\n    // ========================================================================\r\n    // 1. Chart Patterns (Head & Shoulders, Double Top/Bottom)\r\n    // ========================================================================\r\n    if (this.chartPatternsDetector && swingPoints.length >= 3) {\r\n      const pattern = this.chartPatternsDetector.detect(swingPoints);\r\n\r\n      if (pattern.detected) {\r\n        const directionMatch =\r\n          (direction === SignalDirection.LONG && pattern.direction === 'LONG') ||\r\n          (direction === SignalDirection.SHORT && pattern.direction === 'SHORT');\r\n\r\n        if (directionMatch) {\r\n          confidenceBoost += this.config.chartPatternBoost;\r\n          patternsDetected.push(pattern.type);\r\n          reasonParts.push(pattern.type);\r\n\r\n          this.logger.info(`üìä ${strategyName} Chart Pattern Detected!`, {\r\n            pattern: pattern.type,\r\n            direction: pattern.direction,\r\n            patternConfidence: pattern.confidence.toFixed(1) + '%',\r\n            boost: `+${(this.config.chartPatternBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          });\r\n        } else {\r\n          this.logger.debug(`‚ö†Ô∏è ${strategyName} Chart pattern detected but direction mismatch`, {\r\n            pattern: pattern.type,\r\n            patternDirection: pattern.direction,\r\n            signalDirection: direction,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // 2. Engulfing Pattern\r\n    // ========================================================================\r\n    if (this.engulfingPatternDetector && candles.length >= 2) {\r\n      const engulfing = this.engulfingPatternDetector.detect(candles);\r\n\r\n      if (engulfing.detected) {\r\n        const directionMatch =\r\n          (direction === SignalDirection.LONG && engulfing.direction === 'LONG') ||\r\n          (direction === SignalDirection.SHORT && engulfing.direction === 'SHORT');\r\n\r\n        if (directionMatch) {\r\n          confidenceBoost += this.config.engulfingBoost;\r\n          patternsDetected.push(engulfing.type);\r\n          reasonParts.push(engulfing.type);\r\n\r\n          this.logger.info(`üïØÔ∏è ${strategyName} Engulfing Pattern Detected!`, {\r\n            pattern: engulfing.type,\r\n            direction: engulfing.direction,\r\n            engulfingRatio: engulfing.engulfingRatio.toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n            patternConfidence: engulfing.confidence.toFixed(1) + '%',\r\n            boost: `+${(this.config.engulfingBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          });\r\n        } else {\r\n          this.logger.debug(`‚ö†Ô∏è ${strategyName} Engulfing pattern detected but direction mismatch`, {\r\n            pattern: engulfing.type,\r\n            engulfingDirection: engulfing.direction,\r\n            signalDirection: direction,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // 3. Triple Pattern (Triple Top/Bottom)\r\n    // ========================================================================\r\n    if (this.triplePatternDetector && swingPoints.length >= 5) {\r\n      const triple = this.triplePatternDetector.detect(swingPoints);\r\n\r\n      if (triple.detected) {\r\n        const directionMatch =\r\n          (direction === SignalDirection.LONG && triple.direction === 'LONG') ||\r\n          (direction === SignalDirection.SHORT && triple.direction === 'SHORT');\r\n\r\n        if (directionMatch) {\r\n          confidenceBoost += this.config.tripleBoost;\r\n          patternsDetected.push(triple.type);\r\n          reasonParts.push(triple.type);\r\n\r\n          this.logger.info(`üî∫ ${strategyName} Triple Pattern Detected!`, {\r\n            pattern: triple.type,\r\n            direction: triple.direction,\r\n            patternConfidence: triple.confidence.toFixed(1) + '%',\r\n            neckline: triple.neckline.toFixed(DECIMAL_PLACES.PRICE),\r\n            boost: `+${(this.config.tripleBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          });\r\n        } else {\r\n          this.logger.debug(`‚ö†Ô∏è ${strategyName} Triple pattern detected but direction mismatch`, {\r\n            pattern: triple.type,\r\n            tripleDirection: triple.direction,\r\n            signalDirection: direction,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // 4. Triangle Pattern (Ascending/Descending/Symmetrical)\r\n    // ========================================================================\r\n    if (this.trianglePatternDetector && swingPoints.length >= 6) {\r\n      const triangle = this.trianglePatternDetector.detect(swingPoints, trend);\r\n\r\n      if (triangle.detected) {\r\n        const directionMatch =\r\n          (direction === SignalDirection.LONG && triangle.direction === 'LONG') ||\r\n          (direction === SignalDirection.SHORT && triangle.direction === 'SHORT');\r\n\r\n        if (directionMatch) {\r\n          confidenceBoost += this.config.triangleBoost;\r\n          patternsDetected.push(triangle.type);\r\n          reasonParts.push(triangle.type);\r\n\r\n          this.logger.info(`üî∫ ${strategyName} Triangle Pattern Detected!`, {\r\n            pattern: triangle.type,\r\n            direction: triangle.direction,\r\n            patternConfidence: triangle.confidence.toFixed(1) + '%',\r\n            apex: triangle.apex.toFixed(DECIMAL_PLACES.PRICE),\r\n            target: triangle.target.toFixed(DECIMAL_PLACES.PRICE),\r\n            boost: `+${(this.config.triangleBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          });\r\n        } else {\r\n          this.logger.debug(`‚ö†Ô∏è ${strategyName} Triangle pattern detected but direction mismatch`, {\r\n            pattern: triangle.type,\r\n            triangleDirection: triangle.direction,\r\n            signalDirection: direction,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // 5. Wedge Pattern (Rising/Falling)\r\n    // ========================================================================\r\n    if (this.wedgePatternDetector && swingPoints.length >= 6) {\r\n      const wedge = this.wedgePatternDetector.detect(swingPoints, trend);\r\n\r\n      if (wedge.detected) {\r\n        const directionMatch =\r\n          (direction === SignalDirection.LONG && wedge.direction === 'LONG') ||\r\n          (direction === SignalDirection.SHORT && wedge.direction === 'SHORT');\r\n\r\n        if (directionMatch) {\r\n          confidenceBoost += this.config.wedgeBoost;\r\n          patternsDetected.push(wedge.type);\r\n          reasonParts.push(wedge.type);\r\n\r\n          this.logger.info(`üìê ${strategyName} Wedge Pattern Detected!`, {\r\n            pattern: wedge.type,\r\n            direction: wedge.direction,\r\n            patternConfidence: wedge.confidence.toFixed(1) + '%',\r\n            apex: wedge.apex.toFixed(DECIMAL_PLACES.PRICE),\r\n            target: wedge.target.toFixed(DECIMAL_PLACES.PRICE),\r\n            boost: `+${(this.config.wedgeBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          });\r\n        } else {\r\n          this.logger.debug(`‚ö†Ô∏è ${strategyName} Wedge pattern detected but direction mismatch`, {\r\n            pattern: wedge.type,\r\n            wedgeDirection: wedge.direction,\r\n            signalDirection: direction,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // 6. Flag Pattern (Bull/Bear Flag - continuation pattern)\r\n    // ========================================================================\r\n    if (this.flagPatternDetector && swingPoints.length >= 6) {\r\n      const flag = this.flagPatternDetector.detect(swingPoints);\r\n\r\n      if (flag.detected) {\r\n        const directionMatch =\r\n          (direction === SignalDirection.LONG && flag.direction === 'LONG') ||\r\n          (direction === SignalDirection.SHORT && flag.direction === 'SHORT');\r\n\r\n        if (directionMatch) {\r\n          confidenceBoost += this.config.flagBoost;\r\n          patternsDetected.push(flag.type);\r\n          reasonParts.push(flag.type);\r\n\r\n          this.logger.info(`üö© ${strategyName} Flag Pattern Detected!`, {\r\n            pattern: flag.type,\r\n            direction: flag.direction,\r\n            patternConfidence: flag.confidence.toFixed(1) + '%',\r\n            poleHeight: flag.poleHeight.toFixed(DECIMAL_PLACES.PRICE),\r\n            target: flag.target.toFixed(DECIMAL_PLACES.PRICE),\r\n            boost: `+${(this.config.flagBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          });\r\n        } else {\r\n          this.logger.debug(`‚ö†Ô∏è ${strategyName} Flag pattern detected but direction mismatch`, {\r\n            pattern: flag.type,\r\n            flagDirection: flag.direction,\r\n            signalDirection: direction,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Return Result\r\n    // ========================================================================\r\n    const reasonAdditions = reasonParts.length > 0 ? ' + ' + reasonParts.join(' + ') : '';\r\n\r\n    if (patternsDetected.length > 0) {\r\n      this.logger.info(`‚ú® ${strategyName} Pattern Analysis Complete`, {\r\n        patternsDetected: patternsDetected.join(', '),\r\n        totalBoost: `+${(confidenceBoost * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n      });\r\n    }\r\n\r\n    return {\r\n      confidenceBoost,\r\n      reasonAdditions,\r\n      patternsDetected,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if any patterns are enabled\r\n   */\r\n  hasEnabledPatterns(): boolean {\r\n    return (\r\n      this.config.enableChartPatterns === true ||\r\n      this.config.enableEngulfingPattern === true ||\r\n      this.config.enableTriplePattern === true ||\r\n      this.config.enableTrianglePattern === true ||\r\n      this.config.enableWedgePattern === true ||\r\n      this.config.enableFlagPattern === true\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\triangle-pattern.detector.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'detect' has a complexity of 19. Maximum allowed is 10.","line":74,"column":9,"nodeType":"FunctionExpression","messageId":"complex","endLine":149,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":75,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":75,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -12.","line":79,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":79,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":194,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":66},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":208,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":208,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":209,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":209,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":216,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":216,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":218,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":218,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":220,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":220,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":225,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":225,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":226,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":226,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":233,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":233,"endColumn":31}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENTAGE_THRESHOLDS, TIME_UNITS } from '../constants';\r\n/**\r\n * Triangle Pattern Detector\r\n *\r\n * Detects triangle continuation patterns (Ascending, Descending, Symmetrical).\r\n * These are consolidation patterns that typically continue the previous trend.\r\n *\r\n * Ascending Triangle (Bullish):\r\n *     __________ Flat resistance\r\n *    /  /  /  /\r\n *   /  /  /  /   Rising support\r\n *  /  /  /  /    ‚Üí LONG on breakout\r\n *\r\n * Descending Triangle (Bearish):\r\n *  \\  \\  \\  \\   Falling resistance\r\n *   \\  \\  \\  \\\r\n *    \\__\\__\\__\\ Flat support\r\n *              ‚Üí SHORT on breakout\r\n *\r\n * Symmetrical Triangle (Continuation):\r\n *      /\\\r\n *     /  \\      Both lines converging\r\n *    /    \\     ‚Üí Breakout direction = trend direction\r\n *   /      \\\r\n */\r\n\r\nimport { SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum TrianglePatternType {\r\n  ASCENDING = 'ASCENDING_TRIANGLE',\r\n  DESCENDING = 'DESCENDING_TRIANGLE',\r\n  SYMMETRICAL = 'SYMMETRICAL_TRIANGLE',\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface TrianglePattern {\r\n  detected: boolean;\r\n  type: TrianglePatternType;\r\n  direction: 'LONG' | 'SHORT';\r\n  confidence: number; // 0-100%\r\n  apex: number; // Price at apex (where lines would meet)\r\n  target: number; // Breakout target\r\n  stopLoss: number; // Stop loss level\r\n  resistanceLine: { slope: number; highs: SwingPoint[] };\r\n  supportLine: { slope: number; lows: SwingPoint[] };\r\n  explanation: string;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BASE_CONFIDENCE = 65;\r\nconst MIN_TOUCHES = 2; // Minimum touches per trendline\r\nconst FLAT_SLOPE_THRESHOLD = 0.00005; // Slope considered \"flat\"\r\nconst CONVERGENCE_THRESHOLD = 0.0001; // Minimum convergence required\r\nconst MIN_PATTERN_BARS = PERCENTAGE_THRESHOLDS.MODERATE;\r\nconst MAX_PATTERN_BARS = 200;\r\n\r\n// ============================================================================\r\n// TRIANGLE PATTERN DETECTOR\r\n// ============================================================================\r\n\r\nexport class TrianglePatternDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect triangle pattern from swing points\r\n   */\r\n  detect(swingPoints: SwingPoint[], currentTrend?: 'BULLISH' | 'BEARISH' | 'NEUTRAL'): TrianglePattern {\r\n    if (swingPoints.length < 6) {\r\n      return this.noPattern('Not enough swing points (need 6+)');\r\n    }\r\n\r\n    const recent = swingPoints.slice(-12); // Last 12 swing points\r\n\r\n    // Separate highs and lows\r\n    const highs = recent.filter(p => p.type === SwingPointType.HIGH);\r\n    const lows = recent.filter(p => p.type === SwingPointType.LOW);\r\n\r\n    if (highs.length < MIN_TOUCHES || lows.length < MIN_TOUCHES) {\r\n      return this.noPattern('Not enough highs/lows for trendlines');\r\n    }\r\n\r\n    // Calculate trendlines\r\n    const resistanceLine = this.calculateTrendline(highs);\r\n    const supportLine = this.calculateTrendline(lows);\r\n\r\n    // Check pattern timespan\r\n    const firstPoint = recent[0];\r\n    const lastPoint = recent[recent.length - 1];\r\n    const patternMinutes = (lastPoint.timestamp - firstPoint.timestamp) / TIME_UNITS.MINUTE;\r\n\r\n    if (patternMinutes < MIN_PATTERN_BARS || patternMinutes > MAX_PATTERN_BARS) {\r\n      return this.noPattern('Pattern timespan invalid');\r\n    }\r\n\r\n    // Determine triangle type based on slopes\r\n    const resistanceFlat = Math.abs(resistanceLine.slope) < FLAT_SLOPE_THRESHOLD;\r\n    const supportFlat = Math.abs(supportLine.slope) < FLAT_SLOPE_THRESHOLD;\r\n    const converging = resistanceLine.slope - supportLine.slope < -CONVERGENCE_THRESHOLD;\r\n\r\n    // Ascending Triangle: flat resistance + rising support\r\n    if (resistanceFlat && supportLine.slope > 0 && converging) {\r\n      return this.buildPattern(\r\n        TrianglePatternType.ASCENDING,\r\n        'LONG',\r\n        resistanceLine,\r\n        supportLine,\r\n        highs,\r\n        lows,\r\n        currentTrend,\r\n      );\r\n    }\r\n\r\n    // Descending Triangle: falling resistance + flat support\r\n    if (supportFlat && resistanceLine.slope < 0 && converging) {\r\n      return this.buildPattern(\r\n        TrianglePatternType.DESCENDING,\r\n        'SHORT',\r\n        resistanceLine,\r\n        supportLine,\r\n        highs,\r\n        lows,\r\n        currentTrend,\r\n      );\r\n    }\r\n\r\n    // Symmetrical Triangle: both converging\r\n    if (converging && !resistanceFlat && !supportFlat && resistanceLine.slope < 0 && supportLine.slope > 0) {\r\n      // Direction depends on trend\r\n      const direction = currentTrend === 'BULLISH' ? 'LONG' : currentTrend === 'BEARISH' ? 'SHORT' : 'LONG';\r\n      return this.buildPattern(\r\n        TrianglePatternType.SYMMETRICAL,\r\n        direction,\r\n        resistanceLine,\r\n        supportLine,\r\n        highs,\r\n        lows,\r\n        currentTrend,\r\n      );\r\n    }\r\n\r\n    return this.noPattern('No valid triangle pattern');\r\n  }\r\n\r\n  /**\r\n   * Calculate trendline using linear regression\r\n   */\r\n  private calculateTrendline(points: SwingPoint[]): { slope: number; intercept: number } {\r\n    const n = points.length;\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n    let sumXY = 0;\r\n    let sumX2 = 0;\r\n\r\n    // Use timestamp as X, price as Y\r\n    const baseTime = points[0].timestamp;\r\n\r\n    for (const point of points) {\r\n      const x = (point.timestamp - baseTime) / TIME_UNITS.MINUTE; // Minutes from start\r\n      const y = point.price;\r\n      sumX += x;\r\n      sumY += y;\r\n      sumXY += x * y;\r\n      sumX2 += x * x;\r\n    }\r\n\r\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\r\n    const intercept = (sumY - slope * sumX) / n;\r\n\r\n    return { slope, intercept };\r\n  }\r\n\r\n  /**\r\n   * Build triangle pattern result\r\n   */\r\n  private buildPattern(\r\n    type: TrianglePatternType,\r\n    direction: 'LONG' | 'SHORT',\r\n    resistanceLine: { slope: number; intercept: number },\r\n    supportLine: { slope: number; intercept: number },\r\n    highs: SwingPoint[],\r\n    lows: SwingPoint[],\r\n    currentTrend?: 'BULLISH' | 'BEARISH' | 'NEUTRAL',\r\n  ): TrianglePattern {\r\n    // Calculate apex (where lines meet)\r\n    const latestHigh = highs[highs.length - 1];\r\n    const latestLow = lows[lows.length - 1];\r\n    const currentPrice = (latestHigh.price + latestLow.price) / 2;\r\n\r\n    // Triangle height (widest part)\r\n    const firstHigh = highs[0].price;\r\n    const firstLow = lows[0].price;\r\n    const triangleHeight = firstHigh - firstLow;\r\n\r\n    // Target: project triangle height from breakout\r\n    const target = direction === 'LONG'\r\n      ? currentPrice + triangleHeight\r\n      : currentPrice - triangleHeight;\r\n\r\n    // Stop loss: opposite side of triangle\r\n    const stopLoss = direction === 'LONG'\r\n      ? latestLow.price - triangleHeight * 0.15\r\n      : latestHigh.price + triangleHeight * 0.15;\r\n\r\n    // Calculate confidence\r\n    let confidence = BASE_CONFIDENCE;\r\n\r\n    // Bonus for trend alignment\r\n    if (type === TrianglePatternType.ASCENDING && currentTrend === 'BULLISH') {\r\n      confidence += 15;\r\n    } else if (type === TrianglePatternType.DESCENDING && currentTrend === 'BEARISH') {\r\n      confidence += 15;\r\n    } else if (type === TrianglePatternType.SYMMETRICAL) {\r\n      confidence += 10; // Symmetrical is more neutral\r\n    }\r\n\r\n    // Bonus for more touches\r\n    const totalTouches = highs.length + lows.length;\r\n    if (totalTouches >= 6) {\r\n      confidence += 10;\r\n    }\r\n\r\n    return {\r\n      detected: true,\r\n      type,\r\n      direction,\r\n      confidence: Math.min(100, confidence),\r\n      apex: currentPrice,\r\n      target,\r\n      stopLoss,\r\n      resistanceLine: { slope: resistanceLine.slope, highs },\r\n      supportLine: { slope: supportLine.slope, lows },\r\n      explanation: `${type}: ${highs.length} highs, ${lows.length} lows, ${totalTouches} touches`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Return no pattern result\r\n   */\r\n  private noPattern(reason: string): TrianglePattern {\r\n    return {\r\n      detected: false,\r\n      type: TrianglePatternType.NONE,\r\n      direction: 'LONG',\r\n      confidence: 0,\r\n      apex: 0,\r\n      target: 0,\r\n      stopLoss: 0,\r\n      resistanceLine: { slope: 0, highs: [] },\r\n      supportLine: { slope: 0, lows: [] },\r\n      explanation: reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\triple-pattern.detector.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":66,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":66,"endColumn":31},{"ruleId":"complexity","severity":1,"message":"Method 'detectTripleTop' has a complexity of 14. Maximum allowed is 10.","line":90,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":161,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -10.","line":91,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":91,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":94,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":94,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":97,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":97,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":98,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":98,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":99,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":99,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":113,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":113,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":138,"column":58,"nodeType":"Literal","messageId":"noMagic","endLine":138,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":141,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":141,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.0.","line":145,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":145,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":145,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":145,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":151,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":151,"endColumn":33},{"ruleId":"complexity","severity":1,"message":"Method 'detectTripleBottom' has a complexity of 14. Maximum allowed is 10.","line":168,"column":29,"nodeType":"FunctionExpression","messageId":"complex","endLine":239,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -10.","line":169,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":169,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":172,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":172,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":175,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":175,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":176,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":176,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":177,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":177,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":191,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":216,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":216,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":219,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":219,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.0.","line":223,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":223,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":223,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":223,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":229,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":229,"endColumn":33}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS, TIME_UNITS } from '../constants';\r\n/**\r\n * Triple Top/Bottom Pattern Detector\r\n *\r\n * Detects triple top (bearish) and triple bottom (bullish) reversal patterns.\r\n * These are stronger reversal signals than double patterns - 3 failed attempts\r\n * to break a level indicates strong resistance/support.\r\n *\r\n * Triple Top:\r\n *  Peak1  Peak2  Peak3\r\n *    |     |     |      ‚Üí 3 peaks at same level\r\n *    |_____|_____|      ‚Üí break neckline = SHORT\r\n *\r\n * Triple Bottom:\r\n *     ______               ‚Üê Neckline\r\n *    /  |  \\\r\n * Bot1 Bot2 Bot3          ‚Üí 3 bottoms at same level = LONG\r\n */\r\n\r\nimport { SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum TriplePatternType {\r\n  TRIPLE_TOP = 'TRIPLE_TOP',\r\n  TRIPLE_BOTTOM = 'TRIPLE_BOTTOM',\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface TriplePattern {\r\n  detected: boolean;\r\n  type: TriplePatternType;\r\n  direction: 'LONG' | 'SHORT';\r\n  confidence: number; // 0-100%\r\n  neckline: number;\r\n  target: number;\r\n  stopLoss: number;\r\n  points: SwingPoint[]; // 5 points: peak1, valley1, peak2, valley2, peak3\r\n  explanation: string;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BASE_CONFIDENCE = CONFIDENCE_THRESHOLDS.MODERATE; // Higher than double patterns (3 tests > 2 tests)\r\nconst PEAK_TOLERANCE_PERCENT = 3.0; // Peaks/bottoms must be within ¬±3%\r\nconst MIN_PATTERN_BARS = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // Minimum timespan\r\nconst MAX_PATTERN_BARS = 150; // Maximum timespan\r\n\r\n// ============================================================================\r\n// TRIPLE PATTERN DETECTOR\r\n// ============================================================================\r\n\r\nexport class TriplePatternDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect triple pattern from swing points\r\n   * @param swingPoints - Array of swing points (minimum 5 required)\r\n   * @returns TriplePattern result\r\n   */\r\n  detect(swingPoints: SwingPoint[]): TriplePattern {\r\n    if (swingPoints.length < 5) {\r\n      return this.noPattern('Not enough swing points (need 5+)');\r\n    }\r\n\r\n    // Try triple top\r\n    const tripleTop = this.detectTripleTop(swingPoints);\r\n    if (tripleTop.detected) {\r\n      return tripleTop;\r\n    }\r\n\r\n    // Try triple bottom\r\n    const tripleBottom = this.detectTripleBottom(swingPoints);\r\n    if (tripleBottom.detected) {\r\n      return tripleBottom;\r\n    }\r\n\r\n    return this.noPattern('No triple pattern detected');\r\n  }\r\n\r\n  /**\r\n   * Detect Triple Top pattern\r\n   * Structure: HIGH, LOW, HIGH, LOW, HIGH\r\n   * All 3 HIGHs should be at approximately same level (¬±3%)\r\n   */\r\n  private detectTripleTop(swingPoints: SwingPoint[]): TriplePattern {\r\n    const recent = swingPoints.slice(-10); // Look at last 10 swing points\r\n\r\n    // Search for pattern: HIGH, LOW, HIGH, LOW, HIGH\r\n    for (let i = 0; i <= recent.length - 5; i++) {\r\n      const peak1 = recent[i];\r\n      const valley1 = recent[i + 1];\r\n      const peak2 = recent[i + 2];\r\n      const valley2 = recent[i + 3];\r\n      const peak3 = recent[i + 4];\r\n\r\n      // Validate structure: HIGH -> LOW -> HIGH -> LOW -> HIGH\r\n      if (\r\n        peak1.type !== SwingPointType.HIGH ||\r\n        valley1.type !== SwingPointType.LOW ||\r\n        peak2.type !== SwingPointType.HIGH ||\r\n        valley2.type !== SwingPointType.LOW ||\r\n        peak3.type !== SwingPointType.HIGH\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Validate: all 3 peaks at approximately same level (¬±3%)\r\n      const avgPeak = (peak1.price + peak2.price + peak3.price) / 3;\r\n      const peak1Diff = Math.abs((peak1.price - avgPeak) / avgPeak) * PERCENT_MULTIPLIER;\r\n      const peak2Diff = Math.abs((peak2.price - avgPeak) / avgPeak) * PERCENT_MULTIPLIER;\r\n      const peak3Diff = Math.abs((peak3.price - avgPeak) / avgPeak) * PERCENT_MULTIPLIER;\r\n\r\n      if (\r\n        peak1Diff > PEAK_TOLERANCE_PERCENT ||\r\n        peak2Diff > PEAK_TOLERANCE_PERCENT ||\r\n        peak3Diff > PEAK_TOLERANCE_PERCENT\r\n      ) {\r\n        continue; // Peaks too different\r\n      }\r\n\r\n      // Validate: valleys should be lower than peaks\r\n      if (valley1.price >= peak1.price || valley2.price >= peak2.price) {\r\n        continue;\r\n      }\r\n\r\n      // Check pattern timespan\r\n      const patternMinutes = (peak3.timestamp - peak1.timestamp) / TIME_UNITS.MINUTE;\r\n      if (patternMinutes < MIN_PATTERN_BARS || patternMinutes > MAX_PATTERN_BARS) {\r\n        continue; // Pattern too short or too long\r\n      }\r\n\r\n      // Calculate pattern metrics\r\n      const neckline = (valley1.price + valley2.price) / 2;\r\n      const patternHeight = avgPeak - neckline;\r\n      const target = neckline - patternHeight; // Project downward\r\n      const stopLoss = avgPeak + patternHeight * 0.15; // 15% above peaks\r\n\r\n      // Calculate confidence\r\n      const maxDiff = Math.max(peak1Diff, peak2Diff, peak3Diff);\r\n      const confidence = BASE_CONFIDENCE + (3.0 - maxDiff) * 5; // Bonus for closer peaks\r\n\r\n      return {\r\n        detected: true,\r\n        type: TriplePatternType.TRIPLE_TOP,\r\n        direction: 'SHORT',\r\n        confidence: Math.min(100, confidence),\r\n        neckline,\r\n        target,\r\n        stopLoss,\r\n        points: [peak1, valley1, peak2, valley2, peak3],\r\n        explanation: `Triple Top: peaks ${peak1.price.toFixed(DECIMAL_PLACES.PRICE)}/${peak2.price.toFixed(DECIMAL_PLACES.PRICE)}/${peak3.price.toFixed(DECIMAL_PLACES.PRICE)}, neckline ${neckline.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      };\r\n    }\r\n\r\n    return this.noPattern('No valid Triple Top pattern');\r\n  }\r\n\r\n  /**\r\n   * Detect Triple Bottom pattern\r\n   * Structure: LOW, HIGH, LOW, HIGH, LOW\r\n   * All 3 LOWs should be at approximately same level (¬±3%)\r\n   */\r\n  private detectTripleBottom(swingPoints: SwingPoint[]): TriplePattern {\r\n    const recent = swingPoints.slice(-10);\r\n\r\n    // Search for pattern: LOW, HIGH, LOW, HIGH, LOW\r\n    for (let i = 0; i <= recent.length - 5; i++) {\r\n      const bottom1 = recent[i];\r\n      const peak1 = recent[i + 1];\r\n      const bottom2 = recent[i + 2];\r\n      const peak2 = recent[i + 3];\r\n      const bottom3 = recent[i + 4];\r\n\r\n      // Validate structure: LOW -> HIGH -> LOW -> HIGH -> LOW\r\n      if (\r\n        bottom1.type !== SwingPointType.LOW ||\r\n        peak1.type !== SwingPointType.HIGH ||\r\n        bottom2.type !== SwingPointType.LOW ||\r\n        peak2.type !== SwingPointType.HIGH ||\r\n        bottom3.type !== SwingPointType.LOW\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Validate: all 3 bottoms at approximately same level (¬±3%)\r\n      const avgBottom = (bottom1.price + bottom2.price + bottom3.price) / 3;\r\n      const bottom1Diff = Math.abs((bottom1.price - avgBottom) / avgBottom) * PERCENT_MULTIPLIER;\r\n      const bottom2Diff = Math.abs((bottom2.price - avgBottom) / avgBottom) * PERCENT_MULTIPLIER;\r\n      const bottom3Diff = Math.abs((bottom3.price - avgBottom) / avgBottom) * PERCENT_MULTIPLIER;\r\n\r\n      if (\r\n        bottom1Diff > PEAK_TOLERANCE_PERCENT ||\r\n        bottom2Diff > PEAK_TOLERANCE_PERCENT ||\r\n        bottom3Diff > PEAK_TOLERANCE_PERCENT\r\n      ) {\r\n        continue; // Bottoms too different\r\n      }\r\n\r\n      // Validate: peaks should be higher than bottoms\r\n      if (peak1.price <= bottom1.price || peak2.price <= bottom2.price) {\r\n        continue;\r\n      }\r\n\r\n      // Check pattern timespan\r\n      const patternMinutes = (bottom3.timestamp - bottom1.timestamp) / TIME_UNITS.MINUTE;\r\n      if (patternMinutes < MIN_PATTERN_BARS || patternMinutes > MAX_PATTERN_BARS) {\r\n        continue;\r\n      }\r\n\r\n      // Calculate pattern metrics\r\n      const neckline = (peak1.price + peak2.price) / 2;\r\n      const patternHeight = neckline - avgBottom;\r\n      const target = neckline + patternHeight; // Project upward\r\n      const stopLoss = avgBottom - patternHeight * 0.15; // 15% below bottoms\r\n\r\n      // Calculate confidence\r\n      const maxDiff = Math.max(bottom1Diff, bottom2Diff, bottom3Diff);\r\n      const confidence = BASE_CONFIDENCE + (3.0 - maxDiff) * 5;\r\n\r\n      return {\r\n        detected: true,\r\n        type: TriplePatternType.TRIPLE_BOTTOM,\r\n        direction: 'LONG',\r\n        confidence: Math.min(100, confidence),\r\n        neckline,\r\n        target,\r\n        stopLoss,\r\n        points: [bottom1, peak1, bottom2, peak2, bottom3],\r\n        explanation: `Triple Bottom: bottoms ${bottom1.price.toFixed(DECIMAL_PLACES.PRICE)}/${bottom2.price.toFixed(DECIMAL_PLACES.PRICE)}/${bottom3.price.toFixed(DECIMAL_PLACES.PRICE)}, neckline ${neckline.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      };\r\n    }\r\n\r\n    return this.noPattern('No valid Triple Bottom pattern');\r\n  }\r\n\r\n  /**\r\n   * Return no pattern result\r\n   */\r\n  private noPattern(reason: string): TriplePattern {\r\n    return {\r\n      detected: false,\r\n      type: TriplePatternType.NONE,\r\n      direction: 'LONG',\r\n      confidence: 0,\r\n      neckline: 0,\r\n      target: 0,\r\n      stopLoss: 0,\r\n      points: [],\r\n      explanation: reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\volume.analyzer.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":102,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":102,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3943,3946],"text":"(poc != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":224,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":224,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7569,7579],"text":"nodeStart == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":232,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":232,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7791,7800],"text":"nodeStart != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":242,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":242,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8083,8092],"text":"nodeStart != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":269,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":269,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8830,8840],"text":"nodeStart == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":277,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":277,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9052,9061],"text":"nodeStart != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":287,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":287,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9344,9353],"text":"nodeStart != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":306,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":306,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":368,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":368,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11473,11485],"text":"analysis.poc != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":406,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":406,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":449,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":449,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13959,13972],"text":"analysis.poc == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Volume Analyzer\r\n *\r\n * Analyzes volume by price levels (Volume Profile / VPVR).\r\n * Identifies:\r\n * - High Volume Nodes (HVN) - strong support/resistance zones\r\n * - Low Volume Nodes (LVN) - weak zones that price moves through quickly\r\n * - Point of Control (POC) - price level with maximum volume\r\n * - Volume imbalance by price level\r\n *\r\n * Single Responsibility: Analyze volume data ONLY\r\n * Does NOT make trading decisions - only provides analysis\r\n */\r\n\r\nimport { Candle, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface VolumeLevel {\r\n  price: number; // Price level (rounded)\r\n  volume: number; // Total volume at this level\r\n  buyVolume: number; // Volume from bullish candles\r\n  sellVolume: number; // Volume from bearish candles\r\n  buySellRatio: number; // Buy / Sell ratio\r\n}\r\n\r\nexport interface VolumeNode {\r\n  type: 'HVN' | 'LVN'; // High Volume Node or Low Volume Node\r\n  priceStart: number; // Start of price zone\r\n  priceEnd: number; // End of price zone\r\n  volume: number; // Total volume in this zone\r\n  percentOfTotal: number; // % of total volume\r\n  distance: number; // Distance from current price (%)\r\n}\r\n\r\nexport interface VolumeAnalysis {\r\n  poc: VolumeLevel | null; // Point of Control (max volume level)\r\n  hvns: VolumeNode[]; // High Volume Nodes (strong support/resistance)\r\n  lvns: VolumeNode[]; // Low Volume Nodes (weak zones)\r\n  volumeByPrice: VolumeLevel[]; // All volume levels (sorted by price)\r\n  totalVolume: number; // Total volume across all levels\r\n  avgVolume: number; // Average volume per level\r\n  currentPriceVolume: VolumeLevel | null; // Volume at current price\r\n}\r\n\r\nexport interface VolumeConfig {\r\n  enabled: boolean;\r\n  priceBuckets: number; // Number of price buckets (50-200)\r\n  hvnThreshold: number; // Min % of avg volume to be HVN (1.5 = 150%)\r\n  lvnThreshold: number; // Max % of avg volume to be LVN (0.5 = CONFIDENCE_THRESHOLDS.MODERATE%)\r\n  minNodeSize: number; // Min price range for node (% of total range)\r\n}\r\n\r\n// ============================================================================\r\n// VOLUME ANALYZER\r\n// ============================================================================\r\n\r\nexport class VolumeAnalyzer {\r\n  constructor(\r\n    private config: VolumeConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Analyze volume distribution by price\r\n   *\r\n   * @param candles - Historical candles\r\n   * @param currentPrice - Current market price\r\n   * @returns Volume analysis\r\n   */\r\n  analyze(candles: Candle[], currentPrice: number): VolumeAnalysis {\r\n    if (candles.length === 0) {\r\n      this.logger.warn('No candles available for volume analysis');\r\n      return this.getEmptyAnalysis();\r\n    }\r\n\r\n    // 1. Build volume profile (volume by price)\r\n    const volumeByPrice = this.buildVolumeProfile(candles);\r\n\r\n    // 2. Calculate total and average volume\r\n    const totalVolume = volumeByPrice.reduce((sum, level) => sum + level.volume, 0);\r\n    const avgVolume = volumeByPrice.length > 0 ? totalVolume / volumeByPrice.length : 0;\r\n\r\n    // 3. Find Point of Control (max volume)\r\n    const poc = this.findPOC(volumeByPrice);\r\n\r\n    // 4. Detect High Volume Nodes (HVN)\r\n    const hvns = this.detectHVN(volumeByPrice, avgVolume, currentPrice);\r\n\r\n    // 5. Detect Low Volume Nodes (LVN)\r\n    const lvns = this.detectLVN(volumeByPrice, avgVolume, currentPrice);\r\n\r\n    // 6. Find volume at current price\r\n    const currentPriceVolume = this.findVolumeAtPrice(volumeByPrice, currentPrice);\r\n\r\n    this.logger.debug('Volume analysis complete', {\r\n      totalVolume: totalVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n      avgVolume: avgVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n      poc: poc ? `${poc.price.toFixed(DECIMAL_PLACES.PERCENT)} (${poc.volume.toFixed(DECIMAL_PLACES.PERCENT)})` : 'N/A',\r\n      hvns: hvns.length,\r\n      lvns: lvns.length,\r\n    });\r\n\r\n    return {\r\n      poc,\r\n      hvns,\r\n      lvns,\r\n      volumeByPrice,\r\n      totalVolume,\r\n      avgVolume,\r\n      currentPriceVolume,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Volume Profile\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Build volume profile (volume by price)\r\n   */\r\n  private buildVolumeProfile(candles: Candle[]): VolumeLevel[] {\r\n    // Find price range\r\n    let minPrice = candles[0].low;\r\n    let maxPrice = candles[0].high;\r\n\r\n    for (const candle of candles) {\r\n      if (candle.low < minPrice) {\r\n        minPrice = candle.low;\r\n      }\r\n      if (candle.high > maxPrice) {\r\n        maxPrice = candle.high;\r\n      }\r\n    }\r\n\r\n    const priceRange = maxPrice - minPrice;\r\n    const bucketSize = priceRange / this.config.priceBuckets;\r\n\r\n    // Create buckets\r\n    const buckets = new Map<number, { volume: number; buyVolume: number; sellVolume: number }>();\r\n\r\n    // Fill buckets with volume\r\n    for (const candle of candles) {\r\n      const isBullish = candle.close > candle.open;\r\n      const bucketIndex = Math.floor((candle.close - minPrice) / bucketSize);\r\n      const bucketPrice = minPrice + bucketIndex * bucketSize;\r\n\r\n      if (!buckets.has(bucketPrice)) {\r\n        buckets.set(bucketPrice, { volume: 0, buyVolume: 0, sellVolume: 0 });\r\n      }\r\n\r\n      const bucket = buckets.get(bucketPrice)!;\r\n      bucket.volume += candle.volume;\r\n\r\n      if (isBullish) {\r\n        bucket.buyVolume += candle.volume;\r\n      } else {\r\n        bucket.sellVolume += candle.volume;\r\n      }\r\n    }\r\n\r\n    // Convert to array and sort by price\r\n    const volumeByPrice: VolumeLevel[] = Array.from(buckets.entries())\r\n      .map(([price, data]) => ({\r\n        price,\r\n        volume: data.volume,\r\n        buyVolume: data.buyVolume,\r\n        sellVolume: data.sellVolume,\r\n        buySellRatio: data.sellVolume > 0 ? data.buyVolume / data.sellVolume : 0,\r\n      }))\r\n      .sort((a, b) => a.price - b.price);\r\n\r\n    return volumeByPrice;\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - POC\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find Point of Control (price level with max volume)\r\n   */\r\n  private findPOC(volumeByPrice: VolumeLevel[]): VolumeLevel | null {\r\n    if (volumeByPrice.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    let poc = volumeByPrice[0];\r\n    for (const level of volumeByPrice) {\r\n      if (level.volume > poc.volume) {\r\n        poc = level;\r\n      }\r\n    }\r\n\r\n    return poc;\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - HVN/LVN Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect High Volume Nodes (strong support/resistance)\r\n   */\r\n  private detectHVN(\r\n    volumeByPrice: VolumeLevel[],\r\n    avgVolume: number,\r\n    currentPrice: number,\r\n  ): VolumeNode[] {\r\n    const nodes: VolumeNode[] = [];\r\n    const threshold = avgVolume * this.config.hvnThreshold;\r\n\r\n    let nodeStart: VolumeLevel | null = null;\r\n    let nodeVolume = 0;\r\n\r\n    for (let i = 0; i < volumeByPrice.length; i++) {\r\n      const level = volumeByPrice[i];\r\n\r\n      if (level.volume >= threshold) {\r\n        // Start or continue HVN\r\n        if (!nodeStart) {\r\n          nodeStart = level;\r\n          nodeVolume = level.volume;\r\n        } else {\r\n          nodeVolume += level.volume;\r\n        }\r\n      } else {\r\n        // End HVN if one was in progress\r\n        if (nodeStart) {\r\n          const prevLevel = volumeByPrice[i - 1];\r\n          nodes.push(this.createNode('HVN', nodeStart, prevLevel, nodeVolume, currentPrice));\r\n          nodeStart = null;\r\n          nodeVolume = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle last node if still open\r\n    if (nodeStart) {\r\n      const lastLevel = volumeByPrice[volumeByPrice.length - 1];\r\n      nodes.push(this.createNode('HVN', nodeStart, lastLevel, nodeVolume, currentPrice));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Detect Low Volume Nodes (weak zones)\r\n   */\r\n  private detectLVN(\r\n    volumeByPrice: VolumeLevel[],\r\n    avgVolume: number,\r\n    currentPrice: number,\r\n  ): VolumeNode[] {\r\n    const nodes: VolumeNode[] = [];\r\n    const threshold = avgVolume * this.config.lvnThreshold;\r\n\r\n    let nodeStart: VolumeLevel | null = null;\r\n    let nodeVolume = 0;\r\n\r\n    for (let i = 0; i < volumeByPrice.length; i++) {\r\n      const level = volumeByPrice[i];\r\n\r\n      if (level.volume <= threshold) {\r\n        // Start or continue LVN\r\n        if (!nodeStart) {\r\n          nodeStart = level;\r\n          nodeVolume = level.volume;\r\n        } else {\r\n          nodeVolume += level.volume;\r\n        }\r\n      } else {\r\n        // End LVN if one was in progress\r\n        if (nodeStart) {\r\n          const prevLevel = volumeByPrice[i - 1];\r\n          nodes.push(this.createNode('LVN', nodeStart, prevLevel, nodeVolume, currentPrice));\r\n          nodeStart = null;\r\n          nodeVolume = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle last node if still open\r\n    if (nodeStart) {\r\n      const lastLevel = volumeByPrice[volumeByPrice.length - 1];\r\n      nodes.push(this.createNode('LVN', nodeStart, lastLevel, nodeVolume, currentPrice));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Create volume node\r\n   */\r\n  private createNode(\r\n    type: 'HVN' | 'LVN',\r\n    startLevel: VolumeLevel,\r\n    endLevel: VolumeLevel,\r\n    volume: number,\r\n    currentPrice: number,\r\n  ): VolumeNode {\r\n    const percentOfTotal = 0; // Will be calculated later if needed\r\n    const midPrice = (startLevel.price + endLevel.price) / 2;\r\n    const distance = ((midPrice - currentPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n    return {\r\n      type,\r\n      priceStart: startLevel.price,\r\n      priceEnd: endLevel.price,\r\n      volume,\r\n      percentOfTotal,\r\n      distance,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS - Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find volume at specific price\r\n   */\r\n  private findVolumeAtPrice(volumeByPrice: VolumeLevel[], price: number): VolumeLevel | null {\r\n    // Find closest level\r\n    let closest: VolumeLevel | null = null;\r\n    let minDistance = Infinity;\r\n\r\n    for (const level of volumeByPrice) {\r\n      const distance = Math.abs(level.price - price);\r\n      if (distance < minDistance) {\r\n        minDistance = distance;\r\n        closest = level;\r\n      }\r\n    }\r\n\r\n    return closest;\r\n  }\r\n\r\n  /**\r\n   * Get empty analysis (when no data)\r\n   */\r\n  private getEmptyAnalysis(): VolumeAnalysis {\r\n    return {\r\n      poc: null,\r\n      hvns: [],\r\n      lvns: [],\r\n      volumeByPrice: [],\r\n      totalVolume: 0,\r\n      avgVolume: 0,\r\n      currentPriceVolume: null,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // UTILITY METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get human-readable summary\r\n   */\r\n  getSummary(analysis: VolumeAnalysis): string {\r\n    const parts: string[] = [];\r\n\r\n    // POC\r\n    if (analysis.poc) {\r\n      parts.push(`POC: ${analysis.poc.price.toFixed(DECIMAL_PLACES.PERCENT)} (${analysis.poc.volume.toFixed(0)})`);\r\n    } else {\r\n      parts.push('No POC');\r\n    }\r\n\r\n    // HVNs\r\n    if (analysis.hvns.length > 0) {\r\n      const nearest = analysis.hvns.reduce((prev, curr) =>\r\n        Math.abs(curr.distance) < Math.abs(prev.distance) ? curr : prev,\r\n      );\r\n      parts.push(\r\n        `Nearest HVN: ${nearest.priceStart.toFixed(DECIMAL_PLACES.PERCENT)}-${nearest.priceEnd.toFixed(DECIMAL_PLACES.PERCENT)} (${nearest.distance.toFixed(DECIMAL_PLACES.PERCENT)}% away)`,\r\n      );\r\n    } else {\r\n      parts.push('No HVNs');\r\n    }\r\n\r\n    // LVNs\r\n    parts.push(`LVNs: ${analysis.lvns.length}`);\r\n\r\n    // Total volume\r\n    parts.push(`Total volume: ${analysis.totalVolume.toFixed(0)}`);\r\n\r\n    return parts.join(' | ');\r\n  }\r\n\r\n  /**\r\n   * Check if there's a HVN blocking the path\r\n   *\r\n   * @param analysis - Volume analysis\r\n   * @param direction - Trade direction (LONG/SHORT)\r\n   * @param maxDistance - Max distance to check (% from current price)\r\n   * @returns True if HVN is blocking\r\n   */\r\n  hasBlockingHVN(\r\n    analysis: VolumeAnalysis,\r\n    direction: 'LONG' | 'SHORT',\r\n    maxDistance: number = 2.0,\r\n  ): boolean {\r\n    for (const hvn of analysis.hvns) {\r\n      // For LONG: check HVNs above current price\r\n      if (direction === 'LONG' && hvn.distance > 0 && hvn.distance <= maxDistance) {\r\n        return true;\r\n      }\r\n\r\n      // For SHORT: check HVNs below current price\r\n      if (direction === 'SHORT' && hvn.distance < 0 && Math.abs(hvn.distance) <= maxDistance) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if current price is in a LVN (weak zone)\r\n   *\r\n   * @param analysis - Volume analysis\r\n   * @param currentPrice - Current market price\r\n   * @returns True if in LVN\r\n   */\r\n  isInLVN(analysis: VolumeAnalysis, currentPrice: number): boolean {\r\n    for (const lvn of analysis.lvns) {\r\n      if (currentPrice >= lvn.priceStart && currentPrice <= lvn.priceEnd) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if current price is near POC\r\n   *\r\n   * @param analysis - Volume analysis\r\n   * @param currentPrice - Current market price\r\n   * @param threshold - Max distance % to be considered \"near\"\r\n   * @returns True if near POC\r\n   */\r\n  isNearPOC(analysis: VolumeAnalysis, currentPrice: number, threshold: number = MULTIPLIERS.HALF): boolean {\r\n    if (!analysis.poc) {\r\n      return false;\r\n    }\r\n\r\n    const distance = Math.abs(((currentPrice - analysis.poc.price) / currentPrice) * PERCENT_MULTIPLIER);\r\n    return distance <= threshold;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\volume.calculator.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":81,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":81,"endColumn":65},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.1.","line":102,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":102,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.9.","line":105,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":105,"endColumn":17}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Volume Calculator\r\n *\r\n * Calculates volume metrics and confirmations for trading signals.\r\n * Used to filter out low liquidity entries and boost high volume signals.\r\n */\r\n\r\nimport { Candle, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_ROLLING_PERIOD = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // Candles for average calculation\r\nconst LOW_VOLUME_THRESHOLD = MULTIPLIERS.HALF; // Volume < 0.5x avg = low liquidity\r\nconst HIGH_VOLUME_THRESHOLD = 2.0; // Volume > 2x avg = high volume\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface VolumeAnalysis {\r\n  currentVolume: number;\r\n  avgVolume: number;\r\n  volumeRatio: number; // current / avg\r\n  isLowVolume: boolean; // < 0.5x avg (should block)\r\n  isHighVolume: boolean; // > 2x avg (boost confidence)\r\n  volumeModifier: number; // Confidence modifier (-10% to +10%)\r\n}\r\n\r\n// ============================================================================\r\n// VOLUME CALCULATOR\r\n// ============================================================================\r\n\r\nexport class VolumeCalculator {\r\n  constructor(\r\n    private logger: LoggerService,\r\n    private rollingPeriod: number = DEFAULT_ROLLING_PERIOD,\r\n  ) {}\r\n\r\n  /**\r\n   * Calculate volume analysis\r\n   * @param candles - Recent candles (at least rollingPeriod candles)\r\n   * @returns Volume analysis result\r\n   */\r\n  calculate(candles: Candle[]): VolumeAnalysis {\r\n    if (candles.length < this.rollingPeriod) {\r\n      this.logger.warn('Not enough candles for volume analysis', {\r\n        required: this.rollingPeriod,\r\n        available: candles.length,\r\n      });\r\n      return this.noVolumeData();\r\n    }\r\n\r\n    // Calculate average volume over rolling period\r\n    const recentCandles = candles.slice(-this.rollingPeriod);\r\n    const avgVolume =\r\n      recentCandles.reduce((sum, c) => sum + c.volume, 0) / this.rollingPeriod;\r\n\r\n    // Current candle volume\r\n    const currentCandle = candles[candles.length - 1];\r\n    const currentVolume = currentCandle.volume;\r\n\r\n    // Volume ratio\r\n    const volumeRatio = currentVolume / avgVolume;\r\n\r\n    // Low/High volume detection\r\n    const isLowVolume = volumeRatio < LOW_VOLUME_THRESHOLD;\r\n    const isHighVolume = volumeRatio > HIGH_VOLUME_THRESHOLD;\r\n\r\n    // Volume modifier for confidence\r\n    const volumeModifier = this.calculateVolumeModifier(volumeRatio);\r\n\r\n    this.logger.debug('Volume analysis', {\r\n      currentVolume: currentVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n      avgVolume: avgVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n      volumeRatio: volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      isLowVolume,\r\n      isHighVolume,\r\n      volumeModifier: (volumeModifier * PERCENT_MULTIPLIER - 100).toFixed(1) + '%',\r\n    });\r\n\r\n    return {\r\n      currentVolume,\r\n      avgVolume,\r\n      volumeRatio,\r\n      isLowVolume,\r\n      isHighVolume,\r\n      volumeModifier,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate volume modifier for confidence\r\n   * @param volumeRatio - Current volume / average volume\r\n   * @returns Modifier (0.90 to 1.10)\r\n   */\r\n  private calculateVolumeModifier(volumeRatio: number): number {\r\n    if (volumeRatio > HIGH_VOLUME_THRESHOLD) {\r\n      // High volume: +10% confidence\r\n      return 1.1;\r\n    } else if (volumeRatio < LOW_VOLUME_THRESHOLD) {\r\n      // Low volume: -10% confidence\r\n      return 0.9;\r\n    }\r\n    // Normal volume: no modifier\r\n    return 1.0;\r\n  }\r\n\r\n  /**\r\n   * Return no volume data result\r\n   */\r\n  private noVolumeData(): VolumeAnalysis {\r\n    return {\r\n      currentVolume: 0,\r\n      avgVolume: 0,\r\n      volumeRatio: 0,\r\n      isLowVolume: false,\r\n      isHighVolume: false,\r\n      volumeModifier: MULTIPLIERS.NEUTRAL,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\wedge-pattern.detector.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'detect' has a complexity of 13. Maximum allowed is 10.","line":66,"column":9,"nodeType":"FunctionExpression","messageId":"complex","endLine":134,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":67,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":67,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -12.","line":71,"column":38,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":71,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":104,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":104,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":120,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":120,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":179,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":179,"endColumn":66},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":193,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":193,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":194,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":46},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":201,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":201,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":203,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":203,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":208,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":208,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":209,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":209,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":216,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":216,"endColumn":31}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TIME_UNITS } from '../constants';\r\n/**\r\n * Wedge Pattern Detector\r\n *\r\n * Detects wedge reversal patterns (Rising Wedge, Falling Wedge).\r\n * Unlike triangles which are continuation patterns, wedges are REVERSAL patterns.\r\n *\r\n * Rising Wedge (Bearish Reversal):\r\n *    /|        Both lines rising\r\n *   / |        but converging\r\n *  /  |        ‚Üí SHORT on break\r\n * /   |        Price exhaustion\r\n *\r\n * Falling Wedge (Bullish Reversal):\r\n * |\\          Both lines falling\r\n * | \\         but converging\r\n * |  \\        ‚Üí LONG on break\r\n * |   \\       Selling exhaustion\r\n */\r\n\r\nimport { SwingPoint, SwingPointType, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum WedgePatternType {\r\n  RISING = 'RISING_WEDGE',\r\n  FALLING = 'FALLING_WEDGE',\r\n  NONE = 'NONE',\r\n}\r\n\r\nexport interface WedgePattern {\r\n  detected: boolean;\r\n  type: WedgePatternType;\r\n  direction: 'LONG' | 'SHORT';\r\n  confidence: number; // 0-100%\r\n  apex: number; // Price at apex\r\n  target: number; // Breakout target\r\n  stopLoss: number; // Stop loss level\r\n  resistanceLine: { slope: number; highs: SwingPoint[] };\r\n  supportLine: { slope: number; lows: SwingPoint[] };\r\n  explanation: string;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BASE_CONFIDENCE = 65;\r\nconst MIN_TOUCHES = 2; // Minimum touches per trendline\r\nconst CONVERGENCE_THRESHOLD = 0.0001; // Minimum convergence required\r\nconst MIN_PATTERN_BARS = 25; // Wedges need time to develop\r\nconst MAX_PATTERN_BARS = 180;\r\n\r\n// ============================================================================\r\n// WEDGE PATTERN DETECTOR\r\n// ============================================================================\r\n\r\nexport class WedgePatternDetector {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect wedge pattern from swing points\r\n   */\r\n  detect(swingPoints: SwingPoint[], currentTrend?: 'BULLISH' | 'BEARISH' | 'NEUTRAL'): WedgePattern {\r\n    if (swingPoints.length < 6) {\r\n      return this.noPattern('Not enough swing points (need 6+)');\r\n    }\r\n\r\n    const recent = swingPoints.slice(-12); // Last 12 swing points\r\n\r\n    // Separate highs and lows\r\n    const highs = recent.filter(p => p.type === SwingPointType.HIGH);\r\n    const lows = recent.filter(p => p.type === SwingPointType.LOW);\r\n\r\n    if (highs.length < MIN_TOUCHES || lows.length < MIN_TOUCHES) {\r\n      return this.noPattern('Not enough highs/lows for trendlines');\r\n    }\r\n\r\n    // Calculate trendlines\r\n    const resistanceLine = this.calculateTrendline(highs);\r\n    const supportLine = this.calculateTrendline(lows);\r\n\r\n    // Check pattern timespan\r\n    const firstPoint = recent[0];\r\n    const lastPoint = recent[recent.length - 1];\r\n    const patternMinutes = (lastPoint.timestamp - firstPoint.timestamp) / TIME_UNITS.MINUTE;\r\n\r\n    if (patternMinutes < MIN_PATTERN_BARS || patternMinutes > MAX_PATTERN_BARS) {\r\n      return this.noPattern('Pattern timespan invalid');\r\n    }\r\n\r\n    // Check if lines converge\r\n    const converging = resistanceLine.slope - supportLine.slope < -CONVERGENCE_THRESHOLD;\r\n\r\n    if (!converging) {\r\n      return this.noPattern('Lines not converging');\r\n    }\r\n\r\n    // Rising Wedge: BOTH lines rising (bearish reversal)\r\n    if (resistanceLine.slope > 0 && supportLine.slope > 0) {\r\n      // Support line MUST be steeper (rising faster) for valid rising wedge\r\n      if (supportLine.slope > resistanceLine.slope * 0.5) {\r\n        return this.buildPattern(\r\n          WedgePatternType.RISING,\r\n          'SHORT',\r\n          resistanceLine,\r\n          supportLine,\r\n          highs,\r\n          lows,\r\n          currentTrend,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Falling Wedge: BOTH lines falling (bullish reversal)\r\n    if (resistanceLine.slope < 0 && supportLine.slope < 0) {\r\n      // Resistance line MUST be steeper (falling faster) for valid falling wedge\r\n      if (resistanceLine.slope < supportLine.slope * 0.5) {\r\n        return this.buildPattern(\r\n          WedgePatternType.FALLING,\r\n          'LONG',\r\n          resistanceLine,\r\n          supportLine,\r\n          highs,\r\n          lows,\r\n          currentTrend,\r\n        );\r\n      }\r\n    }\r\n\r\n    return this.noPattern('No valid wedge pattern');\r\n  }\r\n\r\n  /**\r\n   * Calculate trendline using linear regression\r\n   */\r\n  private calculateTrendline(points: SwingPoint[]): { slope: number; intercept: number } {\r\n    const n = points.length;\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n    let sumXY = 0;\r\n    let sumX2 = 0;\r\n\r\n    // Use timestamp as X, price as Y\r\n    const baseTime = points[0].timestamp;\r\n\r\n    for (const point of points) {\r\n      const x = (point.timestamp - baseTime) / TIME_UNITS.MINUTE; // Minutes from start\r\n      const y = point.price;\r\n      sumX += x;\r\n      sumY += y;\r\n      sumXY += x * y;\r\n      sumX2 += x * x;\r\n    }\r\n\r\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\r\n    const intercept = (sumY - slope * sumX) / n;\r\n\r\n    return { slope, intercept };\r\n  }\r\n\r\n  /**\r\n   * Build wedge pattern result\r\n   */\r\n  private buildPattern(\r\n    type: WedgePatternType,\r\n    direction: 'LONG' | 'SHORT',\r\n    resistanceLine: { slope: number; intercept: number },\r\n    supportLine: { slope: number; intercept: number },\r\n    highs: SwingPoint[],\r\n    lows: SwingPoint[],\r\n    currentTrend?: 'BULLISH' | 'BEARISH' | 'NEUTRAL',\r\n  ): WedgePattern {\r\n    // Calculate apex (where lines meet)\r\n    const latestHigh = highs[highs.length - 1];\r\n    const latestLow = lows[lows.length - 1];\r\n    const currentPrice = (latestHigh.price + latestLow.price) / 2;\r\n\r\n    // Wedge height (widest part)\r\n    const firstHigh = highs[0].price;\r\n    const firstLow = lows[0].price;\r\n    const wedgeHeight = firstHigh - firstLow;\r\n\r\n    // Target: project wedge height from breakout\r\n    const target = direction === 'LONG'\r\n      ? currentPrice + wedgeHeight\r\n      : currentPrice - wedgeHeight;\r\n\r\n    // Stop loss: opposite side of wedge\r\n    const stopLoss = direction === 'LONG'\r\n      ? latestLow.price - wedgeHeight * 0.15\r\n      : latestHigh.price + wedgeHeight * 0.15;\r\n\r\n    // Calculate confidence\r\n    let confidence = BASE_CONFIDENCE;\r\n\r\n    // Bonus for trend exhaustion (wedge against trend = more reliable)\r\n    if (type === WedgePatternType.RISING && currentTrend === 'BULLISH') {\r\n      confidence += 15; // Rising wedge in bullish trend = exhaustion signal\r\n    } else if (type === WedgePatternType.FALLING && currentTrend === 'BEARISH') {\r\n      confidence += 15; // Falling wedge in bearish trend = exhaustion signal\r\n    }\r\n\r\n    // Bonus for more touches\r\n    const totalTouches = highs.length + lows.length;\r\n    if (totalTouches >= 6) {\r\n      confidence += 10;\r\n    }\r\n\r\n    return {\r\n      detected: true,\r\n      type,\r\n      direction,\r\n      confidence: Math.min(100, confidence),\r\n      apex: currentPrice,\r\n      target,\r\n      stopLoss,\r\n      resistanceLine: { slope: resistanceLine.slope, highs },\r\n      supportLine: { slope: supportLine.slope, lows },\r\n      explanation: `${type}: ${highs.length} highs, ${lows.length} lows, ${totalTouches} touches`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Return no pattern result\r\n   */\r\n  private noPattern(reason: string): WedgePattern {\r\n    return {\r\n      detected: false,\r\n      type: WedgePatternType.NONE,\r\n      direction: 'LONG',\r\n      confidence: 0,\r\n      apex: 0,\r\n      target: 0,\r\n      stopLoss: 0,\r\n      resistanceLine: { slope: 0, highs: [] },\r\n      supportLine: { slope: 0, lows: [] },\r\n      explanation: reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\weight.calculator.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'getRSIModifier' has a complexity of 24. Maximum allowed is 10.","line":38,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":89,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":48,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":56,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":58,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":58,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":58,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":58,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":60,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":60,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":65,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":65,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 40.","line":73,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":75,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":75,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":77,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":77,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":85,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":85,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":104,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":104,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":106,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":106,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.8.","line":108,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":108,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":110,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":110,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":118,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":118,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":146,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":146,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":168,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.20.","line":169,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":169,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.30.","line":170,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":170,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.10.","line":171,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":171,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.70.","line":172,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":172,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.95.","line":173,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":173,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.85.","line":177,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":177,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.20.","line":178,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":178,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.70.","line":179,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":179,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.10.","line":180,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":180,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.30.","line":181,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":181,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.95.","line":182,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":182,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.10.","line":188,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":188,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":195,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":195,"endColumn":35},{"ruleId":"complexity","severity":1,"message":"Method 'getStochasticModifier' has a complexity of 11. Maximum allowed is 10.","line":208,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":251,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":217,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":217,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":218,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":218,"endColumn":37},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.15.","line":222,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":222,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.05.","line":224,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":224,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":225,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":225,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.95.","line":226,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":226,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":230,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":230,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":231,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":231,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.15.","line":235,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":235,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.05.","line":237,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":237,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":238,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":238,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.95.","line":239,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":239,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":247,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":247,"endColumn":35},{"ruleId":"complexity","severity":1,"message":"Method 'applyWeights' has a complexity of 11. Maximum allowed is 10.","line":259,"column":15,"nodeType":"FunctionExpression","messageId":"complex","endLine":339,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":277,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":277,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":289,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":289,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":296,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":296,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":303,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":303,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":314,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":314,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":325,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":325,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":329,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":329,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":332,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":332,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":333,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":333,"endColumn":44}],"suppressedMessages":[],"errorCount":52,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Weight Calculator (Phase 3)\r\n *\r\n * Replaces hard blocks with gradient weights for better signal quality.\r\n * Instead of blocking signals, applies confidence modifiers based on market conditions.\r\n *\r\n * Benefits:\r\n * - +30-50% more entries (no hard blocks)\r\n * - Better risk adjustment (weak signals = low confidence)\r\n * - Fewer missed opportunities\r\n */\r\n\r\nimport { WeightSystemConfig, SignalDirection, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PERCENT_TO_DECIMAL = 100;\r\n\r\n// ============================================================================\r\n// WEIGHT CALCULATOR\r\n// ============================================================================\r\n\r\nexport class WeightCalculator {\r\n  constructor(\r\n    private config: WeightSystemConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Calculate RSI-based confidence modifier\r\n   * @param rsi - Current RSI value (0-100)\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns Multiplier for confidence (0.85 to 1.20)\r\n   */\r\n  getRSIModifier(rsi: number, direction: SignalDirection): number {\r\n    if (!this.config.enabled || !this.config.rsiWeights.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    const cfg = this.config.rsiWeights;\r\n    let modifier = 1.0;\r\n\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: Favor oversold, penalize overbought\r\n      if (rsi < 20) {\r\n        modifier = 1.0 + cfg.extremeBonus; // +20% extreme oversold (< 20)\r\n      } else if (rsi <= PERCENTAGE_THRESHOLDS.MODERATE) {\r\n        modifier = 1.0 + cfg.strongBonus; // +15% oversold (20-30)\r\n      } else if (rsi <= PERCENTAGE_THRESHOLDS.MODERATE_HIGH) {\r\n        modifier = 1.0 + cfg.moderateBonus; // +10% moderate oversold (30-40)\r\n      } else if (rsi >= cfg.neutralZoneMin && rsi <= cfg.neutralZoneMax) {\r\n        modifier = 1.0; // No modifier in neutral zone (40-60)\r\n      } else if (rsi > 60 && rsi <= CONFIDENCE_THRESHOLDS.MODERATE) {\r\n        modifier = 1.0 - cfg.slightPenalty; // -5% slightly overbought (60-70)\r\n      } else if (rsi > 70 && rsi <= 80) {\r\n        modifier = 1.0 - cfg.moderatePenalty; // -10% overbought (70-80)\r\n      } else if (rsi > 80) {\r\n        modifier = 1.0 - cfg.strongPenalty; // -15% very overbought (> 80)\r\n      }\r\n    } else {\r\n      // SHORT: Favor overbought, penalize oversold\r\n      if (rsi > 80) {\r\n        modifier = 1.0 + cfg.extremeBonus; // +20% extreme overbought (> 80)\r\n      } else if (rsi >= CONFIDENCE_THRESHOLDS.MODERATE) {\r\n        modifier = 1.0 + cfg.strongBonus; // +15% overbought (70-80)\r\n      } else if (rsi >= PERCENTAGE_THRESHOLDS.VERY_HIGH) {\r\n        modifier = 1.0 + cfg.moderateBonus; // +10% moderate overbought (60-70)\r\n      } else if (rsi >= cfg.neutralZoneMin && rsi <= cfg.neutralZoneMax) {\r\n        modifier = 1.0; // No modifier in neutral zone (40-60)\r\n      } else if (rsi < 40 && rsi >= PERCENTAGE_THRESHOLDS.MODERATE) {\r\n        modifier = 1.0 - cfg.slightPenalty; // -5% slightly oversold (30-40)\r\n      } else if (rsi < 30 && rsi >= PERCENTAGE_THRESHOLDS.LOW_MODERATE) {\r\n        modifier = 1.0 - cfg.moderatePenalty; // -10% oversold (20-30)\r\n      } else if (rsi < 20) {\r\n        modifier = 1.0 - cfg.strongPenalty; // -15% very oversold (< 20)\r\n      }\r\n    }\r\n\r\n    this.logger.debug('RSI modifier calculated', {\r\n      rsi: rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      direction,\r\n      modifier: modifier.toFixed(3),\r\n    });\r\n\r\n    return modifier;\r\n  }\r\n\r\n  /**\r\n   * Calculate volume-based confidence modifier\r\n   * @param volumeRatio - Current volume / avg volume (e.g., 1.5 = 150%)\r\n   * @returns Multiplier for confidence (0.90 to 1.10)\r\n   */\r\n  getVolumeModifier(volumeRatio: number): number {\r\n    if (!this.config.enabled || !this.config.volumeWeights.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    const cfg = this.config.volumeWeights;\r\n    let modifier = 1.0;\r\n\r\n    if (volumeRatio > 2.0) {\r\n      modifier = 1.0 + cfg.veryHighBonus; // +10% very high volume\r\n    } else if (volumeRatio >= 1.5) {\r\n      modifier = 1.0 + cfg.highBonus; // +5% high volume\r\n    } else if (volumeRatio >= 0.8) {\r\n      modifier = 1.0; // Normal volume (no modifier)\r\n    } else if (volumeRatio >= 0.5) {\r\n      modifier = 1.0 - cfg.lowPenalty; // -5% low volume\r\n    } else {\r\n      modifier = 1.0 - cfg.veryLowPenalty; // -10% very low volume\r\n    }\r\n\r\n    this.logger.debug('Volume modifier calculated', {\r\n      volumeRatio: volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      modifier: modifier.toFixed(3),\r\n    });\r\n\r\n    return modifier;\r\n  }\r\n\r\n  /**\r\n   * Calculate level strength-based confidence modifier\r\n   * @param touches - Number of touches on the level\r\n   * @returns Multiplier for confidence (1.00 to 1.40)\r\n   */\r\n  getLevelStrengthModifier(touches: number): number {\r\n    if (!this.config.enabled || !this.config.levelStrengthWeights.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    const cfg = this.config.levelStrengthWeights;\r\n    let modifier = 1.0;\r\n\r\n    if (touches >= cfg.minTouchesForStrong) {\r\n      modifier = 1.0 + cfg.strongLevelBonus; // +40% strong level (3+ touches)\r\n    } else if (touches >= cfg.minTouchesForMedium) {\r\n      modifier = 1.0 + cfg.mediumLevelBonus; // +20% medium level (2 touches)\r\n    }\r\n    // touches === 1: no modifier (weak level)\r\n\r\n    this.logger.debug('Level strength modifier calculated', {\r\n      touches,\r\n      modifier: modifier.toFixed(3),\r\n    });\r\n\r\n    return modifier;\r\n  }\r\n\r\n  /**\r\n   * Calculate Bollinger Bands-based confidence modifier (BB.MD)\r\n   * @param percentB - Price position in BB (0.0 - 1.0)\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param isSqueeze - Is BB squeeze detected\r\n   * @returns Multiplier for confidence (0.90 to 1.30 + squeeze bonus)\r\n   */\r\n  getBollingerModifier(percentB: number, direction: SignalDirection, isSqueeze: boolean): number {\r\n    if (!this.config.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    let modifier = 1.0;\r\n\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: Price near lower band = good entry (BB.MD Section 2.3)\r\n      if (percentB <= 0.15) {\r\n        modifier = 1.20; // +20% very close to lower band\r\n      } else if (percentB <= 0.30) {\r\n        modifier = 1.10; // +10% somewhat close to lower band\r\n      } else if (percentB > 0.70) {\r\n        modifier = 0.95; // -5% price near upper band (bad for LONG)\r\n      }\r\n    } else {\r\n      // SHORT: Price near upper band = good entry\r\n      if (percentB >= 0.85) {\r\n        modifier = 1.20; // +20% very close to upper band\r\n      } else if (percentB >= 0.70) {\r\n        modifier = 1.10; // +10% somewhat close to upper band\r\n      } else if (percentB < 0.30) {\r\n        modifier = 0.95; // -5% price near lower band (bad for SHORT)\r\n      }\r\n    }\r\n\r\n    // BB Squeeze bonus (BB.MD Section 2.3)\r\n    if (isSqueeze) {\r\n      modifier += 0.10; // +10% additional bonus for squeeze (potential breakout)\r\n    }\r\n\r\n    this.logger.debug('Bollinger modifier calculated', {\r\n      percentB: percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n      direction,\r\n      isSqueeze,\r\n      modifier: modifier.toFixed(3),\r\n    });\r\n\r\n    return modifier;\r\n  }\r\n\r\n  /**\r\n   * Calculate Stochastic-based confidence modifier with RSI confirmation (BB.MD)\r\n   * @param stochK - Stochastic %K value (0-100)\r\n   * @param rsi - RSI value for confirmation (0-100)\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns Multiplier for confidence (0.95 to 1.15)\r\n   */\r\n  getStochasticModifier(stochK: number, rsi: number, direction: SignalDirection): number {\r\n    if (!this.config.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    let modifier = 1.0;\r\n\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: Favor oversold Stochastic\r\n      const isStochOversold = stochK < 20;\r\n      const isRSIOversold = rsi < 30;\r\n\r\n      if (isStochOversold && isRSIOversold) {\r\n        // Double confirmation (BB.MD Section 2.3)\r\n        modifier = 1.15; // +15% both oversold\r\n      } else if (isStochOversold) {\r\n        modifier = 1.05; // +5% only Stochastic oversold\r\n      } else if (stochK > 80) {\r\n        modifier = 0.95; // -5% Stochastic overbought (bad for LONG)\r\n      }\r\n    } else {\r\n      // SHORT: Favor overbought Stochastic\r\n      const isStochOverbought = stochK > 80;\r\n      const isRSIOverbought = rsi > 70;\r\n\r\n      if (isStochOverbought && isRSIOverbought) {\r\n        // Double confirmation (BB.MD Section 2.3)\r\n        modifier = 1.15; // +15% both overbought\r\n      } else if (isStochOverbought) {\r\n        modifier = 1.05; // +5% only Stochastic overbought\r\n      } else if (stochK < 20) {\r\n        modifier = 0.95; // -5% Stochastic oversold (bad for SHORT)\r\n      }\r\n    }\r\n\r\n    this.logger.debug('Stochastic modifier calculated', {\r\n      stochK: stochK.toFixed(DECIMAL_PLACES.PERCENT),\r\n      rsi: rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      direction,\r\n      modifier: modifier.toFixed(3),\r\n    });\r\n\r\n    return modifier;\r\n  }\r\n\r\n  /**\r\n   * Apply all weight modifiers to confidence\r\n   * @param baseConfidence - Original confidence from strategy\r\n   * @param params - Market parameters\r\n   * @returns Adjusted confidence with all modifiers applied\r\n   */\r\n  applyWeights(\r\n    baseConfidence: number,\r\n    params: {\r\n      rsi?: number;\r\n      direction?: SignalDirection;\r\n      volumeRatio?: number;\r\n      levelTouches?: number;\r\n      bollingerBands?: {\r\n        percentB: number;\r\n        isSqueeze: boolean;\r\n      };\r\n      stochastic?: {\r\n        k: number;\r\n      };\r\n    },\r\n  ): number {\r\n    if (!this.config.enabled) {\r\n      this.logger.debug('Weight system disabled, returning base confidence', {\r\n        baseConfidence: baseConfidence.toFixed(3),\r\n      });\r\n      return baseConfidence;\r\n    }\r\n\r\n    let confidence = baseConfidence;\r\n    const modifiers: string[] = [];\r\n\r\n    // Apply RSI modifier\r\n    if (params.rsi !== undefined && params.direction !== undefined) {\r\n      const rsiMod = this.getRSIModifier(params.rsi, params.direction);\r\n      confidence *= rsiMod;\r\n      modifiers.push(`RSI√ó${rsiMod.toFixed(3)}`);\r\n    }\r\n\r\n    // Apply volume modifier\r\n    if (params.volumeRatio !== undefined) {\r\n      const volMod = this.getVolumeModifier(params.volumeRatio);\r\n      confidence *= volMod;\r\n      modifiers.push(`Vol√ó${volMod.toFixed(3)}`);\r\n    }\r\n\r\n    // Apply level strength modifier\r\n    if (params.levelTouches !== undefined) {\r\n      const levelMod = this.getLevelStrengthModifier(params.levelTouches);\r\n      confidence *= levelMod;\r\n      modifiers.push(`Level√ó${levelMod.toFixed(3)}`);\r\n    }\r\n\r\n    // Apply Bollinger Bands modifier (BB.MD)\r\n    if (params.bollingerBands !== undefined && params.direction !== undefined) {\r\n      const bbMod = this.getBollingerModifier(\r\n        params.bollingerBands.percentB,\r\n        params.direction,\r\n        params.bollingerBands.isSqueeze,\r\n      );\r\n      confidence *= bbMod;\r\n      modifiers.push(`BB√ó${bbMod.toFixed(3)}`);\r\n    }\r\n\r\n    // Apply Stochastic modifier with RSI confirmation (BB.MD)\r\n    if (\r\n      params.stochastic !== undefined &&\r\n      params.rsi !== undefined &&\r\n      params.direction !== undefined\r\n    ) {\r\n      const stochMod = this.getStochasticModifier(params.stochastic.k, params.rsi, params.direction);\r\n      confidence *= stochMod;\r\n      modifiers.push(`Stoch√ó${stochMod.toFixed(3)}`);\r\n    }\r\n\r\n    // Clamp confidence to valid range [0.1, 1.0]\r\n    confidence = Math.max(0.1, Math.min(1.0, confidence));\r\n\r\n    this.logger.info('‚öñÔ∏è Weight system applied', {\r\n      baseConfidence: baseConfidence.toFixed(3),\r\n      finalConfidence: confidence.toFixed(3),\r\n      modifiers: modifiers.join(', '),\r\n      change: `${((confidence - baseConfidence) * PERCENT_TO_DECIMAL).toFixed(1)}%`,\r\n    });\r\n\r\n    return confidence;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\analyzers\\wick.analyzer.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.0001.","line":52,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":26},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":111,"column":69,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":111,"endColumn":71}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Wick Analyzer\r\n *\r\n * Detects large wicks (rejection candles) that signal potential reversals or resistance.\r\n * Wick > 2x body size indicates strong rejection at that level.\r\n */\r\n\r\nimport { Candle, LoggerService, SignalDirection } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst LARGE_WICK_THRESHOLD = 2.0; // Wick > 2x body = large wick\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum WickDirection {\r\n  UP = 'UP', // Upper wick (resistance rejection)\r\n  DOWN = 'DOWN', // Lower wick (support rejection)\r\n  NONE = 'NONE', // No significant wick\r\n}\r\n\r\nexport interface WickAnalysis {\r\n  hasLargeWick: boolean;\r\n  wickDirection: WickDirection;\r\n  wickSize: number; // Absolute size\r\n  bodySize: number; // Absolute size\r\n  wickToBodyRatio: number; // wick / body\r\n  blocksDirection?: SignalDirection; // Which direction this wick blocks\r\n}\r\n\r\n// ============================================================================\r\n// WICK ANALYZER\r\n// ============================================================================\r\n\r\nexport class WickAnalyzer {\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Detect large wicks on a candle\r\n   * @param candle - Candle to analyze\r\n   * @returns Wick analysis result\r\n   */\r\n  analyze(candle: Candle): WickAnalysis {\r\n    const bodySize = Math.abs(candle.close - candle.open);\r\n\r\n    // Handle doji/very small body\r\n    if (bodySize < 0.0001) {\r\n      this.logger.debug('Doji candle detected (no body)', {\r\n        timestamp: candle.timestamp,\r\n      });\r\n      return this.noWick(0);\r\n    }\r\n\r\n    const upperWick = candle.high - Math.max(candle.open, candle.close);\r\n    const lowerWick = Math.min(candle.open, candle.close) - candle.low;\r\n\r\n    // Check upper wick\r\n    if (upperWick > bodySize * LARGE_WICK_THRESHOLD) {\r\n      const ratio = upperWick / bodySize;\r\n      this.logger.debug('Large upper wick detected', {\r\n        upperWick: upperWick.toFixed(DECIMAL_PLACES.PRICE),\r\n        bodySize: bodySize.toFixed(DECIMAL_PLACES.PRICE),\r\n        ratio: ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      return {\r\n        hasLargeWick: true,\r\n        wickDirection: WickDirection.UP,\r\n        wickSize: upperWick,\r\n        bodySize,\r\n        wickToBodyRatio: ratio,\r\n        blocksDirection: SignalDirection.LONG, // Upper wick blocks LONG (resistance)\r\n      };\r\n    }\r\n\r\n    // Check lower wick\r\n    if (lowerWick > bodySize * LARGE_WICK_THRESHOLD) {\r\n      const ratio = lowerWick / bodySize;\r\n      this.logger.debug('Large lower wick detected', {\r\n        lowerWick: lowerWick.toFixed(DECIMAL_PLACES.PRICE),\r\n        bodySize: bodySize.toFixed(DECIMAL_PLACES.PRICE),\r\n        ratio: ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      return {\r\n        hasLargeWick: true,\r\n        wickDirection: WickDirection.DOWN,\r\n        wickSize: lowerWick,\r\n        bodySize,\r\n        wickToBodyRatio: ratio,\r\n        blocksDirection: SignalDirection.SHORT, // Lower wick blocks SHORT (support)\r\n      };\r\n    }\r\n\r\n    // No large wick\r\n    return this.noWick(bodySize);\r\n  }\r\n\r\n  /**\r\n   * Check if wick blocks a specific signal direction\r\n   * @param wickAnalysis - Wick analysis result\r\n   * @param signalDirection - Signal direction to check\r\n   * @returns True if wick blocks this direction\r\n   */\r\n  blocksSignal(wickAnalysis: WickAnalysis, signalDirection: SignalDirection): boolean {\r\n    if (!wickAnalysis.hasLargeWick || (wickAnalysis.blocksDirection == null)) {\r\n      return false;\r\n    }\r\n    return wickAnalysis.blocksDirection === signalDirection;\r\n  }\r\n\r\n  /**\r\n   * Return no wick result\r\n   */\r\n  private noWick(bodySize: number): WickAnalysis {\r\n    return {\r\n      hasLargeWick: false,\r\n      wickDirection: WickDirection.NONE,\r\n      wickSize: 0,\r\n      bodySize,\r\n      wickToBodyRatio: 0,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\backtest\\backtest-engine-v2.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fs' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENTAGE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PendingEntry' is defined but never used. Allowed unused vars must match /^_/u.","line":33,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CandleProvider' is defined but never used. Allowed unused vars must match /^_/u.","line":36,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TickDeltaAnalyzerService' is defined but never used. Allowed unused vars must match /^_/u.","line":53,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":53,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LadderTpManagerService' is defined but never used. Allowed unused vars must match /^_/u.","line":54,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LimitOrderExecutorService' is defined but never used. Allowed unused vars must match /^_/u.","line":55,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OrderFlowAnalyzerService' is defined but never used. Allowed unused vars must match /^_/u.","line":56,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TimeframeValidator' is defined but never used. Allowed unused vars must match /^_/u.","line":65,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'symbol' is defined but never used. Allowed unused args must match /^_/u.","line":80,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":52},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":84,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":84,"endColumn":20},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getCandles' has no 'await' expression.","line":91,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":91,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":108,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":108,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5292,5297],"text":"limit != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5292,5297],"text":"limit ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5292,5297],"text":"Boolean(limit)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getCurrentPrice' has no 'await' expression.","line":114,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":114,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6115,6118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6115,6118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 123. Maximum allowed is 120.","line":230,"column":1,"nodeType":"Program","messageId":"max","endLine":230,"endColumn":124},{"ruleId":"complexity","severity":1,"message":"Constructor has a complexity of 25. Maximum allowed is 10.","line":244,"column":14,"nodeType":"FunctionExpression","messageId":"complex","endLine":474,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":251,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":251,"endColumn":44,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9885,9920],"text":"Boolean((config.config.weightMatrix?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .weightMatrix on an `any` value.","line":251,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":251,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `WeightMatrixConfig`.","line":252,"column":61,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":252,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .weightMatrix on an `any` value.","line":252,"column":75,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":252,"endColumn":87},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .weightMatrix on an `any` value.","line":254,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":254,"endColumn":57},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":259,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":259,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10265,10321],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":260,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":260,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10327,10420],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":260,"column":60,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":260,"endColumn":70},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":261,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":261,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10426,10511],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":261,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":261,"endColumn":66},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":262,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":262,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10517,10608],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":262,"column":58,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":262,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":264,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":264,"endColumn":33},{"ruleId":"max-len","severity":1,"message":"This line has a length of 121. Maximum allowed is 120.","line":266,"column":1,"nodeType":"Program","messageId":"max","endLine":266,"endColumn":122},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `TrendFollowingConfig`.","line":266,"column":36,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":266,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":266,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":266,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":266,"column":90,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":266,"endColumn":107,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10800,10817],"text":"(this.weightMatrix != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":266,"column":108,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":266,"endColumn":110,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[10818,10820],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":268,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":268,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10850,10904],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":270,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":270,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `LevelBasedConfig`.","line":272,"column":32,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":272,"endColumn":67},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":272,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":272,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":272,"column":82,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":272,"endColumn":99,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11089,11106],"text":"(this.weightMatrix != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":272,"column":100,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":272,"endColumn":102,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[11107,11109],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":274,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":274,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11139,11189],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":276,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":276,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `CounterTrendConfig`.","line":278,"column":34,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":278,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":278,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":278,"endColumn":58},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":278,"column":86,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":278,"endColumn":103,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11380,11397],"text":"(this.weightMatrix != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":278,"column":104,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":278,"endColumn":106,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[11398,11400],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":280,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":280,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11430,11482],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":284,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":284,"endColumn":43,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[11578,11612],"text":"Boolean((config.config.whaleHunter?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .whaleHunter on an `any` value.","line":284,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":284,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `WhaleDetectorConfig`.","line":285,"column":54,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":285,"endColumn":88},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .whaleHunter on an `any` value.","line":285,"column":68,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":285,"endColumn":79},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":296,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":296,"endColumn":46,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[12077,12112],"text":"Boolean((config.config.wallTracking?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .wallTracking on an `any` value.","line":296,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":296,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `WallTrackingConfig`.","line":297,"column":51,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":297,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .wallTracking on an `any` value.","line":297,"column":65,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":297,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `WhaleHunterConfig`.","line":303,"column":11,"nodeType":"ObjectExpression","messageId":"unsafeArgument","endLine":306,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .whaleHunter on an `any` value.","line":304,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":304,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":305,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":305,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sessionBasedSL on an `any` value.","line":305,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":305,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":319,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":319,"endColumn":49,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[12832,12872],"text":"Boolean((config.config.scalpingMicroWall?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingMicroWall on an `any` value.","line":319,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":319,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `MicroWallDetectorConfig`.","line":321,"column":9,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":321,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingMicroWall on an `any` value.","line":321,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":321,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ScalpingMicroWallConfig`.","line":326,"column":11,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":326,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingMicroWall on an `any` value.","line":326,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":326,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":331,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":331,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13218,13275],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":334,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":334,"endColumn":49,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13294,13334],"text":"Boolean((config.config.scalpingTickDelta?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingTickDelta on an `any` value.","line":334,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":334,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ScalpingTickDeltaConfig`.","line":338,"column":11,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":338,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingTickDelta on an `any` value.","line":338,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":338,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":342,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":342,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13576,13633],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":345,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":345,"endColumn":49,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13652,13692],"text":"Boolean((config.config.scalpingOrderFlow?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingOrderFlow on an `any` value.","line":345,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":345,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ScalpingOrderFlowConfig`.","line":349,"column":11,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":349,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingOrderFlow on an `any` value.","line":349,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":349,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":353,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":353,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[13934,13991],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":358,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":358,"endColumn":48,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[14155,14194],"text":"Boolean((config.config.scalpingLadderTp?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingLadderTp on an `any` value.","line":358,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":358,"endColumn":39},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":359,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":359,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14205,14288],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":361,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":361,"endColumn":50,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[14305,14346],"text":"Boolean((config.config.scalpingLimitOrder?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scalpingLimitOrder on an `any` value.","line":361,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":361,"endColumn":41},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":362,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":362,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14357,14442],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":366,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":366,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14498,14567],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":369,"column":28,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":369,"endColumn":37,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[14698,14707],"text":"(Boolean(sAny.name))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":369,"column":41,"nodeType":"ChainExpression","messageId":"conditionErrorString","endLine":369,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[14711,14733],"text":"((sAny.constructor?.name).length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[14711,14733],"text":"((sAny.constructor?.name) !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14711,14733],"text":"(Boolean((sAny.constructor?.name)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":370,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":370,"endColumn":37,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[14772,14785],"text":"(Boolean(sAny.priority))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":371,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":371,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14803,14870],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":2,"message":"'strategyName' will evaluate to '[object Object]' when stringified.","line":371,"column":34,"nodeType":"Identifier","messageId":"baseToString","endLine":371,"endColumn":46},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"{}\" of template literal expression.","line":371,"column":34,"nodeType":"Identifier","messageId":"invalidType","endLine":371,"endColumn":46},{"ruleId":"@typescript-eslint/no-base-to-string","severity":2,"message":"'priority' will evaluate to '[object Object]' when stringified.","line":371,"column":61,"nodeType":"Identifier","messageId":"baseToString","endLine":371,"endColumn":69},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"{}\" of template literal expression.","line":371,"column":61,"nodeType":"Identifier","messageId":"invalidType","endLine":371,"endColumn":69},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":373,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":373,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[14885,14901],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":375,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":375,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 9.","line":376,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":376,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":377,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":377,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":379,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":379,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":379,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":379,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 12.","line":379,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":380,"column":48,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":380,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":383,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":383,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":383,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":383,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":383,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":383,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":384,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":384,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":384,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":384,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EntryConfirmationConfig`.","line":385,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":385,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entryConfirmation on an `any` value.","line":385,"column":73,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":385,"endColumn":90},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (986). Maximum allowed is 300.","line":389,"column":1,"nodeType":null,"messageId":"exceed","endLine":1307,"endColumn":1},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ContextConfig`.","line":390,"column":7,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":398,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":390,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":390,"endColumn":34,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[15830,15857],"text":"(Boolean(config.config.contextConfig))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .contextConfig on an `any` value.","line":390,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":390,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":397,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":397,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":397,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16071,16074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16071,16074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `CandleProvider`.","line":399,"column":7,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":399,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":399,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16116,16119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16116,16119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `EntryScannerConfig`.","line":403,"column":7,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":416,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":403,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":403,"endColumn":32,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16199,16224],"text":"(Boolean(config.config.entryConfig))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .entryConfig on an `any` value.","line":403,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":403,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":411,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":415,"endColumn":12},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":411,"column":22,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":411,"endColumn":73},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":411,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":411,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":411,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":411,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16519,16522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16519,16522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":412,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":412,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .level on an `any` value.","line":412,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":412,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":413,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":413,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .percent on an `any` value.","line":413,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":413,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":414,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":414,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sizePercent on an `any` value.","line":414,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":414,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `CandleProvider`.","line":417,"column":7,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":417,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":417,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16684,16687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16684,16687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":424,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":424,"endColumn":43,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16939,16973],"text":"Boolean((config.config.dailyLimits?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dailyLimits on an `any` value.","line":424,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":424,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `DailyLimitsConfig`.","line":425,"column":56,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":425,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dailyLimits on an `any` value.","line":425,"column":70,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":425,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dailyLimits on an `any` value.","line":428,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":428,"endColumn":47},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":429,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":429,"endColumn":67,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[17305,17352],"text":"(Boolean(config.config.dailyLimits.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dailyLimits on an `any` value.","line":429,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":429,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dailyLimits on an `any` value.","line":430,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":430,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":435,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":435,"endColumn":47,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[17475,17513],"text":"Boolean((config.config.riskBasedSizing?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .riskBasedSizing on an `any` value.","line":435,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":435,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `RiskBasedSizingConfig`.","line":436,"column":64,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":436,"endColumn":93},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .riskBasedSizing on an `any` value.","line":436,"column":78,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":436,"endColumn":93},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .riskBasedSizing on an `any` value.","line":438,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":438,"endColumn":51},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":442,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":442,"endColumn":42,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[17805,17838],"text":"Boolean((config.config.lossStreak?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lossStreak on an `any` value.","line":442,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":442,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `LossStreakConfig`.","line":443,"column":54,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":443,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lossStreak on an `any` value.","line":443,"column":68,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":443,"endColumn":78},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lossStreak on an `any` value.","line":445,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":445,"endColumn":45},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":446,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":446,"endColumn":66,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[18085,18125],"text":"(Boolean(config.config.lossStreak.stopAfterLosses))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lossStreak on an `any` value.","line":446,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":446,"endColumn":50},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":450,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":450,"endColumn":49,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[18170,18210],"text":"Boolean((config.config.maxConcurrentRisk?.enabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .maxConcurrentRisk on an `any` value.","line":450,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":450,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `MaxConcurrentRiskConfig`.","line":451,"column":68,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":451,"endColumn":99},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .maxConcurrentRisk on an `any` value.","line":451,"column":82,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":451,"endColumn":99},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .maxConcurrentRisk on an `any` value.","line":453,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":453,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .maxConcurrentRisk on an `any` value.","line":454,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":454,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .maxConcurrentRisk on an `any` value.","line":455,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":455,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `TFAlignmentConfig`.","line":464,"column":7,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":470,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":464,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":464,"endColumn":32,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[18988,19013],"text":"(Boolean(config.config.tfAlignment))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .tfAlignment on an `any` value.","line":464,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":464,"endColumn":32},{"ruleId":"complexity","severity":1,"message":"Async method 'run' has a complexity of 18. Maximum allowed is 10.","line":479,"column":12,"nodeType":"FunctionExpression","messageId":"complex","endLine":569,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":486,"column":25,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":486,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19604,19616],"text":"(dataProvider != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":486,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":486,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19617,19619],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":488,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":488,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19633,19696],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":489,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":489,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19702,19757],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":490,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":490,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19763,19833],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":491,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":491,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19843,19860],"text":"this.dataProvider != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":492,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":492,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[19871,19922],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":496,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":496,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":504,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":504,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":509,"column":97,"nodeType":"Literal","messageId":"noMagic","endLine":509,"endColumn":100},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":510,"column":97,"nodeType":"Literal","messageId":"noMagic","endLine":510,"endColumn":100},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":511,"column":99,"nodeType":"Literal","messageId":"noMagic","endLine":511,"endColumn":102},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":527,"column":15,"nodeType":"Literal","messageId":"noMagic","endLine":527,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":528,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":528,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21266,21357],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":529,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":529,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21367,21522],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":529,"column":36,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":529,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21394,21414],"text":"(this.currentPosition != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":529,"column":144,"nodeType":"Literal","messageId":"noMagic","endLine":529,"endColumn":145},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":530,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":530,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21532,21624],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":531,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":531,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[21634,21795],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":531,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":531,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21668,21689],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":531,"column":98,"nodeType":"Literal","messageId":"noMagic","endLine":531,"endColumn":101},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":535,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":535,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21871,21892],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":540,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":540,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22021,22041],"text":"this.currentPosition != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 136. Maximum allowed is 120.","line":545,"column":1,"nodeType":"Program","messageId":"max","endLine":545,"endColumn":137},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":545,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":545,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22183,22204],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":545,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":545,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":550,"column":15,"nodeType":"Literal","messageId":"noMagic","endLine":550,"endColumn":19},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":558,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":558,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[22637,22675],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":561,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":561,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22726,22746],"text":"this.currentPosition != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":566,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":566,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[22899,22971],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"complexity","severity":1,"message":"Async method 'checkEntry' has a complexity of 77. Maximum allowed is 10.","line":594,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":893,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 21.","line":609,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":609,"endColumn":51},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 9.","line":611,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":611,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 21.","line":613,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":613,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5000.","line":620,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":620,"endColumn":29},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":639,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":639,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[25402,25507],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":640,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":640,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[25519,25626],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":660,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":660,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":661,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":661,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":668,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":668,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":675,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":675,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":676,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":676,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26954,27060],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":677,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":677,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27070,27121],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":677,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":677,"endColumn":55},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":678,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":678,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27131,27237],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":678,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":678,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":678,"column":94,"nodeType":"Literal","messageId":"noMagic","endLine":678,"endColumn":95},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":679,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":679,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27247,27356],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":679,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":679,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":679,"column":97,"nodeType":"Literal","messageId":"noMagic","endLine":679,"endColumn":98},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":680,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":680,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27366,27490],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":680,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":680,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":680,"column":112,"nodeType":"Literal","messageId":"noMagic","endLine":680,"endColumn":113},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":681,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":681,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27500,27622],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":681,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":681,"endColumn":45},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":681,"column":66,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":681,"endColumn":69,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[27557,27560],"text":"(atr !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[27557,27560],"text":"(!Number.isNaN(atr))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27557,27560],"text":"(Boolean(atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":681,"column":96,"nodeType":"Literal","messageId":"noMagic","endLine":681,"endColumn":99},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":681,"column":109,"nodeType":"Literal","messageId":"noMagic","endLine":681,"endColumn":110},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":682,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":682,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27632,27734],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":683,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":683,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27744,27929],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":683,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":683,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":683,"column":96,"nodeType":"Literal","messageId":"noMagic","endLine":683,"endColumn":97},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":683,"column":144,"nodeType":"Literal","messageId":"noMagic","endLine":683,"endColumn":145},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":683,"column":172,"nodeType":"Literal","messageId":"noMagic","endLine":683,"endColumn":173},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":684,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":684,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27939,28016],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":685,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":685,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[28026,28059],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":686,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":686,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[28069,28217],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":686,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":686,"endColumn":63},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":687,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":687,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[28227,28412],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":687,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":687,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28253,28272],"text":"(this.currentContext != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":691,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":691,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28483,28501],"text":"(this.vwapIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'vwapData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":692,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":692,"endColumn":21},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":695,"column":69,"nodeType":"Literal","messageId":"noMagic","endLine":695,"endColumn":72},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":699,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":699,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28889,28912],"text":"(this.tfAlignmentService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'tfAlignmentScore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":708,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":708,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":708,"column":32,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":708,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[29272,29289],"text":"(tfAlignmentResult != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":724,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":724,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[29820,29837],"text":"(this.dataProvider != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":725,"column":14,"nodeType":"AwaitExpression","messageId":"conditionErrorNullableObject","endLine":725,"endColumn":105,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[29852,29943],"text":"(await this.dataProvider.loadOrderbookForCandle(this.config.symbol, currentCandle.timestamp)) != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":725,"column":107,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":725,"endColumn":109,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[29945,29947],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":727,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":732,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":729,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":729,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.02.","line":730,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":730,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":730,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":730,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":732,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":732,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30193,30196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30193,30196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":741,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":741,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30444,30460],"text":"(this.wallTracker != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":741,"column":31,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":741,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30464,30484],"text":"(marketData.orderbook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":745,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":745,"endColumn":27},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":746,"column":11,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":752,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":746,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":746,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":747,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":747,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30787,30790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30787,30790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .price on an `any` value.","line":747,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":747,"endColumn":82},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":748,"column":64,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":748,"endColumn":81,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[30864,30881],"text":"(Boolean((bid as any).size))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":748,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":748,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30872,30875],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30872,30875],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .size on an `any` value.","line":748,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":748,"endColumn":81},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":748,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":748,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30893,30896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30893,30896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .quantity on an `any` value.","line":748,"column":98,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":748,"endColumn":106},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":749,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":751,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":756,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":756,"endColumn":27},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":757,"column":11,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":763,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":757,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":757,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":758,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":758,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31325,31328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31325,31328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .price on an `any` value.","line":758,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":758,"endColumn":82},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":759,"column":64,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":759,"endColumn":81,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[31402,31419],"text":"(Boolean((ask as any).size))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":759,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":759,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31410,31413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31410,31413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .size on an `any` value.","line":759,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":759,"endColumn":81},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":759,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":759,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31431,31434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31431,31434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .quantity on an `any` value.","line":759,"column":98,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":759,"endColumn":106},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":760,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":762,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":776,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":776,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32029,32037],"text":"(e.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":783,"column":19,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":783,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32324,32344],"text":"((b.signal?.confidence) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[32324,32344],"text":"((b.signal?.confidence) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[32324,32344],"text":"(Boolean((b.signal?.confidence)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":783,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":783,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[32345,32347],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":783,"column":49,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":783,"endColumn":69,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32354,32374],"text":"((a.signal?.confidence) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[32354,32374],"text":"((a.signal?.confidence) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[32354,32374],"text":"(Boolean((a.signal?.confidence)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":783,"column":70,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":783,"endColumn":72,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[32375,32377],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":787,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":787,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32474,32491],"text":"(this.weightMatrix != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":787,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":787,"endColumn":72,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[32495,32535],"text":"(Boolean((this.config.config.weightMatrix?.enabled)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .weightMatrix on an `any` value.","line":787,"column":51,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":787,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":789,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":789,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32633,32658],"text":"((signal.signal?.confidence) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[32633,32658],"text":"((signal.signal?.confidence) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[32633,32658],"text":"(Boolean((signal.signal?.confidence)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":789,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":789,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[32659,32661],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":789,"column":72,"nodeType":"Literal","messageId":"noMagic","endLine":789,"endColumn":75},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":791,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":791,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .weightMatrix on an `any` value.","line":795,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":795,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":805,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":805,"endColumn":28},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":806,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":806,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[33332,33430],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":808,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":808,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33500,33508],"text":"(e.reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[33500,33508],"text":"(e.reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[33500,33508],"text":"(Boolean(e.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":808,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":808,"endColumn":65},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":808,"column":90,"nodeType":"Literal","messageId":"noMagic","endLine":808,"endColumn":92},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":809,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":809,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[33601,33707],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":813,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":813,"endColumn":21},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":827,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":827,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[34430,34577],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":830,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":830,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[34668,34812],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":836,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":836,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[34953,34982],"text":"(bestSignal.signal!.confidence !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[34953,34982],"text":"(!Number.isNaN(bestSignal.signal!.confidence))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[34953,34982],"text":"(Boolean(bestSignal.signal!.confidence))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":836,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":836,"endColumn":49},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":843,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":843,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[35216,35235],"text":"(this.currentContext != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":843,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":843,"endColumn":52},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":845,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":847,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":845,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":845,"endColumn":32},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":846,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":846,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[35361,35433],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":852,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":854,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":852,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":852,"endColumn":32},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":853,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":853,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[35641,35858],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":853,"column":174,"nodeType":"Literal","messageId":"noMagic","endLine":853,"endColumn":175},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":856,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":881,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":858,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":858,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[35983,36114],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":861,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":880,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":869,"column":52,"nodeType":"Property","messageId":"anyAssignment","endLine":869,"endColumn":171},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":869,"column":168,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":869,"endColumn":171,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36711,36714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36711,36714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":870,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":870,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[36751,36861],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":882,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":882,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[37171,37191],"text":"(this.currentContext == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":882,"column":58,"nodeType":"Literal","messageId":"noMagic","endLine":882,"endColumn":61},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":883,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":883,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[37233,37298],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":887,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":887,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[37358,37461],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":888,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":888,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[37469,37555],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":889,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":889,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[37563,37648],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":890,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":890,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[37656,37716],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":890,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":890,"endColumn":62},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":891,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":891,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[37724,37837],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":910,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":910,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[38434,38444],"text":"signalData != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":911,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":911,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[38459,38543],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":917,"column":13,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":917,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[38701,38737],"text":"((signalData.signal.signal?.confidence) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[38701,38737],"text":"((signalData.signal.signal?.confidence) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[38701,38737],"text":"(Boolean((signalData.signal.signal?.confidence)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":917,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":917,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[38738,38740],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":917,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":917,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":925,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":925,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39067,39080],"text":"stillPending == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":927,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":927,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[39150,39216],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"complexity","severity":1,"message":"Method 'openPosition' has a complexity of 13. Maximum allowed is 10.","line":937,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":1068,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":946,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":946,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39576,39599],"text":"this.dailyLimitsService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":949,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":949,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[39710,39780],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":955,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":955,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39860,39882],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":958,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":958,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[39992,40061],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":967,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":972,"endColumn":80},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":969,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":969,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":970,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":970,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":972,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":972,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":975,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":975,"endColumn":48},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1000,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1000,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[41497,41524],"text":"this.riskBasedSizingService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1006,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1006,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[41685,41805],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1006,"column":83,"nodeType":"Literal","messageId":"noMagic","endLine":1006,"endColumn":84},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1006,"column":116,"nodeType":"Literal","messageId":"noMagic","endLine":1006,"endColumn":117},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1010,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1010,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[41870,41892],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1014,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1014,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[42076,42268],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1014,"column":112,"nodeType":"Literal","messageId":"noMagic","endLine":1014,"endColumn":115},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1014,"column":155,"nodeType":"Literal","messageId":"noMagic","endLine":1014,"endColumn":156},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1014,"column":188,"nodeType":"Literal","messageId":"noMagic","endLine":1014,"endColumn":189},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1020,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1031,"endColumn":7},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1020,"column":25,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1020,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .strategies on an `any` value.","line":1020,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1020,"endColumn":54},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1020,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1020,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42472,42475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42472,42475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .percent on an `any` value.","line":1021,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1021,"endColumn":69},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1027,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":1027,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .level on an `any` value.","line":1027,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1027,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1029,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":1029,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sizePercent on an `any` value.","line":1029,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1029,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1043,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":1043,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1061,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1061,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[43688,43763],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1061,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":1061,"endColumn":75},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1062,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1062,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[43769,43862],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1062,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":1062,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1062,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":1062,"endColumn":71},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1062,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":1062,"endColumn":82},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1063,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1063,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[43868,43916],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1064,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1064,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[43922,44093],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1064,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":1064,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1064,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":1064,"endColumn":127},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1064,"column":170,"nodeType":"Literal","messageId":"noMagic","endLine":1064,"endColumn":171},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1065,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1065,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[44099,44224],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1065,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":1065,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1065,"column":100,"nodeType":"Literal","messageId":"noMagic","endLine":1065,"endColumn":103},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1065,"column":113,"nodeType":"Literal","messageId":"noMagic","endLine":1065,"endColumn":114},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1066,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1066,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[44230,44343],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1066,"column":27,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1066,"endColumn":108},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1066,"column":27,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1066,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":1066,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1066,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1066,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1066,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44273,44276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44273,44276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":1066,"column":81,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1066,"endColumn":97},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .price on an `any` value.","line":1066,"column":84,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1066,"endColumn":89},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1066,"column":98,"nodeType":"Literal","messageId":"noMagic","endLine":1066,"endColumn":99},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .join on an `any` value.","line":1066,"column":104,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1066,"endColumn":108},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1067,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1067,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[44349,44439],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1067,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":1067,"endColumn":78},{"ruleId":"complexity","severity":1,"message":"Method 'checkExit' has a complexity of 15. Maximum allowed is 10.","line":1073,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":1138,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1074,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1074,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[44601,44622],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":1081,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":1081,"endColumn":27},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1082,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1082,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[44789,44939],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1082,"column":88,"nodeType":"Literal","messageId":"noMagic","endLine":1082,"endColumn":89},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1082,"column":120,"nodeType":"Literal","messageId":"noMagic","endLine":1082,"endColumn":121},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1082,"column":150,"nodeType":"Literal","messageId":"noMagic","endLine":1082,"endColumn":151},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1083,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1083,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[44947,45032],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1083,"column":86,"nodeType":"Literal","messageId":"noMagic","endLine":1083,"endColumn":87},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1084,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1084,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[45040,45195],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1084,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":1084,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1084,"column":142,"nodeType":"Literal","messageId":"noMagic","endLine":1084,"endColumn":143},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1086,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1086,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[45264,45409],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1086,"column":69,"nodeType":"Literal","messageId":"noMagic","endLine":1086,"endColumn":70},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1086,"column":109,"nodeType":"Literal","messageId":"noMagic","endLine":1086,"endColumn":110},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1087,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1087,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[45419,45634],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1087,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":1087,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1087,"column":122,"nodeType":"Literal","messageId":"noMagic","endLine":1087,"endColumn":123},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1087,"column":141,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":1087,"endColumn":164},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1089,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1089,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[45660,45802],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1089,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":1089,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1089,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":1089,"endColumn":108},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1090,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1090,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[45812,46030],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1090,"column":69,"nodeType":"Literal","messageId":"noMagic","endLine":1090,"endColumn":70},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1090,"column":124,"nodeType":"Literal","messageId":"noMagic","endLine":1090,"endColumn":125},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1090,"column":143,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":1090,"endColumn":166},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1097,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1097,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[46190,46293],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1097,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":1097,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1097,"column":105,"nodeType":"Literal","messageId":"noMagic","endLine":1097,"endColumn":106},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1103,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1103,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[46459,46564],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1103,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":1103,"endColumn":71},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1103,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":1103,"endColumn":108},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1126,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1126,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[47235,47336],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1126,"column":106,"nodeType":"Literal","messageId":"noMagic","endLine":1126,"endColumn":107},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":1131,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":1131,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[47476,47567],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":1131,"column":96,"nodeType":"Literal","messageId":"noMagic","endLine":1131,"endColumn":97},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1149,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1149,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47937,47958],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1154,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":1154,"endColumn":77},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1155,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":1155,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1178,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":1178,"endColumn":46},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1179,"column":71,"nodeType":"Literal","messageId":"noMagic","endLine":1179,"endColumn":74},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1186,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":1186,"endColumn":41},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1186,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":1186,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1197,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1197,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[49422,49443],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1227,"column":58,"nodeType":"Literal","messageId":"noMagic","endLine":1227,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1233,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1233,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[50539,50562],"text":"this.dailyLimitsService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1238,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1238,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[50701,50723],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1244,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1244,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[50883,50912],"text":"this.maxConcurrentRiskService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":1245,"column":52,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":1245,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .exchange on an `any` value.","line":1245,"column":71,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1245,"endColumn":79},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1255,"column":48,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1255,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51198,51203],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[51198,51203],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51198,51203],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1255,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1255,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[51204,51206],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1256,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1256,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51263,51268],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[51263,51268],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51263,51268],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1256,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1256,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[51269,51271],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1258,"column":60,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1258,"endColumn":65,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51344,51349],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[51344,51349],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51344,51349],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1258,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1258,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[51350,51352],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1259,"column":61,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1259,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51422,51428],"text":"(t.fees != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[51422,51428],"text":"(t.fees ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51422,51428],"text":"(Boolean(t.fees))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1259,"column":68,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1259,"endColumn":70,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[51429,51431],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1262,"column":86,"nodeType":"Literal","messageId":"noMagic","endLine":1262,"endColumn":89},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1264,"column":56,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1264,"endColumn":61,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51658,51663],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[51658,51663],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51658,51663],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1264,"column":62,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1264,"endColumn":64,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[51664,51666],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1265,"column":65,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1265,"endColumn":70,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51740,51745],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[51740,51745],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51740,51745],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1265,"column":71,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1265,"endColumn":73,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[51746,51748],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1274,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1274,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[52136,52145],"text":"(t.holding != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[52136,52145],"text":"(t.holding ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[52136,52145],"text":"(Boolean(t.holding))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1274,"column":57,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1274,"endColumn":59,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[52146,52148],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1277,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1277,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[52236,52248],"text":"(t.pnlPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[52236,52248],"text":"(t.pnlPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[52236,52248],"text":"(Boolean(t.pnlPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1277,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1277,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[52249,52251],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1277,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":1277,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1280,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":1280,"endColumn":65},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 252.","line":1282,"column":71,"nodeType":"Literal","messageId":"noMagic","endLine":1282,"endColumn":74},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1293,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":1293,"endColumn":65},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":1299,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":1299,"endColumn":80}],"suppressedMessages":[],"errorCount":358,"fatalErrorCount":0,"warningCount":94,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Backtest Engine V2\r\n *\r\n * Uses REAL bot classes for accurate simulation:\r\n * - LevelBasedStrategy, TrendFollowingStrategy, CounterTrendStrategy\r\n * - RSIAnalyzer, EMAAnalyzer, ATRIndicator\r\n * - ZigZagIndicator, LiquidityDetector\r\n * - StrategyCoordinator\r\n *\r\n * LIMITATIONS:\r\n * - FastEntry NOT supported (requires intra-candle simulation)\r\n * - SmartBreakeven NOT supported (requires position monitoring)\r\n * - RetestEntry NOT supported (requires time-based waiting)\r\n * - Backtest simulates only CLOSED candles (no partial fills)\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { LoggerService, LogLevel, StrategyMarketData, SignalDirection, Candle, StrategySignal } from '../types';\r\nimport { LevelBasedStrategy } from '../strategies/level-based.strategy';\r\nimport { CONFIDENCE_THRESHOLDS, MULTIPLIERS, PERCENTAGE_THRESHOLDS } from '../constants';\r\nimport { TrendFollowingStrategy } from '../strategies/trend-following.strategy';\r\nimport { CounterTrendStrategy } from '../strategies/counter-trend.strategy';\r\nimport { WhaleHunterStrategy } from '../strategies/whale-hunter.strategy';\r\nimport { RSIIndicator } from '../indicators/rsi.indicator';\r\nimport { EMAIndicator } from '../indicators/ema.indicator';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { LiquidityDetector } from '../analyzers/liquidity.detector';\r\nimport { DivergenceDetector } from '../analyzers/divergence.detector';\r\nimport { StochasticIndicator } from '../indicators/stochastic.indicator';\r\nimport { BollingerBandsIndicator } from '../indicators/bollinger.indicator';\r\nimport { EntryConfirmationManager, PendingEntry } from '../services/entry-confirmation.service';\r\nimport { ContextAnalyzer } from '../analyzers/context.analyzer';\r\nimport { EntryScanner } from '../analyzers/entry.scanner';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { TimeframeRole, TradingContext, EntrySignal } from '../types';\r\nimport { WeightMatrixCalculatorService } from '../services/weight-matrix-calculator.service';\r\nimport { WhaleDetectorService } from '../services/whale-detector.service';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { WallTrackerService } from '../services/wall-tracker.service';\r\nimport { SqliteDataProvider } from './data-providers/sqlite.provider';\r\n\r\n// Scalping Strategies (Phase 1-5)\r\nimport { ScalpingMicroWallStrategy } from '../strategies/scalping-micro-wall.strategy';\r\nimport { ScalpingTickDeltaStrategy } from '../strategies/scalping-tick-delta.strategy';\r\nimport { ScalpingLadderTpStrategy } from '../strategies/scalping-ladder-tp.strategy';\r\nimport { ScalpingLimitOrderStrategy } from '../strategies/scalping-limit-order.strategy';\r\nimport { ScalpingOrderFlowStrategy } from '../strategies/scalping-order-flow.strategy';\r\n\r\n// Scalping Strategy Services\r\nimport { MicroWallDetectorService } from '../services/micro-wall-detector.service';\r\nimport { TickDeltaAnalyzerService } from '../services/tick-delta-analyzer.service';\r\nimport { LadderTpManagerService } from '../services/ladder-tp-manager.service';\r\nimport { LimitOrderExecutorService } from '../services/limit-order-executor.service';\r\nimport { OrderFlowAnalyzerService } from '../services/order-flow-analyzer.service';\r\n\r\n// PHASE 5: Risk Management Services\r\nimport { DailyLimitsService } from '../services/daily-limits.service';\r\nimport { RiskBasedSizingService } from '../services/risk-based-sizing.service';\r\nimport { LossStreakService } from '../services/loss-streak.service';\r\nimport { MaxConcurrentRiskService } from '../services/max-concurrent-risk.service';\r\n\r\n// PHASE 6: Multi-Timeframe Services\r\nimport { TimeframeValidator } from '../utils/timeframe-validator';\r\nimport { VWAPIndicator } from '../indicators/vwap.indicator';\r\nimport { TFAlignmentService } from '../services/tf-alignment.service';\r\n\r\n// ============================================================================\r\n// MOCK CANDLE PROVIDER FOR BACKTEST\r\n// ============================================================================\r\n\r\nclass MockCandleProvider {\r\n  private candles1m: Candle[] = [];\r\n  private candles5m: Candle[] = [];\r\n  private candles15m: Candle[] = [];\r\n  private currentTimestamp: number = 0;\r\n  private logger: LoggerService;\r\n\r\n  constructor(logger: LoggerService, symbol: string) {\r\n    this.logger = logger;\r\n  }\r\n\r\n  setHistoricalData(candles1m: Candle[], candles5m: Candle[], candles15m: Candle[], currentTimestamp: number) {\r\n    this.candles1m = candles1m;\r\n    this.candles5m = candles5m;\r\n    this.candles15m = candles15m;\r\n    this.currentTimestamp = currentTimestamp;\r\n  }\r\n\r\n  async getCandles(role: TimeframeRole, limit?: number): Promise<Candle[]> {\r\n    let candles: Candle[];\r\n\r\n    switch (role) {\r\n    case TimeframeRole.ENTRY:\r\n      candles = this.candles1m.filter(c => c.timestamp <= this.currentTimestamp);\r\n      break;\r\n    case TimeframeRole.PRIMARY:\r\n      candles = this.candles5m.filter(c => c.timestamp <= this.currentTimestamp);\r\n      break;\r\n    case TimeframeRole.TREND1:\r\n      candles = this.candles15m.filter(c => c.timestamp <= this.currentTimestamp);\r\n      break;\r\n    default:\r\n      candles = [];\r\n    }\r\n\r\n    if (limit) {\r\n      return candles.slice(-limit);\r\n    }\r\n    return candles;\r\n  }\r\n\r\n  async getCurrentPrice(): Promise<number> {\r\n    const recent = this.candles1m.filter(c => c.timestamp <= this.currentTimestamp);\r\n    return recent.length > 0 ? recent[recent.length - 1].close : 0;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface BacktestCandle {\r\n  timestamp: number;\r\n  open: number;\r\n  high: number;\r\n  low: number;\r\n  close: number;\r\n  volume: number;\r\n}\r\n\r\nexport interface BacktestConfig {\r\n  symbol: string;\r\n  initialBalance: number;\r\n  positionSizeUsdt: number;\r\n  leverage: number;\r\n  takerFee: number;\r\n  makerFee: number;\r\n\r\n  // Real bot config\r\n  config: any; // Full config.json (dev-only, flexible for backtest)\r\n}\r\n\r\nexport interface BacktestTrade {\r\n  entryTime: number;\r\n  entryPrice: number;\r\n  direction: SignalDirection;\r\n  size: number;\r\n  stopLoss: number;\r\n  takeProfits: Array<{ level: number; price: number; closePercent: number }>;\r\n  exitTime?: number;\r\n  exitPrice?: number;\r\n  exitReason?: string;\r\n  pnl?: number;\r\n  pnlPercent?: number;\r\n  fees?: number;\r\n  holding?: number;\r\n  confidence?: number;\r\n  strategyName?: string;\r\n}\r\n\r\nexport interface BacktestResult {\r\n  config: BacktestConfig;\r\n  totalTrades: number;\r\n  winningTrades: number;\r\n  losingTrades: number;\r\n  winRate: number;\r\n  totalPnl: number;\r\n  totalFees: number;\r\n  netPnl: number;\r\n  netPnlPercent: number;\r\n  winLossRatio: number;\r\n  profitFactor: number;\r\n  avgWin: number;\r\n  avgLoss: number;\r\n  maxDrawdown: number;\r\n  maxDrawdownPercent: number;\r\n  sharpeRatio: number;\r\n  avgHoldingTime: number;\r\n  trades: BacktestTrade[];\r\n  equityCurve: Array<{ time: number; balance: number }>;\r\n}\r\n\r\n// ============================================================================\r\n// BACKTEST ENGINE V2\r\n// ============================================================================\r\n\r\nexport class BacktestEngineV2 {\r\n  private config: BacktestConfig;\r\n  private logger: LoggerService;\r\n\r\n  // Real bot components (multiple strategies like real bot)\r\n  private strategies: Array<\r\n    | LevelBasedStrategy\r\n    | TrendFollowingStrategy\r\n    | CounterTrendStrategy\r\n    | WhaleHunterStrategy\r\n    | ScalpingMicroWallStrategy\r\n    | ScalpingTickDeltaStrategy\r\n    | ScalpingLadderTpStrategy\r\n    | ScalpingLimitOrderStrategy\r\n    | ScalpingOrderFlowStrategy\r\n  > = [];\r\n  private rsiIndicator: RSIIndicator;\r\n  private emaIndicator: EMAIndicator;\r\n  private atrIndicator: ATRIndicator;\r\n  private zigzagIndicator: ZigZagIndicator;\r\n  private liquidityDetector: LiquidityDetector;\r\n  private divergenceDetector: DivergenceDetector;\r\n  private stochasticIndicator: StochasticIndicator;\r\n  private bollingerIndicator: BollingerBandsIndicator;\r\n  private entryConfirmation: EntryConfirmationManager;\r\n  private wallTracker?: WallTrackerService; // PHASE 4: Wall tracking\r\n\r\n  // Context and Entry Scanner (like live bot)\r\n  private candleProvider: MockCandleProvider;\r\n  private contextAnalyzer: ContextAnalyzer;\r\n  private entryScanner: EntryScanner;\r\n  private currentContext: TradingContext | null = null;\r\n\r\n  // State\r\n  private currentPosition: BacktestTrade | null = null;\r\n  private currentIndex: number = 0;\r\n  private trades: BacktestTrade[] = [];\r\n  private balance: number;\r\n  private equityCurve: Array<{ time: number; balance: number }> = [];\r\n  private peakBalance: number;\r\n  private maxDrawdown: number = 0;\r\n  private pendingSignals: Map<string, { signal: StrategySignal; marketData: StrategyMarketData; atr: number }> = new Map();\r\n  private weightMatrix: WeightMatrixCalculatorService | null = null;\r\n  private dataProvider: SqliteDataProvider | null = null;\r\n\r\n  // PHASE 5: Risk Management Services\r\n  private dailyLimitsService: DailyLimitsService | null = null;\r\n  private riskBasedSizingService: RiskBasedSizingService | null = null;\r\n  private lossStreakService: LossStreakService | null = null;\r\n  private maxConcurrentRiskService: MaxConcurrentRiskService | null = null;\r\n\r\n  // PHASE 6: Multi-Timeframe Services\r\n  private vwapIndicator: VWAPIndicator | null = null;\r\n  private tfAlignmentService: TFAlignmentService | null = null;\r\n\r\n  constructor(config: BacktestConfig) {\r\n    this.config = config;\r\n    this.logger = new LoggerService(LogLevel.ERROR, './logs', false);\r\n    this.balance = config.initialBalance;\r\n    this.peakBalance = config.initialBalance;\r\n\r\n    // Initialize Weight Matrix if enabled\r\n    if (config.config.weightMatrix?.enabled) {\r\n      this.weightMatrix = new WeightMatrixCalculatorService(config.config.weightMatrix, this.logger);\r\n      this.logger.info('‚úÖ Weight Matrix enabled for backtest', {\r\n        minConfidenceToEnter: config.config.weightMatrix.minConfidenceToEnter,\r\n      });\r\n    }\r\n\r\n    // Initialize strategies (only if enabled) with Weight Matrix\r\n    console.log('\\nüîç DEBUG BacktestEngineV2 constructor:');\r\n    console.log(`  TrendFollowing enabled: ${config.config.strategies.trendFollowing?.enabled}`);\r\n    console.log(`  LevelBased enabled: ${config.config.strategies.levelBased?.enabled}`);\r\n    console.log(`  CounterTrend enabled: ${config.config.strategies.counterTrend?.enabled}\\n`);\r\n\r\n    if (config.config.strategies.trendFollowing?.enabled === true) {\r\n      this.strategies.push(\r\n        new TrendFollowingStrategy(config.config.strategies.trendFollowing, this.logger, this.weightMatrix || undefined),\r\n      );\r\n      console.log('  ‚úÖ TrendFollowing strategy registered');\r\n    }\r\n    if (config.config.strategies.levelBased?.enabled === true) {\r\n      this.strategies.push(\r\n        new LevelBasedStrategy(config.config.strategies.levelBased, this.logger, this.weightMatrix || undefined),\r\n      );\r\n      console.log('  ‚úÖ LevelBased strategy registered');\r\n    }\r\n    if (config.config.strategies.counterTrend?.enabled === true) {\r\n      this.strategies.push(\r\n        new CounterTrendStrategy(config.config.strategies.counterTrend, this.logger, this.weightMatrix || undefined),\r\n      );\r\n      console.log('  ‚úÖ CounterTrend strategy registered');\r\n    }\r\n\r\n    // Initialize WhaleHunter Strategy (if enabled and orderbook available)\r\n    if (config.config.whaleHunter?.enabled) {\r\n      const whaleDetector = new WhaleDetectorService(config.config.whaleHunter.detector, this.logger);\r\n      const orderbookConfig = {\r\n        enabled: true,\r\n        depth: 50,\r\n        wallThreshold: 0.1,\r\n        imbalanceThreshold: MULTIPLIERS.ONE_AND_HALF,\r\n        updateIntervalMs: 5000,\r\n      };\r\n      const orderbookAnalyzer = new OrderBookAnalyzer(orderbookConfig, this.logger);\r\n\r\n      // Initialize WallTracker if enabled (PHASE 4)\r\n      if (config.config.wallTracking?.enabled) {\r\n        this.wallTracker = new WallTrackerService(config.config.wallTracking, this.logger);\r\n        this.logger.info('üß± WallTracker enabled for backtest');\r\n      }\r\n\r\n      this.strategies.push(\r\n        new WhaleHunterStrategy(\r\n          {\r\n            ...config.config.whaleHunter,\r\n            sessionBasedSL: config.config.sessionBasedSL,\r\n          },\r\n          whaleDetector,\r\n          orderbookAnalyzer,\r\n          this.logger,\r\n          this.wallTracker, // Pass WallTracker (optional)\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üêã WhaleHunter enabled for backtest');\r\n    }\r\n\r\n    // Initialize Scalping Strategies (Phase 1-5)\r\n    // Note: Scalping strategies require orderbook data\r\n    if (config.config.scalpingMicroWall?.enabled) {\r\n      const microWallDetector = new MicroWallDetectorService(\r\n        config.config.scalpingMicroWall.detector,\r\n        this.logger,\r\n      );\r\n      this.strategies.push(\r\n        new ScalpingMicroWallStrategy(\r\n          config.config.scalpingMicroWall,\r\n          microWallDetector,\r\n          this.logger,\r\n        ),\r\n      );\r\n      console.log('  ‚úÖ ScalpingMicroWall strategy registered');\r\n    }\r\n\r\n    if (config.config.scalpingTickDelta?.enabled) {\r\n      // TickDelta uses internal analyzer - no external service needed\r\n      this.strategies.push(\r\n        new ScalpingTickDeltaStrategy(\r\n          config.config.scalpingTickDelta,\r\n          this.logger,\r\n        ),\r\n      );\r\n      console.log('  ‚úÖ ScalpingTickDelta strategy registered');\r\n    }\r\n\r\n    if (config.config.scalpingOrderFlow?.enabled) {\r\n      // OrderFlow uses internal analyzer - no external service needed\r\n      this.strategies.push(\r\n        new ScalpingOrderFlowStrategy(\r\n          config.config.scalpingOrderFlow,\r\n          this.logger,\r\n        ),\r\n      );\r\n      console.log('  ‚úÖ ScalpingOrderFlow strategy registered');\r\n    }\r\n\r\n    // NOTE: LadderTp and LimitOrder are wrappers that require BybitService\r\n    // They cannot be tested in backtest without mock BybitService\r\n    if (config.config.scalpingLadderTp?.enabled) {\r\n      console.log('  ‚ö†Ô∏è  ScalpingLadderTp skipped (requires BybitService for backtest)');\r\n    }\r\n    if (config.config.scalpingLimitOrder?.enabled) {\r\n      console.log('  ‚ö†Ô∏è  ScalpingLimitOrder skipped (requires BybitService for backtest)');\r\n    }\r\n\r\n    // DEBUG: Log registered strategies\r\n    console.log(`\\nüéØ Registered strategies: ${this.strategies.length}`);\r\n    this.strategies.forEach((s, i) => {\r\n      const sAny = s as unknown as Record<string, unknown>;\r\n      const strategyName = sAny.name || sAny.constructor?.name || 'Unknown';\r\n      const priority = sAny.priority || 'N/A';\r\n      console.log(`  ${i + 1}. ${strategyName} (priority: ${priority})`);\r\n    });\r\n    console.log('');\r\n\r\n    this.rsiIndicator = new RSIIndicator(14);\r\n    this.emaIndicator = new EMAIndicator(9); // Fast EMA\r\n    this.atrIndicator = new ATRIndicator(14);\r\n    // Use same ZigZag depth as strategies (from config)\r\n    const zigzagDepth = config.config.strategies.levelBased.zigzagDepth ?? 12;\r\n    this.zigzagIndicator = new ZigZagIndicator(zigzagDepth);\r\n    this.liquidityDetector = new LiquidityDetector(this.logger);\r\n    this.divergenceDetector = new DivergenceDetector(this.logger);\r\n    this.stochasticIndicator = new StochasticIndicator(14, 3, 3);\r\n    this.bollingerIndicator = new BollingerBandsIndicator(20, 2.0);\r\n    this.entryConfirmation = new EntryConfirmationManager(config.config.entryConfirmation, this.logger);\r\n\r\n    // Initialize Context and Entry Scanner (like live bot)\r\n    this.candleProvider = new MockCandleProvider(this.logger, config.symbol);\r\n    this.contextAnalyzer = new ContextAnalyzer(\r\n      config.config.contextConfig || {\r\n        atrPeriod: 14,\r\n        emaPeriod: 50,\r\n        zigzagDepth: 5,\r\n        minimumATR: MULTIPLIERS.HALF,\r\n        maximumATR: 3.0,\r\n        maxEmaDistance: 2.0,\r\n        filteringMode: 'HARD_BLOCK' as any,\r\n      },\r\n      this.candleProvider as any,\r\n      this.logger,\r\n    );\r\n    this.entryScanner = new EntryScanner(\r\n      config.config.entryConfig || {\r\n        rsiPeriod: 14,\r\n        fastEmaPeriod: 9,\r\n        slowEmaPeriod: 21,\r\n        zigzagDepth: 5,\r\n        rsiOversold: 30,\r\n        rsiOverbought: 70,\r\n        stopLossPercent: MULTIPLIERS.ONE_AND_HALF,\r\n        takeProfits: config.config.strategies.levelBased.takeProfits.map((tp: any) => ({\r\n          level: tp.level,\r\n          percent: tp.percent,\r\n          sizePercent: tp.sizePercent,\r\n        })),\r\n      },\r\n      this.candleProvider as any,\r\n      this.logger,\r\n    );\r\n\r\n    // ======================================================================\r\n    // PHASE 5: Initialize Risk Management Services\r\n    // ======================================================================\r\n    if (config.config.dailyLimits?.enabled) {\r\n      this.dailyLimitsService = new DailyLimitsService(config.config.dailyLimits, this.logger);\r\n      this.dailyLimitsService.setStartingBalance(config.initialBalance);\r\n      this.logger.info('‚úÖ Daily Limits enabled for backtest', {\r\n        maxLoss: `-${config.config.dailyLimits.maxDailyLossPercent}%`,\r\n        maxProfit: config.config.dailyLimits.maxDailyProfitPercent\r\n          ? `+${config.config.dailyLimits.maxDailyProfitPercent}%`\r\n          : 'disabled',\r\n      });\r\n    }\r\n\r\n    if (config.config.riskBasedSizing?.enabled) {\r\n      this.riskBasedSizingService = new RiskBasedSizingService(config.config.riskBasedSizing, this.logger);\r\n      this.logger.info('üéØ Risk-Based Sizing enabled for backtest', {\r\n        riskPercent: config.config.riskBasedSizing.riskPerTradePercent + '%',\r\n      });\r\n    }\r\n\r\n    if (config.config.lossStreak?.enabled) {\r\n      this.lossStreakService = new LossStreakService(config.config.lossStreak, this.logger);\r\n      this.logger.info('üîª Loss Streak enabled for backtest', {\r\n        reductions: config.config.lossStreak.reductions,\r\n        stopAfterLosses: config.config.lossStreak.stopAfterLosses || 'disabled',\r\n      });\r\n    }\r\n\r\n    if (config.config.maxConcurrentRisk?.enabled) {\r\n      this.maxConcurrentRiskService = new MaxConcurrentRiskService(config.config.maxConcurrentRisk, this.logger);\r\n      this.logger.info('üìä Max Concurrent Risk enabled for backtest', {\r\n        maxPositions: config.config.maxConcurrentRisk.maxPositions,\r\n        maxTotalExposure: config.config.maxConcurrentRisk.maxTotalExposurePercent + '%',\r\n        maxRiskPerPosition: config.config.maxConcurrentRisk.maxRiskPerPosition + '%',\r\n      });\r\n    }\r\n\r\n    // ======================================================================\r\n    // PHASE 6: Initialize Multi-Timeframe Services\r\n    // ======================================================================\r\n    this.vwapIndicator = new VWAPIndicator();\r\n    this.tfAlignmentService = new TFAlignmentService(\r\n      config.config.tfAlignment || {\r\n        enabled: true,\r\n        rsiWeight: 30,\r\n        emaWeight: 30,\r\n        trendWeight: 40,\r\n        minScore: 60,\r\n      },\r\n      this.logger,\r\n    );\r\n    this.logger.info('‚úÖ PHASE6 Multi-TF services initialized (VWAP + TF Alignment)');\r\n  }\r\n\r\n  /**\r\n   * Run backtest on historical data\r\n   */\r\n  async run(\r\n    candles1m: BacktestCandle[],\r\n    candles5m: BacktestCandle[],\r\n    candles15m: BacktestCandle[],\r\n    dataProvider?: SqliteDataProvider,\r\n  ): Promise<BacktestResult> {\r\n    // Save dataProvider as instance field for orderbook loading\r\n    this.dataProvider = dataProvider || null;\r\n\r\n    console.log('üöÄ Starting backtest V2 (Real Bot Emulation)...');\r\n    console.log(`üìä Data: ${candles1m.length} 1m candles`);\r\n    console.log(`üí∞ Initial balance: ${this.config.initialBalance} USDT`);\r\n    if (this.dataProvider) {\r\n      console.log('üìö Orderbook data: ENABLED (SQLite)');\r\n    }\r\n\r\n    let progress = 0;\r\n    const progressInterval = Math.floor(candles1m.length / 100);\r\n\r\n    // Process each 1m candle\r\n    for (let i = 0; i < candles1m.length; i++) {\r\n      const currentCandle = candles1m[i];\r\n\r\n      // Show progress\r\n      if (i % progressInterval === 0) {\r\n        progress = Math.floor((i / candles1m.length) * 100);\r\n        process.stdout.write(`\\r‚è≥ Progress: ${progress}%`);\r\n      }\r\n\r\n      // Get historical data up to current point\r\n      const historicalCandles1m = this.getHistoricalCandles(candles1m, currentCandle.timestamp, 200);\r\n      const historicalCandles5m = this.getHistoricalCandles(candles5m, currentCandle.timestamp, 200);\r\n      const historicalCandles15m = this.getHistoricalCandles(candles15m, currentCandle.timestamp, 200);\r\n\r\n      // Update CandleProvider (for ContextAnalyzer and EntryScanner)\r\n      this.candleProvider.setHistoricalData(\r\n        historicalCandles1m,\r\n        historicalCandles5m,\r\n        historicalCandles15m,\r\n        currentCandle.timestamp,\r\n      );\r\n\r\n      // Update Context every candle (like live bot)\r\n      if (historicalCandles5m.length >= CONFIDENCE_THRESHOLDS.MODERATE) {\r\n        this.currentContext = await this.contextAnalyzer.analyze();\r\n      }\r\n\r\n      // Debug: Log position status every 500 candles\r\n      if (i % 500 === 0) {\r\n        console.log(`\\n[STATUS] Candle ${i} @ ${new Date(currentCandle.timestamp).toISOString()}`);\r\n        console.log(`  Position: ${this.currentPosition ? `OPEN (${this.currentPosition.direction} @ ${this.currentPosition.entryPrice.toFixed(4)})` : 'CLOSED'}`);\r\n        console.log(`  Context valid: ${this.currentContext?.isValidContext ?? 'not initialized'}`);\r\n        console.log(`  Can check entry: ${!this.currentPosition && historicalCandles5m.length >= 100 && historicalCandles15m.length >= CONFIDENCE_THRESHOLDS.MODERATE}`);\r\n      }\r\n\r\n      // Check pending confirmations (every candle)\r\n      if (!this.currentPosition) {\r\n        this.checkPendingConfirmations(currentCandle);\r\n      }\r\n\r\n      // Check exit conditions if in position\r\n      if (this.currentPosition) {\r\n        this.checkExit(currentCandle, historicalCandles5m, i);\r\n      }\r\n\r\n      // Check entry conditions if not in position\r\n      if (!this.currentPosition && historicalCandles5m.length >= 100 && historicalCandles15m.length >= CONFIDENCE_THRESHOLDS.MODERATE) {\r\n        await this.checkEntry(currentCandle, historicalCandles5m, historicalCandles15m, i);\r\n      }\r\n\r\n      // Update equity curve every 1000 candles\r\n      if (i % 1000 === 0) {\r\n        this.equityCurve.push({\r\n          time: currentCandle.timestamp,\r\n          balance: this.balance,\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log('\\r‚úÖ Progress: 100%    ');\r\n\r\n    // Close any open position at end\r\n    if (this.currentPosition) {\r\n      const lastCandle = candles1m[candles1m.length - 1];\r\n      this.closePosition(lastCandle, lastCandle.close, 'END_OF_BACKTEST');\r\n    }\r\n\r\n    console.log(`‚úÖ Backtest complete! Total trades: ${this.trades.length}`);\r\n\r\n    return this.calculateResults();\r\n  }\r\n\r\n  /**\r\n   * Get historical candles up to timestamp\r\n   */\r\n  private getHistoricalCandles(\r\n    candles: BacktestCandle[],\r\n    timestamp: number,\r\n    maxCount: number,\r\n  ): Candle[] {\r\n    const filtered = candles.filter((c) => c.timestamp <= timestamp);\r\n    const sliced = filtered.slice(-maxCount);\r\n    return sliced.map((c) => ({\r\n      timestamp: c.timestamp,\r\n      open: c.open,\r\n      high: c.high,\r\n      low: c.low,\r\n      close: c.close,\r\n      volume: c.volume,\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Check entry conditions using REAL strategy\r\n   */\r\n  private async checkEntry(\r\n    currentCandle: BacktestCandle,\r\n    historicalCandles5m: Candle[],\r\n    historicalCandles15m: Candle[],\r\n    candleIndex: number,\r\n  ): Promise<void> {\r\n    try {\r\n      const currentPrice = currentCandle.close;\r\n\r\n      // Calculate RSI (PRIMARY 5m + TREND1 15m)\r\n      const rsi = this.rsiIndicator.calculate(historicalCandles5m);\r\n      const rsiTrend1 = this.rsiIndicator.calculate(historicalCandles15m);\r\n\r\n      // Calculate EMA (PRIMARY 5m + TREND1 15m)\r\n      const emaFast = this.emaIndicator.calculate(historicalCandles5m);\r\n      const emaSlowIndicator = new EMAIndicator(21);\r\n      const emaSlow = emaSlowIndicator.calculate(historicalCandles5m);\r\n      const emaFastTrend1Indicator = new EMAIndicator(9);\r\n      const emaFastTrend1 = emaFastTrend1Indicator.calculate(historicalCandles15m);\r\n      const emaSlowTrend1Indicator = new EMAIndicator(21);\r\n      const emaSlowTrend1 = emaSlowTrend1Indicator.calculate(historicalCandles15m);\r\n\r\n      // Calculate ATR\r\n      const atr = this.atrIndicator.calculate(historicalCandles5m);\r\n\r\n      // Check for undefined indicators (debug)\r\n      if (candleIndex % 5000 === 0) {\r\n        const undefinedIndicators = [];\r\n        if (rsi === undefined || isNaN(rsi)) {\r\n          undefinedIndicators.push('RSI');\r\n        }\r\n        if (rsiTrend1 === undefined || isNaN(rsiTrend1)) {\r\n          undefinedIndicators.push('RSI15m');\r\n        }\r\n        if (emaFast === undefined || isNaN(emaFast)) {\r\n          undefinedIndicators.push('EMA_Fast');\r\n        }\r\n        if (emaSlow === undefined || isNaN(emaSlow)) {\r\n          undefinedIndicators.push('EMA_Slow');\r\n        }\r\n        if (atr === undefined || isNaN(atr)) {\r\n          undefinedIndicators.push('ATR');\r\n        }\r\n\r\n        if (undefinedIndicators.length > 0) {\r\n          console.warn(`[WARNING] Candle ${candleIndex}: Undefined indicators: ${undefinedIndicators.join(', ')}`);\r\n          console.warn(`  5m candles available: ${historicalCandles5m.length}, 15m: ${historicalCandles15m.length}`);\r\n        }\r\n      }\r\n\r\n      // Find swing points\r\n      const swingHighs = this.zigzagIndicator.findSwingHighs(historicalCandles5m);\r\n      const swingLows = this.zigzagIndicator.findSwingLows(historicalCandles5m);\r\n      const swingPoints = [...swingHighs, ...swingLows].sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n      // Detect liquidity (simplified - not critical for strategy)\r\n      const liquidityAnalysis = undefined;\r\n\r\n      // Detect divergence (simplified - not critical for strategy)\r\n      const divergence = undefined;\r\n\r\n      // Calculate Stochastic\r\n      const stochasticRaw = this.stochasticIndicator.calculate(historicalCandles5m);\r\n      const stochastic = {\r\n        k: stochasticRaw.k,\r\n        d: stochasticRaw.d,\r\n        isOversold: stochasticRaw.k < 20,\r\n        isOverbought: stochasticRaw.k > 80,\r\n      };\r\n\r\n      // Calculate Bollinger Bands\r\n      const bollingerRaw = this.bollingerIndicator.calculate(historicalCandles5m);\r\n      const bollingerBands = {\r\n        ...bollingerRaw,\r\n        isSqueeze: bollingerRaw.width < 2, // Simple squeeze detection\r\n      };\r\n\r\n      // Determine trend\r\n      const trend = emaFast > emaSlow ? 'BULLISH' : emaFast < emaSlow ? 'BEARISH' : 'NEUTRAL';\r\n\r\n      // Debug: Log market data every 500 candles\r\n      if (candleIndex % 500 === 0) {\r\n        console.log(`\\n[MARKET DATA] Candle ${candleIndex} @ ${new Date(currentCandle.timestamp).toISOString()}`);\r\n        console.log(`  Price: ${currentPrice.toFixed(4)}`);\r\n        console.log(`  RSI: ${rsi?.toFixed(2) ?? 'undefined'} / RSI15m: ${rsiTrend1?.toFixed(2) ?? 'undefined'}`);\r\n        console.log(`  EMA: fast=${emaFast?.toFixed(4) ?? 'undefined'}, slow=${emaSlow?.toFixed(4) ?? 'undefined'}`);\r\n        console.log(`  EMA15m: fast=${emaFastTrend1?.toFixed(4) ?? 'undefined'}, slow=${emaSlowTrend1?.toFixed(4) ?? 'undefined'}`);\r\n        console.log(`  ATR: ${atr?.toFixed(4) ?? 'undefined'} (${atr ? ((atr / currentPrice) * 100).toFixed(2) : 'undefined'}%)`);\r\n        console.log(`  Swings: ${swingPoints.length} (highs=${swingHighs.length}, lows=${swingLows.length})`);\r\n        console.log(`  Swing details: highs=[${swingHighs.slice(0, 3).map(s => s.price.toFixed(4)).join(', ')}...], lows=[${swingLows.slice(0, 3).map(s => s.price.toFixed(4)).join(', ')}...]`);\r\n        console.log(`  Candles passed to strategies: ${historicalCandles5m.length}`);\r\n        console.log(`  Trend: ${trend}`);\r\n        console.log(`  Stochastic: k=${stochastic.k?.toFixed(2) ?? 'undefined'}, oversold=${stochastic.isOversold}, overbought=${stochastic.isOverbought}`);\r\n        console.log(`  Context: ${this.currentContext ? `valid=${this.currentContext.isValidContext}, blockedBy=[${this.currentContext.blockedBy?.join(', ') ?? 'none'}]` : 'not initialized'}`);\r\n      }\r\n\r\n      // PHASE 6: Calculate VWAP\r\n      const vwapValue = this.vwapIndicator ? this.vwapIndicator.calculate(historicalCandles5m) : 0;\r\n      const vwapData = vwapValue > 0 ? {\r\n        value: vwapValue,\r\n        distance: Math.abs(currentPrice - vwapValue),\r\n        distancePercent: ((currentPrice - vwapValue) / vwapValue) * 100,\r\n      } : undefined;\r\n\r\n      // PHASE 6: Calculate TF Alignment (for LONG direction as baseline)\r\n      const tfAlignmentResult = this.tfAlignmentService ? this.tfAlignmentService.calculateAlignment(\r\n        'LONG', // Use LONG as default for scoring\r\n        currentPrice,\r\n        {\r\n          entry: { ema20: emaFast },\r\n          primary: { ema20: emaFast, ema50: emaSlow },\r\n          trend1: { ema20: emaFastTrend1, ema50: emaSlowTrend1 },\r\n        },\r\n      ) : undefined;\r\n      const tfAlignmentScore = tfAlignmentResult ? tfAlignmentResult.score : undefined;\r\n\r\n      // Build StrategyMarketData (same as real bot)\r\n      const marketData: StrategyMarketData = {\r\n        timestamp: currentCandle.timestamp,\r\n        currentPrice,\r\n        candles: historicalCandles5m,\r\n        swingPoints,\r\n        rsi,\r\n        rsiTrend1,\r\n        ema: { fast: emaFast, slow: emaSlow },\r\n        emaTrend1: { fast: emaFastTrend1, slow: emaSlowTrend1 },\r\n        atr,\r\n        trend,\r\n        liquidity: liquidityAnalysis,\r\n        divergence,\r\n        orderbook: this.dataProvider\r\n          ? (await this.dataProvider.loadOrderbookForCandle(this.config.symbol, currentCandle.timestamp)) || undefined\r\n          : undefined,\r\n        context: {\r\n          trend,\r\n          momentum: rsi > 50 ? 'BULLISH' : 'BEARISH',\r\n          volatility: atr > 0.02 ? 'HIGH' : atr > 0.01 ? 'MEDIUM' : 'LOW',\r\n          timeframe: '5m',\r\n        } as any,\r\n        stochastic,\r\n        bollingerBands,\r\n        breakoutPrediction: undefined,\r\n        // PHASE 6: Multi-Timeframe data\r\n        tfAlignment: undefined,\r\n      };\r\n\r\n      // Update WallTracker with orderbook data (if enabled)\r\n      if (this.wallTracker && marketData.orderbook) {\r\n        const orderbook = marketData.orderbook;\r\n\r\n        // Feed bids to WallTracker\r\n        if (orderbook.bids && Array.isArray(orderbook.bids)) {\r\n          for (const bid of orderbook.bids.slice(0, 20)) { // Top 20 bids\r\n            const price = Number(Array.isArray(bid) ? bid[0] : (bid as any).price);\r\n            const size = Number(Array.isArray(bid) ? bid[1] : ((bid as any).size || (bid as any).quantity));\r\n            if (!isNaN(price) && !isNaN(size) && size > 0) {\r\n              this.wallTracker.detectWall(price, size, 'BID');\r\n            }\r\n          }\r\n        }\r\n\r\n        // Feed asks to WallTracker\r\n        if (orderbook.asks && Array.isArray(orderbook.asks)) {\r\n          for (const ask of orderbook.asks.slice(0, 20)) { // Top 20 asks\r\n            const price = Number(Array.isArray(ask) ? ask[0] : (ask as any).price);\r\n            const size = Number(Array.isArray(ask) ? ask[1] : ((ask as any).size || (ask as any).quantity));\r\n            if (!isNaN(price) && !isNaN(size) && size > 0) {\r\n              this.wallTracker.detectWall(price, size, 'ASK');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Evaluate ALL strategies (like real bot)\r\n      const evaluations: StrategySignal[] = [];\r\n      for (const strategy of this.strategies) {\r\n        const evaluation = await strategy.evaluate(marketData);\r\n        evaluations.push(evaluation);\r\n      }\r\n\r\n      // Pick best signal (highest priority, then highest confidence)\r\n      let validSignals = evaluations\r\n        .filter(e => e.valid && e.signal && e.signal.direction !== SignalDirection.HOLD)\r\n        .sort((a, b) => {\r\n          // Sort by priority (lower = higher priority)\r\n          if (a.priority !== b.priority) {\r\n            return a.priority - b.priority;\r\n          }\r\n          // Then by confidence\r\n          return (b.signal?.confidence || 0) - (a.signal?.confidence || 0);\r\n        });\r\n\r\n      // Filter by Weight Matrix confidence threshold if enabled\r\n      if (this.weightMatrix && this.config.config.weightMatrix?.enabled) {\r\n        validSignals = validSignals.filter(signal => {\r\n          const confidencePercent = (signal.signal?.confidence || 0) * 100;\r\n          const passesThreshold = this.weightMatrix!.shouldEnter(confidencePercent);\r\n          if (!passesThreshold && candleIndex % 500 === 0) {\r\n            this.logger.debug('‚ùå Weight Matrix filtered out signal', {\r\n              strategy: signal.strategyName,\r\n              confidence: confidencePercent.toFixed(1) + '%',\r\n              required: (this.config.config.weightMatrix?.minConfidenceToEnter ?? 0) + '%',\r\n            });\r\n          }\r\n          return passesThreshold;\r\n        });\r\n      }\r\n\r\n      const bestSignal = validSignals[0];\r\n\r\n      // Debug: Log evaluation result every 500 candles\r\n      if (candleIndex % 500 === 0) {\r\n        console.log(`[STRATEGIES] Evaluated=${evaluations.length}, Valid signals=${validSignals.length}`);\r\n        evaluations.forEach(e => {\r\n          const reasonPreview = e.reason ? (e.reason.length > 80 ? e.reason.substring(0, 80) + '...' : e.reason) : 'N/A';\r\n          console.log(`  - ${e.strategyName}: valid=${e.valid}, priority=${e.priority}, reason=\"${reasonPreview}\"`);\r\n        });\r\n      }\r\n\r\n      if (bestSignal) {\r\n        const direction = bestSignal.signal!.direction;\r\n\r\n        // Check if entry confirmation is enabled for this direction\r\n        if (this.entryConfirmation.isEnabled(direction)) {\r\n          // Add to pending - wait for next candle confirmation\r\n          const pendingId = this.entryConfirmation.addPending({\r\n            symbol: this.config.symbol,\r\n            direction,\r\n            keyLevel: currentPrice, // Use current price as key level\r\n            detectedAt: currentCandle.timestamp,\r\n            signalData: { signal: bestSignal, atr },\r\n          });\r\n          this.pendingSignals.set(pendingId, { signal: bestSignal, marketData, atr });\r\n          console.log(`[SIGNAL PENDING] ${direction} at ${currentPrice}, waiting for confirmation (id: ${pendingId}) - strategy=${bestSignal.strategyName}`);\r\n        } else {\r\n          // Entry confirmation disabled - open immediately\r\n          console.log(`[SIGNAL FOUND] ${direction} at ${currentPrice}, confidence=${bestSignal.signal?.confidence}, strategy=${bestSignal.strategyName}`);\r\n          this.openPosition(\r\n            currentCandle,\r\n            direction,\r\n            currentPrice,\r\n            atr,\r\n            bestSignal.signal!.confidence || 0.5,\r\n            bestSignal.strategyName,\r\n          );\r\n        }\r\n      } else {\r\n        // FALLBACK: Use Entry Scanner (like live bot)\r\n        // Check every 10 candles instead of 100 for more frequent scanning\r\n        if (this.currentContext && candleIndex % 10 === 0) {\r\n          // Debug: Log scanner attempt\r\n          if (candleIndex % 500 === 0) {\r\n            console.log(`[ENTRY SCANNER] Attempting scan at candle ${candleIndex}`);\r\n          }\r\n\r\n          const entrySignal: EntrySignal = await this.entryScanner.scan(this.currentContext);\r\n\r\n          // Debug: Log scanner result\r\n          if (candleIndex % 500 === 0) {\r\n            console.log(`  Scanner result: shouldEnter=${entrySignal.shouldEnter}, direction=${entrySignal.direction ?? 'N/A'}, confidence=${entrySignal.confidence?.toFixed(2) ?? 'N/A'}, reason=\"${entrySignal.reason ?? 'N/A'}\"`);\r\n          }\r\n\r\n          if (entrySignal.shouldEnter) {\r\n            const direction = entrySignal.direction;\r\n            console.log(`[ENTRY SCANNER] ${direction} at ${currentPrice}, confidence=${entrySignal.confidence}, reason=${entrySignal.reason}`);\r\n\r\n            // Check if entry confirmation is enabled\r\n            if (this.entryConfirmation.isEnabled(direction)) {\r\n              const pendingId = this.entryConfirmation.addPending({\r\n                symbol: this.config.symbol,\r\n                direction,\r\n                keyLevel: currentPrice,\r\n                detectedAt: currentCandle.timestamp,\r\n                signalData: { entrySignal, atr },\r\n              });\r\n              this.pendingSignals.set(pendingId, { signal: { valid: true, signal: { direction, confidence: entrySignal.confidence }, strategyName: 'EntryScanner' } as any, marketData, atr });\r\n              console.log(`[SCANNER PENDING] ${direction} at ${currentPrice}, waiting for confirmation (id: ${pendingId})`);\r\n            } else {\r\n              this.openPosition(\r\n                currentCandle,\r\n                direction,\r\n                currentPrice,\r\n                atr,\r\n                entrySignal.confidence,\r\n                'EntryScanner',\r\n              );\r\n            }\r\n          }\r\n        } else if (!this.currentContext && candleIndex % 500 === 0) {\r\n          console.log('[ENTRY SCANNER] Skipped - context not initialized');\r\n        }\r\n      }\r\n    } catch (error: unknown) {\r\n      console.error(`\\n[ERROR] Candle ${candleIndex} @ ${new Date(currentCandle.timestamp).toISOString()}:`);\r\n      console.error(`  Message: ${error instanceof Error ? error.message : String(error)}`);\r\n      console.error(`  Stack: ${error instanceof Error ? error.stack : 'No stack trace'}`);\r\n      console.error(`  Price: ${currentCandle.close.toFixed(4)}`);\r\n      console.error(`  Historical data: 5m=${historicalCandles5m.length}, 15m=${historicalCandles15m.length} candles`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check pending entry confirmations on candle close\r\n   */\r\n  private checkPendingConfirmations(currentCandle: BacktestCandle): void {\r\n    const allPending = this.entryConfirmation.getAllPending();\r\n\r\n    for (const pending of allPending) {\r\n      const closePrice = currentCandle.close;\r\n\r\n      // Check confirmation\r\n      const result = this.entryConfirmation.checkConfirmation(pending.id, closePrice);\r\n\r\n      if (result.confirmed) {\r\n        // Confirmation successful - open position\r\n        const signalData = this.pendingSignals.get(pending.id);\r\n        if (signalData) {\r\n          console.log(`[CONFIRMED] ${pending.direction} at ${closePrice} - ${result.reason}`);\r\n          this.openPosition(\r\n            currentCandle,\r\n            pending.direction,\r\n            closePrice,\r\n            signalData.atr,\r\n            signalData.signal.signal?.confidence || 0.5,\r\n            signalData.signal.strategyName,\r\n          );\r\n          this.pendingSignals.delete(pending.id);\r\n        }\r\n      } else {\r\n        // Check if still pending (not removed by checkConfirmation)\r\n        const stillPending = this.entryConfirmation.getAllPending().find(p => p.id === pending.id);\r\n        if (!stillPending) {\r\n          // Confirmation failed or expired - cleanup\r\n          console.log(`[REJECTED] ${pending.direction} - ${result.reason}`);\r\n          this.pendingSignals.delete(pending.id);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Open position\r\n   */\r\n  private openPosition(\r\n    candle: BacktestCandle,\r\n    direction: SignalDirection,\r\n    entryPrice: number,\r\n    atr: number,\r\n    confidence: number,\r\n    strategyName: string,\r\n  ): void {\r\n    // PHASE 5: Check Daily Limits\r\n    if (this.dailyLimitsService) {\r\n      const limitsCheck = this.dailyLimitsService.canTrade();\r\n      if (!limitsCheck.allowed) {\r\n        console.log(`‚ùå Trade blocked by daily limits: ${limitsCheck.reason}`);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // PHASE 5: Check Loss Streak\r\n    if (this.lossStreakService) {\r\n      const streakCheck = this.lossStreakService.canTrade();\r\n      if (!streakCheck.allowed) {\r\n        console.log(`‚ùå Trade blocked by loss streak: ${streakCheck.reason}`);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Base position size\r\n    let positionSizeUsdt = this.config.positionSizeUsdt;\r\n\r\n    // Get SL multipliers from config\r\n    const slMultiplier =\r\n      direction === SignalDirection.LONG\r\n        ? this.config.config.strategies.levelBased.stopLossAtrMultiplierLong ??\r\n          this.config.config.strategies.levelBased.stopLossAtrMultiplier ??\r\n          1.0\r\n        : this.config.config.strategies.levelBased.stopLossAtrMultiplier ?? 1.0;\r\n\r\n    // ATR is returned as percentage, convert to price distance\r\n    const atrDistance = entryPrice * (atr / 100) * slMultiplier;\r\n\r\n    const stopLoss =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice - atrDistance\r\n        : entryPrice + atrDistance;\r\n\r\n    // PHASE 5: Check Max Concurrent Risk\r\n    /*if (this.maxConcurrentRiskService) {\r\n      const positionRisk = MaxConcurrentRiskService.calculatePositionRisk(\r\n        signal.symbol,\r\n        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',\r\n        entryPrice,\r\n        stopLoss,\r\n        positionSizeUsdt,\r\n        this.balance\r\n      );\r\n      const riskCheck = this.maxConcurrentRiskService.canOpenPosition(this.balance, positionRisk);\r\n      if (!riskCheck.allowed) {\r\n        console.log(`‚ùå Trade blocked by max concurrent risk: ${riskCheck.reason}`);\r\n        return;\r\n      }\r\n    }\r\n*/\r\n    // PHASE 5: Apply Risk-Based Sizing (overrides base size)\r\n    if (this.riskBasedSizingService) {\r\n      positionSizeUsdt = this.riskBasedSizingService.calculatePositionSize(\r\n        this.balance,\r\n        entryPrice,\r\n        stopLoss,\r\n      );\r\n      console.log(`  üéØ Risk-Based Sizing: ${this.config.positionSizeUsdt.toFixed(2)} ‚Üí ${positionSizeUsdt.toFixed(2)} USDT`);\r\n    }\r\n\r\n    // PHASE 5: Apply Loss Streak multiplier\r\n    if (this.lossStreakService) {\r\n      const multiplier = this.lossStreakService.getSizeMultiplier();\r\n      const originalSize = positionSizeUsdt;\r\n      positionSizeUsdt = positionSizeUsdt * multiplier;\r\n      console.log(`  üîª Loss Streak (${this.lossStreakService.getConsecutiveLosses()} losses): ${(multiplier * 100).toFixed(0)}% ‚Üí ${originalSize.toFixed(2)} ‚Üí ${positionSizeUsdt.toFixed(2)} USDT`);\r\n    }\r\n\r\n    const size = (positionSizeUsdt * this.config.leverage) / entryPrice;\r\n\r\n    // Calculate take profits\r\n    const takeProfits = this.config.config.strategies.levelBased.takeProfits.map((tp: any) => {\r\n      const priceMove = Math.abs(entryPrice - stopLoss) * tp.percent;\r\n      const tpPrice =\r\n        direction === SignalDirection.LONG\r\n          ? entryPrice + priceMove\r\n          : entryPrice - priceMove;\r\n      return {\r\n        level: tp.level,\r\n        price: tpPrice,\r\n        closePercent: tp.sizePercent,\r\n      };\r\n    });\r\n\r\n    // Calculate entry fee (use actual position size, not base size)\r\n    const entryFee = positionSizeUsdt * this.config.takerFee;\r\n    this.balance -= entryFee;\r\n\r\n    this.currentPosition = {\r\n      entryTime: candle.timestamp,\r\n      entryPrice,\r\n      direction,\r\n      size,\r\n      stopLoss,\r\n      takeProfits,\r\n      confidence,\r\n      strategyName,\r\n    };\r\n\r\n    // PHASE 5: Register position with Max Concurrent Risk\r\n    /* if (this.maxConcurrentRiskService) {\r\n      const positionRisk = MaxConcurrentRiskService.calculatePositionRisk(\r\n        signal.symbol,\r\n        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',\r\n        entryPrice,\r\n        stopLoss,\r\n        positionSizeUsdt, // Use final position size after all adjustments\r\n        this.balance\r\n      );\r\n      this.maxConcurrentRiskService.addPosition(positionRisk);\r\n    }\r\n--*/\r\n    console.log(`\\n[POSITION OPENED] ${direction} @ ${entryPrice.toFixed(4)}`);\r\n    console.log(`  ATR: ${atr.toFixed(4)} (${((atr / entryPrice) * 100).toFixed(2)}% of price)`);\r\n    console.log(`  SL multiplier: ${slMultiplier}`);\r\n    console.log(`  SL calculation: ${entryPrice.toFixed(4)} ${direction === SignalDirection.LONG ? '-' : '+'} (${atr.toFixed(4)} * ${slMultiplier}) = ${stopLoss.toFixed(4)}`);\r\n    console.log(`  SL: ${stopLoss.toFixed(4)} (${((Math.abs(stopLoss - entryPrice) / entryPrice) * 100).toFixed(2)}% distance)`);\r\n    console.log(`  TPs: ${takeProfits.map((tp: any, i: number) => `TP${i + 1}=${tp.price.toFixed(4)}`).join(', ')}`);\r\n    console.log(`  Strategy: ${strategyName}, Confidence: ${(confidence * 100).toFixed(0)}%`);\r\n  }\r\n\r\n  /**\r\n   * Check exit conditions\r\n   */\r\n  private checkExit(candle: BacktestCandle, historicalCandles: Candle[], candleIndex: number): void {\r\n    if (!this.currentPosition) {\r\n      return;\r\n    }\r\n\r\n    const position = this.currentPosition;\r\n\r\n    // Debug: Log exit check every 1000 candles\r\n    if (candleIndex % 1000 === 0) {\r\n      console.log(`\\n[EXIT CHECK] Candle ${candleIndex} @ price ${candle.close.toFixed(4)} (high=${candle.high.toFixed(4)}, low=${candle.low.toFixed(4)})`);\r\n      console.log(`  Position: ${position.direction} @ ${position.entryPrice.toFixed(4)}`);\r\n      console.log(`  SL: ${position.stopLoss.toFixed(4)} | Current TPs: ${position.takeProfits.map((tp, i) => `TP${i + 1}=${tp.price.toFixed(4)}`).join(', ')}`);\r\n      if (position.direction === SignalDirection.SHORT) {\r\n        console.log(`  SL check: candle.high (${candle.high.toFixed(4)}) >= SL (${position.stopLoss.toFixed(4)}) ? ${candle.high >= position.stopLoss}`);\r\n        console.log(`  TP check: candle.low (${candle.low.toFixed(4)}) <= TP1 (${position.takeProfits[0]?.price?.toFixed(4) ?? 'none'}) ? ${position.takeProfits[0] ? candle.low <= position.takeProfits[0].price : 'no TP'}`);\r\n      } else {\r\n        console.log(`  SL check: candle.low (${candle.low.toFixed(4)}) <= SL (${position.stopLoss.toFixed(4)}) ? ${candle.low <= position.stopLoss}`);\r\n        console.log(`  TP check: candle.high (${candle.high.toFixed(4)}) >= TP1 (${position.takeProfits[0]?.price?.toFixed(4) ?? 'none'}) ? ${position.takeProfits[0] ? candle.high >= position.takeProfits[0].price : 'no TP'}`);\r\n      }\r\n    }\r\n\r\n    // Check stop loss FIRST\r\n    if (position.direction === SignalDirection.LONG) {\r\n      if (candle.low <= position.stopLoss) {\r\n        console.log(`\\n[STOP LOSS HIT] LONG @ ${candle.low.toFixed(4)} (SL: ${position.stopLoss.toFixed(4)})`);\r\n        this.closePosition(candle, position.stopLoss, 'STOP_LOSS');\r\n        return;\r\n      }\r\n    } else {\r\n      if (candle.high >= position.stopLoss) {\r\n        console.log(`\\n[STOP LOSS HIT] SHORT @ ${candle.high.toFixed(4)} (SL: ${position.stopLoss.toFixed(4)})`);\r\n        this.closePosition(candle, position.stopLoss, 'STOP_LOSS');\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Check take profits\r\n    for (let i = 0; i < position.takeProfits.length; i++) {\r\n      const tp = position.takeProfits[i];\r\n      let hit = false;\r\n\r\n      if (position.direction === SignalDirection.LONG) {\r\n        hit = candle.high >= tp.price;\r\n      } else {\r\n        hit = candle.low <= tp.price;\r\n      }\r\n\r\n      if (hit) {\r\n        // Check if this is the LAST TP (should close entire remaining position)\r\n        const isLastTP = position.takeProfits.length === 1;\r\n\r\n        if (isLastTP) {\r\n          // Close entire remaining position\r\n          console.log(`[TP${i + 1} HIT - LAST TP] Closing entire remaining position @ ${tp.price.toFixed(4)}`);\r\n          this.closePosition(candle, tp.price, `TP${i + 1}`);\r\n          return;\r\n        } else {\r\n          // Partial close\r\n          console.log(`[TP${i + 1} HIT] Partial close ${tp.closePercent}% @ ${tp.price.toFixed(4)}`);\r\n          this.partialClose(candle, tp.price, tp.closePercent, `TP${i + 1}`);\r\n          position.takeProfits.splice(i, 1);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Partial close position\r\n   */\r\n  private partialClose(\r\n    candle: BacktestCandle,\r\n    exitPrice: number,\r\n    closePercent: number,\r\n    reason: string,\r\n  ): void {\r\n    if (!this.currentPosition) {\r\n      return;\r\n    }\r\n\r\n    const position = this.currentPosition;\r\n    const closeSizeUsdt = this.config.positionSizeUsdt * (closePercent / 100);\r\n    const closeSize = position.size * (closePercent / 100);\r\n\r\n    const priceDiff =\r\n      position.direction === SignalDirection.LONG\r\n        ? exitPrice - position.entryPrice\r\n        : position.entryPrice - exitPrice;\r\n    const pnl = (priceDiff / position.entryPrice) * closeSizeUsdt * this.config.leverage;\r\n\r\n    const exitFee = closeSizeUsdt * this.config.makerFee;\r\n    this.balance += pnl - exitFee;\r\n\r\n    const holding = candle.timestamp - position.entryTime;\r\n    this.trades.push({\r\n      entryTime: position.entryTime,\r\n      entryPrice: position.entryPrice,\r\n      direction: position.direction,\r\n      size: closeSize,\r\n      stopLoss: position.stopLoss,\r\n      takeProfits: [],\r\n      exitTime: candle.timestamp,\r\n      exitPrice,\r\n      exitReason: reason,\r\n      pnl,\r\n      pnlPercent: (pnl / closeSizeUsdt) * 100,\r\n      fees: exitFee + (this.config.positionSizeUsdt * (closePercent / 100) * this.config.takerFee),\r\n      holding,\r\n      confidence: position.confidence,\r\n      strategyName: position.strategyName,\r\n    });\r\n\r\n    position.size -= closeSize;\r\n    this.config.positionSizeUsdt *= (100 - closePercent) / 100;\r\n  }\r\n\r\n  /**\r\n   * Close position\r\n   */\r\n  private closePosition(\r\n    candle: BacktestCandle,\r\n    exitPrice: number,\r\n    reason: string,\r\n  ): void {\r\n    if (!this.currentPosition) {\r\n      return;\r\n    }\r\n\r\n    const position = this.currentPosition;\r\n\r\n    const priceDiff =\r\n      position.direction === SignalDirection.LONG\r\n        ? exitPrice - position.entryPrice\r\n        : position.entryPrice - exitPrice;\r\n    const pnl = (priceDiff / position.entryPrice) * this.config.positionSizeUsdt * this.config.leverage;\r\n\r\n    const exitFee = this.config.positionSizeUsdt * this.config.makerFee;\r\n    this.balance += pnl - exitFee;\r\n\r\n    if (this.balance > this.peakBalance) {\r\n      this.peakBalance = this.balance;\r\n    }\r\n    const drawdown = this.peakBalance - this.balance;\r\n    if (drawdown > this.maxDrawdown) {\r\n      this.maxDrawdown = drawdown;\r\n    }\r\n\r\n    const holding = candle.timestamp - position.entryTime;\r\n    this.trades.push({\r\n      ...position,\r\n      exitTime: candle.timestamp,\r\n      exitPrice,\r\n      exitReason: reason,\r\n      pnl,\r\n      pnlPercent: (pnl / this.config.positionSizeUsdt) * 100,\r\n      fees: exitFee + (this.config.positionSizeUsdt * this.config.takerFee),\r\n      holding,\r\n    });\r\n\r\n    // PHASE 5: Update Daily Limits\r\n    if (this.dailyLimitsService) {\r\n      this.dailyLimitsService.onTradeClose(pnl, this.balance);\r\n    }\r\n\r\n    // PHASE 5: Record trade result for Loss Streak\r\n    if (this.lossStreakService) {\r\n      const isWin = pnl > 0;\r\n      this.lossStreakService.recordTrade(isWin);\r\n    }\r\n\r\n    // PHASE 5: Remove position from Max Concurrent Risk\r\n    if (this.maxConcurrentRiskService) {\r\n      this.maxConcurrentRiskService.removePosition(this.config.config.exchange.symbol);\r\n    }\r\n\r\n    this.currentPosition = null;\r\n  }\r\n\r\n  /**\r\n   * Calculate backtest results\r\n   */\r\n  private calculateResults(): BacktestResult {\r\n    const winners = this.trades.filter((t) => (t.pnl || 0) > 0);\r\n    const losers = this.trades.filter((t) => (t.pnl || 0) <= 0);\r\n\r\n    const totalPnl = this.trades.reduce((sum, t) => sum + (t.pnl || 0), 0);\r\n    const totalFees = this.trades.reduce((sum, t) => sum + (t.fees || 0), 0);\r\n    const netPnl = this.balance - this.config.initialBalance;\r\n\r\n    const winRate = this.trades.length > 0 ? (winners.length / this.trades.length) * 100 : 0;\r\n\r\n    const totalWin = winners.reduce((sum, t) => sum + (t.pnl || 0), 0);\r\n    const totalLoss = Math.abs(losers.reduce((sum, t) => sum + (t.pnl || 0), 0));\r\n\r\n    const avgWin = winners.length > 0 ? totalWin / winners.length : 0;\r\n    const avgLoss = losers.length > 0 ? totalLoss / losers.length : 0;\r\n\r\n    const winLossRatio = avgLoss > 0 ? avgWin / avgLoss : 0;\r\n    const profitFactor = totalLoss > 0 ? totalWin / totalLoss : 0;\r\n\r\n    const avgHoldingTime = this.trades.length > 0\r\n      ? this.trades.reduce((sum, t) => sum + (t.holding || 0), 0) / this.trades.length\r\n      : 0;\r\n\r\n    const returns = this.trades.map((t) => (t.pnlPercent || 0) / 100);\r\n    const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;\r\n    const stdDev = Math.sqrt(\r\n      returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length,\r\n    );\r\n    const sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0;\r\n\r\n    return {\r\n      config: this.config,\r\n      totalTrades: this.trades.length,\r\n      winningTrades: winners.length,\r\n      losingTrades: losers.length,\r\n      winRate,\r\n      totalPnl,\r\n      totalFees,\r\n      netPnl,\r\n      netPnlPercent: (netPnl / this.config.initialBalance) * 100,\r\n      winLossRatio,\r\n      profitFactor,\r\n      avgWin,\r\n      avgLoss,\r\n      maxDrawdown: this.maxDrawdown,\r\n      maxDrawdownPercent: (this.maxDrawdown / this.config.initialBalance) * 100,\r\n      sharpeRatio,\r\n      avgHoldingTime,\r\n      trades: this.trades,\r\n      equityCurve: this.equityCurve,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\backtest\\calibrate-whale.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.4.","line":67,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":67,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":67,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":67,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.6.","line":67,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":67,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":72,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":72,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.25.","line":72,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":72,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":77,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":77,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 75.","line":77,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":77,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 85.","line":77,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":77,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":82,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":82,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":82,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":82,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":102,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":102,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.4.","line":102,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":102,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":102,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":102,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.6.","line":102,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":102,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":107,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":107,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.25.","line":107,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":107,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":112,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":112,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":112,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":112,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 75.","line":112,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":112,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":112,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":112,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 85.","line":112,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":112,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":117,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":117,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":117,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":117,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":137,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.4.","line":137,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":137,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.6.","line":137,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.7.","line":137,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":37},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":142,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":142,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":142,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":142,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.25.","line":142,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":142,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":142,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":142,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":147,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":147,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 75.","line":147,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":147,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 85.","line":147,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":152,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":152,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":152,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":152,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 75.","line":152,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":152,"endColumn":24},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":220,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":220,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7111,7181],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":227,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":227,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7299,7351],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":228,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":228,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7357,7415],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":229,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":229,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7421,7472],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":230,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":230,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7478,7516],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":232,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":232,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7567,7642],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":236,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":236,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":237,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":237,"endColumn":49},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":238,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":238,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7870,7935],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":239,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":239,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7941,8050],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":250,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":250,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8422,8488],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":251,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":251,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8498,8762],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":251,"column":179,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":251,"endColumn":201,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8668,8690],"text":"(Boolean(combo.wallBreakEnabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":251,"column":227,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":251,"endColumn":257,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8716,8746],"text":"(Boolean(combo.wallDisappearanceEnabled))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":259,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":259,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9096,9245],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":259,"column":138,"nodeType":"Literal","messageId":"noMagic","endLine":259,"endColumn":139},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":270,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":270,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9597,9805],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":270,"column":123,"nodeType":"Literal","messageId":"noMagic","endLine":270,"endColumn":124},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":270,"column":173,"nodeType":"Literal","messageId":"noMagic","endLine":270,"endColumn":174},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":271,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":271,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9817,9888],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":275,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":275,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[9955,10055],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":293,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10429,10432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10429,10432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10478,10481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10478,10481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10587,10590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10587,10590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11059,11062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11059,11062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":320,"column":25,"nodeType":"MemberExpression","messageId":"unexpected","endLine":320,"endColumn":36},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":321,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":321,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":321,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":321,"endColumn":24},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":327,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":327,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Async method 'runBacktestInternal' has a complexity of 12. Maximum allowed is 10.","line":334,"column":36,"nodeType":"FunctionExpression","messageId":"complex","endLine":446,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":334,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":334,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11532,11535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11532,11535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":358,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":358,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 7.","line":366,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":366,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":40},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":366,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":366,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":50},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":366,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":366,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":379,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":379,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[13631,13654],"text":"(config.trading.leverage !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[13631,13654],"text":"(!Number.isNaN(config.trading.leverage))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13631,13654],"text":"(Boolean(config.trading.leverage))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":379,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":396,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":396,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14265,14270],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14265,14270],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14265,14270],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":396,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":396,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14271,14273],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":397,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":397,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14329,14334],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14329,14334],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14329,14334],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":397,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":397,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14335,14337],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":401,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":401,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14519,14524],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14519,14524],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14519,14524],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":401,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":401,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14525,14527],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":405,"column":51,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":405,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14656,14661],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14656,14661],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14656,14661],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":405,"column":57,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":405,"endColumn":59,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14662,14664],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":411,"column":46,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":411,"endColumn":75,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[14848,14877],"text":"((t.exitReason?.includes('TP1')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[14848,14877],"text":"((t.exitReason?.includes('TP1')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":411,"column":76,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":411,"endColumn":78,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14878,14880],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":414,"column":49,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":414,"endColumn":71,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[15039,15045],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":415,"column":50,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":415,"endColumn":73,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[15114,15121],"text":"SignalDirection.SHORT"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":416,"column":49,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":416,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15173,15178],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15173,15178],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15173,15178],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":416,"column":55,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":416,"endColumn":57,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15179,15181],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":417,"column":51,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":417,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15242,15247],"text":"(t.pnl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15242,15247],"text":"(t.pnl ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15242,15247],"text":"(Boolean(t.pnl))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":417,"column":57,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":417,"endColumn":59,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15248,15250],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":419,"column":92,"nodeType":"Literal","messageId":"noMagic","endLine":419,"endColumn":95},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":420,"column":96,"nodeType":"Literal","messageId":"noMagic","endLine":420,"endColumn":99},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":423,"column":48,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":423,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15573,15582],"text":"(t.holding != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15573,15582],"text":"(t.holding ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15573,15582],"text":"(Boolean(t.holding))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":423,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":423,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15583,15585],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60000.","line":423,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":423,"endColumn":71},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":436,"column":92,"nodeType":"Literal","messageId":"noMagic","endLine":436,"endColumn":95},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":437,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":437,"endColumn":84},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (494). Maximum allowed is 300.","line":438,"column":1,"nodeType":null,"messageId":"exceed","endLine":708,"endColumn":1},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":467,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":467,"endColumn":56},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":492,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":492,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[17814,17858],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":503,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":503,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[18127,18175],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":525,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":525,"endColumn":23},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":526,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":526,"endColumn":50},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":527,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":527,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":529,"column":282,"nodeType":"Literal","messageId":"noMagic","endLine":529,"endColumn":283},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":529,"column":325,"nodeType":"Literal","messageId":"noMagic","endLine":529,"endColumn":326},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":529,"column":359,"nodeType":"Literal","messageId":"noMagic","endLine":529,"endColumn":360},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":529,"column":394,"nodeType":"Literal","messageId":"noMagic","endLine":529,"endColumn":395},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":536,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":536,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":537,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":537,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":543,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":543,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":544,"column":38,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":544,"endColumn":71},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":550,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":550,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":551,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":551,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":551,"column":100,"nodeType":"Literal","messageId":"noMagic","endLine":551,"endColumn":101},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":552,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":552,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":553,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":553,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":572,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":572,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":572,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":572,"endColumn":108},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":584,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":584,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":584,"column":107,"nodeType":"Literal","messageId":"noMagic","endLine":584,"endColumn":108},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":596,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":596,"endColumn":51},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":596,"column":109,"nodeType":"Literal","messageId":"noMagic","endLine":596,"endColumn":110},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":608,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":608,"endColumn":51},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":608,"column":109,"nodeType":"Literal","messageId":"noMagic","endLine":608,"endColumn":110},{"ruleId":"max-len","severity":1,"message":"This line has a length of 154. Maximum allowed is 120.","line":618,"column":1,"nodeType":"Program","messageId":"max","endLine":618,"endColumn":155},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":623,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":623,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":651,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":651,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[24966,25016],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":652,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":652,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25022,25051],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":652,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":652,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":659,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":659,"endColumn":14},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":660,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":660,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25291,25327],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":664,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":664,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25357,25414],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":665,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":665,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25420,25482],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":666,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":666,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25488,25556],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":667,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":667,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25562,25630],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":668,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":668,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25636,25724],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":668,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":668,"endColumn":60},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":669,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":669,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25730,25834],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":669,"column":40,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":669,"endColumn":76},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":670,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":670,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25840,25856],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":671,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":671,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25862,25889],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":672,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":672,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25895,26022],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":673,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":673,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26028,26191],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":674,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":674,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26197,26265],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":674,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":674,"endColumn":65},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":675,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":675,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26271,26386],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":675,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":675,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":675,"column":108,"nodeType":"Literal","messageId":"noMagic","endLine":675,"endColumn":109},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":676,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":676,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26392,26460],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":676,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":676,"endColumn":63},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":677,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":677,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26466,26536],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":677,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":677,"endColumn":65},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":678,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":678,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26542,26616],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":679,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":679,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26622,26694],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":680,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":680,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26700,26781],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":682,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":682,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26789,26825],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":682,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":682,"endColumn":38},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":685,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":685,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26852,26896],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":686,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":686,"endColumn":22},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":687,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":687,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[26948,27210],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":687,"column":179,"nodeType":"Literal","messageId":"noMagic","endLine":687,"endColumn":180},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":687,"column":262,"nodeType":"Literal","messageId":"noMagic","endLine":687,"endColumn":263},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":690,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":690,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[27227,27276],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":698,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":698,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":705,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":705,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[27618,27655],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":124,"fatalErrorCount":0,"warningCount":47,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * WhaleHunter Strategy Calibration Script\r\n *\r\n * Automatically tests multiple parameter combinations to find optimal settings\r\n * for WhaleHunter strategy (single TP mode).\r\n *\r\n * Usage:\r\n *   npm run calibrate-whale\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { BacktestEngineV2, BacktestResult } from './backtest-engine-v2';\r\nimport { SqliteDataProvider } from './data-providers/sqlite.provider';\r\nimport { LoggerService, LogLevel, PERCENTAGE_THRESHOLDS, Config } from '../types';\r\n\r\n// ============================================================================\r\n// CALIBRATION CONFIGURATION\r\n// ============================================================================\r\n\r\ninterface CalibrationParam {\r\n  name: string;\r\n  description: string;\r\n  values: Array<string | number | boolean>;\r\n}\r\n\r\ninterface CalibrationResult {\r\n  params: Record<string, string | number | boolean>;\r\n  metrics: {\r\n    totalTrades: number;\r\n    winRate: number;\r\n    rrRatio: number; // W/L Ratio\r\n    netPnlPercent: number;\r\n    netPnlUsdt: number;\r\n    avgWin: number;\r\n    avgLoss: number;\r\n    stopOutRate: number;\r\n    tp1HitRate: number;\r\n    avgHoldingMinutes: number;\r\n    longWinRate: number;\r\n    shortWinRate: number;\r\n    longTrades: number;\r\n    shortTrades: number;\r\n  };\r\n  timestamp: string;\r\n}\r\n\r\n// ============================================================================\r\n// CALIBRATION MODES\r\n// ============================================================================\r\n\r\ntype CalibrationMode = 'quick' | 'medium' | 'full';\r\n\r\n// Change this to switch between modes:\r\nconst CALIBRATION_MODE = 'full'; // 'quick' | 'medium' | 'full'\r\n\r\n// ============================================================================\r\n// PARAMETER SETS\r\n// ============================================================================\r\n\r\n// QUICK mode: ~54 combinations (~1-2 hours) ‚ö°\r\nconst QUICK_PARAMS: CalibrationParam[] = [\r\n  {\r\n    name: 'takeProfitPercent',\r\n    description: 'Single TP target (whale scalping)',\r\n    values: [0.4, 0.5, 0.6], // 3 variants (most promising)\r\n  },\r\n  {\r\n    name: 'stopLossAtrMultiplier',\r\n    description: 'Stop Loss ATR multiplier',\r\n    values: [0.75, 1.0, 1.25], // 3 variants\r\n  },\r\n  {\r\n    name: 'minConfidenceLong',\r\n    description: 'Minimum confidence for LONG trades',\r\n    values: [60, 75, 85], // 3 variants (added 60)\r\n  },\r\n  {\r\n    name: 'minConfidenceShort',\r\n    description: 'Minimum confidence for SHORT trades',\r\n    values: [60, 70], // 2 variants\r\n  },\r\n  {\r\n    name: 'wallBreakEnabled',\r\n    description: 'WALL_BREAK mode enabled',\r\n    values: [true], // 1 variant (keep enabled)\r\n  },\r\n  {\r\n    name: 'wallDisappearanceEnabled',\r\n    description: 'WALL_DISAPPEARANCE mode enabled',\r\n    values: [true, false], // 2 variants\r\n  },\r\n];\r\n// 3 √ó 3 √ó 3 √ó 2 √ó 1 √ó 2 = 108 combinations\r\n\r\n// MEDIUM mode: ~240 combinations (~4-6 hours)\r\nconst MEDIUM_PARAMS: CalibrationParam[] = [\r\n  {\r\n    name: 'takeProfitPercent',\r\n    description: 'Single TP target (whale scalping)',\r\n    values: [0.3, 0.4, 0.5, 0.6], // 4 variants\r\n  },\r\n  {\r\n    name: 'stopLossAtrMultiplier',\r\n    description: 'Stop Loss ATR multiplier',\r\n    values: [0.75, 1.0, 1.25], // 3 variants\r\n  },\r\n  {\r\n    name: 'minConfidenceLong',\r\n    description: 'Minimum confidence for LONG trades',\r\n    values: [60, 70, 75, 80, 85], // 5 variants (added 60)\r\n  },\r\n  {\r\n    name: 'minConfidenceShort',\r\n    description: 'Minimum confidence for SHORT trades',\r\n    values: [60, 70], // 2 variants\r\n  },\r\n  {\r\n    name: 'wallBreakEnabled',\r\n    description: 'WALL_BREAK mode enabled',\r\n    values: [true, false], // 2 variants\r\n  },\r\n  {\r\n    name: 'wallDisappearanceEnabled',\r\n    description: 'WALL_DISAPPEARANCE mode enabled',\r\n    values: [true], // 1 variant (keep enabled)\r\n  },\r\n];\r\n// 4 √ó 3 √ó 5 √ó 2 √ó 2 √ó 1 = 240 combinations\r\n\r\n// FULL mode: 750 combinations (~15-20 hours with separate LONG/SHORT confidence)\r\nconst FULL_PARAMS: CalibrationParam[] = [\r\n  {\r\n    name: 'takeProfitPercent',\r\n    description: 'Single TP target (whale scalping)',\r\n    values: [0.3, 0.4, 0.5, 0.6, 0.7], // 5 variants\r\n  },\r\n  {\r\n    name: 'stopLossAtrMultiplier',\r\n    description: 'Stop Loss ATR multiplier',\r\n    values: [0.5, 0.75, 1.0, 1.25, 1.5], // 5 variants\r\n  },\r\n  {\r\n    name: 'minConfidenceLong',\r\n    description: 'Minimum confidence for LONG trades',\r\n    values: [60, 70, 75, 80, 85], // 5 variants (added 60 to match old calibration)\r\n  },\r\n  {\r\n    name: 'minConfidenceShort',\r\n    description: 'Minimum confidence for SHORT trades',\r\n    values: [60, 70, 75], // 3 variants (SHORT already works well)\r\n  },\r\n  {\r\n    name: 'wallBreakEnabled',\r\n    description: 'WALL_BREAK mode enabled',\r\n    values: [true, false], // 2 variants\r\n  },\r\n  {\r\n    name: 'wallDisappearanceEnabled',\r\n    description: 'WALL_DISAPPEARANCE mode enabled',\r\n    values: [true, false], // 2 variants\r\n  },\r\n];\r\n// 5 √ó 5 √ó 5 √ó 3 √ó 2 √ó 2 = 750 combinations\r\n\r\n// Select parameters based on mode\r\nfunction getCalibrationParams(mode: CalibrationMode): CalibrationParam[] {\r\n  switch (mode) {\r\n  case 'quick':\r\n    return QUICK_PARAMS;\r\n  case 'medium':\r\n    return MEDIUM_PARAMS;\r\n  case 'full':\r\n    return FULL_PARAMS;\r\n  }\r\n}\r\n\r\nconst CALIBRATION_PARAMS = getCalibrationParams(CALIBRATION_MODE);\r\n\r\n// ============================================================================\r\n// PARALLEL EXECUTION\r\n// ============================================================================\r\n\r\n// Number of parallel backtests (1 = sequential, 2-4 = parallel)\r\n// WARNING: SQLite may have issues with >2 concurrent reads\r\nconst PARALLEL_JOBS = 2; // Change to 2-4 for faster execution (2 recommended)\r\n\r\n// ============================================================================\r\n// EARLY STOPPING\r\n// ============================================================================\r\n\r\n// Skip configurations with obviously bad results\r\nconst ENABLE_EARLY_STOPPING = true;\r\nconst MIN_WIN_RATE = PERCENTAGE_THRESHOLDS.MODERATE_HIGH; // Skip if WR < 40%\r\nconst MIN_RR_RATIO = 0.3; // Skip if R/R < 0.3x\r\nconst MIN_TRADES = 5; // Need at least 5 trades to evaluate\r\n\r\n// ============================================================================\r\n// CALIBRATION ENGINE\r\n// ============================================================================\r\n\r\nclass WhaleCalibrator {\r\n  private logger: LoggerService;\r\n  private dataProvider: SqliteDataProvider;\r\n  private resultsFilePath: string;\r\n  private totalTests = 0;\r\n  private writeLock: Promise<void> = Promise.resolve(); // ‚úÖ Mutex for file writes\r\n\r\n  constructor() {\r\n    this.logger = new LoggerService(LogLevel.ERROR, './logs', false);\r\n    this.dataProvider = new SqliteDataProvider('./data/market-data.db');\r\n\r\n    // Create results file immediately with timestamp\r\n    const timestamp = new Date().toISOString().split('T')[0];\r\n    this.resultsFilePath = path.join(process.cwd(), `whale-calibration-${timestamp}.json`);\r\n\r\n    // Initialize empty JSON array in file\r\n    fs.writeFileSync(this.resultsFilePath, '[\\n');\r\n    console.log(`üíæ Results will be saved to: ${this.resultsFilePath}\\n`);\r\n  }\r\n\r\n  /**\r\n   * Run calibration for all parameter combinations\r\n   */\r\n  async calibrate(): Promise<void> {\r\n    console.log('üêã WhaleHunter Calibration Started\\n');\r\n    console.log(`üéØ Mode: ${CALIBRATION_MODE.toUpperCase()}`);\r\n    console.log(`‚ö° Parallel jobs: ${PARALLEL_JOBS}\\n`);\r\n    console.log('üìä Testing parameters:');\r\n    CALIBRATION_PARAMS.forEach(param => {\r\n      console.log(`  - ${param.description}: ${param.values.length} variations`);\r\n    });\r\n    // Generate all combinations\r\n    const combinations = this.generateCombinations();\r\n    const estimatedMinutes = combinations.length * 1.5 / PARALLEL_JOBS;\r\n    const estimatedHours = estimatedMinutes / 60;\r\n    console.log(`\\nüìà Total combinations: ${combinations.length}\\n`);\r\n    console.log(`‚è±Ô∏è  Estimated time: ${estimatedMinutes.toFixed(0)} min (${estimatedHours.toFixed(1)} hours)\\n`);\r\n\r\n    let completed = 0;\r\n\r\n    // Process in batches for parallel execution\r\n    for (let i = 0; i < combinations.length; i += PARALLEL_JOBS) {\r\n      const batch = combinations.slice(i, i + PARALLEL_JOBS);\r\n\r\n      // Run batch in parallel\r\n      const batchPromises = batch.map(async (combo, batchIndex) => {\r\n        const globalIndex = i + batchIndex + 1;\r\n        console.log(`\\n[${globalIndex}/${combinations.length}] Testing:`);\r\n        console.log(`  TP: ${combo.takeProfitPercent}% | SL: ${combo.stopLossAtrMultiplier}x | LONG: ${combo.minConfidenceLong}% | SHORT: ${combo.minConfidenceShort}% | BREAK: ${combo.wallBreakEnabled ? '‚úÖ' : '‚ùå'} | DISAPP: ${combo.wallDisappearanceEnabled ? '‚úÖ' : '‚ùå'}`);\r\n\r\n        try {\r\n          const result = await this.runBacktest(combo);\r\n\r\n          // Early stopping: skip if results are terrible\r\n          if (ENABLE_EARLY_STOPPING && result.metrics.totalTrades >= MIN_TRADES) {\r\n            if (result.metrics.winRate < MIN_WIN_RATE || result.metrics.rrRatio < MIN_RR_RATIO) {\r\n              console.log(`‚è≠Ô∏è  [${globalIndex}] SKIPPED (WR=${result.metrics.winRate.toFixed(1)}% | R/R=${result.metrics.rrRatio.toFixed(2)}x) - below threshold`);\r\n              completed++;\r\n              return null; // Don't save bad results\r\n            }\r\n          }\r\n\r\n          // ‚úÖ Save result IMMEDIATELY to file (no memory accumulation!)\r\n          // ‚úÖ Thread-safe write with mutex\r\n          completed++;\r\n          await this.saveResultToFile(result, completed === combinations.length);\r\n\r\n          console.log(`‚úÖ [${globalIndex}] WR=${result.metrics.winRate.toFixed(1)}% | R/R=${result.metrics.rrRatio.toFixed(2)}x | PnL=${result.metrics.netPnlPercent.toFixed(2)}% | Trades=${result.metrics.totalTrades}`);\r\n          console.log(`üíæ Progress saved (${completed}/${combinations.length})`);\r\n\r\n          return result;\r\n        } catch (error) {\r\n          console.error(`‚ùå [${globalIndex}] Failed:`, error instanceof Error ? error.message : String(error));\r\n          completed++;\r\n          return null;\r\n        }\r\n      });\r\n\r\n      // Wait for batch to complete\r\n      await Promise.all(batchPromises);\r\n    }\r\n\r\n    // Generate final report from file\r\n    this.generateAndSaveReport();\r\n    this.printSummary();\r\n  }\r\n\r\n  /**\r\n   * Generate all parameter combinations\r\n   */\r\n  private generateCombinations(): Record<string, any>[] {\r\n    const combinations: Record<string, any>[] = [{}];\r\n\r\n    for (const param of CALIBRATION_PARAMS) {\r\n      const newCombinations: Record<string, any>[] = [];\r\n\r\n      for (const combo of combinations) {\r\n        for (const value of param.values) {\r\n          newCombinations.push({\r\n            ...combo,\r\n            [param.name]: value,\r\n          });\r\n        }\r\n      }\r\n\r\n      combinations.length = 0;\r\n      combinations.push(...newCombinations);\r\n    }\r\n\r\n    return combinations;\r\n  }\r\n\r\n  /**\r\n   * Run backtest with specific parameter combination\r\n   */\r\n  private async runBacktest(params: Record<string, any>): Promise<CalibrationResult> {\r\n    // ‚úÖ Silence console.log during backtest (66 console.log calls!)\r\n    const originalLog = console.log;\r\n    console.log = () => {}; // Suppress all console.log\r\n\r\n    try {\r\n      return await this.runBacktestInternal(params);\r\n    } finally {\r\n      // ‚úÖ Restore console.log\r\n      console.log = originalLog;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal backtest execution\r\n   */\r\n  private async runBacktestInternal(params: Record<string, any>): Promise<CalibrationResult> {\r\n    // Load config template\r\n    const configPath = path.join(process.cwd(), 'config.json');\r\n    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8')) as Config;\r\n\r\n    // Apply WhaleHunter parameters\r\n    config.whaleHunter!.enabled = true; // Always enabled for whale calibration\r\n    config.whaleHunter!.takeProfitPercent = params.takeProfitPercent as number;\r\n    config.whaleHunter!.stopLossAtrMultiplier = params.stopLossAtrMultiplier as number;\r\n\r\n    // ‚úÖ Apply direction-specific confidence thresholds\r\n    config.whaleHunter!.minConfidenceLong = params.minConfidenceLong as number;\r\n    config.whaleHunter!.minConfidenceShort = params.minConfidenceShort as number;\r\n\r\n    // NOTE: dynamicTakeProfit uses production config (enabled: true)\r\n    // This means 3-level TP system will be used, NOT single TP\r\n    // takeProfitPercent is used as base, then adjusted by wall size/ATR\r\n\r\n    // Disable other strategies (WhaleHunter only)\r\n    config.strategies.levelBased.enabled = false;\r\n    config.strategies.trendFollowing.enabled = false;\r\n    config.strategies.counterTrend.enabled = false;\r\n\r\n    // WhaleHunter detector modes (correct path)\r\n    if (config.whaleHunter!.detector?.modes) {\r\n      config.whaleHunter!.detector.modes.wallBreak.enabled = params.wallBreakEnabled as boolean;\r\n      config.whaleHunter!.detector.modes.wallDisappearance.enabled = params.wallDisappearanceEnabled as boolean;\r\n    }\r\n\r\n    // Load data (last 7 days for comprehensive whale activity coverage)\r\n    const symbol = 'APEXUSDT';\r\n    const endTime = new Date('2025-11-15').getTime();\r\n    const startTime = endTime - (7 * 24 * 60 * 60 * 1000); // 7 days (full coverage)\r\n\r\n    const timeframeData = await this.dataProvider.loadCandles(symbol, startTime, endTime);\r\n\r\n    if (timeframeData.candles1m.length === 0) {\r\n      throw new Error('No 1m candles loaded');\r\n    }\r\n\r\n    // Wrap config in BacktestConfig structure\r\n    const backtestConfig = {\r\n      symbol: 'APEXUSDT',\r\n      initialBalance: 1000,\r\n      positionSizeUsdt: 100,\r\n      leverage: config.trading.leverage || 10,\r\n      takerFee: 0.0006, // Bybit taker fee\r\n      makerFee: 0.0001, // Bybit maker fee\r\n      config: config, // Full config.json\r\n    };\r\n\r\n    // Run backtest\r\n    const engine = new BacktestEngineV2(backtestConfig);\r\n    const result: BacktestResult = await engine.run(\r\n      timeframeData.candles1m,\r\n      timeframeData.candles5m,\r\n      timeframeData.candles15m,\r\n      this.dataProvider, // Pass dataProvider for orderbook loading\r\n    );\r\n\r\n    // Calculate metrics\r\n    const closedTrades = result.trades.filter(t => t.exitPrice !== undefined);\r\n    const winners = closedTrades.filter(t => (t.pnl || 0) > 0);\r\n    const losers = closedTrades.filter(t => (t.pnl || 0) <= 0);\r\n    const stoppedOut = closedTrades.filter(t => t.exitReason?.includes('Stop Loss'));\r\n\r\n    const avgWin = winners.length > 0\r\n      ? winners.reduce((sum, t) => sum + (t.pnl || 0), 0) / winners.length\r\n      : 0;\r\n\r\n    const avgLoss = losers.length > 0\r\n      ? Math.abs(losers.reduce((sum, t) => sum + (t.pnl || 0), 0) / losers.length)\r\n      : 0;\r\n\r\n    const rrRatio = avgLoss > 0 ? avgWin / avgLoss : 0;\r\n\r\n    // Count TP1 hits (single TP mode)\r\n    const tp1Hits = closedTrades.filter(t => t.exitReason?.includes('TP1') || t.exitReason?.includes('TAKE_PROFIT')).length;\r\n\r\n    // Calculate LONG vs SHORT performance\r\n    const longTrades = closedTrades.filter(t => t.direction === 'LONG');\r\n    const shortTrades = closedTrades.filter(t => t.direction === 'SHORT');\r\n    const longWinners = longTrades.filter(t => (t.pnl || 0) > 0);\r\n    const shortWinners = shortTrades.filter(t => (t.pnl || 0) > 0);\r\n\r\n    const longWinRate = longTrades.length > 0 ? (longWinners.length / longTrades.length) * 100 : 0;\r\n    const shortWinRate = shortTrades.length > 0 ? (shortWinners.length / shortTrades.length) * 100 : 0;\r\n\r\n    const avgHoldingMinutes = closedTrades.length > 0\r\n      ? closedTrades.reduce((sum, t) => sum + (t.holding || 0) / 60000, 0) / closedTrades.length\r\n      : 0;\r\n\r\n    return {\r\n      params,\r\n      metrics: {\r\n        totalTrades: closedTrades.length,\r\n        winRate: result.winRate,\r\n        rrRatio,\r\n        netPnlPercent: result.netPnlPercent,\r\n        netPnlUsdt: result.netPnl,\r\n        avgWin,\r\n        avgLoss,\r\n        stopOutRate: closedTrades.length > 0 ? (stoppedOut.length / closedTrades.length) * 100 : 0,\r\n        tp1HitRate: closedTrades.length > 0 ? (tp1Hits / closedTrades.length) * 100 : 0,\r\n        avgHoldingMinutes,\r\n        longWinRate,\r\n        shortWinRate,\r\n        longTrades: longTrades.length,\r\n        shortTrades: shortTrades.length,\r\n      },\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Save single result to file immediately (append mode)\r\n   * NO memory accumulation - results go straight to disk!\r\n   * ‚úÖ Thread-safe: uses mutex to prevent race conditions\r\n   */\r\n  private async saveResultToFile(result: CalibrationResult, isLast: boolean): Promise<void> {\r\n    // ‚úÖ Wait for previous write to complete (mutex)\r\n    await this.writeLock;\r\n\r\n    // ‚úÖ Create new lock for this write\r\n    let releaseLock: () => void;\r\n    this.writeLock = new Promise((resolve) => {\r\n      releaseLock = resolve;\r\n    });\r\n\r\n    try {\r\n      this.totalTests++;\r\n\r\n      // Append result to JSON array\r\n      const resultJson = JSON.stringify(result, null, 2);\r\n      const prefix = this.totalTests === 1 ? '  ' : ',\\n  ';\r\n      const suffix = isLast ? '\\n]' : '';\r\n\r\n      // Replace first and last lines to indent properly\r\n      const indentedResult = resultJson\r\n        .split('\\n')\r\n        .map((line, i) => (i === 0 ? line : '  ' + line))\r\n        .join('\\n');\r\n\r\n      fs.appendFileSync(this.resultsFilePath, prefix + indentedResult + suffix);\r\n    } finally {\r\n      // ‚úÖ Release lock\r\n      releaseLock!();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate and save final markdown report from file\r\n   */\r\n  private generateAndSaveReport(): void {\r\n    const timestamp = new Date().toISOString().split('T')[0];\r\n    const mdPath = path.join(process.cwd(), `whale-calibration-${timestamp}.md`);\r\n    const mdContent = this.generateMarkdownReport();\r\n    fs.writeFileSync(mdPath, mdContent);\r\n    console.log(`\\nüìä Report saved: ${mdPath}`);\r\n  }\r\n\r\n  /**\r\n   * Load results from file\r\n   */\r\n  private loadResults(): CalibrationResult[] {\r\n    try {\r\n      const content = fs.readFileSync(this.resultsFilePath, 'utf-8');\r\n      return JSON.parse(content) as CalibrationResult[];\r\n    } catch (error) {\r\n      console.error('Failed to load results:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate markdown report\r\n   */\r\n  private generateMarkdownReport(): string {\r\n    // ‚úÖ Load results from file (not from memory!)\r\n    const results = this.loadResults();\r\n    const sorted = [...results].sort((a, b) => b.metrics.rrRatio - a.metrics.rrRatio);\r\n\r\n    let md = '# üêã WhaleHunter Calibration Report\\n\\n';\r\n    md += `**Date:** ${new Date().toISOString()}\\n`;\r\n    md += `**Total Combinations Tested:** ${results.length}\\n\\n`;\r\n    md += '---\\n\\n';\r\n\r\n    md += '## üèÜ Top 20 Results (by R/R Ratio)\\n\\n';\r\n    md += '| Rank | TP% | SL Mult | L Conf% | S Conf% | BREAK | DISAPP | Trades | WR% | R/R | PnL% | Avg Win | Avg Loss | Stop% | L WR% | S WR% |\\n';\r\n    md += '|------|-----|---------|---------|---------|-------|--------|--------|-----|-----|------|---------|----------|-------|-------|-------|\\n';\r\n\r\n    sorted.slice(0, 20).forEach((r, i) => {\r\n      const breakIcon = r.params.wallBreakEnabled ? '‚úÖ' : '‚ùå';\r\n      const disappIcon = r.params.wallDisappearanceEnabled ? '‚úÖ' : '‚ùå';\r\n\r\n      md += `| ${i + 1} | ${r.params.takeProfitPercent} | ${r.params.stopLossAtrMultiplier} | ${r.params.minConfidenceLong} | ${r.params.minConfidenceShort} | ${breakIcon} | ${disappIcon} | ${r.metrics.totalTrades} | ${r.metrics.winRate.toFixed(1)} | **${r.metrics.rrRatio.toFixed(2)}x** | ${r.metrics.netPnlPercent.toFixed(2)} | +${r.metrics.avgWin.toFixed(2)} | -${r.metrics.avgLoss.toFixed(2)} | ${r.metrics.stopOutRate.toFixed(1)} | ${r.metrics.longWinRate.toFixed(1)} | ${r.metrics.shortWinRate.toFixed(1)} |\\n`;\r\n    });\r\n\r\n    md += '\\n---\\n\\n';\r\n\r\n    md += '## üìä Detailed Top 10 Results\\n\\n';\r\n\r\n    sorted.slice(0, 10).forEach((r, i) => {\r\n      md += `### ${i + 1}. R/R ${r.metrics.rrRatio.toFixed(2)}x | WR ${r.metrics.winRate.toFixed(1)}%\\n\\n`;\r\n      md += '**Parameters:**\\n';\r\n      md += `- Single TP Target: **${r.params.takeProfitPercent}%**\\n`;\r\n      md += `- Stop Loss: **${r.params.stopLossAtrMultiplier}x ATR**\\n`;\r\n      md += `- Min Confidence LONG: **${r.params.minConfidenceLong}%**\\n`;\r\n      md += `- Min Confidence SHORT: **${r.params.minConfidenceShort}%**\\n`;\r\n      md += `- WALL_BREAK: ${r.params.wallBreakEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}\\n`;\r\n      md += `- WALL_DISAPPEARANCE: ${r.params.wallDisappearanceEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}\\n`;\r\n      md += '\\n';\r\n\r\n      md += '**Performance:**\\n';\r\n      md += `- Total Trades: ${r.metrics.totalTrades} (LONG: ${r.metrics.longTrades} | SHORT: ${r.metrics.shortTrades})\\n`;\r\n      md += `- Win Rate: **${r.metrics.winRate.toFixed(1)}%** (LONG: ${r.metrics.longWinRate.toFixed(1)}% | SHORT: ${r.metrics.shortWinRate.toFixed(1)}%)\\n`;\r\n      md += `- R/R Ratio: **${r.metrics.rrRatio.toFixed(2)}x** ‚≠ê\\n`;\r\n      md += `- Net PnL: **${r.metrics.netPnlPercent.toFixed(2)}%** (${r.metrics.netPnlUsdt.toFixed(2)} USDT)\\n`;\r\n      md += `- Avg Win: +${r.metrics.avgWin.toFixed(2)} USDT\\n`;\r\n      md += `- Avg Loss: -${r.metrics.avgLoss.toFixed(2)} USDT\\n`;\r\n      md += `- Stop-Out Rate: ${r.metrics.stopOutRate.toFixed(1)}%\\n`;\r\n      md += `- TP1 Hit Rate: ${r.metrics.tp1HitRate.toFixed(1)}%\\n`;\r\n      md += `- Avg Holding: ${r.metrics.avgHoldingMinutes.toFixed(1)} min\\n\\n`;\r\n\r\n      md += '---\\n\\n';\r\n    });\r\n\r\n    // Add analysis section\r\n    md += '## üìà Analysis\\n\\n';\r\n\r\n    // Best TP%\r\n    const bestByTP = this.groupByParam('takeProfitPercent', results);\r\n    md += '### Best Take Profit %\\n\\n';\r\n    md += '| TP% | Avg R/R | Avg WR% | Avg PnL% | Count |\\n';\r\n    md += '|-----|---------|---------|----------|-------|\\n';\r\n    Object.entries(bestByTP)\r\n      .sort((a, b) => b[1].avgRR - a[1].avgRR)\r\n      .forEach(([tp, stats]) => {\r\n        md += `| ${tp} | ${stats.avgRR.toFixed(2)}x | ${stats.avgWR.toFixed(1)}% | ${stats.avgPnL.toFixed(2)}% | ${stats.count} |\\n`;\r\n      });\r\n    md += '\\n';\r\n\r\n    // Best SL Multiplier\r\n    const bestBySL = this.groupByParam('stopLossAtrMultiplier', results);\r\n    md += '### Best Stop Loss Multiplier\\n\\n';\r\n    md += '| SL Mult | Avg R/R | Avg WR% | Avg PnL% | Count |\\n';\r\n    md += '|---------|---------|---------|----------|-------|\\n';\r\n    Object.entries(bestBySL)\r\n      .sort((a, b) => b[1].avgRR - a[1].avgRR)\r\n      .forEach(([sl, stats]) => {\r\n        md += `| ${sl} | ${stats.avgRR.toFixed(2)}x | ${stats.avgWR.toFixed(1)}% | ${stats.avgPnL.toFixed(2)}% | ${stats.count} |\\n`;\r\n      });\r\n    md += '\\n';\r\n\r\n    // Best LONG Confidence\r\n    const bestByConfLong = this.groupByParam('minConfidenceLong', results);\r\n    md += '### Best LONG Confidence Threshold\\n\\n';\r\n    md += '| LONG Conf% | Avg R/R | Avg WR% | Avg PnL% | Count |\\n';\r\n    md += '|------------|---------|---------|----------|-------|\\n';\r\n    Object.entries(bestByConfLong)\r\n      .sort((a, b) => b[1].avgRR - a[1].avgRR)\r\n      .forEach(([conf, stats]) => {\r\n        md += `| ${conf} | ${stats.avgRR.toFixed(2)}x | ${stats.avgWR.toFixed(1)}% | ${stats.avgPnL.toFixed(2)}% | ${stats.count} |\\n`;\r\n      });\r\n    md += '\\n';\r\n\r\n    // Best SHORT Confidence\r\n    const bestByConfShort = this.groupByParam('minConfidenceShort', results);\r\n    md += '### Best SHORT Confidence Threshold\\n\\n';\r\n    md += '| SHORT Conf% | Avg R/R | Avg WR% | Avg PnL% | Count |\\n';\r\n    md += '|-------------|---------|---------|----------|-------|\\n';\r\n    Object.entries(bestByConfShort)\r\n      .sort((a, b) => b[1].avgRR - a[1].avgRR)\r\n      .forEach(([conf, stats]) => {\r\n        md += `| ${conf} | ${stats.avgRR.toFixed(2)}x | ${stats.avgWR.toFixed(1)}% | ${stats.avgPnL.toFixed(2)}% | ${stats.count} |\\n`;\r\n      });\r\n    md += '\\n';\r\n\r\n    return md;\r\n  }\r\n\r\n  /**\r\n   * Group results by parameter value\r\n   */\r\n  private groupByParam(paramName: string, results: CalibrationResult[]): Record<string, { avgRR: number; avgWR: number; avgPnL: number; count: number }> {\r\n    const groups: Record<string, CalibrationResult[]> = {};\r\n\r\n    for (const result of results) {\r\n      const value = String(result.params[paramName]);\r\n      if (!groups[value]) {\r\n        groups[value] = [];\r\n      }\r\n      groups[value].push(result);\r\n    }\r\n\r\n    const stats: Record<string, { avgRR: number; avgWR: number; avgPnL: number; count: number }> = {};\r\n\r\n    for (const [value, results] of Object.entries(groups)) {\r\n      const avgRR = results.reduce((sum, r) => sum + r.metrics.rrRatio, 0) / results.length;\r\n      const avgWR = results.reduce((sum, r) => sum + r.metrics.winRate, 0) / results.length;\r\n      const avgPnL = results.reduce((sum, r) => sum + r.metrics.netPnlPercent, 0) / results.length;\r\n\r\n      stats[value] = {\r\n        avgRR,\r\n        avgWR,\r\n        avgPnL,\r\n        count: results.length,\r\n      };\r\n    }\r\n\r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * Print summary to console\r\n   */\r\n  private printSummary(): void {\r\n    console.log('\\n\\nüèÜ WHALE CALIBRATION SUMMARY\\n');\r\n    console.log('='.repeat(100));\r\n\r\n    // ‚úÖ Load results from file (not from memory!)\r\n    const results = this.loadResults();\r\n    const sorted = [...results].sort((a, b) => b.metrics.rrRatio - a.metrics.rrRatio);\r\n    const best = sorted[0];\r\n\r\n    if (!best) {\r\n      console.log('No results available');\r\n      return;\r\n    }\r\n\r\n    console.log('\\nü•á BEST CONFIGURATION (by R/R Ratio):\\n');\r\n    console.log(`Take Profit: ${best.params.takeProfitPercent}%`);\r\n    console.log(`Stop Loss: ${best.params.stopLossAtrMultiplier}x ATR`);\r\n    console.log(`Min Confidence: ${best.params.minConfidenceToEnter}%`);\r\n    console.log(`WALL_BREAK: ${best.params.wallBreakEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}`);\r\n    console.log(`WALL_DISAPPEARANCE: ${best.params.wallDisappearanceEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}`);\r\n    console.log('');\r\n    console.log('üìä Metrics:');\r\n    console.log(`  - Trades: ${best.metrics.totalTrades} (LONG: ${best.metrics.longTrades} | SHORT: ${best.metrics.shortTrades})`);\r\n    console.log(`  - Win Rate: ${best.metrics.winRate.toFixed(1)}% (LONG: ${best.metrics.longWinRate.toFixed(1)}% | SHORT: ${best.metrics.shortWinRate.toFixed(1)}%)`);\r\n    console.log(`  - R/R Ratio: ${best.metrics.rrRatio.toFixed(2)}x ‚≠ê`);\r\n    console.log(`  - Net PnL: ${best.metrics.netPnlPercent.toFixed(2)}% (${best.metrics.netPnlUsdt.toFixed(2)} USDT)`);\r\n    console.log(`  - Avg Win: +${best.metrics.avgWin.toFixed(2)} USDT`);\r\n    console.log(`  - Avg Loss: -${best.metrics.avgLoss.toFixed(2)} USDT`);\r\n    console.log(`  - Stop-Out Rate: ${best.metrics.stopOutRate.toFixed(1)}%`);\r\n    console.log(`  - TP1 Hit Rate: ${best.metrics.tp1HitRate.toFixed(1)}%`);\r\n    console.log(`  - Avg Holding: ${best.metrics.avgHoldingMinutes.toFixed(1)} min`);\r\n\r\n    console.log('\\n' + '='.repeat(100));\r\n\r\n    // Show top 5\r\n    console.log('\\nüìà Top 5 Configurations:\\n');\r\n    sorted.slice(0, 5).forEach((r, i) => {\r\n      console.log(`${i + 1}. TP:${r.params.takeProfitPercent}% | SL:${r.params.stopLossAtrMultiplier}x | Conf:${r.params.minConfidenceToEnter}% | R/R ${r.metrics.rrRatio.toFixed(2)}x | WR ${r.metrics.winRate.toFixed(1)}% | PnL ${r.metrics.netPnlPercent.toFixed(2)}%`);\r\n    });\r\n\r\n    console.log('\\n‚úÖ Whale Calibration complete!\\n');\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// MAIN\r\n// ============================================================================\r\n\r\nasync function main() {\r\n  const calibrator = new WhaleCalibrator();\r\n  await calibrator.calibrate();\r\n  process.exit(0);\r\n}\r\n\r\nmain().catch((error) => {\r\n  console.error('Fatal error:', error);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\constants\\analyzer-constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\constants\\index.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":42,"column":11,"nodeType":"Literal","messageId":"noMagic","endLine":42,"endColumn":13},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":42,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":42,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":44,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":44,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":44,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":44,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":44,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":44,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":46,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":46,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":46,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":46,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":46,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":46,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":48,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":21},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":48,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":48,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":50,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":11},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":50,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":50,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":50,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":52,"column":15,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":52,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":21},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":52,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":52,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":52,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":54,"column":8,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":10},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":54,"column":13,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":15},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":54,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":54,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":54,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 7.","line":56,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":10},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":56,"column":13,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":15},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":56,"column":18,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":56,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":56,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":32}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Technical Constants\r\n *\r\n * IMPORTANT: This file contains ONLY technical/mathematical constants that NEVER change.\r\n * - Time units (milliseconds)\r\n * - Decimal precision\r\n * - Math operations\r\n * - Timezone offsets\r\n *\r\n * DO NOT add configurable parameters here! Use config.json instead.\r\n * Configurable: EMA periods, RSI thresholds, Confidence levels, TP/SL multipliers, etc.\r\n */\r\n\r\n// ============================================================================\r\n// BASIC MATH & PERCENT\r\n// ============================================================================\r\n\r\n// Note: PERCENT_MULTIPLIER and DECIMAL_PLACES are now defined in technical.constants.ts\r\n// and exported below. Keeping these imports here for backward compatibility.\r\n\r\n// Import technical constants for default export\r\nimport {\r\n  PERCENT_MULTIPLIER as PM,\r\n  PERCENT_DECIMAL_PLACES as PDP,\r\n  DECIMAL_PLACES as DP,\r\n  TIME_MULTIPLIERS as TM,\r\n  RATIO_MULTIPLIERS as RM,\r\n  ARRAY_SIZING as AS,\r\n  MATH_BOUNDS as MB,\r\n} from './technical.constants';\r\n\r\n// ============================================================================\r\n// TIME UNITS (in milliseconds) - NEVER CHANGE\r\n// ============================================================================\r\n\r\nexport const TIME_UNITS = {\r\n  /** 1 millisecond */\r\n  MILLISECOND: 1,\r\n  /** 1 second = 1000 ms */\r\n  SECOND: 1000,\r\n  /** 1 minute = 60000 ms */\r\n  MINUTE: 60 * 1000,\r\n  /** 5 minutes = 300000 ms */\r\n  FIVE_MINUTES: 5 * 60 * 1000,\r\n  /** 15 minutes = 900000 ms */\r\n  FIFTEEN_MINUTES: 15 * 60 * 1000,\r\n  /** 30 minutes = 1800000 ms */\r\n  THIRTY_MINUTES: 30 * 60 * 1000,\r\n  /** 1 hour = 3600000 ms */\r\n  HOUR: 60 * 60 * 1000,\r\n  /** 4 hours = 14400000 ms */\r\n  FOUR_HOURS: 4 * 60 * 60 * 1000,\r\n  /** 1 day = 86400000 ms */\r\n  DAY: 24 * 60 * 60 * 1000,\r\n  /** 1 week = 604800000 ms */\r\n  WEEK: 7 * 24 * 60 * 60 * 1000,\r\n} as const;\r\n\r\n// ============================================================================\r\n// TIMEZONE OFFSETS (UTC hours) - FIXED SESSIONS\r\n// These are standard forex market session times in UTC\r\n// ============================================================================\r\n\r\nexport const TIMEZONE_OFFSETS = {\r\n  /** Tokyo session opens at 00:00 UTC */\r\n  TOKYO_START: 0,\r\n  /** Tokyo session closes at 08:00 UTC */\r\n  TOKYO_END: 8,\r\n\r\n  /** London session opens at 08:00 UTC */\r\n  LONDON_START: 8,\r\n  /** London session closes at 16:00 UTC */\r\n  LONDON_END: 16,\r\n\r\n  /** New York session opens at 13:00 UTC */\r\n  NEW_YORK_START: 13,\r\n  /** New York session closes at 21:00 UTC */\r\n  NEW_YORK_END: 21,\r\n} as const;\r\n\r\n// ============================================================================\r\n// BASIC MATH OPERATIONS\r\n// ============================================================================\r\n\r\nexport const MATH_OPS = {\r\n  ZERO: 0,\r\n  ONE: 1,\r\n  NEGATIVE_ONE: -1,\r\n  TWO: 2,\r\n  THREE: 3,\r\n  FOUR: 4,\r\n  HALF: 0.5,\r\n} as const;\r\n\r\n// ============================================================================\r\n// PERCENTAGE BOUNDARIES (for calculations)\r\n// ============================================================================\r\n\r\nexport const PERCENTAGE_BOUNDS = {\r\n  /** Minimum value: 0% */\r\n  MINIMUM: 0,\r\n  /** Maximum value: 100% */\r\n  MAXIMUM: 100,\r\n  /** Half: 50% */\r\n  HALF: 50,\r\n  /** Quarter: 25% */\r\n  QUARTER: 25,\r\n  /** Tenth: 10% */\r\n  TENTH: 10,\r\n} as const;\r\n\r\n// ============================================================================\r\n// FIXED EXIT PERCENTAGES\r\n// ============================================================================\r\n\r\nexport const FIXED_EXIT_PERCENTAGES = {\r\n  /** Full position exit: 100% */\r\n  FULL: 100,\r\n  /** Half position exit: 50% */\r\n  HALF: 50,\r\n  /** Quarter position exit: 25% */\r\n  QUARTER: 25,\r\n  /** Tenth position exit: 10% */\r\n  TENTH: 10,\r\n} as const;\r\n\r\n// ============================================================================\r\n// DEFAULT ARRAY/LIST SIZES\r\n// ============================================================================\r\n\r\nexport const DEFAULT_SIZES = {\r\n  /** Empty array */\r\n  EMPTY: 0,\r\n  /** Single item */\r\n  SINGLE: 1,\r\n  /** Two items (common for pairs) */\r\n  PAIR: 2,\r\n  /** Four items (common for OHLC) */\r\n  FOUR: 4,\r\n} as const;\r\n\r\n// ============================================================================\r\n// SIGNAL CONSTANTS\r\n// ============================================================================\r\n\r\nexport const SIGNAL_CONSTANTS = {\r\n  /** Minimum consecutive signals required for confirmation */\r\n  MIN_CONSECUTIVE_SIGNALS: 2,\r\n  /** Maximum consecutive signals to track before reset */\r\n  MAX_CONSECUTIVE_SIGNALS: 3,\r\n} as const;\r\n\r\n// ============================================================================\r\n// ORDERBOOK CONSTANTS\r\n// ============================================================================\r\n\r\nexport const ORDERBOOK_CONSTANTS = {\r\n  /** Default orderbook depth (number of levels) */\r\n  DEFAULT_DEPTH: 20,\r\n  /** Minimum bid/ask spread percentage for validation */\r\n  MIN_SPREAD_PERCENT: 0.01,\r\n} as const;\r\n\r\n// ============================================================================\r\n// CONFIDENCE SCORE BOUNDS (for calculations)\r\n// ============================================================================\r\n\r\nexport const CONFIDENCE_BOUNDS = {\r\n  /** Minimum confidence score */\r\n  MINIMUM: 0,\r\n  /** Maximum confidence score */\r\n  MAXIMUM: 100,\r\n} as const;\r\n\r\n// ============================================================================\r\n// WALLTRACKER CONSTANTS\r\n// ============================================================================\r\n\r\nexport const WALLTRACKER_CONSTANTS = {\r\n  /** Minimum wall confidence multiplier */\r\n  MIN_CONFIDENCE_MULTIPLIER: 0.9,\r\n  /** Maximum wall confidence multiplier */\r\n  MAX_CONFIDENCE_MULTIPLIER: 1.1,\r\n} as const;\r\n\r\n// ============================================================================\r\n// EXPORT ALL CONSTANTS AS DEFAULT\r\n// ============================================================================\r\n\r\n\r\n// ============================================================================\r\n// SESSION-BASED SL MULTIPLIERS\r\n// ============================================================================\r\n\r\nexport const SESSION_SL_MULTIPLIERS = {\r\n  ASIAN: 1.0,\r\n  LONDON: 1.5,\r\n  NEW_YORK: 1.5,\r\n  OVERLAP: 1.8,\r\n} as const;\r\n\r\n// ============================================================================\r\n// RISK THRESHOLDS (TP/SL percentages)\r\n// ============================================================================\r\n\r\nexport const RISK_THRESHOLDS = {\r\n  TP_SCALP: 0.15,\r\n  TP_AGGRESSIVE: 0.25,\r\n  TP_STANDARD: 0.4,\r\n  TP_CONSERVATIVE: 0.6,\r\n\r\n  SL_TIGHT: 0.5,\r\n  SL_STANDARD: 1.0,\r\n  SL_MODERATE: 1.2,\r\n  SL_CONSERVATIVE: 1.5,\r\n} as const;\r\n\r\n// ============================================================================\r\n// CONFIDENCE WEIGHTS\r\n// ============================================================================\r\n\r\nexport const CONFIDENCE_WEIGHTS = {\r\n  LOW: 0.3,\r\n  MODERATE: 0.5,\r\n  HIGH: 0.8,\r\n  VERY_HIGH: 0.9,\r\n} as const;\r\n\r\n// ============================================================================\r\n// TECHNICAL CONSTANTS (pure math/time values - never change)\r\n// ============================================================================\r\n\r\nexport {\r\n  PERCENT_MULTIPLIER,\r\n  PERCENT_DECIMAL_PLACES,\r\n  DECIMAL_PLACES,\r\n  TIME_MULTIPLIERS,\r\n  RATIO_MULTIPLIERS,\r\n  ARRAY_SIZING,\r\n  FIRST_INDEX,\r\n  SECOND_INDEX,\r\n  THIRD_INDEX,\r\n  INVALID_INDEX,\r\n  INVALID_TIMEFRAME,\r\n  MATH_BOUNDS,\r\n  roundToDecimalPlaces,\r\n  roundPrice,\r\n  roundPercent,\r\n  roundRSI,\r\n} from './technical.constants';\r\n\r\n// ============================================================================\r\n// ANALYZER-SPECIFIC CONSTANTS (imported from analyzer-constants.ts)\r\n// ============================================================================\r\n\r\nexport {\r\n  BTC_ANALYZER_CONSTANTS,\r\n  CHART_PATTERN_CONSTANTS,\r\n  BREAKOUT_CONSTANTS,\r\n  CONTEXT_ANALYZER_CONSTANTS,\r\n  CORRELATION_CONSTANTS,\r\n  SUPPORT_RESISTANCE_CONSTANTS,\r\n  VOLUME_ANALYSIS_CONSTANTS,\r\n} from './analyzer-constants';\r\n\r\nexport { MULTIPLIERS, PERCENTAGE_THRESHOLDS, CONFIDENCE_THRESHOLDS } from './strategy-constants';\r\n\r\nexport default {\r\n  PERCENT_MULTIPLIER: PM,\r\n  PERCENT_DECIMAL_PLACES: PDP,\r\n  DECIMAL_PLACES: DP,\r\n  TIME_MULTIPLIERS: TM,\r\n  TIME_UNITS,\r\n  TIMEZONE_OFFSETS,\r\n  RATIO_MULTIPLIERS: RM,\r\n  MATH_OPS,\r\n  PERCENTAGE_BOUNDS,\r\n  FIXED_EXIT_PERCENTAGES,\r\n  DEFAULT_SIZES,\r\n  SIGNAL_CONSTANTS,\r\n  ORDERBOOK_CONSTANTS,\r\n  CONFIDENCE_BOUNDS,\r\n  WALLTRACKER_CONSTANTS,\r\n  ARRAY_SIZING: AS,\r\n  MATH_BOUNDS: MB,\r\n\r\n  SESSION_SL_MULTIPLIERS,\r\n  RISK_THRESHOLDS,\r\n  CONFIDENCE_WEIGHTS,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\constants\\strategy-constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\constants\\technical.constants.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":130,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":130,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Technical Constants\r\n *\r\n * Pure mathematical and technical values that never change.\r\n * These are implementation details, not configurable parameters.\r\n * Do NOT add trading strategy parameters here - use config.json instead.\r\n */\r\n\r\n// ============================================================================\r\n// DECIMAL PLACES & PRECISION\r\n// ============================================================================\r\n\r\nexport const DECIMAL_PLACES = {\r\n  /** Price decimal places for display/rounding (e.g., BTCUSDT: 0.01) */\r\n  PRICE: 4,\r\n  /** Quantity decimal places (e.g., 0.50 BTC) */\r\n  QUANTITY: 2,\r\n  /** Percentage display decimal places (e.g., 12.34%) */\r\n  PERCENT: 2,\r\n  /** RSI/Stochastic decimal places (e.g., 45.67) */\r\n  RSI: 2,\r\n  /** ATR decimal places (e.g., 123.45) */\r\n  ATR: 2,\r\n  /** EMA distance percentage (e.g., 0.15%) */\r\n  EMA_DISTANCE: 2,\r\n  /** Ratio/multiplier decimal places */\r\n  RATIO: 4,\r\n} as const;\r\n\r\n// ============================================================================\r\n// TIME CONVERSIONS & PERIODS\r\n// ============================================================================\r\n\r\nexport const TIME_MULTIPLIERS = {\r\n  /** 1000 milliseconds = 1 second */\r\n  MILLISECONDS_PER_SECOND: 1000,\r\n  /** 60 seconds = 1 minute */\r\n  SECONDS_PER_MINUTE: 60,\r\n  /** 60 minutes = 1 hour */\r\n  MINUTES_PER_HOUR: 60,\r\n  /** 24 hours = 1 day */\r\n  HOURS_PER_DAY: 24,\r\n} as const;\r\n\r\n// ============================================================================\r\n// RATIO & MULTIPLIER CONSTANTS\r\n// ============================================================================\r\n\r\nexport const RATIO_MULTIPLIERS = {\r\n  /** 0.25 = 25% or 1:4 ratio */\r\n  QUARTER: 0.25,\r\n  /** 0.5 = 50% or 1:2 ratio (half) */\r\n  HALF: 0.5,\r\n  /** 0.75 = 75% or 3:4 ratio */\r\n  THREE_QUARTER: 0.75,\r\n  /** 1.0 = 100% or full value */\r\n  FULL: 1.0,\r\n  /** 1.1 = 10% increase */\r\n  PLUS_10_PERCENT: 1.1,\r\n  /** 1.2 = 20% increase */\r\n  PLUS_20_PERCENT: 1.2,\r\n  /** 1.5 = 50% increase */\r\n  PLUS_50_PERCENT: 1.5,\r\n} as const;\r\n\r\n// ============================================================================\r\n// PERCENTAGE CONVERSION\r\n// ============================================================================\r\n\r\n/** Convert decimal (0.5) to percentage (50) */\r\nexport const PERCENT_MULTIPLIER = 100;\r\n\r\n/** Decimal places for percent display (2 = 50.12%) */\r\nexport const PERCENT_DECIMAL_PLACES = 2;\r\n\r\n// ============================================================================\r\n// ARRAY & LOOP PARTITIONING\r\n// ============================================================================\r\n\r\nexport const ARRAY_SIZING = {\r\n  /** Split into 3 equal parts (e.g., 3 TP levels) */\r\n  THREE_WAY_SPLIT: 3,\r\n  /** Split into 4 quarters (e.g., 4 size buckets) */\r\n  FOUR_WAY_SPLIT: 4,\r\n  /** Split into 5 parts (e.g., 5 volume buckets) */\r\n  FIVE_WAY_SPLIT: 5,\r\n  /** Split into 6 parts (e.g., 6 timeframes) */\r\n  SIX_WAY_SPLIT: 6,\r\n} as const;\r\n\r\n// ============================================================================\r\n// ARRAY INDEXING & SELECTION\r\n// ============================================================================\r\n\r\n/** Index for getting first element */\r\nexport const FIRST_INDEX = 0;\r\n/** Index for getting second element */\r\nexport const SECOND_INDEX = 1;\r\n/** Index for getting third element */\r\nexport const THIRD_INDEX = 2;\r\n\r\n// ============================================================================\r\n// INVALID/ERROR MARKERS\r\n// ============================================================================\r\n\r\n/** Standard \"not found\" or \"invalid\" index marker */\r\nexport const INVALID_INDEX = -1;\r\n/** Secondary invalid marker for specific edge cases */\r\nexport const INVALID_TIMEFRAME = -2;\r\n\r\n// ============================================================================\r\n// MATHEMATICAL BOUNDARIES\r\n// ============================================================================\r\n\r\nexport const MATH_BOUNDS = {\r\n  /** Minimum safe positive value */\r\n  MIN_SAFE_POSITIVE: 0.00001,\r\n  /** Maximum percentage value (100%) */\r\n  MAX_PERCENTAGE: 100,\r\n  /** Minimum percentage value (0%) */\r\n  MIN_PERCENTAGE: 0,\r\n} as const;\r\n\r\n// ============================================================================\r\n// ROUNDING & PRECISION HELPERS\r\n// ============================================================================\r\n\r\n/** Helper to round to N decimal places */\r\nexport const roundToDecimalPlaces = (value: number, places: number): number => {\r\n  const multiplier = Math.pow(10, places);\r\n  return Math.round(value * multiplier) / multiplier;\r\n};\r\n\r\n/** Helper to round price to PRICE decimal places */\r\nexport const roundPrice = (value: number): number => {\r\n  return roundToDecimalPlaces(value, DECIMAL_PLACES.PRICE);\r\n};\r\n\r\n/** Helper to round percentage to PERCENT decimal places */\r\nexport const roundPercent = (value: number): number => {\r\n  return roundToDecimalPlaces(value, DECIMAL_PLACES.PERCENT);\r\n};\r\n\r\n/** Helper to round RSI/Stochastic to RSI decimal places */\r\nexport const roundRSI = (value: number): number => {\r\n  return roundToDecimalPlaces(value, DECIMAL_PLACES.RSI);\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\atr.indicator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MULTIPLIERS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MULTIPLIERS } from '../constants';\r\n/**\r\n * ATR Indicator (Average True Range)\r\n * Measures market volatility\r\n *\r\n * Formula:\r\n * 1. True Range (TR) = max of:\r\n *    - High - Low\r\n *    - |High - Previous Close|\r\n *    - |Low - Previous Close|\r\n * 2. ATR = EMA of TR over period (Wilder's smoothing)\r\n *\r\n * Returns: ATR value as percentage of current price\r\n * - Low volatility: < MULTIPLIERS.HALF%\r\n * - Normal volatility: MULTIPLIERS.HALF% - 2%\r\n * - High volatility: 2% - 5%\r\n * - Extreme volatility: > 5%\r\n *\r\n * Implementation: Wilder's smoothing (same as RSI)\r\n */\r\n\r\nimport { Candle } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PERCENT_MULTIPLIER = 100;\r\nconst MIN_CANDLES = 2; // Need at least 2 candles for TR calculation\r\n\r\n// ============================================================================\r\n// ATR CALCULATOR\r\n// ============================================================================\r\n\r\nexport class ATRIndicator {\r\n  private readonly period: number;\r\n  private atr: number = 0;\r\n  private initialized: boolean = false;\r\n\r\n  constructor(period: number) {\r\n    if (period < 1) {\r\n      throw new Error('ATR period must be at least 1');\r\n    }\r\n    this.period = period;\r\n  }\r\n\r\n  /**\r\n   * Calculate True Range for a single candle\r\n   *\r\n   * @param current - Current candle\r\n   * @param previous - Previous candle\r\n   * @returns True Range value\r\n   */\r\n  private calculateTrueRange(current: Candle, previous: Candle): number {\r\n    const highLow = current.high - current.low;\r\n    const highClose = Math.abs(current.high - previous.close);\r\n    const lowClose = Math.abs(current.low - previous.close);\r\n\r\n    return Math.max(highLow, highClose, lowClose);\r\n  }\r\n\r\n  /**\r\n   * Calculate ATR for a series of candles\r\n   *\r\n   * @param candles - Array of candles (must be at least period + 1 length)\r\n   * @returns ATR value as percentage of current price\r\n   * @throws {Error} If not enough candles\r\n   */\r\n  calculate(candles: Candle[]): number {\r\n    if (candles.length < this.period + 1) {\r\n      throw new Error(\r\n        `Not enough candles for ATR calculation. Need ${this.period + 1}, got ${candles.length}`,\r\n      );\r\n    }\r\n\r\n    // Reset state\r\n    this.initialized = false;\r\n\r\n    // Calculate True Range for each candle\r\n    const trueRanges: number[] = [];\r\n    for (let i = 1; i < candles.length; i++) {\r\n      const tr = this.calculateTrueRange(candles[i], candles[i - 1]);\r\n      trueRanges.push(tr);\r\n    }\r\n\r\n    // Initial ATR (simple average for first period)\r\n    let sumTR = 0;\r\n    for (let i = 0; i < this.period; i++) {\r\n      sumTR += trueRanges[i];\r\n    }\r\n    this.atr = sumTR / this.period;\r\n    this.initialized = true;\r\n\r\n    // Wilder's smoothing for remaining periods\r\n    for (let i = this.period; i < trueRanges.length; i++) {\r\n      this.atr = (this.atr * (this.period - 1) + trueRanges[i]) / this.period;\r\n    }\r\n\r\n    // Convert to percentage of current price\r\n    const currentPrice = candles[candles.length - 1].close;\r\n    const atrPercent = (this.atr / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n    return atrPercent;\r\n  }\r\n\r\n  /**\r\n   * Update ATR with a new candle (incremental calculation)\r\n   *\r\n   * @param newCandle - New candle\r\n   * @param previousCandle - Previous candle\r\n   * @returns Updated ATR value as percentage\r\n   * @throws {Error} If not initialized\r\n   */\r\n  update(newCandle: Candle, previousCandle: Candle): number {\r\n    if (!this.initialized) {\r\n      throw new Error('ATR not initialized. Call calculate() first.');\r\n    }\r\n\r\n    // Calculate new True Range\r\n    const tr = this.calculateTrueRange(newCandle, previousCandle);\r\n\r\n    // Wilder's smoothing\r\n    this.atr = (this.atr * (this.period - 1) + tr) / this.period;\r\n\r\n    // Convert to percentage of current price\r\n    const atrPercent = (this.atr / newCandle.close) * PERCENT_MULTIPLIER;\r\n\r\n    return atrPercent;\r\n  }\r\n\r\n  /**\r\n   * Get current ATR value (must be initialized)\r\n   *\r\n   * @returns ATR value\r\n   * @throws {Error} If not initialized\r\n   */\r\n  getValue(): number {\r\n    if (!this.initialized) {\r\n      throw new Error('ATR not initialized. Call calculate() first.');\r\n    }\r\n    return this.atr;\r\n  }\r\n\r\n  /**\r\n   * Check if ATR is initialized\r\n   */\r\n  isInitialized(): boolean {\r\n    return this.initialized;\r\n  }\r\n\r\n  /**\r\n   * Reset ATR state\r\n   */\r\n  reset(): void {\r\n    this.atr = 0;\r\n    this.initialized = false;\r\n  }\r\n\r\n  /**\r\n   * Get current state (for serialization/debugging)\r\n   */\r\n  getState(): { period: number; atr: number; initialized: boolean } {\r\n    return {\r\n      period: this.period,\r\n      atr: this.atr,\r\n      initialized: this.initialized,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\bollinger.indicator.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":164,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":247,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":247,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.85.","line":258,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":258,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":269,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":269,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.7.","line":269,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":269,"endColumn":44}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Bollinger Bands Indicator\r\n * Measures volatility and potential reversal zones\r\n *\r\n * Formula:\r\n * 1. Middle Band = SMA(close, period)\r\n * 2. Upper Band = Middle + (stdDev √ó Standard Deviation)\r\n * 3. Lower Band = Middle - (stdDev √ó Standard Deviation)\r\n * 4. Width % = ((Upper - Lower) / Middle) √ó 100\r\n * 5. %B = (Price - Lower) / (Upper - Lower)\r\n *\r\n * Usage:\r\n * - Price near lower band (< 0.15%B): Potential long entry\r\n * - Price near upper band (> 0.85%B): Potential short entry\r\n * - Squeeze (narrow bands): Low volatility, expect breakout\r\n * - Width expansion: High volatility, strong move\r\n */\r\n\r\nimport { Candle } from '../types';\r\nimport { MULTIPLIERS, PERCENTAGE_THRESHOLDS } from '../constants';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_PERIOD = PERCENTAGE_THRESHOLDS.LOW_MODERATE;\r\nconst DEFAULT_STD_DEV = 2.0;\r\nconst MAX_HISTORY_LENGTH = 100;\r\nconst PERCENT_MULTIPLIER = 100;\r\nconst PERCENT_B_MIN = 0;\r\nconst PERCENT_B_MAX = 1;\r\n\r\n// Volatility thresholds for adaptive parameters\r\nconst HIGH_VOLATILITY_THRESHOLD = 0.05; // 5% ATR/price ratio\r\nconst MEDIUM_VOLATILITY_THRESHOLD = 0.03; // 3% ATR/price ratio\r\n\r\n// Adaptive stdDev values\r\nconst HIGH_VOLATILITY_STD_DEV = 2.5;\r\nconst MEDIUM_VOLATILITY_STD_DEV = 2.0;\r\nconst LOW_VOLATILITY_STD_DEV = 1.5;\r\n\r\n// Squeeze detection\r\nconst DEFAULT_SQUEEZE_THRESHOLD = MULTIPLIERS.ZERO_EIGHT; // 80% of average width\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface BollingerBandsResult {\r\n  upper: number; // Upper band\r\n  middle: number; // Middle band (SMA)\r\n  lower: number; // Lower band\r\n  width: number; // Width in percent\r\n  percentB: number; // Price position (0.0 - 1.0)\r\n}\r\n\r\nexport interface BollingerBandsHistory {\r\n  timestamp: number;\r\n  upper: number;\r\n  middle: number;\r\n  lower: number;\r\n  width: number;\r\n}\r\n\r\nexport interface AdaptiveParams {\r\n  period: number;\r\n  stdDev: number;\r\n}\r\n\r\n// ============================================================================\r\n// BOLLINGER BANDS CALCULATOR\r\n// ============================================================================\r\n\r\nexport class BollingerBandsIndicator {\r\n  private period: number;\r\n  private stdDev: number;\r\n  private history: BollingerBandsHistory[] = [];\r\n\r\n  /**\r\n   * Create Bollinger Bands indicator\r\n   *\r\n   * @param period - SMA period (default: 20)\r\n   * @param stdDev - Standard deviation multiplier (default: 2.0)\r\n   */\r\n  constructor(period: number = DEFAULT_PERIOD, stdDev: number = DEFAULT_STD_DEV) {\r\n    this.period = period;\r\n    this.stdDev = stdDev;\r\n  }\r\n\r\n  /**\r\n   * Calculate Bollinger Bands for a series of candles\r\n   *\r\n   * @param candles - Array of candles (must be at least period length)\r\n   * @returns Bollinger Bands result\r\n   * @throws {Error} If not enough candles\r\n   */\r\n  calculate(candles: Candle[]): BollingerBandsResult {\r\n    if (candles.length < this.period) {\r\n      throw new Error(\r\n        `Not enough candles for Bollinger Bands calculation. Need ${this.period}, got ${candles.length}`,\r\n      );\r\n    }\r\n\r\n    // Get last N candles for calculation\r\n    const recentCandles = candles.slice(-this.period);\r\n    const closePrices = recentCandles.map((c) => c.close);\r\n    const currentPrice = closePrices[closePrices.length - 1];\r\n\r\n    // Calculate SMA (middle band)\r\n    const middle = this.calculateSMA(closePrices);\r\n\r\n    // Calculate standard deviation\r\n    const stdDeviation = this.calculateStdDev(closePrices, middle);\r\n\r\n    // Calculate bands\r\n    const upper = middle + this.stdDev * stdDeviation;\r\n    const lower = middle - this.stdDev * stdDeviation;\r\n\r\n    // Calculate width percentage\r\n    const width = ((upper - lower) / middle) * PERCENT_MULTIPLIER;\r\n\r\n    // Calculate %B (price position)\r\n    let percentB: number;\r\n    if (upper === lower) {\r\n      // No volatility, price is at middle\r\n      percentB = MULTIPLIERS.HALF;\r\n    } else {\r\n      percentB = (currentPrice - lower) / (upper - lower);\r\n      percentB = Math.max(PERCENT_B_MIN, Math.min(PERCENT_B_MAX, percentB));\r\n    }\r\n\r\n    // Store in history\r\n    const timestamp = candles[candles.length - 1].timestamp;\r\n    this.addToHistory({ timestamp, upper, middle, lower, width });\r\n\r\n    return {\r\n      upper,\r\n      middle,\r\n      lower,\r\n      width,\r\n      percentB,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Simple Moving Average\r\n   *\r\n   * @param values - Array of values\r\n   * @returns SMA\r\n   */\r\n  private calculateSMA(values: number[]): number {\r\n    const sum = values.reduce((acc, val) => acc + val, 0);\r\n    return sum / values.length;\r\n  }\r\n\r\n  /**\r\n   * Calculate Standard Deviation\r\n   *\r\n   * @param values - Array of values\r\n   * @param mean - Mean (average) of values\r\n   * @returns Standard deviation\r\n   */\r\n  private calculateStdDev(values: number[], mean: number): number {\r\n    const squaredDiffs = values.map((val) => Math.pow(val - mean, 2));\r\n    const variance = this.calculateSMA(squaredDiffs);\r\n    return Math.sqrt(variance);\r\n  }\r\n\r\n  /**\r\n   * Add entry to history (limited to MAX_HISTORY_LENGTH)\r\n   *\r\n   * @param entry - History entry\r\n   */\r\n  private addToHistory(entry: BollingerBandsHistory): void {\r\n    this.history.push(entry);\r\n\r\n    // Trim history if too long\r\n    if (this.history.length > MAX_HISTORY_LENGTH) {\r\n      this.history.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect Bollinger Squeeze\r\n   * Squeeze occurs when bands are narrower than average (low volatility)\r\n   *\r\n   * @param threshold - Squeeze threshold (default: MULTIPLIERS.ZERO_EIGHT = 80% of average)\r\n   * @returns True if squeeze detected\r\n   */\r\n  isSqueeze(threshold: number = DEFAULT_SQUEEZE_THRESHOLD): boolean {\r\n    if (this.history.length < DEFAULT_PERIOD) {\r\n      return false; // Not enough history\r\n    }\r\n\r\n    // Calculate average width over last N periods\r\n    const recentWidths = this.history.slice(-DEFAULT_PERIOD).map((h) => h.width);\r\n    const avgWidth = this.calculateSMA(recentWidths);\r\n\r\n    // Current width\r\n    const currentWidth = this.history[this.history.length - 1].width;\r\n\r\n    // Squeeze: current width < threshold * average width\r\n    return currentWidth < avgWidth * threshold;\r\n  }\r\n\r\n  /**\r\n   * Get adaptive parameters based on market volatility\r\n   * High volatility ‚Üí wider bands (stdDev 2.5)\r\n   * Medium volatility ‚Üí normal bands (stdDev 2.0)\r\n   * Low volatility ‚Üí tighter bands (stdDev 1.5)\r\n   *\r\n   * @param atr - Average True Range\r\n   * @param price - Current price\r\n   * @returns Adaptive parameters\r\n   */\r\n  getAdaptiveParams(atr: number, price: number): AdaptiveParams {\r\n    const volatility = atr / price;\r\n\r\n    if (volatility > HIGH_VOLATILITY_THRESHOLD) {\r\n      return { period: DEFAULT_PERIOD, stdDev: HIGH_VOLATILITY_STD_DEV };\r\n    }\r\n\r\n    if (volatility > MEDIUM_VOLATILITY_THRESHOLD) {\r\n      return { period: DEFAULT_PERIOD, stdDev: MEDIUM_VOLATILITY_STD_DEV };\r\n    }\r\n\r\n    return { period: DEFAULT_PERIOD, stdDev: LOW_VOLATILITY_STD_DEV };\r\n  }\r\n\r\n  /**\r\n   * Apply adaptive parameters to indicator\r\n   *\r\n   * @param params - Adaptive parameters\r\n   */\r\n  applyAdaptiveParams(params: AdaptiveParams): void {\r\n    this.period = params.period;\r\n    this.stdDev = params.stdDev;\r\n  }\r\n\r\n  /**\r\n   * Check if price is near lower band (potential long entry)\r\n   *\r\n   * @param percentB - Current %B value\r\n   * @param threshold - Threshold for \"near\" (default: PERCENTAGE_THRESHOLDS.VERY_LOW = 15%)\r\n   * @returns True if near lower band\r\n   */\r\n  isNearLowerBand(percentB: number, threshold: number = 0.15): boolean {\r\n    return percentB <= threshold;\r\n  }\r\n\r\n  /**\r\n   * Check if price is near upper band (potential short entry)\r\n   *\r\n   * @param percentB - Current %B value\r\n   * @param threshold - Threshold for \"near\" (default: 0.85 = 85%)\r\n   * @returns True if near upper band\r\n   */\r\n  isNearUpperBand(percentB: number, threshold: number = 0.85): boolean {\r\n    return percentB >= threshold;\r\n  }\r\n\r\n  /**\r\n   * Check if price is in middle zone (avoid trading)\r\n   *\r\n   * @param percentB - Current %B value\r\n   * @returns True if in middle zone (0.3 - 0.7)\r\n   */\r\n  isInMiddleZone(percentB: number): boolean {\r\n    return percentB > 0.3 && percentB < 0.7;\r\n  }\r\n\r\n  /**\r\n   * Get history\r\n   *\r\n   * @param length - Number of history entries (optional, default: all)\r\n   * @returns Array of history entries\r\n   */\r\n  getHistory(length?: number): BollingerBandsHistory[] {\r\n    if (length === undefined) {\r\n      return [...this.history];\r\n    }\r\n    return this.history.slice(-length);\r\n  }\r\n\r\n  /**\r\n   * Get current parameters\r\n   *\r\n   * @returns Current period and stdDev\r\n   */\r\n  getParams(): { period: number; stdDev: number } {\r\n    return {\r\n      period: this.period,\r\n      stdDev: this.stdDev,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset indicator state\r\n   */\r\n  reset(): void {\r\n    this.history = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\ema.indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\rsi.indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\stochastic.indicator.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":49,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":49,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":49,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":49,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":49,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":49,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":63,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":63,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":178,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":178,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":192,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":192,"endColumn":35}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Stochastic Oscillator Indicator\r\n * Measures momentum by comparing closing price to price range over a period\r\n *\r\n * Formula:\r\n * 1. %K = 100 * (Close - Lowest Low) / (Highest High - Lowest Low)\r\n * 2. %D = SMA of %K over smoothing period\r\n *\r\n * Range: 0-100\r\n * - Above 80: Overbought\r\n * - Below 20: Oversold\r\n *\r\n * Common settings:\r\n * - K period: 14 (lookback period)\r\n * - D period: 3 (smoothing period for %D)\r\n * - Smooth: 3 (smooth %K before calculating %D)\r\n */\r\n\r\nimport { Candle, CONFIDENCE_THRESHOLDS, PERCENTAGE_THRESHOLDS } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst STOCH_MIN = 0;\r\nconst STOCH_MAX = 100;\r\nconst STOCH_OVERBOUGHT = 80;\r\nconst STOCH_OVERSOLD = PERCENTAGE_THRESHOLDS.LOW_MODERATE;\r\nconst PERCENT_MULTIPLIER = 100;\r\nconst ZERO_RANGE_FALLBACK = CONFIDENCE_THRESHOLDS.MODERATE; // If high === low, return neutral value\r\n\r\n// ============================================================================\r\n// STOCHASTIC CALCULATOR\r\n// ============================================================================\r\n\r\nexport class StochasticIndicator {\r\n  private readonly kPeriod: number;\r\n  private readonly dPeriod: number;\r\n  private readonly smooth: number;\r\n  private kHistory: number[] = [];\r\n\r\n  /**\r\n   * Create Stochastic Oscillator indicator\r\n   *\r\n   * @param kPeriod - Lookback period for %K (default: 14)\r\n   * @param dPeriod - Smoothing period for %D (default: 3)\r\n   * @param smooth - Smoothing for %K before %D (default: 3)\r\n   */\r\n  constructor(kPeriod: number = 14, dPeriod: number = 3, smooth: number = 3) {\r\n    this.kPeriod = kPeriod;\r\n    this.dPeriod = dPeriod;\r\n    this.smooth = smooth;\r\n  }\r\n\r\n  /**\r\n   * Calculate Stochastic for a series of candles\r\n   *\r\n   * @param candles - Array of candles (must be at least kPeriod length)\r\n   * @returns Object with %K and %D values\r\n   * @throws {Error} If not enough candles\r\n   */\r\n  calculate(candles: Candle[]): { k: number; d: number } {\r\n    const minCandles = this.kPeriod + this.smooth + this.dPeriod - 2;\r\n    if (candles.length < minCandles) {\r\n      throw new Error(\r\n        `Not enough candles for Stochastic calculation. Need ${minCandles}, got ${candles.length}`,\r\n      );\r\n    }\r\n\r\n    // Reset history\r\n    this.kHistory = [];\r\n\r\n    // Calculate %K for all periods\r\n    const rawKValues: number[] = [];\r\n    for (let i = this.kPeriod - 1; i < candles.length; i++) {\r\n      const slice = candles.slice(i - this.kPeriod + 1, i + 1);\r\n      const rawK = this.calculateRawK(slice);\r\n      rawKValues.push(rawK);\r\n    }\r\n\r\n    // Smooth %K if smooth > 1\r\n    const smoothedKValues: number[] = [];\r\n    for (let i = this.smooth - 1; i < rawKValues.length; i++) {\r\n      const slice = rawKValues.slice(i - this.smooth + 1, i + 1);\r\n      const smoothedK = this.calculateSMA(slice);\r\n      smoothedKValues.push(smoothedK);\r\n      this.kHistory.push(smoothedK);\r\n    }\r\n\r\n    // Calculate %D (SMA of smoothed %K)\r\n    const currentK = smoothedKValues[smoothedKValues.length - 1];\r\n    let currentD: number;\r\n\r\n    if (smoothedKValues.length < this.dPeriod) {\r\n      // Not enough data for %D yet, return current %K as %D\r\n      currentD = currentK;\r\n    } else {\r\n      const dSlice = smoothedKValues.slice(-this.dPeriod);\r\n      currentD = this.calculateSMA(dSlice);\r\n    }\r\n\r\n    return {\r\n      k: this.clamp(currentK),\r\n      d: this.clamp(currentD),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate raw %K for a period\r\n   *\r\n   * @param candles - Candles for this period (kPeriod length)\r\n   * @returns Raw %K value (0-100)\r\n   */\r\n  private calculateRawK(candles: Candle[]): number {\r\n    const currentClose = candles[candles.length - 1].close;\r\n    const lowestLow = Math.min(...candles.map((c) => c.low));\r\n    const highestHigh = Math.max(...candles.map((c) => c.high));\r\n\r\n    // Handle edge case: no price movement\r\n    if (highestHigh === lowestLow) {\r\n      return ZERO_RANGE_FALLBACK;\r\n    }\r\n\r\n    const k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * PERCENT_MULTIPLIER;\r\n    return k;\r\n  }\r\n\r\n  /**\r\n   * Calculate Simple Moving Average\r\n   *\r\n   * @param values - Array of values\r\n   * @returns SMA\r\n   */\r\n  private calculateSMA(values: number[]): number {\r\n    const sum = values.reduce((acc, val) => acc + val, 0);\r\n    return sum / values.length;\r\n  }\r\n\r\n  /**\r\n   * Clamp value to valid range [0, 100]\r\n   *\r\n   * @param value - Value to clamp\r\n   * @returns Clamped value\r\n   */\r\n  private clamp(value: number): number {\r\n    return Math.max(STOCH_MIN, Math.min(STOCH_MAX, value));\r\n  }\r\n\r\n  /**\r\n   * Check if Stochastic is in oversold zone\r\n   *\r\n   * @param k - Current %K value\r\n   * @returns True if oversold (< 20)\r\n   */\r\n  isOversold(k: number): boolean {\r\n    return k < STOCH_OVERSOLD;\r\n  }\r\n\r\n  /**\r\n   * Check if Stochastic is in overbought zone\r\n   *\r\n   * @param k - Current %K value\r\n   * @returns True if overbought (> 80)\r\n   */\r\n  isOverbought(k: number): boolean {\r\n    return k > STOCH_OVERBOUGHT;\r\n  }\r\n\r\n  /**\r\n   * Detect bullish divergence with RSI\r\n   * Both RSI and Stochastic should be oversold for strong signal\r\n   *\r\n   * @param k - Current Stochastic %K\r\n   * @param rsi - Current RSI value\r\n   * @returns True if both confirm oversold\r\n   */\r\n  confirmOversoldWithRSI(k: number, rsi: number): boolean {\r\n    const rsiOversold = rsi < 30;\r\n    const stochOversold = this.isOversold(k);\r\n    return rsiOversold && stochOversold;\r\n  }\r\n\r\n  /**\r\n   * Detect bearish divergence with RSI\r\n   * Both RSI and Stochastic should be overbought for strong signal\r\n   *\r\n   * @param k - Current Stochastic %K\r\n   * @param rsi - Current RSI value\r\n   * @returns True if both confirm overbought\r\n   */\r\n  confirmOverboughtWithRSI(k: number, rsi: number): boolean {\r\n    const rsiOverbought = rsi > 70;\r\n    const stochOverbought = this.isOverbought(k);\r\n    return rsiOverbought && stochOverbought;\r\n  }\r\n\r\n  /**\r\n   * Detect %K and %D crossover\r\n   * Bullish: %K crosses above %D in oversold zone\r\n   * Bearish: %K crosses below %D in overbought zone\r\n   *\r\n   * @param currentK - Current %K\r\n   * @param currentD - Current %D\r\n   * @param previousK - Previous %K\r\n   * @param previousD - Previous %D\r\n   * @returns 'BULLISH', 'BEARISH', or 'NONE'\r\n   */\r\n  detectCrossover(\r\n    currentK: number,\r\n    currentD: number,\r\n    previousK: number,\r\n    previousD: number,\r\n  ): 'BULLISH' | 'BEARISH' | 'NONE' {\r\n    // Bullish crossover: %K crosses above %D\r\n    if (previousK <= previousD && currentK > currentD) {\r\n      return 'BULLISH';\r\n    }\r\n\r\n    // Bearish crossover: %K crosses below %D\r\n    if (previousK >= previousD && currentK < currentD) {\r\n      return 'BEARISH';\r\n    }\r\n\r\n    return 'NONE';\r\n  }\r\n\r\n  /**\r\n   * Get %K history (for %D calculation or analysis)\r\n   *\r\n   * @returns Array of %K values\r\n   */\r\n  getKHistory(): number[] {\r\n    return [...this.kHistory];\r\n  }\r\n\r\n  /**\r\n   * Reset indicator state\r\n   */\r\n  reset(): void {\r\n    this.kHistory = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\vwap.indicator.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.0001.","line":80,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":80,"endColumn":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * VWAP Indicator (Volume Weighted Average Price)\r\n *\r\n * VWAP is the average price weighted by volume.\r\n * Used by institutional traders as a benchmark.\r\n *\r\n * Formula:\r\n * VWAP = Œ£(Typical Price √ó Volume) / Œ£(Volume)\r\n * where Typical Price = (High + Low + Close) / 3\r\n *\r\n * Interpretation:\r\n * - Price > VWAP = Bullish (buyers in control)\r\n * - Price < VWAP = Bearish (sellers in control)\r\n * - Institutional traders aim to buy below VWAP, sell above VWAP\r\n *\r\n * Use Cases:\r\n * - Senior timeframe filter (M5, M30)\r\n * - Trend confirmation\r\n * - Entry timing (buy when price dips to VWAP in uptrend)\r\n */\r\n\r\nimport { Candle } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_CANDLES = 1;\r\nconst TYPICAL_PRICE_DIVISOR = 3;\r\n\r\n// ============================================================================\r\n// VWAP CALCULATOR\r\n// ============================================================================\r\n\r\nexport class VWAPIndicator {\r\n  /**\r\n   * Calculate VWAP from candles\r\n   *\r\n   * @param candles - Array of candles (ordered by timestamp)\r\n   * @returns VWAP value, or 0 if no volume\r\n   */\r\n  calculate(candles: Candle[]): number {\r\n    if (candles.length < MIN_CANDLES) {\r\n      return 0;\r\n    }\r\n\r\n    let sumPriceVolume = 0;\r\n    let sumVolume = 0;\r\n\r\n    for (const candle of candles) {\r\n      const typicalPrice =\r\n        (candle.high + candle.low + candle.close) / TYPICAL_PRICE_DIVISOR;\r\n      sumPriceVolume += typicalPrice * candle.volume;\r\n      sumVolume += candle.volume;\r\n    }\r\n\r\n    return sumVolume > 0 ? sumPriceVolume / sumVolume : 0;\r\n  }\r\n\r\n  /**\r\n   * Calculate VWAP and determine position relative to price\r\n   *\r\n   * @param candles - Array of candles\r\n   * @param currentPrice - Current market price\r\n   * @returns Object with VWAP value and position (above/below/at)\r\n   */\r\n  analyze(\r\n    candles: Candle[],\r\n    currentPrice: number,\r\n  ): {\r\n    vwap: number;\r\n    position: 'ABOVE' | 'BELOW' | 'AT';\r\n    distance: number;\r\n    distancePercent: number;\r\n  } {\r\n    const vwap = this.calculate(candles);\r\n\r\n    // Determine position\r\n    const threshold = vwap * 0.0001; // 0.01% threshold for \"AT\"\r\n    let position: 'ABOVE' | 'BELOW' | 'AT';\r\n\r\n    if (currentPrice > vwap + threshold) {\r\n      position = 'ABOVE';\r\n    } else if (currentPrice < vwap - threshold) {\r\n      position = 'BELOW';\r\n    } else {\r\n      position = 'AT';\r\n    }\r\n\r\n    // Distance from VWAP\r\n    const distance = currentPrice - vwap;\r\n    const distancePercent = vwap > 0 ? (distance / vwap) * PERCENT_MULTIPLIER : 0;\r\n\r\n    return {\r\n      vwap,\r\n      position,\r\n      distance,\r\n      distancePercent,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if price is aligned with VWAP for given direction\r\n   *\r\n   * @param candles - Array of candles\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Trade direction ('LONG' or 'SHORT')\r\n   * @returns true if aligned (LONG above VWAP, SHORT below VWAP)\r\n   */\r\n  isAligned(\r\n    candles: Candle[],\r\n    currentPrice: number,\r\n    direction: 'LONG' | 'SHORT',\r\n  ): boolean {\r\n    const { position } = this.analyze(candles, currentPrice);\r\n\r\n    if (direction === 'LONG') {\r\n      return position === 'ABOVE' || position === 'AT';\r\n    } else {\r\n      return position === 'BELOW' || position === 'AT';\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\indicators\\zigzag.indicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\providers\\candle.provider.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60000.","line":23,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":23,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":75,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":75,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2400,2407],"text":"config == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":97,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":97,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3067,3073],"text":"cache == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":121,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":121,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3793,3799],"text":"cache == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":142,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":142,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4424,4430],"text":"cache == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":150,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":150,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4712,4718],"text":"config != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":156,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":156,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4874,4879],"text":"(limit != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4874,4879],"text":"(limit ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4874,4879],"text":"(Boolean(limit))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":163,"column":24,"nodeType":"CallExpression","messageId":"conditionErrorNullableNumber","endLine":163,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5059,5084],"text":"(this.lastUpdate.get(role) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5059,5084],"text":"(this.lastUpdate.get(role) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5059,5084],"text":"(Boolean(this.lastUpdate.get(role)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":163,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":163,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5085,5087],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":173,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":173,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5414,5420],"text":"cache == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5970,5977],"text":"metrics != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":205,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":205,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6222,6227],"text":"(cache != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":213,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":213,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6406,6411],"text":"cache != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CandleProvider\r\n *\r\n * Manages multi-timeframe candle caching with separate LRU caches per timeframe.\r\n * Replaces MarketDataCollectorService for candle management.\r\n */\r\n\r\nimport { Candle, TimeframeRole, LoggerService } from '../types';\r\nimport { ArrayLRUCache } from '../utils/lru-cache';\r\nimport { TimeframeProvider } from './timeframe.provider';\r\nimport { BybitService } from '../services/bybit';\r\nimport { MULTIPLIERS } from '../constants';\r\n\r\ninterface CacheMetrics {\r\n  hits: number;\r\n  misses: number;\r\n  hitRate: number;\r\n}\r\n\r\nexport class CandleProvider {\r\n  private caches: Map<TimeframeRole, ArrayLRUCache<Candle>>;\r\n  private lastUpdate: Map<TimeframeRole, number>;\r\n  private ttl: number = 60000; // 1 minute TTL\r\n\r\n  constructor(\r\n    private timeframeProvider: TimeframeProvider,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n    private symbol: string,\r\n  ) {\r\n    this.caches = new Map();\r\n    this.lastUpdate = new Map();\r\n    this.initializeCaches();\r\n  }\r\n\r\n  /**\r\n   * Initialize LRU caches for all enabled timeframes\r\n   */\r\n  private initializeCaches(): void {\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role, config] of timeframes) {\r\n      const cache = new ArrayLRUCache<Candle>(config.candleLimit);\r\n      this.caches.set(role, cache);\r\n      this.lastUpdate.set(role, 0);\r\n\r\n      this.logger.info(`Initialized cache for ${role} (${config.interval}m, limit: ${config.candleLimit})`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load initial candles for all timeframes\r\n   */\r\n  async initialize(): Promise<void> {\r\n    this.logger.info('üîÑ Loading initial candles for all timeframes...');\r\n\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n    const loadPromises: Promise<void>[] = [];\r\n\r\n    for (const [role, config] of timeframes) {\r\n      loadPromises.push(this.loadTimeframeCandles(role, config.interval, config.candleLimit));\r\n    }\r\n\r\n    await Promise.all(loadPromises);\r\n    this.logger.info('‚úÖ All timeframe candles loaded successfully');\r\n  }\r\n\r\n  /**\r\n   * Load initial candles for a specific timeframe only (SCALPING mode optimization)\r\n   */\r\n  async initializeTimeframe(role: TimeframeRole): Promise<void> {\r\n    this.logger.info(`üîÑ Loading initial candles for ${role} only (SCALPING mode)...`);\r\n\r\n    const config = this.timeframeProvider.getTimeframe(role);\r\n    if (!config) {\r\n      throw new Error(`Timeframe ${role} not found in config`);\r\n    }\r\n\r\n    await this.loadTimeframeCandles(role, config.interval, config.candleLimit);\r\n    this.logger.info(`‚úÖ ${role} candles loaded successfully`);\r\n  }\r\n\r\n  /**\r\n   * Load candles for a specific timeframe\r\n   */\r\n  private async loadTimeframeCandles(\r\n    role: TimeframeRole,\r\n    interval: string,\r\n    limit: number,\r\n  ): Promise<void> {\r\n    try {\r\n      this.logger.info(`Loading ${limit} candles for ${role} (${interval}m)...`);\r\n\r\n      const candles = await this.bybitService.getCandles(this.symbol, interval, limit);\r\n      const cache = this.caches.get(role);\r\n\r\n      if (!cache) {\r\n        throw new Error(`Cache not found for ${role}`);\r\n      }\r\n\r\n      // Add all candles to cache\r\n      for (const candle of candles) {\r\n        cache.push(candle);\r\n      }\r\n\r\n      this.lastUpdate.set(role, Date.now());\r\n\r\n      this.logger.info(`‚úÖ Loaded ${candles.length} candles for ${role}`);\r\n    } catch (error) {\r\n      const errorObj = error instanceof Error ? { error: error.message } : { error: String(error) };\r\n      this.logger.error(`Failed to load candles for ${role}`, errorObj);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle candle closed event and update cache\r\n   */\r\n  onCandleClosed(role: TimeframeRole, candle: Candle): void {\r\n    const cache = this.caches.get(role);\r\n    if (!cache) {\r\n      this.logger.warn(`Cache not found for ${role}, skipping update`);\r\n      return;\r\n    }\r\n\r\n    cache.push(candle);\r\n    this.lastUpdate.set(role, Date.now());\r\n\r\n    this.logger.debug(`üìä Cache updated for ${role}`, {\r\n      timestamp: new Date(candle.timestamp).toISOString(),\r\n      close: candle.close,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get candles for a specific timeframe\r\n   * @param role - Timeframe role\r\n   * @param limit - Optional limit (defaults to all candles in cache)\r\n   */\r\n  async getCandles(role: TimeframeRole, limit?: number): Promise<Candle[]> {\r\n    const cache = this.caches.get(role);\r\n    if (!cache) {\r\n      throw new Error(`Cache not found for ${role}`);\r\n    }\r\n\r\n    // Check if cache is valid\r\n    if (!this.isCacheValid(role)) {\r\n      this.logger.warn(`Cache for ${role} is stale, reloading...`);\r\n      const config = this.timeframeProvider.getTimeframe(role);\r\n      if (config) {\r\n        await this.loadTimeframeCandles(role, config.interval, config.candleLimit);\r\n      }\r\n    }\r\n\r\n    const candles = cache.getAll();\r\n    return limit ? candles.slice(-limit) : candles;\r\n  }\r\n\r\n  /**\r\n   * Check if cache is valid (within TTL)\r\n   */\r\n  private isCacheValid(role: TimeframeRole): boolean {\r\n    const lastUpdate = this.lastUpdate.get(role) || 0;\r\n    return Date.now() - lastUpdate < this.ttl;\r\n  }\r\n\r\n  /**\r\n   * Get cache metrics for a specific timeframe\r\n   * Note: ArrayLRUCache doesn't track hits/misses internally, so we return basic metrics\r\n   */\r\n  getCacheMetrics(role: TimeframeRole): CacheMetrics | null {\r\n    const cache = this.caches.get(role);\r\n    if (!cache) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      hits: 0, // Not tracked by ArrayLRUCache\r\n      misses: 0, // Not tracked by ArrayLRUCache\r\n      hitRate: MULTIPLIERS.NEUTRAL, // Assume 100% since we always use cache after initialization\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get cache metrics for all timeframes\r\n   */\r\n  getAllCacheMetrics(): Map<TimeframeRole, CacheMetrics> {\r\n    const metricsMap = new Map<TimeframeRole, CacheMetrics>();\r\n\r\n    for (const role of this.caches.keys()) {\r\n      const metrics = this.getCacheMetrics(role);\r\n      if (metrics) {\r\n        metricsMap.set(role, metrics);\r\n      }\r\n    }\r\n\r\n    return metricsMap;\r\n  }\r\n\r\n  /**\r\n   * Get cache size for a timeframe\r\n   */\r\n  getCacheSize(role: TimeframeRole): number {\r\n    const cache = this.caches.get(role);\r\n    return cache ? cache.size() : 0;\r\n  }\r\n\r\n  /**\r\n   * Clear cache for a specific timeframe\r\n   */\r\n  clearCache(role: TimeframeRole): void {\r\n    const cache = this.caches.get(role);\r\n    if (cache) {\r\n      cache.clear();\r\n      this.lastUpdate.set(role, 0);\r\n      this.logger.info(`Cache cleared for ${role}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all caches\r\n   */\r\n  clearAllCaches(): void {\r\n    for (const role of this.caches.keys()) {\r\n      this.clearCache(role);\r\n    }\r\n    this.logger.info('All caches cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\providers\\timeframe.provider.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":33,"column":11,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":33,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TimeframeProvider\r\n *\r\n * Manages multi-timeframe configuration and provides access to timeframe settings.\r\n * Validates that entry and primary timeframes are always enabled.\r\n */\r\n\r\nimport { TimeframeConfig, TimeframeRole } from '../types';\r\n\r\nexport class TimeframeProvider {\r\n  private timeframes: Map<TimeframeRole, TimeframeConfig>;\r\n\r\n  constructor(timeframesConfig: Record<string, TimeframeConfig>) {\r\n    this.timeframes = new Map();\r\n    this.loadTimeframes(timeframesConfig);\r\n    this.validateTimeframes();\r\n  }\r\n\r\n  /**\r\n   * Load timeframes from config\r\n   */\r\n  private loadTimeframes(config: Record<string, TimeframeConfig>): void {\r\n    const roleMapping: Record<string, TimeframeRole> = {\r\n      entry: TimeframeRole.ENTRY,\r\n      primary: TimeframeRole.PRIMARY,\r\n      trend1: TimeframeRole.TREND1,\r\n      trend2: TimeframeRole.TREND2,\r\n      context: TimeframeRole.CONTEXT,\r\n    };\r\n\r\n    for (const [key, tfConfig] of Object.entries(config)) {\r\n      const role = roleMapping[key];\r\n      if (role && tfConfig.enabled) {\r\n        this.timeframes.set(role, tfConfig);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate that required timeframes are present\r\n   */\r\n  private validateTimeframes(): void {\r\n    if (!this.timeframes.has(TimeframeRole.PRIMARY)) {\r\n      throw new Error('PRIMARY timeframe is required but not enabled in config');\r\n    }\r\n\r\n    if (!this.timeframes.has(TimeframeRole.ENTRY)) {\r\n      throw new Error('ENTRY timeframe is required but not enabled in config');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get timeframe config by role\r\n   */\r\n  getTimeframe(role: TimeframeRole): TimeframeConfig | undefined {\r\n    return this.timeframes.get(role);\r\n  }\r\n\r\n  /**\r\n   * Get all active timeframes\r\n   */\r\n  getAllTimeframes(): Map<TimeframeRole, TimeframeConfig> {\r\n    return new Map(this.timeframes);\r\n  }\r\n\r\n  /**\r\n   * Check if timeframe is enabled\r\n   */\r\n  isTimeframeEnabled(role: TimeframeRole): boolean {\r\n    return this.timeframes.has(role);\r\n  }\r\n\r\n  /**\r\n   * Convert Bybit interval to minutes\r\n   * Examples: \"1\" -> 1, \"5\" -> 5, \"60\" -> 60, \"240\" -> 240\r\n   */\r\n  intervalToMinutes(interval: string): number {\r\n    return parseInt(interval, 10);\r\n  }\r\n\r\n  /**\r\n   * Get all enabled timeframe roles\r\n   */\r\n  getEnabledRoles(): TimeframeRole[] {\r\n    return Array.from(this.timeframes.keys());\r\n  }\r\n\r\n  /**\r\n   * Get timeframe interval by role\r\n   */\r\n  getInterval(role: TimeframeRole): string | undefined {\r\n    return this.timeframes.get(role)?.interval;\r\n  }\r\n\r\n  /**\r\n   * Get candle limit for timeframe\r\n   */\r\n  getCandleLimit(role: TimeframeRole): number | undefined {\r\n    return this.timeframes.get(role)?.candleLimit;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\adaptive-stop-loss.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'calculateStopLoss' has a complexity of 12. Maximum allowed is 10.","line":87,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":155,"endColumn":4},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentPrice' is defined but never used. Allowed unused args must match /^_/u.","line":91,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":122,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":122,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4244,4250],"text":"result != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":170,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":170,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6116,6141],"text":"(structure.liquidityZones == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":181,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":181,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6608,6623],"text":"(zone.sweepCount != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6608,6623],"text":"(zone.sweepCount ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6608,6623],"text":"(Boolean(zone.sweepCount))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":217,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":217,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7643,7665],"text":"(structure.orderBlocks == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.0.","line":236,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":236,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":263,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":263,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9022,9044],"text":"(structure.swingPoints == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 86400000.","line":275,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":275,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.0.","line":293,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":293,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":319,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":319,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10849,10877],"text":"(structure.supportResistance == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":329,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":329,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.0.","line":349,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":349,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":375,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":375,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12688,12702],"text":"(structure.atr == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12689,12702],"text":"(structure.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12688,12702],"text":"(!Boolean(structure.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":380,"column":72,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":75},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.5.","line":388,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":388,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":422,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":422,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14293,14297],"text":"(atr == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14294,14297],"text":"(atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14293,14297],"text":"(!Boolean(atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Adaptive Stop Loss Service (Phase 3)\r\n *\r\n * Multi-factor stop loss placement based on market structure.\r\n * Priority order: SWEEP > ORDER_BLOCK > SWING > LEVEL > ATR > PERCENT\r\n *\r\n * Why adaptive SL is better:\r\n * - Structure-based SL (sweeps, OBs, swings) respects market mechanics\r\n * - Prevents tight SL that gets swept by MM algos\r\n * - Reduces \"fake-out\" stop-outs on local wicks\r\n * - Better R/R ratio (wider but smarter placement)\r\n *\r\n * Example:\r\n * Entry: 1.2000 LONG\r\n * - Swing low: 1.1950 (recent swing)\r\n * - ATR SL: 1.1920 (1.5x ATR)\r\n * - Result: SL @ 1.1945 (swing - 0.3 ATR buffer) ‚úÖ\r\n * - Why: Respects structure + small buffer for noise\r\n */\r\n\r\nimport {\r\n  AdaptiveStopLossConfig,\r\n  StopLossCalculation,\r\n  StopLossType,\r\n  LoggerService,\r\n  SignalDirection,\r\n  SwingPoint,\r\n  SwingPointType,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BUFFER_MIN = 0.0001; // Minimum buffer (0.01%)\r\nconst BUFFER_MAX = 0.005; // Maximum buffer (0.5%)\r\n\r\n// ============================================================================\r\n// INTERFACES\r\n// ============================================================================\r\n\r\ninterface MarketStructure {\r\n  swingPoints?: SwingPoint[];\r\n  liquidityZones?: Array<{\r\n    price: number;\r\n    type: 'BUY_SIDE' | 'SELL_SIDE';\r\n    timestamp: number;\r\n    sweepCount?: number;\r\n  }>;\r\n  orderBlocks?: Array<{ price: number; strength: number }>;\r\n  supportResistance?: Array<{ price: number; strength: number; touches: number }>;\r\n  atr?: number;\r\n}\r\n\r\n// ============================================================================\r\n// ADAPTIVE STOP LOSS SERVICE\r\n// ============================================================================\r\n\r\nexport class AdaptiveStopLossService {\r\n  constructor(\r\n    private config: AdaptiveStopLossConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('AdaptiveStopLossService initialized', {\r\n      enabled: config.enabled,\r\n      priorityOrder: config.priorityOrder,\r\n      bufferMultiplier: config.bufferMultiplier,\r\n      minDistance: `${config.minDistancePercent}%`,\r\n      maxDistance: `${config.maxDistancePercent}%`,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate optimal stop loss based on market structure\r\n   *\r\n   * @param entryPrice Entry price\r\n   * @param direction Trade direction (LONG/SHORT)\r\n   * @param structure Market structure data (swings, zones, levels, etc)\r\n   * @param currentPrice Current market price (for validation)\r\n   * @returns Stop loss calculation with reasoning\r\n   */\r\n  calculateStopLoss(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n    currentPrice: number,\r\n  ): StopLossCalculation {\r\n    if (!this.config.enabled) {\r\n      return this.fallbackPercentSL(entryPrice, direction, 'Adaptive SL disabled');\r\n    }\r\n\r\n    // Try each method in priority order\r\n    for (const type of this.config.priorityOrder) {\r\n      let result: StopLossCalculation | null = null;\r\n\r\n      switch (type) {\r\n      case StopLossType.SWEEP:\r\n        result = this.calculateSweepBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.ORDER_BLOCK:\r\n        result = this.calculateOrderBlockBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.SWING:\r\n        result = this.calculateSwingBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.LEVEL:\r\n        result = this.calculateLevelBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.ATR:\r\n        result = this.calculateATRBasedSL(entryPrice, direction, structure);\r\n        break;\r\n      case StopLossType.PERCENT:\r\n        result = this.fallbackPercentSL(entryPrice, direction, 'Fallback to fixed percent');\r\n        break;\r\n      }\r\n\r\n      if (result) {\r\n        // Validate distance\r\n        const distancePercent = Math.abs((result.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n\r\n        if (distancePercent < this.config.minDistancePercent) {\r\n          this.logger.debug(`${type} SL too tight: ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}%`, {\r\n            minRequired: this.config.minDistancePercent,\r\n          });\r\n          continue; // Try next method\r\n        }\r\n\r\n        if (distancePercent > this.config.maxDistancePercent) {\r\n          this.logger.debug(`${type} SL too wide: ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}%`, {\r\n            maxAllowed: this.config.maxDistancePercent,\r\n          });\r\n          continue; // Try next method\r\n        }\r\n\r\n        // Valid SL found\r\n        result.distancePercent = distancePercent;\r\n        this.logger.info(`‚úÖ Adaptive SL selected: ${type}`, {\r\n          slPrice: result.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          distance: `${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n          reason: result.reason,\r\n        });\r\n\r\n        return result;\r\n      }\r\n    }\r\n\r\n    // All methods failed - use emergency fallback\r\n    this.logger.warn('‚ö†Ô∏è All adaptive SL methods failed - using emergency fallback');\r\n    return this.fallbackPercentSL(entryPrice, direction, 'Emergency fallback (all methods failed)');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: SL CALCULATION METHODS (Priority Order)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * 1. SWEEP-BASED SL (Highest Priority)\r\n   * Place SL beyond recent liquidity sweep to avoid re-sweep\r\n   */\r\n  private calculateSweepBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.liquidityZones || structure.liquidityZones.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Find recent sweep zone on opposite side\r\n    const recentSweeps = structure.liquidityZones\r\n      .filter((zone) => {\r\n        const isOpposite = isLong ? zone.type === 'SELL_SIDE' : zone.type === 'BUY_SIDE';\r\n        const isRecent = Date.now() - zone.timestamp < TIME_UNITS.HOUR; // Last 1 hour\r\n        const hasBeenSwept = zone.sweepCount && zone.sweepCount > 0;\r\n        return isOpposite && isRecent && hasBeenSwept;\r\n      })\r\n      .sort((a, b) => b.timestamp - a.timestamp);\r\n\r\n    if (recentSweeps.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const sweepZone = recentSweeps[0];\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n\r\n    // Place SL beyond sweep with buffer\r\n    const slPrice = isLong\r\n      ? sweepZone.price - buffer\r\n      : sweepZone.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.SWEEP,\r\n      price: slPrice,\r\n      distancePercent: 0, // Will be calculated in main method\r\n      reason: `Beyond liquidity sweep @ ${sweepZone.price.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      structurePrice: sweepZone.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 2. ORDER BLOCK-BASED SL\r\n   * Place SL beyond order block that caused reversal\r\n   */\r\n  private calculateOrderBlockBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.orderBlocks || structure.orderBlocks.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Find strongest OB below/above entry\r\n    const relevantOBs = structure.orderBlocks\r\n      .filter((ob) => (isLong ? ob.price < entryPrice : ob.price > entryPrice))\r\n      .sort((a, b) => b.strength - a.strength);\r\n\r\n    if (relevantOBs.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const ob = relevantOBs[0];\r\n\r\n    // OB should be within reasonable distance\r\n    const obDistance = Math.abs((ob.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n    if (obDistance > 3.0) {\r\n      // OB too far\r\n      return null;\r\n    }\r\n\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n    const slPrice = isLong ? ob.price - buffer : ob.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.ORDER_BLOCK,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `Beyond order block @ ${ob.price.toFixed(DECIMAL_PLACES.PRICE)} (strength: ${ob.strength.toFixed(DECIMAL_PLACES.PERCENT)})`,\r\n      structurePrice: ob.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 3. SWING-BASED SL\r\n   * Place SL beyond recent swing low/high\r\n   */\r\n  private calculateSwingBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.swingPoints || structure.swingPoints.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const targetType = isLong ? SwingPointType.LOW : SwingPointType.HIGH;\r\n\r\n    // Find nearest swing point of correct type\r\n    const relevantSwings = structure.swingPoints\r\n      .filter((sp) => {\r\n        const correctType = sp.type === targetType;\r\n        const correctSide = isLong ? sp.price < entryPrice : sp.price > entryPrice;\r\n        const notTooOld = Date.now() - sp.timestamp < 86400000; // Last 24h\r\n        return correctType && correctSide && notTooOld;\r\n      })\r\n      .sort((a, b) => {\r\n        // Prefer closer swing points\r\n        const distA = Math.abs(a.price - entryPrice);\r\n        const distB = Math.abs(b.price - entryPrice);\r\n        return distA - distB;\r\n      });\r\n\r\n    if (relevantSwings.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const swing = relevantSwings[0];\r\n\r\n    // Swing should be within reasonable distance\r\n    const swingDistance = Math.abs((swing.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n    if (swingDistance > 4.0) {\r\n      return null;\r\n    }\r\n\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n    const slPrice = isLong ? swing.price - buffer : swing.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.SWING,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `Beyond swing ${targetType.toLowerCase()} @ ${swing.price.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      structurePrice: swing.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 4. LEVEL-BASED SL\r\n   * Place SL beyond support/resistance level\r\n   */\r\n  private calculateLevelBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.supportResistance || structure.supportResistance.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Find nearest strong level on correct side\r\n    const relevantLevels = structure.supportResistance\r\n      .filter((level) => {\r\n        const correctSide = isLong ? level.price < entryPrice : level.price > entryPrice;\r\n        const strongEnough = level.touches >= 2 && level.strength >= MULTIPLIERS.HALF;\r\n        return correctSide && strongEnough;\r\n      })\r\n      .sort((a, b) => {\r\n        // Prefer closer + stronger\r\n        const distA = Math.abs(a.price - entryPrice);\r\n        const distB = Math.abs(b.price - entryPrice);\r\n        const scoreA = a.strength / distA;\r\n        const scoreB = b.strength / distB;\r\n        return scoreB - scoreA;\r\n      });\r\n\r\n    if (relevantLevels.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const level = relevantLevels[0];\r\n\r\n    // Level should be within reasonable distance\r\n    const levelDistance = Math.abs((level.price - entryPrice) / entryPrice) * PERCENT_MULTIPLIER;\r\n    if (levelDistance > 3.0) {\r\n      return null;\r\n    }\r\n\r\n    const buffer = this.calculateBuffer(structure.atr);\r\n    const slPrice = isLong ? level.price - buffer : level.price + buffer;\r\n\r\n    return {\r\n      type: StopLossType.LEVEL,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `Beyond ${isLong ? 'support' : 'resistance'} @ ${level.price.toFixed(DECIMAL_PLACES.PRICE)} (${level.touches} touches)`,\r\n      structurePrice: level.price,\r\n      buffer,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 5. ATR-BASED SL (Fallback)\r\n   * Standard ATR-based stop loss\r\n   */\r\n  private calculateATRBasedSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    structure: MarketStructure,\r\n  ): StopLossCalculation | null {\r\n    if (!structure.atr || structure.atr <= 0) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const atrDistance = structure.atr * this.config.bufferMultiplier * 1.5; // 1.5x ATR default\r\n\r\n    const slPrice = isLong ? entryPrice - atrDistance : entryPrice + atrDistance;\r\n\r\n    return {\r\n      type: StopLossType.ATR,\r\n      price: slPrice,\r\n      distancePercent: 0,\r\n      reason: `ATR-based (${this.config.bufferMultiplier * 1.5}x ATR = ${atrDistance.toFixed(DECIMAL_PLACES.PRICE)})`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 6. PERCENT-BASED SL (Emergency Fallback)\r\n   * Fixed percentage stop loss when all else fails\r\n   */\r\n  private fallbackPercentSL(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n    reason: string,\r\n  ): StopLossCalculation {\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const distance = (this.config.fallbackPercent / PERCENT_MULTIPLIER) * entryPrice;\r\n    const slPrice = isLong ? entryPrice - distance : entryPrice + distance;\r\n\r\n    return {\r\n      type: StopLossType.PERCENT,\r\n      price: slPrice,\r\n      distancePercent: this.config.fallbackPercent,\r\n      reason: `Fixed ${this.config.fallbackPercent}% (${reason})`,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate buffer size based on ATR\r\n   * Buffer prevents SL from being exactly at structure (prone to false triggers)\r\n   */\r\n  private calculateBuffer(atr?: number): number {\r\n    if (!atr || atr <= 0) {\r\n      return BUFFER_MIN;\r\n    }\r\n\r\n    const buffer = atr * this.config.bufferMultiplier;\r\n\r\n    // Clamp to min/max\r\n    return Math.max(BUFFER_MIN, Math.min(BUFFER_MAX, buffer));\r\n  }\r\n\r\n  /**\r\n   * Get config (for testing/monitoring)\r\n   */\r\n  getConfig(): AdaptiveStopLossConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\adaptive-tp3.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'checkExtension' has a complexity of 11. Maximum allowed is 10.","line":102,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":183,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":114,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":114,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3834,3840],"text":"state == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":154,"column":22,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":154,"endColumn":46,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[5309,5315],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":194,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":194,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6669,6675],"text":"state == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":228,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":228,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7784,7790],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":245,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":245,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8392,8397],"text":"(state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":260,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":260,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[8735,8752],"text":"((state?.maxReached) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[8735,8752],"text":"((state?.maxReached) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":260,"column":30,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":260,"endColumn":32,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8753,8755],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":268,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":268,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8914,8919],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Adaptive TP3 Service (Phase 3)\r\n *\r\n * Dynamically extends TP3 when strong momentum continues after TP2.\r\n * Base TP3: 2.0%\r\n * Extension: +0.5% per tick (max 3 ticks = +1.5%)\r\n * Max TP3: 3.5%\r\n *\r\n * Why adaptive TP3 is better:\r\n * - Captures more profit on strong trends (don't leave money on table)\r\n * - Only extends when momentum confirmed (volume + EMA + no reversal)\r\n * - Protects with trailing stop (if TP3 not hit, trailing captures)\r\n *\r\n * Example:\r\n * TP2 hit @ +1.0%, momentum strong:\r\n * - Tick 1: TP3 @ +2.0% ‚Üí +2.5% (not hit, continue)\r\n * - Tick 2: TP3 @ +2.5% ‚Üí +3.0% (not hit, continue)\r\n * - Tick 3: TP3 @ +3.0% ‚Üí +3.5% (MAX, no more extension)\r\n * - Result: TP3 hit @ +3.2% instead of +2.0% = +60% more profit! ‚úÖ\r\n */\r\n\r\nimport {\r\n  AdaptiveTP3Config,\r\n  LoggerService,\r\n  Position,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// INTERFACES\r\n// ============================================================================\r\n\r\ninterface TP3State {\r\n  baseTp3Percent: number; // Original TP3 target\r\n  currentTp3Percent: number; // Current TP3 target (extended)\r\n  ticksApplied: number; // How many extension ticks applied\r\n  lastExtensionTime: number; // Timestamp of last extension\r\n  maxReached: boolean; // Max ticks reached\r\n}\r\n\r\n// ============================================================================\r\n// ADAPTIVE TP3 SERVICE\r\n// ============================================================================\r\n\r\nexport class AdaptiveTP3Service {\r\n  private states: Map<string, TP3State> = new Map();\r\n\r\n  constructor(\r\n    private config: AdaptiveTP3Config,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('AdaptiveTP3Service initialized', {\r\n      enabled: config.enabled,\r\n      baseTP3: config.baseTP3Percent + '%',\r\n      tickSize: config.tickSizePercent + '%',\r\n      maxTicks: config.maxTicks,\r\n      maxExtension: (config.tickSizePercent * config.maxTicks).toFixed(1) + '%',\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Initialize TP3 state after TP2 hit\r\n   *\r\n   * @param positionId Position ID\r\n   * @param baseTP3Percent Base TP3 target (e.g., 2.0%)\r\n   */\r\n  initialize(positionId: string, baseTP3Percent: number): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.states.set(positionId, {\r\n      baseTp3Percent: baseTP3Percent,\r\n      currentTp3Percent: baseTP3Percent,\r\n      ticksApplied: 0,\r\n      lastExtensionTime: Date.now(),\r\n      maxReached: false,\r\n    });\r\n\r\n    this.logger.info('üìä Adaptive TP3 initialized', {\r\n      positionId,\r\n      baseTP3: baseTP3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      maxPossible: (baseTP3Percent + this.config.tickSizePercent * this.config.maxTicks).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if should extend TP3 (call this on candle close)\r\n   *\r\n   * Conditions for extension:\r\n   * 1. TP3 not hit yet (price hasn't reached current TP3)\r\n   * 2. Strong momentum continues (volume + EMA angle)\r\n   * 3. No reversal signals (price still trending)\r\n   * 4. Max ticks not reached\r\n   *\r\n   * @returns { shouldExtend, newTP3Percent, reason }\r\n   */\r\n  checkExtension(\r\n    position: Position,\r\n    currentPrice: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number, // EMA slope in degrees\r\n  ): { shouldExtend: boolean; newTP3Percent?: number; reason: string } {\r\n    if (!this.config.enabled) {\r\n      return { shouldExtend: false, reason: 'Adaptive TP3 disabled' };\r\n    }\r\n\r\n    const state = this.states.get(position.id);\r\n    if (!state) {\r\n      return { shouldExtend: false, reason: 'Not initialized' };\r\n    }\r\n\r\n    // Check if max ticks reached\r\n    if (state.maxReached || state.ticksApplied >= this.config.maxTicks) {\r\n      state.maxReached = true;\r\n      return { shouldExtend: false, reason: 'Max ticks reached' };\r\n    }\r\n\r\n    // Calculate current profit percent\r\n    const profitPercent = this.calculateProfitPercent(position, currentPrice);\r\n\r\n    // Check if TP3 already hit\r\n    if (profitPercent >= state.currentTp3Percent) {\r\n      return { shouldExtend: false, reason: 'TP3 already hit' };\r\n    }\r\n\r\n    // Check momentum conditions\r\n\r\n    // 1. Volume elevated\r\n    const volumeRatio = currentVolume / avgVolume;\r\n    if (volumeRatio < this.config.momentumThreshold.volumeMultiplier) {\r\n      return {\r\n        shouldExtend: false,\r\n        reason: `Volume too low: ${volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x < ${this.config.momentumThreshold.volumeMultiplier}x`,\r\n      };\r\n    }\r\n\r\n    // 2. EMA angle steep (momentum)\r\n    const absAngle = Math.abs(emaAngle);\r\n    if (absAngle < this.config.momentumThreshold.emaAngle) {\r\n      return {\r\n        shouldExtend: false,\r\n        reason: `EMA angle too flat: ${absAngle.toFixed(DECIMAL_PLACES.PERCENT)}¬∞ < ${this.config.momentumThreshold.emaAngle}¬∞`,\r\n      };\r\n    }\r\n\r\n    // 3. No reversal (price still trending in correct direction)\r\n    if (this.config.momentumThreshold.noReversal) {\r\n      const isLong = position.side === 'LONG';\r\n      const profitDirection = profitPercent > 0;\r\n      const expectedDirection = isLong;\r\n\r\n      if (profitDirection !== expectedDirection) {\r\n        return {\r\n          shouldExtend: false,\r\n          reason: 'Price reversed direction',\r\n        };\r\n      }\r\n\r\n      // Check if profit is increasing (not stalling)\r\n      const minProfitForExtension = state.currentTp3Percent - this.config.tickSizePercent;\r\n      if (profitPercent < minProfitForExtension) {\r\n        return {\r\n          shouldExtend: false,\r\n          reason: `Profit stalling: ${profitPercent.toFixed(DECIMAL_PLACES.PERCENT)}% < ${minProfitForExtension.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // All checks passed - extend TP3!\r\n    const newTP3Percent = state.currentTp3Percent + this.config.tickSizePercent;\r\n\r\n    return {\r\n      shouldExtend: true,\r\n      newTP3Percent,\r\n      reason: `Momentum strong: ${volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x vol, ${absAngle.toFixed(DECIMAL_PLACES.PERCENT)}¬∞ EMA`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extend TP3 by one tick\r\n   *\r\n   * @param positionId Position ID\r\n   * @param newTP3Price New TP3 price (from exchange/position manager)\r\n   * @returns Updated TP3 percent\r\n   */\r\n  extendTP3(positionId: string, newTP3Price: number): number | null {\r\n    const state = this.states.get(positionId);\r\n    if (!state) {\r\n      return null;\r\n    }\r\n\r\n    const newPercent = state.currentTp3Percent + this.config.tickSizePercent;\r\n\r\n    state.currentTp3Percent = newPercent;\r\n    state.ticksApplied++;\r\n    state.lastExtensionTime = Date.now();\r\n\r\n    if (state.ticksApplied >= this.config.maxTicks) {\r\n      state.maxReached = true;\r\n    }\r\n\r\n    this.logger.info('üìà TP3 extended!', {\r\n      positionId,\r\n      oldTP3: (state.currentTp3Percent - this.config.tickSizePercent).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      newTP3: newPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      ticksApplied: state.ticksApplied,\r\n      maxTicks: this.config.maxTicks,\r\n      newPrice: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    return newPercent;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate current profit percent\r\n   */\r\n  private calculateProfitPercent(position: Position, currentPrice: number): number {\r\n    const isLong = position.side === 'LONG';\r\n    if (isLong) {\r\n      return ((currentPrice - position.entryPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    } else {\r\n      return ((position.entryPrice - currentPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC: STATE MANAGEMENT\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get current TP3 target\r\n   */\r\n  getCurrentTP3Percent(positionId: string): number | null {\r\n    const state = this.states.get(positionId);\r\n    return state ? state.currentTp3Percent : null;\r\n  }\r\n\r\n  /**\r\n   * Get TP3 state\r\n   */\r\n  getState(positionId: string): TP3State | undefined {\r\n    return this.states.get(positionId);\r\n  }\r\n\r\n  /**\r\n   * Check if max extension reached\r\n   */\r\n  isMaxReached(positionId: string): boolean {\r\n    const state = this.states.get(positionId);\r\n    return state?.maxReached || false;\r\n  }\r\n\r\n  /**\r\n   * Reset state (position closed)\r\n   */\r\n  reset(positionId: string): void {\r\n    const state = this.states.get(positionId);\r\n    if (state) {\r\n      this.logger.debug('Resetting TP3 state', {\r\n        positionId,\r\n        finalTP3: state.currentTp3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        ticksApplied: state.ticksApplied,\r\n      });\r\n    }\r\n    this.states.delete(positionId);\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): AdaptiveTP3Config {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\auxiliary-data-logger.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":37,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":37,"endColumn":39,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1240,1270],"text":"(this.config.orderBook?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1240,1270],"text":"(this.config.orderBook?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":46,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":46,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1511,1538],"text":"(this.config.volume?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1511,1538],"text":"(this.config.volume?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":63,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":63,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2020,2043],"text":"(this.orderBookAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":63,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":63,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2047,2067],"text":"(this.volumeAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":69,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":69,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2152,2174],"text":"(this.orderBookAnalyzer != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":69,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":69,"endColumn":58,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2178,2199],"text":"(this.config.orderBook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":78,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":78,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2390,2409],"text":"(this.volumeAnalyzer != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":78,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":78,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2413,2431],"text":"(this.config.volume != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":100,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":100,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2998,3021],"text":"(this.orderBookAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":100,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":100,"endColumn":58,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3025,3047],"text":"(this.config.orderBook == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":143,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":143,"endColumn":12},{"ruleId":"complexity","severity":1,"message":"Async method 'logVolume' has a complexity of 12. Maximum allowed is 10.","line":165,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":236,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":169,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":169,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5278,5298],"text":"(this.volumeAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":169,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":169,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5302,5321],"text":"(this.config.volume == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":179,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":179,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6059,6077],"text":"(volumeAnalysis.poc != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":205,"column":9,"nodeType":"Literal","messageId":"noMagic","endLine":205,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":224,"column":83,"nodeType":"Literal","messageId":"noMagic","endLine":224,"endColumn":86}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Auxiliary Data Logger Service\r\n *\r\n * Logs OrderBook and Volume data for informational purposes.\r\n * Does NOT affect signal generation decisions - logging only!\r\n *\r\n * Extracted from SignalGeneratorService for better testability.\r\n */\r\n\r\nimport {\r\n  SignalDirection,\r\n  Config,\r\n  TimeframeRole,\r\n  LoggerService,\r\n} from '../types';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { VolumeAnalyzer } from '../analyzers/volume.analyzer';\r\nimport { BybitService } from './bybit';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\n\r\n// ============================================================================\r\n// AUXILIARY DATA LOGGER SERVICE\r\n// ============================================================================\r\n\r\nexport class AuxiliaryDataLogger {\r\n  private orderBookAnalyzer: OrderBookAnalyzer | null = null;\r\n  private volumeAnalyzer: VolumeAnalyzer | null = null;\r\n\r\n  constructor(\r\n    private bybitService: BybitService,\r\n    private candleProvider: CandleProvider,\r\n    private config: Config,\r\n    private logger: LoggerService,\r\n  ) {\r\n    // Initialize OrderBook analyzer if enabled\r\n    if (this.config.orderBook?.enabled) {\r\n      this.orderBookAnalyzer = new OrderBookAnalyzer(\r\n        this.config.orderBook,\r\n        this.logger,\r\n      );\r\n      this.logger.info('OrderBook logging enabled');\r\n    }\r\n\r\n    // Initialize Volume analyzer if enabled\r\n    if (this.config.volume?.enabled) {\r\n      this.volumeAnalyzer = new VolumeAnalyzer(\r\n        this.config.volume,\r\n        this.logger,\r\n      );\r\n      this.logger.info('Volume logging enabled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log OrderBook and Volume analysis (non-blocking)\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction\r\n   */\r\n  async logAnalysis(currentPrice: number, direction: SignalDirection): Promise<void> {\r\n    // Skip if both analyzers disabled\r\n    if (!this.orderBookAnalyzer && !this.volumeAnalyzer) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Log OrderBook if enabled\r\n      if (this.orderBookAnalyzer && this.config.orderBook) {\r\n        await this.logOrderBook(\r\n          this.config.exchange.symbol,\r\n          currentPrice,\r\n          direction,\r\n        );\r\n      }\r\n\r\n      // Log Volume if enabled\r\n      if (this.volumeAnalyzer && this.config.volume) {\r\n        await this.logVolume(currentPrice, direction);\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to log auxiliary data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log OrderBook analysis\r\n   *\r\n   * @param symbol - Trading symbol\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction\r\n   */\r\n  private async logOrderBook(\r\n    symbol: string,\r\n    currentPrice: number,\r\n    direction: SignalDirection,\r\n  ): Promise<void> {\r\n    if (!this.orderBookAnalyzer || !this.config.orderBook) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.debug('Fetching order book...');\r\n\r\n      const orderBookData = await this.bybitService.getOrderBook(\r\n        symbol,\r\n        this.config.orderBook.depth,\r\n      );\r\n\r\n      const orderBookAnalysis = this.orderBookAnalyzer.analyze(\r\n        {\r\n          bids: orderBookData.bids,\r\n          asks: orderBookData.asks,\r\n          timestamp: orderBookData.timestamp,\r\n        },\r\n        currentPrice,\r\n      );\r\n\r\n      // Log summary\r\n      const summary = this.orderBookAnalyzer.getSummary(orderBookAnalysis);\r\n      this.logger.info('üìä OrderBook Analysis', { summary });\r\n\r\n      // Log detailed analysis\r\n      this.logger.debug('OrderBook details', {\r\n        imbalance: {\r\n          direction: orderBookAnalysis.imbalance.direction,\r\n          ratio: orderBookAnalysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n          strength: `${(orderBookAnalysis.imbalance.strength * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          bidVolume: orderBookAnalysis.imbalance.bidVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n          askVolume: orderBookAnalysis.imbalance.askVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n        },\r\n        walls: orderBookAnalysis.walls.length,\r\n        spread: `${orderBookAnalysis.spread.toFixed(DECIMAL_PLACES.PRICE)}%`,\r\n        depth: `${orderBookAnalysis.depth.bid} bids / ${orderBookAnalysis.depth.ask} asks`,\r\n      });\r\n\r\n      // Check for blocking walls (info only)\r\n      const hasWall = this.orderBookAnalyzer.hasBlockingWall(\r\n        orderBookAnalysis,\r\n        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',\r\n        2.0,\r\n      );\r\n\r\n      if (hasWall) {\r\n        this.logger.info('‚ö†Ô∏è OrderBook wall detected in path', {\r\n          direction,\r\n          distance: '< 2%',\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to log OrderBook', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log Volume analysis\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction\r\n   */\r\n  private async logVolume(\r\n    currentPrice: number,\r\n    direction: SignalDirection,\r\n  ): Promise<void> {\r\n    if (!this.volumeAnalyzer || !this.config.volume) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.debug('Analyzing volume profile...');\r\n\r\n      // Get PRIMARY candles for volume analysis\r\n      const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n\r\n      if (!primaryCandles || primaryCandles.length === 0) {\r\n        this.logger.warn('No candles available for volume analysis');\r\n        return;\r\n      }\r\n\r\n      const volumeAnalysis = this.volumeAnalyzer.analyze(primaryCandles, currentPrice);\r\n\r\n      // Log summary\r\n      const summary = this.volumeAnalyzer.getSummary(volumeAnalysis);\r\n      this.logger.info('üìà Volume Analysis', { summary });\r\n\r\n      // Log detailed analysis\r\n      this.logger.debug('Volume details', {\r\n        poc: volumeAnalysis.poc\r\n          ? `${volumeAnalysis.poc.price.toFixed(DECIMAL_PLACES.PERCENT)} (${volumeAnalysis.poc.volume.toFixed(0)})`\r\n          : 'N/A',\r\n        hvns: volumeAnalysis.hvns.length,\r\n        lvns: volumeAnalysis.lvns.length,\r\n        totalVolume: volumeAnalysis.totalVolume.toFixed(0),\r\n        avgVolume: volumeAnalysis.avgVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Check for blocking HVNs (info only)\r\n      const hasHVN = this.volumeAnalyzer.hasBlockingHVN(\r\n        volumeAnalysis,\r\n        direction === SignalDirection.LONG ? 'LONG' : 'SHORT',\r\n        2.0,\r\n      );\r\n\r\n      if (hasHVN) {\r\n        this.logger.info('‚ö†Ô∏è High Volume Node detected in path', {\r\n          direction,\r\n          distance: '< 2%',\r\n        });\r\n      }\r\n\r\n      // Check if in LVN (weak zone)\r\n      const inLVN = this.volumeAnalyzer.isInLVN(volumeAnalysis, currentPrice);\r\n      if (inLVN) {\r\n        this.logger.info('üìç Current price is in Low Volume Node (weak zone)', {\r\n          price: currentPrice,\r\n        });\r\n      }\r\n\r\n      // Check if near POC\r\n      const nearPOC = this.volumeAnalyzer.isNearPOC(volumeAnalysis, currentPrice, 0.5);\r\n      if (nearPOC) {\r\n        this.logger.info('üìç Current price is near Point of Control', {\r\n          price: currentPrice,\r\n          poc: volumeAnalysis.poc?.price.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to log Volume', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\blocking-rules.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MAX_DISTANCE_TO_EMA_PERCENT' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":28,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":28,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'COOLDOWN_PERIOD_MS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES_5M' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES_30M' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":31,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_CANDLES_1H' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'VOLUME_MIN_MULTIPLIER_TREND' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'VOLUME_MIN_MULTIPLIER_LEVEL' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MIN_DROP_FROM_ATH_FOR_LONG' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":37,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":33},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'checkBlockingRules' has no 'await' expression.","line":93,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":93,"endColumn":27},{"ruleId":"complexity","severity":1,"message":"Async method 'checkBlockingRules' has a complexity of 13. Maximum allowed is 10.","line":93,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":156,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":239,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":239,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":267,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":267,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -3.","line":272,"column":41,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":272,"endColumn":43}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Blocking Rules Service\r\n *\r\n * Centralized blocking rules for all strategies.\r\n * Philosophy: \"Better to miss a good trade than take a bad trade\"\r\n *\r\n * Global Blocks (apply to ALL strategies):\r\n * - GLOBAL_1: Insufficient data\r\n * - GLOBAL_2: EMA distance > 5.5% (falling knife / blow-off top)\r\n * - GLOBAL_3: Active positions limit (max 1)\r\n * - GLOBAL_4: Cooldown period (10 sec between signals)\r\n *\r\n * Additional Blocks:\r\n * - Volume blocks (low liquidity)\r\n * - Wick blocks (rejection candles)\r\n * - ATH protection (buying tops)\r\n */\r\n\r\nimport { SignalDirection, Candle, LoggerService } from '../types';\r\nimport { VolumeCalculator } from '../analyzers/volume.calculator';\r\nimport { WickAnalyzer } from '../analyzers/wick.analyzer';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_DISTANCE_TO_EMA_PERCENT = 5.5; // GLOBAL_2\r\nconst COOLDOWN_PERIOD_MS = 10000; // GLOBAL_4: 10 seconds\r\nconst MIN_CANDLES_5M = 100; // GLOBAL_1\r\nconst MIN_CANDLES_30M = CONFIDENCE_THRESHOLDS.MODERATE; // GLOBAL_1\r\nconst MIN_CANDLES_1H = CONFIDENCE_THRESHOLDS.MODERATE; // GLOBAL_1\r\n\r\nconst VOLUME_MIN_MULTIPLIER_TREND = MULTIPLIERS.HALF; // Trend-Following\r\nconst VOLUME_MIN_MULTIPLIER_LEVEL = 0.3; // Level-Based\r\n\r\nconst MIN_DROP_FROM_ATH_FOR_LONG = 0.2; // ATH protection (%)\r\nconst CANDLES_FOR_24H_HIGH = 288; // 24h at 5m intervals\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface BlockingRulesConfig {\r\n  maxDistanceToEmaPercent: number; // GLOBAL_2\r\n  cooldownPeriodMs: number; // GLOBAL_4\r\n  minCandles5m: number; // GLOBAL_1\r\n  volumeMinMultiplierTrend: number;\r\n  volumeMinMultiplierLevel: number;\r\n  minDropFromAthForLong: number; // ATH protection\r\n  enableAthProtection: boolean; // ATH protection toggle\r\n  enableVolumeChecks: boolean; // Volume checks toggle\r\n  enableWickChecks: boolean; // Wick checks toggle\r\n}\r\n\r\nexport interface BlockingContext {\r\n  direction: SignalDirection;\r\n  strategy: 'TrendFollowing' | 'LevelBased' | 'CounterTrend';\r\n  candles: Candle[];\r\n  currentPrice: number;\r\n  ema50: number;\r\n  rsi?: number;\r\n  hasActivePosition: boolean;\r\n  lastSignalTime: number;\r\n}\r\n\r\nexport interface BlockingResult {\r\n  blocked: boolean;\r\n  reason?: string;\r\n  blockId?: string;\r\n}\r\n\r\n// ============================================================================\r\n// BLOCKING RULES SERVICE\r\n// ============================================================================\r\n\r\nexport class BlockingRulesService {\r\n  private volumeCalculator: VolumeCalculator;\r\n  private wickAnalyzer: WickAnalyzer;\r\n\r\n  constructor(\r\n    private config: BlockingRulesConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.volumeCalculator = new VolumeCalculator(logger);\r\n    this.wickAnalyzer = new WickAnalyzer(logger);\r\n  }\r\n\r\n  /**\r\n   * Check all blocking rules for a signal\r\n   * Returns blocked=true if ANY rule blocks the signal\r\n   */\r\n  async checkBlockingRules(context: BlockingContext): Promise<BlockingResult> {\r\n    // ========================================================================\r\n    // GLOBAL BLOCKS (apply to ALL strategies)\r\n    // ========================================================================\r\n\r\n    // GLOBAL_1: Insufficient data\r\n    const insufficientDataBlock = this.checkInsufficientData(context.candles);\r\n    if (insufficientDataBlock.blocked) {\r\n      return insufficientDataBlock;\r\n    }\r\n\r\n    // GLOBAL_2: EMA distance > 5.5%\r\n    const emaDistanceBlock = this.checkEmaDistance(context.currentPrice, context.ema50);\r\n    if (emaDistanceBlock.blocked) {\r\n      return emaDistanceBlock;\r\n    }\r\n\r\n    // GLOBAL_3: Active positions limit\r\n    const activePositionBlock = this.checkActivePositionLimit(context.hasActivePosition);\r\n    if (activePositionBlock.blocked) {\r\n      return activePositionBlock;\r\n    }\r\n\r\n    // GLOBAL_4: Cooldown period\r\n    const cooldownBlock = this.checkCooldownPeriod(context.lastSignalTime);\r\n    if (cooldownBlock.blocked) {\r\n      return cooldownBlock;\r\n    }\r\n\r\n    // ========================================================================\r\n    // STRATEGY-SPECIFIC BLOCKS\r\n    // ========================================================================\r\n\r\n    // Volume checks (if enabled)\r\n    if (this.config.enableVolumeChecks) {\r\n      const volumeBlock = this.checkVolume(context.candles, context.strategy);\r\n      if (volumeBlock.blocked) {\r\n        return volumeBlock;\r\n      }\r\n    }\r\n\r\n    // Wick checks (if enabled)\r\n    if (this.config.enableWickChecks) {\r\n      const wickBlock = this.checkWicks(context.candles, context.direction);\r\n      if (wickBlock.blocked) {\r\n        return wickBlock;\r\n      }\r\n    }\r\n\r\n    // ATH protection (if enabled, LONG only, Trend-Following only)\r\n    if (\r\n      this.config.enableAthProtection &&\r\n      context.direction === SignalDirection.LONG &&\r\n      context.strategy === 'TrendFollowing'\r\n    ) {\r\n      const athBlock = this.checkAthProtection(context.candles, context.currentPrice);\r\n      if (athBlock.blocked) {\r\n        return athBlock;\r\n      }\r\n    }\r\n\r\n    // No blocks triggered\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_1: Check for insufficient data\r\n   */\r\n  private checkInsufficientData(candles: Candle[]): BlockingResult {\r\n    if (candles.length < this.config.minCandles5m) {\r\n      this.logger.warn('[BlockingRules] GLOBAL_1: Insufficient data', {\r\n        candles: candles.length,\r\n        required: this.config.minCandles5m,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_1',\r\n        reason: `Insufficient data: ${candles.length} < ${this.config.minCandles5m} candles`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_2: Check EMA distance > 5.5%\r\n   * Most effective blocking rule (prevented 15+ losses in backtests)\r\n   */\r\n  private checkEmaDistance(price: number, ema50: number): BlockingResult {\r\n    const distancePercent = Math.abs((price - ema50) / ema50) * PERCENT_MULTIPLIER;\r\n\r\n    if (distancePercent > this.config.maxDistanceToEmaPercent) {\r\n      this.logger.warn('[BlockingRules] GLOBAL_2: EMA distance too far', {\r\n        distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        max: this.config.maxDistanceToEmaPercent,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_2',\r\n        reason: `EMA distance ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}% > ${this.config.maxDistanceToEmaPercent}% (falling knife / blow-off top)`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_3: Check active positions limit (max 1)\r\n   */\r\n  private checkActivePositionLimit(hasActivePosition: boolean): BlockingResult {\r\n    if (hasActivePosition) {\r\n      this.logger.warn('[BlockingRules] GLOBAL_3: Active position exists');\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_3',\r\n        reason: 'Active position exists (max 1 position limit)',\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * GLOBAL_4: Check cooldown period (10 sec between signals)\r\n   */\r\n  private checkCooldownPeriod(lastSignalTime: number): BlockingResult {\r\n    const now = Date.now();\r\n    const timeSinceLastSignal = now - lastSignalTime;\r\n\r\n    if (timeSinceLastSignal < this.config.cooldownPeriodMs) {\r\n      this.logger.debug('[BlockingRules] GLOBAL_4: Cooldown period active', {\r\n        timeSince: timeSinceLastSignal,\r\n        required: this.config.cooldownPeriodMs,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'GLOBAL_4',\r\n        reason: `Cooldown period active (${timeSinceLastSignal}ms < ${this.config.cooldownPeriodMs}ms)`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * VOL_TREND_1 / VOL_LEVEL_1: Check volume\r\n   */\r\n  private checkVolume(candles: Candle[], strategy: string): BlockingResult {\r\n    const volumeAnalysis = this.volumeCalculator.calculate(candles);\r\n\r\n    if (!volumeAnalysis || volumeAnalysis.avgVolume === 0) {\r\n      return { blocked: false }; // No volume data, skip check\r\n    }\r\n\r\n    const threshold =\r\n      strategy === 'LevelBased'\r\n        ? this.config.volumeMinMultiplierLevel\r\n        : this.config.volumeMinMultiplierTrend;\r\n\r\n    if (volumeAnalysis.isLowVolume && volumeAnalysis.volumeRatio < threshold) {\r\n      this.logger.warn('[BlockingRules] VOL: Low volume', {\r\n        strategy,\r\n        ratio: volumeAnalysis.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        threshold,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: strategy === 'LevelBased' ? 'VOL_LEVEL_1' : 'VOL_TREND_1',\r\n        reason: `Low volume: ${volumeAnalysis.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x < ${threshold}x (low liquidity risk)`,\r\n      };\r\n    }\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * WICK_LONG / WICK_SHORT: Check for large wicks (rejection candles)\r\n   */\r\n  private checkWicks(candles: Candle[], direction: SignalDirection): BlockingResult {\r\n    if (candles.length < 3) {\r\n      return { blocked: false }; // Not enough candles to check\r\n    }\r\n\r\n    // Check last 3 candles\r\n    const recentCandles = candles.slice(-3);\r\n\r\n    for (const candle of recentCandles) {\r\n      const wickAnalysis = this.wickAnalyzer.analyze(candle);\r\n\r\n      if (wickAnalysis.hasLargeWick) {\r\n        const blocks = this.wickAnalyzer.blocksSignal(wickAnalysis, direction);\r\n        if (blocks) {\r\n          this.logger.warn('[BlockingRules] WICK: Large wick detected', {\r\n            direction,\r\n            wickDirection: wickAnalysis.wickDirection,\r\n          });\r\n          return {\r\n            blocked: true,\r\n            blockId: direction === SignalDirection.LONG ? 'WICK_LONG' : 'WICK_SHORT',\r\n            reason: `Large ${wickAnalysis.wickDirection} wick detected (rejection candle)`,\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return { blocked: false };\r\n  }\r\n\r\n  /**\r\n   * ATH_LONG: Check ATH protection (avoid buying tops)\r\n   * Only for LONG signals in Trend-Following strategy\r\n   */\r\n  private checkAthProtection(candles: Candle[], currentPrice: number): BlockingResult {\r\n    if (candles.length < CANDLES_FOR_24H_HIGH) {\r\n      return { blocked: false }; // Not enough data for 24h high\r\n    }\r\n\r\n    // Get 24h high (last 288 candles at 5m)\r\n    const last24hCandles = candles.slice(-CANDLES_FOR_24H_HIGH);\r\n    const high24h = Math.max(...last24hCandles.map((c) => c.high));\r\n\r\n    // Calculate drop from high\r\n    const dropFromHighPercent = ((high24h - currentPrice) / high24h) * PERCENT_MULTIPLIER;\r\n\r\n    if (dropFromHighPercent < this.config.minDropFromAthForLong) {\r\n      this.logger.warn('[BlockingRules] ATH_LONG: Too close to ATH', {\r\n        dropFromHigh: dropFromHighPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        min: this.config.minDropFromAthForLong,\r\n      });\r\n      return {\r\n        blocked: true,\r\n        blockId: 'ATH_LONG',\r\n        reason: `Too close to ATH: drop ${dropFromHighPercent.toFixed(DECIMAL_PLACES.PERCENT)}% < ${this.config.minDropFromAthForLong}% (buying the top risk)`,\r\n      };\r\n    }\r\n\r\n    return { blocked: false };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\circuit-breaker.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEFAULT_ERROR_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DEFAULT_COOLDOWN_MS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":25,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":25,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":25,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":35},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":25,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":25,"endColumn":42},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":88,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":88,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3181,3194],"text":"(this.tripTime != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3181,3194],"text":"(this.tripTime ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3181,3194],"text":"(Boolean(this.tripTime))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":226,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":226,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6852,6865],"text":"(this.tripTime != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6852,6865],"text":"(this.tripTime ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6852,6865],"text":"(Boolean(this.tripTime))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Circuit Breaker Service\r\n *\r\n * Protects the system from API failures by tracking consecutive errors.\r\n * When error threshold is reached, the circuit \"trips\" and pauses operations.\r\n *\r\n * States:\r\n * - CLOSED: Normal operation (no errors or below threshold)\r\n * - OPEN: Circuit tripped (pause operations for cooldown period)\r\n * - HALF_OPEN: Testing if service recovered (allow one request)\r\n *\r\n * Configuration:\r\n * - errorThreshold: Number of consecutive errors before trip (default: 5)\r\n * - cooldownMs: How long to wait before testing recovery (default: 5 min)\r\n * - autoReset: Automatically close circuit after successful call (default: true)\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_ERROR_THRESHOLD = 5; // Trip after 5 consecutive errors\r\nconst DEFAULT_COOLDOWN_MS = 5 * 60 * 1000; // 5 minutes\r\nconst MAX_ERROR_HISTORY = 100; // Keep last 100 errors for analysis\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum CircuitState {\r\n  CLOSED = 'CLOSED', // Normal operation\r\n  OPEN = 'OPEN', // Circuit tripped\r\n  HALF_OPEN = 'HALF_OPEN', // Testing recovery\r\n}\r\n\r\nexport interface CircuitBreakerConfig {\r\n  errorThreshold: number; // Consecutive errors before trip\r\n  cooldownMs: number; // Cooldown period when open\r\n  autoReset: boolean; // Auto-close on success\r\n}\r\n\r\nexport interface CircuitBreakerStats {\r\n  state: CircuitState;\r\n  consecutiveErrors: number;\r\n  totalErrors: number;\r\n  totalSuccesses: number;\r\n  lastErrorTime: number | null;\r\n  lastSuccessTime: number | null;\r\n  tripCount: number; // How many times circuit tripped\r\n  tripTime: number | null; // When circuit last tripped\r\n}\r\n\r\n// ============================================================================\r\n// CIRCUIT BREAKER SERVICE\r\n// ============================================================================\r\n\r\nexport class CircuitBreakerService {\r\n  private state: CircuitState = CircuitState.CLOSED;\r\n  private consecutiveErrors: number = 0;\r\n  private totalErrors: number = 0;\r\n  private totalSuccesses: number = 0;\r\n  private lastErrorTime: number | null = null;\r\n  private lastSuccessTime: number | null = null;\r\n  private tripCount: number = 0;\r\n  private tripTime: number | null = null;\r\n  private errorHistory: { timestamp: number; error: string }[] = [];\r\n\r\n  constructor(\r\n    private config: CircuitBreakerConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('[CircuitBreaker] Initialized', {\r\n      errorThreshold: config.errorThreshold,\r\n      cooldownMs: config.cooldownMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if circuit allows operations\r\n   * @returns true if operations are allowed (CLOSED or HALF_OPEN)\r\n   */\r\n  isOpen(): boolean {\r\n    // If circuit is OPEN, check if cooldown period has passed\r\n    if (this.state === CircuitState.OPEN) {\r\n      const now = Date.now();\r\n      const timeSinceTrip = this.tripTime ? now - this.tripTime : 0;\r\n\r\n      if (timeSinceTrip >= this.config.cooldownMs) {\r\n        // Cooldown period passed, move to HALF_OPEN\r\n        this.logger.info('[CircuitBreaker] Moving to HALF_OPEN state', {\r\n          timeSinceTrip,\r\n        });\r\n        this.state = CircuitState.HALF_OPEN;\r\n        return false; // HALF_OPEN still blocks (will allow one test)\r\n      }\r\n\r\n      return true; // Still OPEN\r\n    }\r\n\r\n    return false; // CLOSED or HALF_OPEN\r\n  }\r\n\r\n  /**\r\n   * Record a successful operation\r\n   */\r\n  recordSuccess(): void {\r\n    this.totalSuccesses++;\r\n    this.lastSuccessTime = Date.now();\r\n    this.consecutiveErrors = 0; // Reset consecutive error count\r\n\r\n    if (this.state === CircuitState.HALF_OPEN && this.config.autoReset) {\r\n      // Successful call in HALF_OPEN state ‚Üí close circuit\r\n      this.logger.info('[CircuitBreaker] Recovery successful, closing circuit', {\r\n        totalSuccesses: this.totalSuccesses,\r\n      });\r\n      this.state = CircuitState.CLOSED;\r\n    } else if (this.state === CircuitState.CLOSED) {\r\n      this.logger.debug('[CircuitBreaker] Success recorded', {\r\n        totalSuccesses: this.totalSuccesses,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Record a failed operation\r\n   */\r\n  recordError(error: string | Error): void {\r\n    this.totalErrors++;\r\n    this.consecutiveErrors++;\r\n    this.lastErrorTime = Date.now();\r\n\r\n    const errorMessage = error instanceof Error ? error.message : error;\r\n\r\n    // Add to error history\r\n    this.errorHistory.push({\r\n      timestamp: Date.now(),\r\n      error: errorMessage,\r\n    });\r\n\r\n    // Limit error history size\r\n    if (this.errorHistory.length > MAX_ERROR_HISTORY) {\r\n      this.errorHistory.shift();\r\n    }\r\n\r\n    this.logger.warn('[CircuitBreaker] Error recorded', {\r\n      consecutiveErrors: this.consecutiveErrors,\r\n      error: errorMessage,\r\n    });\r\n\r\n    // Check if threshold reached\r\n    if (this.consecutiveErrors >= this.config.errorThreshold) {\r\n      this.trip();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trip the circuit (move to OPEN state)\r\n   */\r\n  private trip(): void {\r\n    if (this.state === CircuitState.OPEN) {\r\n      return; // Already open\r\n    }\r\n\r\n    this.state = CircuitState.OPEN;\r\n    this.tripCount++;\r\n    this.tripTime = Date.now();\r\n\r\n    this.logger.error('[CircuitBreaker] ‚ö†Ô∏è CIRCUIT TRIPPED - Operations paused', {\r\n      consecutiveErrors: this.consecutiveErrors,\r\n      tripCount: this.tripCount,\r\n      cooldownMs: this.config.cooldownMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Manually close the circuit (reset)\r\n   */\r\n  reset(): void {\r\n    this.logger.info('[CircuitBreaker] Manual reset');\r\n    this.state = CircuitState.CLOSED;\r\n    this.consecutiveErrors = 0;\r\n    this.tripTime = null;\r\n  }\r\n\r\n  /**\r\n   * Get current circuit breaker statistics\r\n   */\r\n  getStats(): CircuitBreakerStats {\r\n    return {\r\n      state: this.state,\r\n      consecutiveErrors: this.consecutiveErrors,\r\n      totalErrors: this.totalErrors,\r\n      totalSuccesses: this.totalSuccesses,\r\n      lastErrorTime: this.lastErrorTime,\r\n      lastSuccessTime: this.lastSuccessTime,\r\n      tripCount: this.tripCount,\r\n      tripTime: this.tripTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get error history\r\n   */\r\n  getErrorHistory(): { timestamp: number; error: string }[] {\r\n    return [...this.errorHistory];\r\n  }\r\n\r\n  /**\r\n   * Get circuit state\r\n   */\r\n  getState(): CircuitState {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Check if cooldown period has passed (circuit can move to HALF_OPEN)\r\n   */\r\n  canAttemptRecovery(): boolean {\r\n    if (this.state !== CircuitState.OPEN) {\r\n      return false;\r\n    }\r\n\r\n    const now = Date.now();\r\n    const timeSinceTrip = this.tripTime ? now - this.tripTime : 0;\r\n    return timeSinceTrip >= this.config.cooldownMs;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\compound-interest-calculator.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.1.","line":162,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":166,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":166,"endColumn":77}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Compound Interest Calculator Service\r\n *\r\n * Calculates position sizes using compound interest logic to automatically\r\n * scale positions based on account profit while protecting base deposit.\r\n *\r\n * Features:\r\n * - Automatic position scaling based on profit\r\n * - Base deposit protection (never fully risked)\r\n * - Profit locking (portion of profit is protected)\r\n * - Configurable reinvestment percentage\r\n * - Risk limits per trade\r\n *\r\n * Example Usage:\r\n * ```typescript\r\n * const calculator = new CompoundInterestCalculatorService(config, logger, bybitService);\r\n * const result = await calculator.calculatePositionSize();\r\n * console.log(`Position size: ${result.positionSize} USDT`);\r\n * ```\r\n */\r\n\r\nimport { CompoundInterestConfig, LoggerService } from '../types';\r\nimport {\r\n  calculateCompoundPositionSize,\r\n  validateCompoundConfig,\r\n  CompoundCalculationResult,\r\n} from '../utils/compound-interest.helpers';\r\n\r\nexport class CompoundInterestCalculatorService {\r\n  constructor(\r\n    private config: CompoundInterestConfig,\r\n    private logger: LoggerService,\r\n    private getBalance: () => Promise<number>, // Function to get current balance from exchange\r\n  ) {\r\n    // Validate config on initialization\r\n    try {\r\n      validateCompoundConfig(config);\r\n      this.logger.info('‚úÖ CompoundInterestCalculator initialized', {\r\n        enabled: config.enabled,\r\n        baseDeposit: config.baseDeposit,\r\n        reinvestmentPercent: config.reinvestmentPercent,\r\n        profitLockPercent: config.profitLockPercent,\r\n        minSize: config.minPositionSize,\r\n        maxSize: config.maxPositionSize,\r\n      });\r\n    } catch (error: unknown) {\r\n      this.logger.error('‚ùå Invalid CompoundInterest config', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate position size based on current balance and compound interest rules\r\n   *\r\n   * @returns Calculation result with position size and breakdown\r\n   */\r\n  async calculatePositionSize(): Promise<CompoundCalculationResult> {\r\n    try {\r\n      // Get current balance from exchange\r\n      const currentBalance = await this.getBalance();\r\n\r\n      this.logger.debug('Calculating compound position size', {\r\n        currentBalance,\r\n        baseDeposit: this.config.baseDeposit,\r\n      });\r\n\r\n      // Calculate using helpers\r\n      const result = calculateCompoundPositionSize(currentBalance, this.config);\r\n\r\n      // Log result\r\n      this.logCalculationResult(result);\r\n\r\n      return result;\r\n    } catch (error: unknown) {\r\n      this.logger.error('Error calculating compound position size', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  getConfig(): CompoundInterestConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update configuration (useful for dynamic adjustments)\r\n   *\r\n   * @param newConfig - New configuration\r\n   */\r\n  updateConfig(newConfig: Partial<CompoundInterestConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n\r\n    try {\r\n      validateCompoundConfig(this.config);\r\n      this.logger.info('‚úÖ CompoundInterest config updated', {\r\n        enabled: this.config.enabled,\r\n        reinvestmentPercent: this.config.reinvestmentPercent,\r\n      });\r\n    } catch (error: unknown) {\r\n      this.logger.error('‚ùå Invalid config update', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if compound interest is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get position size without making API call (for testing/simulation)\r\n   *\r\n   * @param currentBalance - Balance to use for calculation\r\n   * @returns Calculation result\r\n   */\r\n  calculatePositionSizeSync(currentBalance: number): CompoundCalculationResult {\r\n    return calculateCompoundPositionSize(currentBalance, this.config);\r\n  }\r\n\r\n  /**\r\n   * Estimate future position size after a profit/loss\r\n   *\r\n   * @param currentBalance - Current balance\r\n   * @param estimatedPnL - Expected profit or loss\r\n   * @returns Estimated position size after PnL\r\n   */\r\n  estimateFuturePositionSize(currentBalance: number, estimatedPnL: number): number {\r\n    const futureBalance = currentBalance + estimatedPnL;\r\n    const result = calculateCompoundPositionSize(futureBalance, this.config);\r\n    return result.positionSize;\r\n  }\r\n\r\n  /**\r\n   * Calculate potential growth from current position\r\n   *\r\n   * @param currentBalance - Current balance\r\n   * @returns Growth metrics\r\n   */\r\n  calculateGrowthMetrics(currentBalance: number): {\r\n    currentSize: number;\r\n    profitToNextLevel: number; // How much profit needed to increase position by 10%\r\n    maxPossibleSize: number;\r\n    growthFactor: number; // Current size / min size\r\n  } {\r\n    const currentResult = calculateCompoundPositionSize(currentBalance, this.config);\r\n\r\n    // Calculate profit needed for 10% position increase\r\n    const targetSize = currentResult.positionSize * 1.1;\r\n    let profitNeeded = 0;\r\n\r\n    // Binary search for required profit\r\n    for (let profit = 0; profit < this.config.maxPositionSize; profit += 0.1) {\r\n      const testBalance = currentBalance + profit;\r\n      const testResult = calculateCompoundPositionSize(testBalance, this.config);\r\n      if (testResult.positionSize >= targetSize) {\r\n        profitNeeded = profit;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return {\r\n      currentSize: currentResult.positionSize,\r\n      profitToNextLevel: profitNeeded,\r\n      maxPossibleSize: this.config.maxPositionSize,\r\n      growthFactor: currentResult.positionSize / this.config.minPositionSize,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE METHODS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Log calculation result with appropriate level\r\n   */\r\n  private logCalculationResult(result: CompoundCalculationResult): void {\r\n    const {\r\n      positionSize,\r\n      currentBalance,\r\n      totalProfit,\r\n      lockedProfit,\r\n      protectionActive,\r\n      limitApplied,\r\n    } = result;\r\n\r\n    const logData = {\r\n      positionSize: positionSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n      currentBalance: currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      totalProfit: totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\r\n      lockedProfit: lockedProfit.toFixed(DECIMAL_PLACES.PERCENT),\r\n      protectionActive,\r\n      limitApplied,\r\n      growthFactor: (positionSize / this.config.minPositionSize).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n    };\r\n\r\n    if (protectionActive) {\r\n      this.logger.warn('üõ°Ô∏è Deposit protection ACTIVE', logData);\r\n    } else if (limitApplied !== 'none') {\r\n      this.logger.info(`‚ö†Ô∏è Position limit applied: ${limitApplied}`, logData);\r\n    } else {\r\n      this.logger.debug('üí∞ Compound position calculated', logData);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\confirmation-filter.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":38,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":38,"endColumn":54,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1054,1099],"text":"(this.config.strategy.btcConfirmation?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1054,1099],"text":"(this.config.strategy.btcConfirmation?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":62,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":62,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1841,1858],"text":"(this.btcAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":62,"column":31,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":62,"endColumn":76,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1863,1908],"text":"((this.config.strategy.btcConfirmation?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[1862,1908],"text":"((this.config.strategy.btcConfirmation?.enabled) === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":73,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":73,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2141,2153],"text":"btcAnalysis == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":128,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":128,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3926,3943],"text":"(this.btcAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":128,"column":31,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":128,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3947,3984],"text":"(this.config.strategy.btcConfirmation == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":148,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":148,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":155,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":155,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4724,4748],"text":"btcConfig.useCorrelation ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4724,4748],"text":"btcConfig.useCorrelation === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":157,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":157,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4804,4831],"text":"(btcConfig.correlationPeriod != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4804,4831],"text":"(btcConfig.correlationPeriod ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4804,4831],"text":"(Boolean(btcConfig.correlationPeriod))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":157,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":157,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4832,4834],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":157,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":157,"endColumn":70}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Confirmation Filter Service\r\n *\r\n * Filters signals based on BTC confirmation:\r\n * - Fetches BTC candles\r\n * - Analyzes BTC direction/momentum\r\n * - Checks alignment with signal direction\r\n * - Returns confirmation result\r\n *\r\n * Extracted from SignalGeneratorService for better testability.\r\n */\r\n\r\nimport {\r\n  SignalDirection,\r\n  Config,\r\n  Candle,\r\n  LoggerService,\r\n  ConfirmationResult,\r\n  BTCAnalysis,\r\n} from '../types';\r\nimport { BTCAnalyzer } from '../analyzers/btc.analyzer';\r\nimport { BybitService } from './bybit';\r\n\r\n// ============================================================================\r\n// CONFIRMATION FILTER SERVICE\r\n// ============================================================================\r\n\r\nexport class ConfirmationFilter {\r\n  private btcAnalyzer: BTCAnalyzer | null = null;\r\n\r\n  constructor(\r\n    private bybitService: BybitService,\r\n    private config: Config,\r\n    private logger: LoggerService,\r\n  ) {\r\n    // Initialize BTC analyzer if enabled\r\n    if (this.config.strategy.btcConfirmation?.enabled) {\r\n      this.btcAnalyzer = new BTCAnalyzer(\r\n        this.config.strategy.btcConfirmation,\r\n        this.logger,\r\n      );\r\n      this.logger.info('BTC confirmation filter enabled', {\r\n        symbol: this.config.strategy.btcConfirmation.symbol,\r\n        timeframe: this.config.strategy.btcConfirmation.timeframe,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Confirm signal based on BTC analysis\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param altSymbol - Altcoin symbol for correlation\r\n   * @returns Confirmation result with BTC analysis\r\n   */\r\n  async confirm(\r\n    direction: SignalDirection,\r\n    altSymbol: string,\r\n  ): Promise<ConfirmationResult> {\r\n    // If BTC confirmation disabled, always confirm\r\n    if (!this.btcAnalyzer || !this.config.strategy.btcConfirmation?.enabled) {\r\n      return {\r\n        shouldConfirm: true,\r\n        reason: 'BTC confirmation disabled',\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Analyze BTC\r\n      const btcAnalysis = await this.analyzeBTC(direction, altSymbol);\r\n\r\n      if (!btcAnalysis) {\r\n        // If BTC analysis fails, fail-open (allow signal)\r\n        this.logger.warn('BTC analysis failed, allowing signal (fail-open)');\r\n        return {\r\n          shouldConfirm: true,\r\n          reason: 'BTC analysis failed (fail-open)',\r\n        };\r\n      }\r\n\r\n      // Check if BTC confirms the signal\r\n      const shouldConfirm = this.btcAnalyzer.shouldConfirm(btcAnalysis);\r\n\r\n      if (shouldConfirm) {\r\n        this.logger.info('‚úÖ BTC confirmation PASSED', {\r\n          direction,\r\n          btcDirection: btcAnalysis.direction,\r\n          btcMomentum: `${(btcAnalysis.momentum * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          isAligned: btcAnalysis.isAligned,\r\n        });\r\n      } else {\r\n        this.logger.info('‚ùå BTC confirmation FAILED - signal blocked', {\r\n          direction,\r\n          btcDirection: btcAnalysis.direction,\r\n          btcMomentum: `${(btcAnalysis.momentum * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n          isAligned: btcAnalysis.isAligned,\r\n          reason: btcAnalysis.reason,\r\n        });\r\n      }\r\n\r\n      return {\r\n        shouldConfirm,\r\n        btcAnalysis,\r\n        reason: btcAnalysis.reason,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error in confirmation filter', { error });\r\n      // Fail-open on error\r\n      return {\r\n        shouldConfirm: true,\r\n        reason: 'Error in BTC confirmation (fail-open)',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze BTC movement for signal confirmation\r\n   *\r\n   * @param signalDirection - Direction of the altcoin signal\r\n   * @param altSymbol - Altcoin symbol for correlation\r\n   * @returns BTC analysis or null if failed\r\n   */\r\n  private async analyzeBTC(\r\n    signalDirection: SignalDirection,\r\n    altSymbol: string,\r\n  ): Promise<BTCAnalysis | null> {\r\n    if (!this.btcAnalyzer || !this.config.strategy.btcConfirmation) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const btcConfig = this.config.strategy.btcConfirmation;\r\n\r\n      // Fetch BTC candles\r\n      this.logger.debug('Fetching BTC candles', {\r\n        symbol: btcConfig.symbol,\r\n        timeframe: btcConfig.timeframe,\r\n        limit: btcConfig.candleLimit,\r\n      });\r\n\r\n      const btcCandles = await this.bybitService.getCandles(\r\n        btcConfig.symbol,\r\n        btcConfig.timeframe,\r\n        btcConfig.candleLimit,\r\n      );\r\n\r\n      if (!btcCandles || btcCandles.length === 0) {\r\n        this.logger.warn('Failed to fetch BTC candles');\r\n        return null;\r\n      }\r\n\r\n      // Fetch altcoin candles for correlation (if enabled)\r\n      let altCandles: Candle[] | undefined;\r\n      if (btcConfig.useCorrelation) {\r\n        try {\r\n          const correlationPeriod = btcConfig.correlationPeriod || 50;\r\n          altCandles = await this.bybitService.getCandles(\r\n            altSymbol,\r\n            btcConfig.timeframe,\r\n            correlationPeriod,\r\n          );\r\n        } catch (error) {\r\n          this.logger.warn('Failed to fetch altcoin candles for correlation', { error });\r\n        }\r\n      }\r\n\r\n      // Analyze BTC\r\n      const analysis = this.btcAnalyzer.analyze(btcCandles, signalDirection, altCandles);\r\n\r\n      return analysis;\r\n    } catch (error) {\r\n      this.logger.error('Error analyzing BTC', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\daily-limits.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":69,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":69,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2124,2157],"text":"(this.config.maxDailyProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2124,2157],"text":"(this.config.maxDailyProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2124,2157],"text":"(Boolean(this.config.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":129,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":129,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4052,4085],"text":"(this.config.maxDailyProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4052,4085],"text":"(this.config.maxDailyProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4052,4085],"text":"(Boolean(this.config.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":165,"column":36,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":165,"endColumn":69,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5355,5388],"text":"(this.config.maxDailyProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5355,5388],"text":"(this.config.maxDailyProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5355,5388],"text":"(Boolean(this.config.maxDailyProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Daily Limits Service (PHASE 5)\r\n *\r\n * Protects capital by stopping trading after hitting daily loss limit or profit target.\r\n *\r\n * Features:\r\n * - Daily loss limit (e.g., -5% of starting balance)\r\n * - Daily profit target (optional, e.g., +5% of starting balance)\r\n * - Automatic reset at specified UTC time\r\n * - Emergency stop option (completely halt bot)\r\n *\r\n * Usage:\r\n * 1. Initialize with starting balance at bot startup\r\n * 2. Call onTradeClose() after each trade closes\r\n * 3. Check canTrade() before opening new positions\r\n * 4. System automatically resets stats on new day\r\n */\r\n\r\nimport { DailyLimitsConfig, DailyStats, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// DAILY LIMITS SERVICE\r\n// ============================================================================\r\n\r\nexport class DailyLimitsService {\r\n  private stats: DailyStats;\r\n\r\n  constructor(\r\n    private config: DailyLimitsConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.stats = this.initStats();\r\n  }\r\n\r\n  /**\r\n   * Initialize daily stats\r\n   * @returns New DailyStats object for today\r\n   */\r\n  private initStats(): DailyStats {\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    return {\r\n      date: today,\r\n      startingBalance: 0, // Will be set via setStartingBalance()\r\n      currentBalance: 0,\r\n      realizedPnL: 0,\r\n      maxLossHit: false,\r\n      maxProfitHit: false,\r\n      tradesCount: 0,\r\n      lastResetTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set starting balance for the day\r\n   * Should be called once at bot startup\r\n   *\r\n   * @param balance - Current account balance\r\n   */\r\n  setStartingBalance(balance: number): void {\r\n    this.stats.startingBalance = balance;\r\n    this.stats.currentBalance = balance;\r\n\r\n    this.logger.info('üìä Daily limits initialized (PHASE 5)', {\r\n      date: this.stats.date,\r\n      startingBalance: balance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      maxLoss: `-${this.config.maxDailyLossPercent}%`,\r\n      maxProfit: this.config.maxDailyProfitPercent\r\n        ? `+${this.config.maxDailyProfitPercent}%`\r\n        : 'disabled',\r\n      emergencyStop: this.config.emergencyStopOnLimit,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update stats after trade close\r\n   * Call this after each position closes\r\n   *\r\n   * @param pnl - Realized PnL from the trade\r\n   * @param newBalance - New account balance after trade\r\n   */\r\n  onTradeClose(pnl: number, newBalance: number): void {\r\n    this.stats.currentBalance = newBalance;\r\n    this.stats.realizedPnL += pnl;\r\n    this.stats.tradesCount++;\r\n\r\n    this.logger.debug('Daily limits updated', {\r\n      pnl: pnl.toFixed(DECIMAL_PLACES.PERCENT),\r\n      totalPnL: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n      balance: newBalance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      tradesCount: this.stats.tradesCount,\r\n    });\r\n\r\n    this.checkLimits();\r\n  }\r\n\r\n  /**\r\n   * Check if daily limits exceeded\r\n   * Triggers emergency stop if configured\r\n   */\r\n  private checkLimits(): void {\r\n    if (this.stats.startingBalance === 0) {\r\n      this.logger.warn('Starting balance not set - cannot check limits');\r\n      return;\r\n    }\r\n\r\n    const pnlPercent = (this.stats.realizedPnL / this.stats.startingBalance) * PERCENT_MULTIPLIER;\r\n\r\n    // Check loss limit\r\n    if (pnlPercent <= -this.config.maxDailyLossPercent) {\r\n      this.stats.maxLossHit = true;\r\n\r\n      this.logger.error('üõë DAILY LOSS LIMIT HIT! (PHASE 5)', {\r\n        pnl: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        limit: `-${this.config.maxDailyLossPercent}%`,\r\n        tradesCount: this.stats.tradesCount,\r\n      });\r\n\r\n      if (this.config.emergencyStopOnLimit) {\r\n        this.logger.error('‚õî EMERGENCY STOP - Bot shutting down to protect capital');\r\n        process.exit(1); // Stop bot\r\n      }\r\n    }\r\n\r\n    // Check profit target\r\n    if (\r\n      this.config.maxDailyProfitPercent &&\r\n      pnlPercent >= this.config.maxDailyProfitPercent\r\n    ) {\r\n      this.stats.maxProfitHit = true;\r\n\r\n      this.logger.info('‚úÖ DAILY PROFIT TARGET HIT! (PHASE 5)', {\r\n        pnl: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        target: `+${this.config.maxDailyProfitPercent}%`,\r\n        tradesCount: this.stats.tradesCount,\r\n      });\r\n\r\n      if (this.config.emergencyStopOnLimit) {\r\n        this.logger.info('üéØ Profit target reached - Bot shutting down (success)');\r\n        process.exit(0); // Stop bot (success)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if trading allowed\r\n   * Call before opening new positions\r\n   *\r\n   * @returns Object with allowed flag and optional reason for blocking\r\n   */\r\n  canTrade(): { allowed: boolean; reason?: string } {\r\n    // Check if need reset (new day)\r\n    this.checkReset();\r\n\r\n    if (this.stats.maxLossHit) {\r\n      return {\r\n        allowed: false,\r\n        reason: `Daily loss limit hit (${this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT)} USDT, ${((this.stats.realizedPnL / this.stats.startingBalance) * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT)}%)`,\r\n      };\r\n    }\r\n\r\n    if (this.stats.maxProfitHit && this.config.maxDailyProfitPercent) {\r\n      return {\r\n        allowed: false,\r\n        reason: `Daily profit target hit (+${this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT)} USDT, +${((this.stats.realizedPnL / this.stats.startingBalance) * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT)}%)`,\r\n      };\r\n    }\r\n\r\n    return { allowed: true };\r\n  }\r\n\r\n  /**\r\n   * Check if need to reset stats (new day)\r\n   * Automatically called in canTrade()\r\n   */\r\n  private checkReset(): void {\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    if (this.stats.date !== today) {\r\n      this.logger.info('üîÑ Daily limits reset (new day) (PHASE 5)', {\r\n        previousDate: this.stats.date,\r\n        previousPnL: this.stats.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        trades: this.stats.tradesCount,\r\n        maxLossHit: this.stats.maxLossHit,\r\n        maxProfitHit: this.stats.maxProfitHit,\r\n      });\r\n\r\n      this.stats = this.initStats();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current daily stats\r\n   * @returns Copy of current stats\r\n   */\r\n  getStats(): DailyStats {\r\n    return { ...this.stats };\r\n  }\r\n\r\n  /**\r\n   * Manually reset stats (for testing)\r\n   * Should not be used in production\r\n   */\r\n  reset(): void {\r\n    this.logger.warn('‚ö†Ô∏è Daily limits manually reset');\r\n    this.stats = this.initStats();\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\data-collector.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ParsedMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RECONNECT_DELAY_MS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":36,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":113,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":113,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3777,3785],"text":"this.db == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":183,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":183,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5937,5956],"text":"this.databaseWriter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":203,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":203,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6415,6437],"text":"this.orderbookInterval != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":209,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":209,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6600,6619],"text":"this.databaseWriter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":219,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":219,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":222,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":222,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7019,7026],"text":"this.ws != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":228,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":228,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7118,7125],"text":"this.db != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":255,"column":26,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":267,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":264,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":264,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8001,8008],"text":"this.ws != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-base-to-string","severity":2,"message":"'data' may evaluate to '[object Object]' when stringified.","line":271,"column":37,"nodeType":"Identifier","messageId":"baseToString","endLine":271,"endColumn":41},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":278,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":287,"endColumn":8},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'subscribeToStreams' has no 'await' expression.","line":300,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":300,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":301,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":301,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9091,9099],"text":"(this.ws == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'handleWebSocketMessage' has a complexity of 13. Maximum allowed is 10.","line":344,"column":33,"nodeType":"FunctionExpression","messageId":"complex","endLine":413,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":348,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":348,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10508,10515],"text":"parsed == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":368,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":368,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10986,10993],"text":"this.ws != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":445,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":445,"endColumn":34},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (356). Maximum allowed is 300.","line":448,"column":1,"nodeType":null,"messageId":"exceed","endLine":525,"endColumn":1},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'scheduleReconnect' has no 'await' expression.","line":453,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":453,"endColumn":34},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":470,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":470,"endColumn":31,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[13921,13921],"text":"void "},"desc":"Add void operator to ignore."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":486,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":486,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[14290,14304],"text":"(map[timeframe].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[14290,14304],"text":"(map[timeframe] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14290,14304],"text":"(Boolean(map[timeframe]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":497,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":497,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14500,14508],"text":"this.db == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":501,"column":26,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":503,"endColumn":18,"fix":{"range":[14659,14708],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":504,"column":28,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":506,"endColumn":18,"fix":{"range":[14810,14859],"text":""}},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":507,"column":25,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":509,"endColumn":18,"fix":{"range":[14950,14999],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":512,"column":16,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":512,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15033,15052],"text":"((candlesCount?.count) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15033,15052],"text":"((candlesCount?.count) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15033,15052],"text":"(Boolean((candlesCount?.count)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":512,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":512,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15053,15055],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":513,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":513,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15087,15108],"text":"((orderbookCount?.count) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15087,15108],"text":"((orderbookCount?.count) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15087,15108],"text":"(Boolean((orderbookCount?.count)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":513,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":513,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15109,15111],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":514,"column":20,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":514,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15135,15153],"text":"((tradesCount?.count) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15135,15153],"text":"((tradesCount?.count) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15135,15153],"text":"(Boolean((tradesCount?.count)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":514,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":514,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15154,15156],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":31,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\r\n * Data Collector Service (Refactored)\r\n *\r\n * Standalone service for collecting real-time market data for backtesting.\r\n * Collects: candles (multiple timeframes), orderbook snapshots, trade ticks.\r\n *\r\n * REFACTORED: Decomposed into separate components to prevent blocking.\r\n * - WebSocketReceiver: Parse messages (NO AWAIT)\r\n * - DataQueue: In-memory queues with memory limits\r\n * - DatabaseWriter: Batch INSERT operations\r\n * - PingPongHandler: Ping/pong handling\r\n *\r\n * NO TRADING LOGIC - data collection only!\r\n */\r\n\r\nimport sqlite3 from 'sqlite3';\r\nimport { open, Database } from 'sqlite';\r\nimport WebSocket from 'ws';\r\nimport {\r\n  DataCollectionConfig,\r\n  OrderbookSnapshot,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// Import decomposed components\r\nimport { PingPongHandler } from './data-collector/ping-pong.handler';\r\nimport { DataQueue } from './data-collector/data-queue';\r\nimport { DatabaseWriter } from './data-collector/database-writer';\r\nimport { WebSocketReceiver, ParsedMessage } from './data-collector/websocket-receiver';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BYBIT_WS_PUBLIC = 'wss://stream.bybit.com/v5/public/linear';\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst ORDERBOOK_SNAPSHOT_INTERVAL_MS = 5000; // 5s instead of 1s (reduce load)\r\n\r\n// ============================================================================\r\n// SERVICE\r\n// ============================================================================\r\n\r\nexport class DataCollectorService {\r\n  private db: Database | null = null;\r\n  private ws: WebSocket | null = null;\r\n  private orderbookInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts = 0;\r\n  private isConnecting = false;\r\n  private isStopping = false;\r\n\r\n  // Latest orderbook snapshots (in memory)\r\n  private latestOrderbooks: Map<string, { bids: Array<[string, string]>; asks: Array<[string, string]> }> =\r\n    new Map();\r\n\r\n  // Decomposed components\r\n  private pingPongHandler: PingPongHandler;\r\n  private dataQueue: DataQueue;\r\n  private databaseWriter: DatabaseWriter | null = null;\r\n  private receiver: WebSocketReceiver;\r\n\r\n  constructor(\r\n    private config: DataCollectionConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    // Initialize components\r\n    this.pingPongHandler = new PingPongHandler(logger);\r\n    this.dataQueue = new DataQueue(logger);\r\n    this.receiver = new WebSocketReceiver(logger);\r\n  }\r\n\r\n  /**\r\n   * Initialize database and create tables\r\n   */\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      this.logger.info('Initializing Data Collector (Multi-Symbol)', {\r\n        symbols: this.config.symbols,\r\n        symbolCount: this.config.symbols.length,\r\n        timeframes: this.config.timeframes,\r\n        orderbookInterval: this.config.orderbookInterval + 's',\r\n        compression: this.config.database.compression,\r\n      });\r\n\r\n      // Open SQLite database\r\n      this.db = await open({\r\n        filename: this.config.database.path,\r\n        driver: sqlite3.Database,\r\n      });\r\n\r\n      // Create tables\r\n      await this.createTables();\r\n\r\n      // Initialize DatabaseWriter\r\n      this.databaseWriter = new DatabaseWriter(\r\n        this.db,\r\n        this.logger,\r\n        this.config.database.compression,\r\n      );\r\n\r\n      this.logger.info('Database initialized', { path: this.config.database.path });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize database', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create database tables with indexes\r\n   */\r\n  private async createTables(): Promise<void> {\r\n    if (!this.db) {\r\n      throw new Error('Database not initialized');\r\n    }\r\n\r\n    // Candles table\r\n    await this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS candles (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        symbol TEXT NOT NULL,\r\n        timeframe TEXT NOT NULL,\r\n        timestamp INTEGER NOT NULL,\r\n        open REAL NOT NULL,\r\n        high REAL NOT NULL,\r\n        low REAL NOT NULL,\r\n        close REAL NOT NULL,\r\n        volume REAL NOT NULL,\r\n        createdAt INTEGER NOT NULL\r\n      );\r\n      CREATE INDEX IF NOT EXISTS idx_candles_symbol_timeframe_timestamp\r\n        ON candles(symbol, timeframe, timestamp);\r\n      CREATE UNIQUE INDEX IF NOT EXISTS idx_candles_unique\r\n        ON candles(symbol, timeframe, timestamp);\r\n    `);\r\n\r\n    // Orderbook snapshots table (with compression)\r\n    await this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS orderbook_snapshots (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        symbol TEXT NOT NULL,\r\n        timestamp INTEGER NOT NULL,\r\n        bids BLOB NOT NULL,\r\n        asks BLOB NOT NULL,\r\n        createdAt INTEGER NOT NULL\r\n      );\r\n      CREATE INDEX IF NOT EXISTS idx_orderbook_symbol_timestamp\r\n        ON orderbook_snapshots(symbol, timestamp);\r\n    `);\r\n\r\n    // Trade ticks table\r\n    await this.db.exec(`\r\n      CREATE TABLE IF NOT EXISTS trade_ticks (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        symbol TEXT NOT NULL,\r\n        timestamp INTEGER NOT NULL,\r\n        price REAL NOT NULL,\r\n        size REAL NOT NULL,\r\n        side TEXT NOT NULL,\r\n        createdAt INTEGER NOT NULL\r\n      );\r\n      CREATE INDEX IF NOT EXISTS idx_trade_ticks_symbol_timestamp\r\n        ON trade_ticks(symbol, timestamp);\r\n    `);\r\n\r\n    this.logger.info('Database tables created');\r\n  }\r\n\r\n  /**\r\n   * Start collecting data (connect WebSocket + start intervals)\r\n   */\r\n  async start(): Promise<void> {\r\n    this.logger.info('Starting Data Collector...');\r\n\r\n    await this.connectWebSocket();\r\n\r\n    // Start orderbook snapshot interval (if enabled)\r\n    if (this.config.collectOrderbook) {\r\n      this.startOrderbookSnapshotInterval();\r\n    }\r\n\r\n    // Start database writer\r\n    if (this.databaseWriter) {\r\n      this.databaseWriter.start(\r\n        () => this.dataQueue.drainCandles(),\r\n        () => this.dataQueue.drainOrderbooks(),\r\n        () => this.dataQueue.drainTicks(),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop collecting data\r\n   */\r\n  async stop(): Promise<void> {\r\n    this.logger.info('Stopping Data Collector...');\r\n    this.isStopping = true;\r\n\r\n    // Stop ping/pong\r\n    this.pingPongHandler.stop();\r\n\r\n    // Stop orderbook interval\r\n    if (this.orderbookInterval) {\r\n      clearInterval(this.orderbookInterval);\r\n      this.orderbookInterval = null;\r\n    }\r\n\r\n    // Stop database writer (will flush remaining data)\r\n    if (this.databaseWriter) {\r\n      await this.databaseWriter.stop(\r\n        () => this.dataQueue.drainCandles(),\r\n        () => this.dataQueue.drainOrderbooks(),\r\n        () => this.dataQueue.drainTicks(),\r\n      );\r\n    }\r\n\r\n    // Wait for any pending operations\r\n    this.logger.info('Waiting for pending operations...');\r\n    await new Promise((resolve) => setTimeout(resolve, 1000));\r\n\r\n    // Close WebSocket\r\n    if (this.ws) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n\r\n    // Close database\r\n    if (this.db) {\r\n      await this.db.close();\r\n      this.db = null;\r\n    }\r\n\r\n    // Clear queues\r\n    this.dataQueue.clear();\r\n\r\n    this.logger.info('Data Collector stopped');\r\n  }\r\n\r\n  /**\r\n   * Connect to Bybit WebSocket and subscribe to streams\r\n   */\r\n  private async connectWebSocket(): Promise<void> {\r\n    if (this.isConnecting) {\r\n      return;\r\n    }\r\n    this.isConnecting = true;\r\n\r\n    try {\r\n      this.logger.info('Connecting to Bybit WebSocket...', { url: BYBIT_WS_PUBLIC });\r\n\r\n      this.ws = new WebSocket(BYBIT_WS_PUBLIC, {\r\n        handshakeTimeout: 10000,\r\n      });\r\n\r\n      this.ws.on('open', async () => {\r\n        this.logger.info('WebSocket connected');\r\n        this.reconnectAttempts = 0;\r\n        this.isConnecting = false;\r\n\r\n        // Subscribe to all streams\r\n        await this.subscribeToStreams();\r\n\r\n        // Start ping/pong handler\r\n        if (this.ws) {\r\n          this.pingPongHandler.start(this.ws);\r\n        }\r\n      });\r\n\r\n      // CRITICAL FIX: Remove await from message handler (fire-and-forget)\r\n      this.ws.on('message', (data: WebSocket.Data) => {\r\n        this.handleWebSocketMessage(data.toString()); // NO AWAIT!\r\n      });\r\n\r\n      this.ws.on('error', (error) => {\r\n        this.logger.error('WebSocket error', { error: error.message });\r\n      });\r\n\r\n      this.ws.on('close', async () => {\r\n        this.logger.warn('WebSocket closed');\r\n        this.isConnecting = false;\r\n\r\n        // Stop ping/pong\r\n        this.pingPongHandler.stop();\r\n\r\n        // Reconnect\r\n        await this.scheduleReconnect();\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to connect WebSocket', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      this.isConnecting = false;\r\n      await this.scheduleReconnect();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe to all configured streams (candles, orderbook, trades)\r\n   */\r\n  private async subscribeToStreams(): Promise<void> {\r\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    const subscriptions: string[] = [];\r\n\r\n    // Subscribe to all symbols\r\n    for (const symbol of this.config.symbols) {\r\n      // Subscribe to candles (kline) for all timeframes\r\n      for (const timeframe of this.config.timeframes) {\r\n        const numericInterval = this.toNumericInterval(timeframe);\r\n        subscriptions.push(`kline.${numericInterval}.${symbol}`);\r\n      }\r\n\r\n      // Subscribe to orderbook (50 levels)\r\n      if (this.config.collectOrderbook) {\r\n        subscriptions.push(`orderbook.50.${symbol}`);\r\n      }\r\n\r\n      // Subscribe to trade ticks\r\n      if (this.config.collectTradeTicks) {\r\n        subscriptions.push(`publicTrade.${symbol}`);\r\n      }\r\n    }\r\n\r\n    // Send subscription message\r\n    const subscribeMsg = {\r\n      op: 'subscribe',\r\n      args: subscriptions,\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeMsg));\r\n\r\n    this.logger.info('Subscribed to streams', {\r\n      symbols: this.config.symbols,\r\n      totalSubscriptions: subscriptions.length,\r\n      subscriptionsPerSymbol: subscriptions.length / this.config.symbols.length,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle WebSocket message (NO AWAIT - fire-and-forget)\r\n   */\r\n  private handleWebSocketMessage(data: string): void {\r\n    // Parse message (synchronous operation)\r\n    const parsed = this.receiver.parseMessage(data);\r\n\r\n    if (!parsed) {\r\n      return;\r\n    }\r\n\r\n    // Handle different message types\r\n    switch (parsed.type) {\r\n    case 'subscription':\r\n      if (parsed.success) {\r\n        this.logger.info('‚úÖ Subscription confirmed', {\r\n          conn_id: parsed.conn_id,\r\n        });\r\n      } else {\r\n        this.logger.error('‚ùå Subscription failed', {\r\n          ret_msg: parsed.ret_msg,\r\n          conn_id: parsed.conn_id,\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'server-ping':\r\n      if (this.ws) {\r\n        this.pingPongHandler.handleServerPing(this.ws, { op: 'ping', args: parsed.args });\r\n      }\r\n      break;\r\n\r\n    case 'pong':\r\n      this.pingPongHandler.handlePong({ op: parsed.op });\r\n      break;\r\n\r\n    case 'candle':\r\n      // Add to queue (NO AWAIT!)\r\n      this.dataQueue.addCandle(parsed.candle);\r\n\r\n      // Log 1m candles for monitoring\r\n      if (parsed.candle.timeframe === '1m') {\r\n        this.logger.info('üïê 1m Candle received', {\r\n          symbol: parsed.candle.symbol,\r\n          timestamp: new Date(parsed.candle.timestamp).toISOString(),\r\n          close: parsed.candle.close,\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'orderbook':\r\n      // Store latest orderbook in memory (will be saved by interval)\r\n      this.latestOrderbooks.set(parsed.symbol, {\r\n        bids: parsed.bids,\r\n        asks: parsed.asks,\r\n      });\r\n      break;\r\n\r\n    case 'trade-ticks':\r\n      // Add ticks to queue (NO AWAIT!)\r\n      for (const tick of parsed.ticks) {\r\n        this.dataQueue.addTick(tick);\r\n      }\r\n      break;\r\n\r\n    case 'unhandled':\r\n      this.logger.warn('‚ö†Ô∏è Unhandled message', {\r\n        op: parsed.op,\r\n        keys: parsed.keys,\r\n      });\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start orderbook snapshot interval (save every N seconds)\r\n   */\r\n  private startOrderbookSnapshotInterval(): void {\r\n    const intervalMs = ORDERBOOK_SNAPSHOT_INTERVAL_MS;\r\n\r\n    this.orderbookInterval = setInterval(() => {\r\n      // Add orderbook snapshots to queue (NO AWAIT!)\r\n      for (const [symbol, orderbook] of this.latestOrderbooks) {\r\n        const snapshot: OrderbookSnapshot = {\r\n          symbol: symbol,\r\n          timestamp: Date.now(),\r\n          bids: JSON.stringify(orderbook.bids),\r\n          asks: JSON.stringify(orderbook.asks),\r\n          createdAt: Date.now(),\r\n        };\r\n\r\n        this.dataQueue.addOrderbook(snapshot);\r\n      }\r\n\r\n      // Log stats\r\n      if (this.latestOrderbooks.size > 0) {\r\n        this.logger.debug('Orderbook snapshots queued', {\r\n          symbols: Array.from(this.latestOrderbooks.keys()),\r\n          count: this.latestOrderbooks.size,\r\n        });\r\n      }\r\n    }, intervalMs);\r\n\r\n    this.logger.info('Orderbook snapshot interval started', {\r\n      interval: intervalMs / 1000 + 's',\r\n      symbols: this.config.symbols,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Schedule reconnect with exponential backoff\r\n   */\r\n  private async scheduleReconnect(): Promise<void> {\r\n    if (this.reconnectAttempts >= this.config.websocket.maxReconnectAttempts) {\r\n      this.logger.error('Max reconnect attempts reached', {\r\n        attempts: this.reconnectAttempts,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.reconnectAttempts++;\r\n    const delay = this.config.websocket.reconnectDelay * this.reconnectAttempts;\r\n\r\n    this.logger.info('Scheduling reconnect', {\r\n      attempt: this.reconnectAttempts,\r\n      delay: delay + 'ms',\r\n    });\r\n\r\n    setTimeout(() => {\r\n      this.connectWebSocket();\r\n    }, delay);\r\n  }\r\n\r\n  /**\r\n   * Convert timeframe to numeric interval for Bybit v5 subscriptions\r\n   */\r\n  private toNumericInterval(timeframe: string): string {\r\n    const map: Record<string, string> = {\r\n      '1m': '1',\r\n      '5m': '5',\r\n      '15m': '15',\r\n      '30m': '30',\r\n      '1h': '60',\r\n      '4h': '240',\r\n    };\r\n    return map[timeframe] || timeframe;\r\n  }\r\n\r\n  /**\r\n   * Get database statistics\r\n   */\r\n  async getStats(): Promise<{\r\n    candles: number;\r\n    orderbook_snapshots: number;\r\n    trade_ticks: number;\r\n  }> {\r\n    if (!this.db) {\r\n      throw new Error('Database not initialized');\r\n    }\r\n\r\n    const candlesCount = (await this.db.get('SELECT COUNT(*) as count FROM candles')) as\r\n      | { count: number }\r\n      | undefined;\r\n    const orderbookCount = (await this.db.get('SELECT COUNT(*) as count FROM orderbook_snapshots')) as\r\n      | { count: number }\r\n      | undefined;\r\n    const tradesCount = (await this.db.get('SELECT COUNT(*) as count FROM trade_ticks')) as\r\n      | { count: number }\r\n      | undefined;\r\n\r\n    return {\r\n      candles: candlesCount?.count || 0,\r\n      orderbook_snapshots: orderbookCount?.count || 0,\r\n      trade_ticks: tradesCount?.count || 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get queue sizes (for monitoring)\r\n   */\r\n  getQueueSizes(): { candles: number; orderbooks: number; ticks: number } {\r\n    return this.dataQueue.getSizes();\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\delta-analyzer.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DECIMAL_PLACES' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":108,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":108,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":142,"column":8,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":142,"endColumn":35,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[3940,3946],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":143,"column":8,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":143,"endColumn":36,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[4012,4019],"text":"SignalDirection.SHORT"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Delta Analyzer Service\r\n *\r\n * Analyzes buy/sell pressure from tick-by-tick trades.\r\n *\r\n * Delta = Cumulative Buy Volume - Cumulative Sell Volume\r\n *\r\n * Use Cases:\r\n * - Entry confirmation (delta matches signal direction)\r\n * - Divergence detection (price up, delta down = weak rally)\r\n * - Reversal signals (delta flip)\r\n *\r\n * Data Source: Bybit publicTrade WebSocket stream\r\n * - Aggressor side (Buy/Sell) identifies taker direction\r\n * - Buy = aggressive buyer taking ask liquidity (bullish)\r\n * - Sell = aggressive seller hitting bid liquidity (bearish)\r\n */\r\n\r\nimport { DeltaConfig, DeltaTick, DeltaAnalysis, Signal, LoggerService } from '../types';\r\n\r\nexport class DeltaAnalyzerService {\r\n  private ticks: DeltaTick[] = [];\r\n\r\n  constructor(\r\n    private config: DeltaConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('DeltaAnalyzerService initialized', {\r\n      enabled: config.enabled,\r\n      windowMs: config.windowSizeMs,\r\n      threshold: config.minDeltaThreshold,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add trade tick from WebSocket publicTrade stream\r\n   *\r\n   * @param tick - Trade tick with aggressor side (BUY/SELL)\r\n   */\r\n  addTick(tick: DeltaTick): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.ticks.push(tick);\r\n\r\n    // Remove old ticks outside rolling window\r\n    const cutoff = Date.now() - this.config.windowSizeMs;\r\n    this.ticks = this.ticks.filter((t) => t.timestamp >= cutoff);\r\n\r\n    // this.logger.debug('Delta tick added', {\r\n    //   side: tick.side,\r\n    //   qty: tick.quantity.toFixed(DECIMAL_PLACES.PERCENT),\r\n    //   price: tick.price.toFixed(DECIMAL_PLACES.PRICE),\r\n    //   ticksCount: this.ticks.length,\r\n    // });\r\n  }\r\n\r\n  /**\r\n   * Analyze current delta from recent ticks\r\n   *\r\n   * @returns Delta analysis with trend and strength\r\n   */\r\n  analyze(): DeltaAnalysis {\r\n    const cutoff = Date.now() - this.config.windowSizeMs;\r\n    const recentTicks = this.ticks.filter((t) => t.timestamp >= cutoff);\r\n\r\n    if (recentTicks.length === 0) {\r\n      // No data - return neutral\r\n      return {\r\n        timestamp: Date.now(),\r\n        buyVolume: 0,\r\n        sellVolume: 0,\r\n        delta: 0,\r\n        deltaPercent: 0,\r\n        trend: 'NEUTRAL',\r\n        strength: 0,\r\n      };\r\n    }\r\n\r\n    let buyVolume = 0;\r\n    let sellVolume = 0;\r\n\r\n    for (const tick of recentTicks) {\r\n      if (tick.side === 'BUY') {\r\n        buyVolume += tick.quantity;\r\n      } else {\r\n        sellVolume += tick.quantity;\r\n      }\r\n    }\r\n\r\n    const totalVolume = buyVolume + sellVolume;\r\n    const delta = buyVolume - sellVolume;\r\n    const deltaPercent = totalVolume > 0 ? (delta / totalVolume) * PERCENT_MULTIPLIER : 0;\r\n\r\n    // Trend determination\r\n    let trend: 'BULLISH' | 'BEARISH' | 'NEUTRAL';\r\n    if (Math.abs(delta) < this.config.minDeltaThreshold) {\r\n      trend = 'NEUTRAL';\r\n    } else if (delta > 0) {\r\n      trend = 'BULLISH';\r\n    } else {\r\n      trend = 'BEARISH';\r\n    }\r\n\r\n    // Strength (0-100) based on delta percentage\r\n    const strength = Math.min(Math.abs(deltaPercent), 100);\r\n\r\n    const analysis: DeltaAnalysis = {\r\n      timestamp: Date.now(),\r\n      buyVolume,\r\n      sellVolume,\r\n      delta,\r\n      deltaPercent,\r\n      trend,\r\n      strength,\r\n    };\r\n\r\n    this.logger.debug('Delta analyzed', {\r\n      buyVol: buyVolume.toFixed(0),\r\n      sellVol: sellVolume.toFixed(0),\r\n      delta: delta.toFixed(0),\r\n      deltaPercent: deltaPercent.toFixed(1) + '%',\r\n      trend,\r\n      strength: strength.toFixed(0),\r\n    });\r\n\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * Check if delta confirms signal direction\r\n   *\r\n   * @param signal - Trading signal to confirm\r\n   * @returns True if delta trend matches signal direction\r\n   */\r\n  confirmSignal(signal: Signal): boolean {\r\n    const analysis = this.analyze();\r\n\r\n    const confirms =\r\n      (signal.direction === 'LONG' && analysis.trend === 'BULLISH') ||\r\n      (signal.direction === 'SHORT' && analysis.trend === 'BEARISH');\r\n\r\n    if (confirms) {\r\n      this.logger.info('‚úÖ Delta confirms signal', {\r\n        direction: signal.direction,\r\n        delta: analysis.delta.toFixed(0),\r\n        deltaPercent: analysis.deltaPercent.toFixed(1) + '%',\r\n        strength: analysis.strength.toFixed(0),\r\n      });\r\n    } else {\r\n      this.logger.warn('‚ö†Ô∏è Delta contradicts signal', {\r\n        direction: signal.direction,\r\n        deltaTrend: analysis.trend,\r\n        delta: analysis.delta.toFixed(0),\r\n      });\r\n    }\r\n\r\n    return confirms;\r\n  }\r\n\r\n  /**\r\n   * Get current tick count in window\r\n   */\r\n  getTickCount(): number {\r\n    const cutoff = Date.now() - this.config.windowSizeMs;\r\n    return this.ticks.filter((t) => t.timestamp >= cutoff).length;\r\n  }\r\n\r\n  /**\r\n   * Clear all ticks (for testing)\r\n   */\r\n  reset(): void {\r\n    this.ticks = [];\r\n    this.logger.debug('Delta analyzer reset');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\entry-confirmation.service.ts","messages":[{"ruleId":"max-len","severity":1,"message":"This line has a length of 130. Maximum allowed is 120.","line":40,"column":1,"nodeType":"Program","messageId":"max","endLine":40,"endColumn":131},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":79,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":79,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":129,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":129,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4324,4332],"text":"pending == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":163,"column":118,"nodeType":"Literal","messageId":"noMagic","endLine":163,"endColumn":119},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":201,"column":121,"nodeType":"Literal","messageId":"noMagic","endLine":201,"endColumn":122},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":257,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":257,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":272,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":272,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9034,9041],"text":"pending != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":327,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":327,"endColumn":21}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Entry Confirmation Manager\r\n *\r\n * Prevents premature entries by waiting for next candle close confirmation.\r\n *\r\n * LONG Flow:\r\n * 1. Strategy detects potential LONG at support level\r\n * 2. Instead of entering immediately, save as \"pending\"\r\n * 3. Wait for next 1m candle to close\r\n * 4. If candle closes ABOVE support ‚Üí confirm entry (bounce confirmed)\r\n * 5. If candle closes BELOW support ‚Üí cancel (falling knife)\r\n *\r\n * SHORT Flow:\r\n * 1. Strategy detects potential SHORT at resistance level\r\n * 2. Instead of entering immediately, save as \"pending\"\r\n * 3. Wait for next 1m candle to close\r\n * 4. If candle closes BELOW resistance ‚Üí confirm entry (rejection confirmed)\r\n * 5. If candle closes ABOVE resistance ‚Üí cancel (pump continues)\r\n *\r\n * Benefits:\r\n * - Reduces quick stop-outs (< 5min holds)\r\n * - Confirms price rejection/bounce before entry\r\n * - Configurable per direction (LONG/SHORT)\r\n */\r\n\r\nimport { LoggerService, SignalDirection, EntryConfirmationConfig } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface PendingEntry {\r\n  id: string; // Unique ID for tracking\r\n  symbol: string;\r\n  direction: SignalDirection; // LONG or SHORT\r\n  keyLevel: number; // Support (LONG) or Resistance (SHORT) price level\r\n  detectedAt: number; // Timestamp when signal detected\r\n  expiresAt: number; // Timestamp when signal expires\r\n  signalData: Record<string, unknown>; // Original signal data to use if confirmed (flexible type for different signal structures)\r\n}\r\n\r\nexport interface ConfirmationResult {\r\n  confirmed: boolean;\r\n  reason: string;\r\n  closePrice?: number;\r\n  keyLevel?: number;\r\n}\r\n\r\n// ============================================================================\r\n// ENTRY CONFIRMATION MANAGER\r\n// ============================================================================\r\n\r\nexport class EntryConfirmationManager {\r\n  private pendingEntries: Map<string, PendingEntry> = new Map();\r\n\r\n  constructor(\r\n    private config: EntryConfirmationConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Check if confirmation is enabled for direction\r\n   */\r\n  isEnabled(direction: SignalDirection): boolean {\r\n    return direction === SignalDirection.LONG\r\n      ? this.config.long.enabled\r\n      : this.config.short.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get expiry time in milliseconds for direction\r\n   */\r\n  private getExpiryMs(direction: SignalDirection): number {\r\n    const seconds =\r\n      direction === SignalDirection.LONG\r\n        ? this.config.long.expirySeconds\r\n        : this.config.short.expirySeconds;\r\n    return seconds * 1000;\r\n  }\r\n\r\n  /**\r\n   * Add pending entry waiting for confirmation\r\n   *\r\n   * @param entry - Pending entry details\r\n   * @returns Pending entry ID\r\n   */\r\n  addPending(entry: Omit<PendingEntry, 'id' | 'expiresAt'>): string {\r\n    const id = `${entry.symbol}_${entry.direction}_${Date.now()}`;\r\n    const expiryMs = this.getExpiryMs(entry.direction);\r\n    const expiresAt = Date.now() + expiryMs;\r\n\r\n    const pendingEntry: PendingEntry = {\r\n      id,\r\n      expiresAt,\r\n      ...entry,\r\n    };\r\n\r\n    this.pendingEntries.set(id, pendingEntry);\r\n\r\n    const levelType = entry.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n    const confirmCondition =\r\n      entry.direction === SignalDirection.LONG\r\n        ? 'candle close above support'\r\n        : 'candle close below resistance';\r\n\r\n    this.logger.info(`‚è≥ ${entry.direction} entry pending confirmation`, {\r\n      id,\r\n      symbol: entry.symbol,\r\n      direction: entry.direction,\r\n      [`${levelType}Level`]: entry.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n      waitingFor: `Next 1m ${confirmCondition}`,\r\n      expiresIn: `${expiryMs / TIME_UNITS.MINUTE}min`,\r\n    });\r\n\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Check if pending entry should be confirmed\r\n   *\r\n   * @param id - Pending entry ID\r\n   * @param currentCandleClose - Current 1m candle close price\r\n   * @returns Confirmation result\r\n   */\r\n  checkConfirmation(id: string, currentCandleClose: number): ConfirmationResult {\r\n    const pending = this.pendingEntries.get(id);\r\n\r\n    if (!pending) {\r\n      return {\r\n        confirmed: false,\r\n        reason: 'Pending entry not found',\r\n      };\r\n    }\r\n\r\n    // Check expiry\r\n    if (Date.now() > pending.expiresAt) {\r\n      const levelType = pending.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n      this.logger.info(`‚è±Ô∏è ${pending.direction} entry EXPIRED`, {\r\n        id,\r\n        symbol: pending.symbol,\r\n        direction: pending.direction,\r\n        [`${levelType}Level`]: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n        reason: 'Confirmation timeout',\r\n      });\r\n\r\n      this.pendingEntries.delete(id);\r\n      return {\r\n        confirmed: false,\r\n        reason: 'Confirmation timeout - signal expired',\r\n      };\r\n    }\r\n\r\n    // LONG confirmation: candle closed ABOVE support\r\n    if (pending.direction === SignalDirection.LONG) {\r\n      if (currentCandleClose > pending.keyLevel) {\r\n        this.logger.info('‚úÖ LONG entry CONFIRMED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          supportLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          bouncePercent: (((currentCandleClose - pending.keyLevel) / pending.keyLevel) * PERCENT_MULTIPLIER).toFixed(3) + '%',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: true,\r\n          reason: 'Candle closed above support - bounce confirmed',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      } else {\r\n        // Candle closed BELOW/AT support - falling knife!\r\n        this.logger.info('‚ùå LONG entry REJECTED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          supportLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          reason: 'Candle closed below support - falling knife',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: false,\r\n          reason: 'Candle closed below support - no bounce',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      }\r\n    }\r\n\r\n    // SHORT confirmation: candle closed BELOW resistance\r\n    if (pending.direction === SignalDirection.SHORT) {\r\n      if (currentCandleClose < pending.keyLevel) {\r\n        this.logger.info('‚úÖ SHORT entry CONFIRMED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          resistanceLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          rejectionPercent: (((pending.keyLevel - currentCandleClose) / pending.keyLevel) * PERCENT_MULTIPLIER).toFixed(3) + '%',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: true,\r\n          reason: 'Candle closed below resistance - rejection confirmed',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      } else {\r\n        // Candle closed ABOVE/AT resistance - pump continues!\r\n        this.logger.info('‚ùå SHORT entry REJECTED', {\r\n          id,\r\n          symbol: pending.symbol,\r\n          resistanceLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          reason: 'Candle closed above resistance - pump continues',\r\n        });\r\n\r\n        this.pendingEntries.delete(id);\r\n        return {\r\n          confirmed: false,\r\n          reason: 'Candle closed above resistance - no rejection',\r\n          closePrice: currentCandleClose,\r\n          keyLevel: pending.keyLevel,\r\n        };\r\n      }\r\n    }\r\n\r\n    // Should never reach here\r\n    return {\r\n      confirmed: false,\r\n      reason: 'Unknown direction',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get pending entry data\r\n   *\r\n   * @param id - Pending entry ID\r\n   * @returns Pending entry or undefined\r\n   */\r\n  getPending(id: string): PendingEntry | undefined {\r\n    return this.pendingEntries.get(id);\r\n  }\r\n\r\n  /**\r\n   * Get all pending entries\r\n   *\r\n   * @param direction - Optional: filter by direction\r\n   * @returns Array of pending entries\r\n   */\r\n  getAllPending(direction?: SignalDirection): PendingEntry[] {\r\n    const allEntries = Array.from(this.pendingEntries.values());\r\n\r\n    if (direction != null) {\r\n      return allEntries.filter((entry) => entry.direction === direction);\r\n    }\r\n\r\n    return allEntries;\r\n  }\r\n\r\n  /**\r\n   * Cancel pending entry\r\n   *\r\n   * @param id - Pending entry ID\r\n   * @returns true if cancelled, false if not found\r\n   */\r\n  cancel(id: string): boolean {\r\n    const pending = this.pendingEntries.get(id);\r\n    if (pending) {\r\n      const levelType = pending.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n      this.logger.info(`üö´ ${pending.direction} entry CANCELLED`, {\r\n        id,\r\n        symbol: pending.symbol,\r\n        direction: pending.direction,\r\n        [`${levelType}Level`]: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n\r\n      this.pendingEntries.delete(id);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries\r\n   *\r\n   * @returns Number of expired entries removed\r\n   */\r\n  cleanupExpired(): number {\r\n    const now = Date.now();\r\n    let count = 0;\r\n\r\n    for (const [id, entry] of this.pendingEntries.entries()) {\r\n      if (now > entry.expiresAt) {\r\n        this.logger.debug(`Removing expired pending ${entry.direction}`, {\r\n          id,\r\n          symbol: entry.symbol,\r\n          direction: entry.direction,\r\n        });\r\n        this.pendingEntries.delete(id);\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Clear all pending entries\r\n   */\r\n  clear(): void {\r\n    this.pendingEntries.clear();\r\n  }\r\n\r\n  /**\r\n   * Get count of pending entries\r\n   *\r\n   * @param direction - Optional: filter by direction\r\n   * @returns Count of pending entries\r\n   */\r\n  getPendingCount(direction?: SignalDirection): number {\r\n    if (direction != null) {\r\n      return this.getAllPending(direction).length;\r\n    }\r\n    return this.pendingEntries.size;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\fast-entry.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'checkFastTrigger' has a complexity of 11. Maximum allowed is 10.","line":46,"column":19,"nodeType":"FunctionExpression","messageId":"complex","endLine":122,"endColumn":4},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":78,"column":28,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":78,"endColumn":55,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[2414,2420],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":101,"column":23,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":101,"endColumn":50,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[3231,3237],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":189,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":189,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5891,5899],"text":"partial == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":239,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":239,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7524,7532],"text":"partial == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Fast Entry Service\r\n *\r\n * Allows partial entry before candle close to reduce late entry slippage.\r\n *\r\n * Flow:\r\n * 1. Signal generated\r\n * 2. Check fast trigger conditions (candle body, volume, senior TF)\r\n * 3. If TRUE: Execute partial entry (40% size)\r\n * 4. Schedule confirmation check on candle close\r\n * 5. On close: Add remaining 60% if confirmed, else close partial\r\n *\r\n * Benefits:\r\n * - Better entry price (0.3-0.5% improvement)\r\n * - Reduced stop-outs from late entries\r\n * - Partial position = lower risk if signal invalidates\r\n */\r\n\r\nimport { FastEntryConfig, PartialPosition, Signal, Candle, LoggerService } from '../types';\r\n\r\nexport class FastEntryService {\r\n  private partialPositions: Map<string, PartialPosition> = new Map();\r\n\r\n  constructor(\r\n    private config: FastEntryConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('FastEntryService initialized', {\r\n      enabled: config.enabled,\r\n      partialSize: `${config.partialSizePercent}%`,\r\n      minBody: `${config.minBodyPercent}%`,\r\n      volumeMultiplier: config.volumeMultiplier,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if fast entry conditions met\r\n   *\r\n   * Conditions:\r\n   * 1. Candle body ‚â• 50% of range\r\n   * 2. Body direction matches signal\r\n   * 3. Volume > SMA(20) √ó multiplier\r\n   * 4. Senior TF aligned (optional)\r\n   */\r\n  checkFastTrigger(\r\n    signal: Signal,\r\n    currentCandle: Candle,\r\n    volume: number,\r\n    volumeSMA: number,\r\n    seniorTFTrend: 'UP' | 'DOWN' | 'NEUTRAL',\r\n  ): boolean {\r\n    if (!this.config.enabled) {\r\n      return false;\r\n    }\r\n\r\n    // 1. Check candle body percentage\r\n    const range = currentCandle.high - currentCandle.low;\r\n\r\n    if (range === 0) {\r\n      this.logger.debug('Fast trigger: no range (doji candle)');\r\n      return false;\r\n    }\r\n\r\n    const body = Math.abs(currentCandle.close - currentCandle.open);\r\n    const bodyPercent = (body / range) * PERCENT_MULTIPLIER;\r\n\r\n    if (bodyPercent < this.config.minBodyPercent) {\r\n      this.logger.debug('Fast trigger: body too small', {\r\n        bodyPercent: bodyPercent.toFixed(1),\r\n        required: this.config.minBodyPercent,\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // 2. Check body direction matches signal\r\n    const isBullishCandle = currentCandle.close > currentCandle.open;\r\n    const directionMatch = signal.direction === 'LONG' ? isBullishCandle : !isBullishCandle;\r\n\r\n    if (!directionMatch) {\r\n      this.logger.debug('Fast trigger: direction mismatch', {\r\n        signalDirection: signal.direction,\r\n        candleDirection: isBullishCandle ? 'BULLISH' : 'BEARISH',\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // 3. Check volume\r\n    const volumeThreshold = volumeSMA * this.config.volumeMultiplier;\r\n    if (volume < volumeThreshold) {\r\n      this.logger.debug('Fast trigger: volume too low', {\r\n        volume: volume.toFixed(0),\r\n        threshold: volumeThreshold.toFixed(0),\r\n        ratio: (volume / volumeSMA).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // 4. Check senior TF alignment (optional)\r\n    if (this.config.requireSeniorTFAlignment) {\r\n      const aligned = signal.direction === 'LONG'\r\n        ? seniorTFTrend === 'UP'\r\n        : seniorTFTrend === 'DOWN';\r\n\r\n      if (!aligned) {\r\n        this.logger.debug('Fast trigger: senior TF not aligned', {\r\n          signalDirection: signal.direction,\r\n          seniorTFTrend,\r\n        });\r\n        return false;\r\n      }\r\n    }\r\n\r\n    this.logger.info('‚úÖ Fast trigger conditions met!', {\r\n      bodyPercent: bodyPercent.toFixed(1) + '%',\r\n      volume: volume.toFixed(0),\r\n      volumeRatio: (volume / volumeSMA).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n      seniorTF: seniorTFTrend,\r\n    });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Execute partial entry (40% of position size)\r\n   */\r\n  async executePartialEntry(\r\n    symbol: string,\r\n    signal: Signal,\r\n    fullPositionSize: number,\r\n    openPositionFn: (qty: number) => Promise<{ orderId: string; avgPrice: number }>,\r\n  ): Promise<PartialPosition | null> {\r\n    const partialSize = fullPositionSize * (this.config.partialSizePercent / PERCENT_MULTIPLIER);\r\n\r\n    try {\r\n      this.logger.info('üöÄ Executing partial entry...', {\r\n        symbol,\r\n        direction: signal.direction,\r\n        fullSize: fullPositionSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        partialSize: partialSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        percent: this.config.partialSizePercent + '%',\r\n      });\r\n\r\n      // Open partial position\r\n      const order = await openPositionFn(partialSize);\r\n\r\n      const partial: PartialPosition = {\r\n        orderId: order.orderId,\r\n        symbol,\r\n        side: signal.direction,\r\n        qty: partialSize,\r\n        entryPrice: order.avgPrice,\r\n        timestamp: Date.now(),\r\n        signal,\r\n        confirmScheduled: false,\r\n      };\r\n\r\n      this.partialPositions.set(symbol, partial);\r\n\r\n      this.logger.info('‚úÖ Partial entry executed', {\r\n        orderId: order.orderId,\r\n        size: partialSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        price: order.avgPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        percent: this.config.partialSizePercent + '%',\r\n      });\r\n\r\n      return partial;\r\n\r\n    } catch (error: unknown) {\r\n      this.logger.error('‚ùå Failed to execute partial entry', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Confirm entry - add remaining position (60%)\r\n   */\r\n  async confirmEntry(\r\n    symbol: string,\r\n    remainingSize: number,\r\n    addToPositionFn: (qty: number) => Promise<{ orderId: string; avgPrice: number }>,\r\n  ): Promise<boolean> {\r\n    const partial = this.partialPositions.get(symbol);\r\n\r\n    if (!partial) {\r\n      this.logger.warn('No partial position found for confirmation', { symbol });\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      this.logger.info('‚úÖ Confirming entry - adding remaining position...', {\r\n        symbol,\r\n        partialQty: partial.qty.toFixed(DECIMAL_PLACES.PERCENT),\r\n        remainingQty: remainingSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        totalQty: (partial.qty + remainingSize).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Add remaining position\r\n      const order = await addToPositionFn(remainingSize);\r\n\r\n      this.logger.info('‚úÖ Entry confirmed - position completed', {\r\n        orderId: order.orderId,\r\n        addedQty: remainingSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        addedPrice: order.avgPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalQty: (partial.qty + remainingSize).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      this.partialPositions.delete(symbol);\r\n      return true;\r\n\r\n    } catch (error: unknown) {\r\n      this.logger.error('‚ùå Failed to confirm entry', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel partial entry - close partial position\r\n   *\r\n   * Called when:\r\n   * - Candle closes against signal direction\r\n   * - Confirmation timeout exceeded\r\n   * - Signal invalidated\r\n   */\r\n  async cancelPartialEntry(\r\n    symbol: string,\r\n    closePositionFn: () => Promise<void>,\r\n  ): Promise<void> {\r\n    const partial = this.partialPositions.get(symbol);\r\n\r\n    if (!partial) {\r\n      this.logger.debug('No partial position to cancel', { symbol });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.logger.warn('‚ùå Cancelling partial entry...', {\r\n        symbol,\r\n        qty: partial.qty.toFixed(DECIMAL_PLACES.PERCENT),\r\n        entryPrice: partial.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        reason: 'Signal not confirmed',\r\n      });\r\n\r\n      await closePositionFn();\r\n\r\n      this.logger.info('‚ùå Partial entry cancelled', {\r\n        symbol,\r\n        orderId: partial.orderId,\r\n      });\r\n\r\n      this.partialPositions.delete(symbol);\r\n\r\n    } catch (error: unknown) {\r\n      this.logger.error('‚ùå Failed to cancel partial entry', {\r\n        error,\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        stack: error instanceof Error ? error.stack : undefined,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get partial position by symbol\r\n   */\r\n  getPartialPosition(symbol: string): PartialPosition | undefined {\r\n    return this.partialPositions.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Check if partial position exists\r\n   */\r\n  hasPartialPosition(symbol: string): boolean {\r\n    return this.partialPositions.has(symbol);\r\n  }\r\n\r\n  /**\r\n   * Get all partial positions\r\n   */\r\n  getAllPartialPositions(): PartialPosition[] {\r\n    return Array.from(this.partialPositions.values());\r\n  }\r\n\r\n  /**\r\n   * Clear partial position (without closing)\r\n   * Use when position closed externally\r\n   */\r\n  clearPartialPosition(symbol: string): void {\r\n    this.partialPositions.delete(symbol);\r\n    this.logger.debug('Partial position cleared', { symbol });\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): FastEntryConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\funding-rate-filter.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":131,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":131,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4869,4891],"text":"(this.cachedFundingRate != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":136,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":136,"endColumn":63}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Funding Rate Filter Service\r\n *\r\n * Filters trading signals based on funding rate to avoid overheated positions.\r\n *\r\n * Logic:\r\n * - Positive funding rate = longs pay shorts ‚Üí too many longs ‚Üí risky to LONG\r\n * - Negative funding rate = shorts pay longs ‚Üí too many shorts ‚Üí risky to SHORT\r\n *\r\n * Example:\r\n * - Funding rate = +0.1% ‚Üí block LONG signals (market too bullish, risk of reversal)\r\n * - Funding rate = -0.1% ‚Üí block SHORT signals (market too bearish, risk of reversal)\r\n */\r\n\r\nimport { LoggerService, SignalDirection, FundingRateFilterConfig } from '../types';\r\n\r\n// ============================================================================\r\n// INTERFACES\r\n// ============================================================================\r\n\r\nexport interface FundingRateData {\r\n  fundingRate: number; // Current funding rate (e.g., 0.0001 = 0.01%)\r\n  timestamp: number; // Timestamp of funding rate\r\n  nextFundingTime: number; // Next funding timestamp\r\n}\r\n\r\nexport interface FilterResult {\r\n  allowed: boolean; // Whether signal is allowed\r\n  reason?: string; // Reason for blocking (if blocked)\r\n  fundingRate?: number; // Current funding rate\r\n}\r\n\r\n// ============================================================================\r\n// SERVICE\r\n// ============================================================================\r\n\r\nexport class FundingRateFilterService {\r\n  private cachedFundingRate: FundingRateData | null = null;\r\n  private lastFetchTime: number = 0;\r\n\r\n  constructor(\r\n    private config: FundingRateFilterConfig,\r\n    private getFundingRate: () => Promise<FundingRateData>, // Injected Bybit API call\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Check if signal is allowed based on funding rate\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns FilterResult with allowed flag and reason\r\n   */\r\n  async checkSignal(direction: SignalDirection): Promise<FilterResult> {\r\n    // Check if filter is enabled\r\n    if (!this.config.enabled) {\r\n      return { allowed: true };\r\n    }\r\n\r\n    // Skip if direction is HOLD\r\n    if (direction === SignalDirection.HOLD) {\r\n      return { allowed: true };\r\n    }\r\n\r\n    try {\r\n      // Get current funding rate (from cache or API)\r\n      const fundingData = await this.getCurrentFundingRate();\r\n      const fundingRate = fundingData.fundingRate;\r\n\r\n      // Check LONG signal\r\n      if (direction === SignalDirection.LONG) {\r\n        if (fundingRate > this.config.blockLongThreshold) {\r\n          this.logger.warn('üö´ Funding Rate Filter: LONG blocked', {\r\n            fundingRate: (fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            threshold: (this.config.blockLongThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            reason: 'Funding too high (too many longs)',\r\n          });\r\n\r\n          return {\r\n            allowed: false,\r\n            reason: `Funding rate too high: ${(fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}% (threshold: ${(this.config.blockLongThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}%)`,\r\n            fundingRate,\r\n          };\r\n        }\r\n      }\r\n\r\n      // Check SHORT signal\r\n      if (direction === SignalDirection.SHORT) {\r\n        if (fundingRate < this.config.blockShortThreshold) {\r\n          this.logger.warn('üö´ Funding Rate Filter: SHORT blocked', {\r\n            fundingRate: (fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            threshold: (this.config.blockShortThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n            reason: 'Funding too low (too many shorts)',\r\n          });\r\n\r\n          return {\r\n            allowed: false,\r\n            reason: `Funding rate too low: ${(fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}% (threshold: ${(this.config.blockShortThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE)}%)`,\r\n            fundingRate,\r\n          };\r\n        }\r\n      }\r\n\r\n      // Signal allowed\r\n      this.logger.debug('‚úÖ Funding Rate Filter: Signal allowed', {\r\n        direction,\r\n        fundingRate: (fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n      });\r\n\r\n      return {\r\n        allowed: true,\r\n        fundingRate,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error checking funding rate filter', { error });\r\n      // Allow signal if filter fails (fail-safe)\r\n      return { allowed: true, reason: 'Filter error (allowed by default)' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current funding rate (from cache or API)\r\n   *\r\n   * @returns FundingRateData\r\n   */\r\n  private async getCurrentFundingRate(): Promise<FundingRateData> {\r\n    const now = Date.now();\r\n\r\n    // Check if cache is valid\r\n    if (\r\n      this.cachedFundingRate &&\r\n      now - this.lastFetchTime < this.config.cacheTimeMs\r\n    ) {\r\n      this.logger.debug('üì¶ Using cached funding rate', {\r\n        fundingRate: (this.cachedFundingRate.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n        cacheAge: Math.floor((now - this.lastFetchTime) / 1000) + 's',\r\n      });\r\n      return this.cachedFundingRate;\r\n    }\r\n\r\n    // Fetch from API\r\n    this.logger.debug('üîÑ Fetching funding rate from API');\r\n    const fundingData = await this.getFundingRate();\r\n\r\n    // Update cache\r\n    this.cachedFundingRate = fundingData;\r\n    this.lastFetchTime = now;\r\n\r\n    this.logger.info('üìä Funding rate updated', {\r\n      fundingRate: (fundingData.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n      nextFundingTime: new Date(fundingData.nextFundingTime).toISOString(),\r\n    });\r\n\r\n    return fundingData;\r\n  }\r\n\r\n  /**\r\n   * Clear cache (for testing)\r\n   */\r\n  clearCache(): void {\r\n    this.cachedFundingRate = null;\r\n    this.lastFetchTime = 0;\r\n    this.logger.debug('üóëÔ∏è Funding rate cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get current cached funding rate (if available)\r\n   */\r\n  getCachedFundingRate(): FundingRateData | null {\r\n    return this.cachedFundingRate;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\ladder-tp-manager.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":164,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":325,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":325,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":325,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":325,"endColumn":39}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Ladder TP Manager Service (Phase 3)\r\n *\r\n * Manages multi-level take profit execution for scalping strategies.\r\n *\r\n * Features:\r\n * - 3 TP levels with partial closes (e.g., 0.08%, 0.15%, 0.25%)\r\n * - Position closes: 33%, 33%, 34%\r\n * - Move SL to breakeven after TP1\r\n * - Trailing SL after TP2\r\n * - R/R Ratio: ~1.26:1 (weighted average)\r\n *\r\n * Example:\r\n * Entry: 1.0000 LONG\r\n * TP1: 1.0008 (33% close) ‚Üí Move SL to 1.0000 (breakeven)\r\n * TP2: 1.0015 (33% close) ‚Üí Trailing SL activated\r\n * TP3: 1.0025 (34% close) ‚Üí Full exit\r\n */\r\n\r\nimport {\r\n  LoggerService,\r\n  SignalDirection,\r\n  PositionSide,\r\n  LadderTpManagerConfig,\r\n  LadderTpLevel,\r\n  Position,\r\n} from '../types';\r\nimport { BybitService } from './bybit/bybit.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_PARTIAL_CLOSE_PERCENT = 10; // Min % to close (avoid too small closes)\r\nconst MAX_PARTIAL_CLOSE_PERCENT = 90; // Max % to close (avoid closing full position)\r\nconst PRICE_TOLERANCE_PERCENT = 0.01; // 0.01% tolerance for TP hit detection\r\n\r\n// ============================================================================\r\n// LADDER TP MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class LadderTpManagerService {\r\n  constructor(\r\n    private config: LadderTpManagerConfig,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('LadderTpManagerService initialized', {\r\n      levels: config.levels.length,\r\n      moveToBreakeven: config.moveToBreakevenAfterTP1,\r\n      trailing: config.trailingAfterTP2,\r\n      trailingDistance: config.trailingDistancePercent,\r\n    });\r\n\r\n    // Validate config\r\n    this.validateConfig();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Create ladder TP levels for position\r\n   *\r\n   * Calculates TP prices based on entry price and direction\r\n   *\r\n   * @param entry - Entry price\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns Array of ladder TP levels\r\n   */\r\n  createLadderLevels(entry: number, direction: SignalDirection): LadderTpLevel[] {\r\n    this.logger.debug('Creating ladder TP levels', {\r\n      entry,\r\n      direction,\r\n      levelsCount: this.config.levels.length,\r\n    });\r\n\r\n    const levels: LadderTpLevel[] = this.config.levels.map((levelConfig, index) => {\r\n      // Calculate target price\r\n      let targetPrice: number;\r\n      if (direction === SignalDirection.LONG) {\r\n        // LONG: TP above entry\r\n        targetPrice = entry * (1 + levelConfig.pricePercent / PERCENT_MULTIPLIER);\r\n      } else {\r\n        // SHORT: TP below entry\r\n        targetPrice = entry * (1 - levelConfig.pricePercent / PERCENT_MULTIPLIER);\r\n      }\r\n\r\n      return {\r\n        level: index + 1,\r\n        pricePercent: levelConfig.pricePercent,\r\n        closePercent: levelConfig.closePercent,\r\n        targetPrice,\r\n        hit: false,\r\n      };\r\n    });\r\n\r\n    this.logger.info('‚úÖ Ladder TP levels created', {\r\n      direction,\r\n      levels: levels.map((l) => ({\r\n        level: l.level,\r\n        price: l.targetPrice,\r\n        closePercent: l.closePercent,\r\n      })),\r\n    });\r\n\r\n    return levels;\r\n  }\r\n\r\n  /**\r\n   * Check if TP level was hit\r\n   *\r\n   * Compares current price with TP target price\r\n   *\r\n   * @param level - TP level to check\r\n   * @param currentPrice - Current market price\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns True if TP was hit\r\n   */\r\n  checkTpHit(level: LadderTpLevel, currentPrice: number, direction: SignalDirection): boolean {\r\n    if (level.hit) {\r\n      return false; // Already hit\r\n    }\r\n\r\n    // Calculate tolerance\r\n    const tolerance = level.targetPrice * (PRICE_TOLERANCE_PERCENT / PERCENT_MULTIPLIER);\r\n\r\n    let isHit: boolean;\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: current price >= target price\r\n      isHit = currentPrice >= level.targetPrice - tolerance;\r\n    } else {\r\n      // SHORT: current price <= target price\r\n      isHit = currentPrice <= level.targetPrice + tolerance;\r\n    }\r\n\r\n    if (isHit) {\r\n      this.logger.info(`üéØ TP${level.level} HIT!`, {\r\n        targetPrice: level.targetPrice,\r\n        currentPrice,\r\n        closePercent: level.closePercent,\r\n      });\r\n    }\r\n\r\n    return isHit;\r\n  }\r\n\r\n  /**\r\n   * Execute partial close for TP level\r\n   *\r\n   * Closes specified % of position via Bybit API\r\n   *\r\n   * @param level - TP level to execute\r\n   * @param position - Current position\r\n   * @returns True if close successful\r\n   */\r\n  async executePartialClose(level: LadderTpLevel, position: Position): Promise<boolean> {\r\n    try {\r\n      // Calculate quantity to close\r\n      const closeQty = position.quantity * (level.closePercent / PERCENT_MULTIPLIER);\r\n\r\n      if (closeQty < 0.01) {\r\n        this.logger.warn('Close quantity too small, skipping partial close', {\r\n          level: level.level,\r\n          closeQty,\r\n          minQty: 0.01,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      this.logger.info(`üí∞ Executing TP${level.level} partial close`, {\r\n        level: level.level,\r\n        closePercent: level.closePercent,\r\n        closeQty,\r\n        targetPrice: level.targetPrice,\r\n      });\r\n\r\n      // Execute partial close via Bybit\r\n      await this.bybitService.closePosition(position.side, closeQty);\r\n\r\n      this.logger.info(`‚úÖ TP${level.level} partial close executed`, {\r\n        level: level.level,\r\n        closedQty: closeQty,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Failed to execute TP${level.level} partial close`, {\r\n        level: level.level,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move SL to breakeven (entry price)\r\n   *\r\n   * Called after TP1 hit to protect position\r\n   *\r\n   * @param position - Current position\r\n   * @returns True if SL moved successfully\r\n   */\r\n  async moveToBreakeven(position: Position): Promise<boolean> {\r\n    if (!this.config.moveToBreakevenAfterTP1) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const breakeven = position.entryPrice;\r\n\r\n      this.logger.info('‚öñÔ∏è Moving SL to breakeven after TP1', {\r\n        oldSl: position.stopLoss,\r\n        newSl: breakeven,\r\n        entry: position.entryPrice,\r\n      });\r\n\r\n      // Update SL via Bybit API\r\n      await this.bybitService.updateStopLoss(breakeven);\r\n\r\n      this.logger.info('‚úÖ SL moved to breakeven', {\r\n        slPrice: breakeven,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Failed to move SL to breakeven', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move SL to trailing price\r\n   *\r\n   * Called after TP2 hit to maximize profits\r\n   *\r\n   * @param position - Current position\r\n   * @param currentPrice - Current market price\r\n   * @returns True if SL moved successfully\r\n   */\r\n  async moveTrailing(position: Position, currentPrice: number): Promise<boolean> {\r\n    if (!this.config.trailingAfterTP2) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // Calculate trailing SL price\r\n      let newSlPrice: number;\r\n      if (position.side === PositionSide.LONG) {\r\n        // LONG: SL below current price\r\n        newSlPrice = currentPrice * (1 - this.config.trailingDistancePercent / PERCENT_MULTIPLIER);\r\n      } else {\r\n        // SHORT: SL above current price\r\n        newSlPrice = currentPrice * (1 + this.config.trailingDistancePercent / PERCENT_MULTIPLIER);\r\n      }\r\n\r\n      // Only move SL if it improves current SL\r\n      const shouldMove =\r\n        position.side === PositionSide.LONG\r\n          ? newSlPrice > position.stopLoss.price // LONG: move SL up\r\n          : newSlPrice < position.stopLoss.price; // SHORT: move SL down\r\n\r\n      if (!shouldMove) {\r\n        this.logger.debug('Trailing SL not better than current SL, skipping', {\r\n          currentSl: position.stopLoss.price,\r\n          newSl: newSlPrice,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      this.logger.info('üìà Moving SL to trailing price after TP2', {\r\n        oldSl: position.stopLoss.price,\r\n        newSl: newSlPrice,\r\n        currentPrice,\r\n        trailingDistance: this.config.trailingDistancePercent,\r\n      });\r\n\r\n      // Update SL via Bybit API\r\n      await this.bybitService.updateStopLoss(newSlPrice);\r\n\r\n      this.logger.info('‚úÖ Trailing SL updated', {\r\n        slPrice: newSlPrice,\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Failed to move trailing SL', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Validate configuration\r\n   */\r\n  private validateConfig(): void {\r\n    if (this.config.levels.length === 0) {\r\n      throw new Error('LadderTpManagerConfig must have at least 1 level');\r\n    }\r\n\r\n    // Validate each level\r\n    for (const level of this.config.levels) {\r\n      if (level.pricePercent <= 0) {\r\n        throw new Error(`Invalid pricePercent: ${level.pricePercent} (must be > 0)`);\r\n      }\r\n\r\n      if (level.closePercent < MIN_PARTIAL_CLOSE_PERCENT || level.closePercent > MAX_PARTIAL_CLOSE_PERCENT) {\r\n        throw new Error(\r\n          `Invalid closePercent: ${level.closePercent} (must be ${MIN_PARTIAL_CLOSE_PERCENT}-${MAX_PARTIAL_CLOSE_PERCENT}%)`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Validate total closePercent ~= 100%\r\n    const totalClose = this.config.levels.reduce((sum, level) => sum + level.closePercent, 0);\r\n    if (Math.abs(totalClose - 100) > 5) {\r\n      this.logger.warn('Total closePercent is not ~100%, some position may remain', {\r\n        totalClose,\r\n      });\r\n    }\r\n\r\n    if (this.config.trailingAfterTP2 && this.config.trailingDistancePercent <= 0) {\r\n      throw new Error(`Invalid trailingDistancePercent: ${this.config.trailingDistancePercent} (must be > 0)`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get config for external access\r\n   */\r\n  getConfig(): LadderTpManagerConfig {\r\n    return this.config;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\limit-order-executor.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":164,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":31},{"ruleId":"complexity","severity":1,"message":"Async method 'waitForFill' has a complexity of 11. Maximum allowed is 10.","line":184,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":260,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":211,"column":24,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":211,"endColumn":45},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":222,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":237,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":223,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":223,"endColumn":64},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":224,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":236,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":346,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":346,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[11293,11307],"text":"(order.avgPrice.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[11293,11307],"text":"(order.avgPrice !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11293,11307],"text":"(Boolean(order.avgPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (312). Maximum allowed is 300.","line":465,"column":1,"nodeType":null,"messageId":"exceed","endLine":488,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Limit Order Executor Service (Phase 2)\r\n *\r\n * Executes trades using limit orders instead of market orders\r\n * for fee savings (0.01% maker vs 0.06% taker = 0.05% savings).\r\n *\r\n * Features:\r\n * - Place limit orders at bid/ask with minimal slippage\r\n * - Wait for fill with configurable timeout\r\n * - Automatic fallback to market order if not filled\r\n * - Retry logic with max attempts\r\n * - Detailed execution statistics\r\n */\r\n\r\nimport {\r\n  LoggerService,\r\n  SignalDirection,\r\n  PositionSide,\r\n  LimitOrderExecutorConfig,\r\n  LimitOrderResult,\r\n  MarketOrderResult,\r\n} from '../types';\r\nimport { BybitService } from './bybit/bybit.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAKER_FEE_PERCENT = 0.01; // Maker fee (limit order filled)\r\nconst TAKER_FEE_PERCENT = 0.06; // Taker fee (market order)\r\nconst ORDER_CHECK_INTERVAL_MS = 200; // Check order status every 200ms\r\nconst BYBIT_SUCCESS_CODE = 0;\r\nconst POSITION_IDX_ONE_WAY = 0;\r\n\r\n// ============================================================================\r\n// LIMIT ORDER EXECUTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class LimitOrderExecutorService {\r\n  constructor(\r\n    private config: LimitOrderExecutorConfig,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('LimitOrderExecutorService initialized', {\r\n      enabled: config.enabled,\r\n      timeoutMs: config.timeoutMs,\r\n      slippagePercent: config.slippagePercent,\r\n      fallbackToMarket: config.fallbackToMarket,\r\n      maxRetries: config.maxRetries,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate optimal limit price for entry\r\n   *\r\n   * For LONG: Place limit order below current ask (bid side)\r\n   * For SHORT: Place limit order above current bid (ask side)\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param currentPrice - Current market price\r\n   * @param slippagePercent - Slippage % (e.g., 0.02 = 0.02%)\r\n   * @returns Calculated limit price\r\n   */\r\n  calculateLimitPrice(\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n    slippagePercent: number,\r\n  ): number {\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: Place bid below ask to get filled as maker\r\n      // Example: ask = 100, slippage = 0.02% ‚Üí limit = 99.98\r\n      return currentPrice * (1 - slippagePercent / PERCENT_MULTIPLIER);\r\n    } else {\r\n      // SHORT: Place ask above bid to get filled as maker\r\n      // Example: bid = 100, slippage = 0.02% ‚Üí limit = 100.02\r\n      return currentPrice * (1 + slippagePercent / PERCENT_MULTIPLIER);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Place limit order with retry logic\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param quantity - Order quantity (contracts)\r\n   * @param limitPrice - Limit price\r\n   * @param leverage - Position leverage\r\n   * @returns LimitOrderResult with order details\r\n   */\r\n  async placeLimitOrder(\r\n    direction: SignalDirection,\r\n    quantity: number,\r\n    limitPrice: number,\r\n    leverage: number,\r\n  ): Promise<LimitOrderResult> {\r\n    const startTime = Date.now();\r\n    let lastError: Error | undefined;\r\n\r\n    // Retry logic\r\n    for (let attempt = 1; attempt <= this.config.maxRetries + 1; attempt++) {\r\n      try {\r\n        this.logger.info('üìù Placing limit order', {\r\n          attempt,\r\n          maxAttempts: this.config.maxRetries + 1,\r\n          direction,\r\n          quantity,\r\n          limitPrice,\r\n          leverage,\r\n        });\r\n\r\n        // Set leverage first\r\n        await this.bybitService.setLeverage(leverage);\r\n\r\n        // Round quantity and price to exchange precision\r\n        const orderQty = this.bybitService.roundQuantity(quantity);\r\n        const orderPrice = this.bybitService.roundPrice(limitPrice);\r\n\r\n        // Submit limit order\r\n        const response = await this.bybitService.getRestClient().submitOrder({\r\n          category: 'linear',\r\n          symbol: this.bybitService.getSymbol(),\r\n          side: direction === SignalDirection.LONG ? 'Buy' : 'Sell',\r\n          orderType: 'Limit',\r\n          qty: orderQty,\r\n          price: orderPrice,\r\n          timeInForce: 'GTC', // Good Till Cancelled\r\n          positionIdx: POSITION_IDX_ONE_WAY,\r\n        });\r\n\r\n        if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n          throw new Error(`Failed to place limit order: ${response.retMsg}`);\r\n        }\r\n\r\n        const orderId = response.result.orderId;\r\n        const executionTime = Date.now() - startTime;\r\n\r\n        this.logger.info('‚úÖ Limit order placed successfully', {\r\n          orderId,\r\n          direction,\r\n          quantity: orderQty,\r\n          limitPrice: orderPrice,\r\n          executionTime,\r\n        });\r\n\r\n        return {\r\n          orderId,\r\n          filled: false, // Order placed but not filled yet\r\n          feePaid: 0, // Fee will be calculated after fill\r\n          executionTime,\r\n        };\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        this.logger.warn(`Limit order placement failed (attempt ${attempt})`, {\r\n          error: error instanceof Error ? error.message : String(error),\r\n        });\r\n\r\n        // Retry only if we have attempts left\r\n        if (attempt < this.config.maxRetries + 1) {\r\n          await this.sleep(500); // Wait 500ms before retry\r\n        }\r\n      }\r\n    }\r\n\r\n    // All retries failed\r\n    throw new Error(\r\n      `Failed to place limit order after ${this.config.maxRetries + 1} attempts: ${lastError?.message}`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Wait for limit order to fill with timeout\r\n   *\r\n   * Checks order status every 200ms until filled or timeout\r\n   *\r\n   * @param orderId - Order ID to monitor\r\n   * @param timeoutMs - Max wait time (ms)\r\n   * @returns True if filled, false if timeout\r\n   */\r\n  async waitForFill(orderId: string, timeoutMs: number): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    const endTime = startTime + timeoutMs;\r\n\r\n    this.logger.debug('‚è≥ Waiting for limit order fill', {\r\n      orderId,\r\n      timeoutMs,\r\n    });\r\n\r\n    while (Date.now() < endTime) {\r\n      try {\r\n        // Get order status\r\n        const response = await this.bybitService.getRestClient().getActiveOrders({\r\n          category: 'linear',\r\n          symbol: this.bybitService.getSymbol(),\r\n          orderId,\r\n        });\r\n\r\n        if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n          this.logger.warn('Failed to check order status', {\r\n            orderId,\r\n            error: response.retMsg,\r\n          });\r\n          await this.sleep(ORDER_CHECK_INTERVAL_MS);\r\n          continue;\r\n        }\r\n\r\n        const orders = response.result?.list || [];\r\n\r\n        // If order not in active list, it was filled or cancelled\r\n        if (orders.length === 0) {\r\n          // Check order history to confirm fill\r\n          const historyResponse = await this.bybitService.getRestClient().getHistoricOrders({\r\n            category: 'linear',\r\n            symbol: this.bybitService.getSymbol(),\r\n            orderId,\r\n          });\r\n\r\n          if (historyResponse.retCode === BYBIT_SUCCESS_CODE) {\r\n            const historicOrders = historyResponse.result?.list || [];\r\n            if (historicOrders.length > 0) {\r\n              const order = historicOrders[0];\r\n              const filled = order.orderStatus === 'Filled';\r\n\r\n              this.logger.info(filled ? '‚úÖ Limit order filled' : '‚ùå Limit order not filled', {\r\n                orderId,\r\n                status: order.orderStatus,\r\n                fillPrice: order.avgPrice,\r\n                executionTime: Date.now() - startTime,\r\n              });\r\n\r\n              return filled;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Order still active, wait and check again\r\n        await this.sleep(ORDER_CHECK_INTERVAL_MS);\r\n      } catch (error) {\r\n        this.logger.warn('Error checking order status', {\r\n          orderId,\r\n          error: error instanceof Error ? error.message : String(error),\r\n        });\r\n        await this.sleep(ORDER_CHECK_INTERVAL_MS);\r\n      }\r\n    }\r\n\r\n    // Timeout reached\r\n    const executionTime = Date.now() - startTime;\r\n    this.logger.warn('‚è±Ô∏è Limit order fill timeout', {\r\n      orderId,\r\n      timeoutMs,\r\n      executionTime,\r\n    });\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Cancel unfilled limit order\r\n   *\r\n   * @param orderId - Order ID to cancel\r\n   * @returns True if cancelled successfully\r\n   */\r\n  async cancelOrder(orderId: string): Promise<boolean> {\r\n    try {\r\n      this.logger.info('üö´ Cancelling unfilled limit order', { orderId });\r\n\r\n      const response = await this.bybitService.getRestClient().cancelOrder({\r\n        category: 'linear',\r\n        symbol: this.bybitService.getSymbol(),\r\n        orderId,\r\n      });\r\n\r\n      if (response.retCode !== BYBIT_SUCCESS_CODE) {\r\n        // Order might already be filled or cancelled\r\n        if (response.retMsg.includes('not exists') || response.retMsg.includes('too late')) {\r\n          this.logger.warn('Order already filled or cancelled', {\r\n            orderId,\r\n            reason: response.retMsg,\r\n          });\r\n          return false;\r\n        }\r\n\r\n        throw new Error(`Failed to cancel order: ${response.retMsg}`);\r\n      }\r\n\r\n      this.logger.info('‚úÖ Order cancelled successfully', { orderId });\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error('Failed to cancel order', {\r\n        orderId,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fallback to market order execution\r\n   *\r\n   * Used when limit order times out or fails\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param quantity - Order quantity (contracts)\r\n   * @param leverage - Position leverage\r\n   * @returns MarketOrderResult with execution details\r\n   */\r\n  async fallbackToMarket(\r\n    direction: SignalDirection,\r\n    quantity: number,\r\n    leverage: number,\r\n  ): Promise<MarketOrderResult> {\r\n    const startTime = Date.now();\r\n\r\n    this.logger.info('üîÑ Falling back to market order', {\r\n      direction,\r\n      quantity,\r\n      leverage,\r\n    });\r\n\r\n    try {\r\n      // Use existing BybitService.openPosition for market order\r\n      const side = direction === SignalDirection.LONG ? PositionSide.LONG : PositionSide.SHORT;\r\n\r\n      const orderId = await this.bybitService.openPosition({\r\n        side,\r\n        quantity,\r\n        leverage,\r\n      });\r\n\r\n      // Get order details to find fill price\r\n      const response = await this.bybitService.getRestClient().getHistoricOrders({\r\n        category: 'linear',\r\n        symbol: this.bybitService.getSymbol(),\r\n        orderId,\r\n        limit: 1,\r\n      });\r\n\r\n      let fillPrice = 0;\r\n      if (response.retCode === BYBIT_SUCCESS_CODE && response.result?.list?.length > 0) {\r\n        const order = response.result.list[0];\r\n        fillPrice = parseFloat(order.avgPrice || '0');\r\n      }\r\n\r\n      const executionTime = Date.now() - startTime;\r\n\r\n      // Calculate taker fee (0.06%)\r\n      const feePaid = (quantity * fillPrice * TAKER_FEE_PERCENT) / PERCENT_MULTIPLIER;\r\n\r\n      this.logger.info('‚úÖ Market order executed', {\r\n        orderId,\r\n        fillPrice,\r\n        feePaid,\r\n        executionTime,\r\n      });\r\n\r\n      return {\r\n        orderId,\r\n        filled: true as const, // Market orders are always filled\r\n        fillPrice,\r\n        feePaid,\r\n        executionTime,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to execute market order', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute entry with limit order and optional market fallback\r\n   *\r\n   * Main entry point for limit order execution:\r\n   * 1. Calculate limit price\r\n   * 2. Place limit order\r\n   * 3. Wait for fill with timeout\r\n   * 4. If not filled ‚Üí cancel and fallback to market (if enabled)\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param quantity - Order quantity (contracts)\r\n   * @param currentPrice - Current market price\r\n   * @param leverage - Position leverage\r\n   * @returns Execution result (limit or market)\r\n   */\r\n  async executeEntry(\r\n    direction: SignalDirection,\r\n    quantity: number,\r\n    currentPrice: number,\r\n    leverage: number,\r\n  ): Promise<LimitOrderResult | MarketOrderResult> {\r\n    if (!this.config.enabled) {\r\n      this.logger.warn('Limit order execution disabled, using market order');\r\n      return await this.fallbackToMarket(direction, quantity, leverage);\r\n    }\r\n\r\n    try {\r\n      // 1. Calculate limit price\r\n      const limitPrice = this.calculateLimitPrice(\r\n        direction,\r\n        currentPrice,\r\n        this.config.slippagePercent,\r\n      );\r\n\r\n      this.logger.info('üìä Limit order execution started', {\r\n        direction,\r\n        quantity,\r\n        currentPrice,\r\n        limitPrice,\r\n        slippage: this.config.slippagePercent,\r\n      });\r\n\r\n      // 2. Place limit order\r\n      const limitResult = await this.placeLimitOrder(direction, quantity, limitPrice, leverage);\r\n\r\n      // 3. Wait for fill\r\n      const filled = await this.waitForFill(limitResult.orderId, this.config.timeoutMs);\r\n\r\n      if (filled) {\r\n        // Success! Calculate maker fee (0.01%)\r\n        const feePaid = (quantity * limitPrice * MAKER_FEE_PERCENT) / PERCENT_MULTIPLIER;\r\n\r\n        this.logger.info('üí∞ Limit order filled successfully - Fee savings achieved!', {\r\n          orderId: limitResult.orderId,\r\n          fillPrice: limitPrice,\r\n          feePaid,\r\n          feeSavings: `${(TAKER_FEE_PERCENT - MAKER_FEE_PERCENT).toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n        });\r\n\r\n        return {\r\n          ...limitResult,\r\n          filled: true,\r\n          fillPrice: limitPrice,\r\n          feePaid,\r\n        };\r\n      }\r\n\r\n      // 4. Not filled - cancel and fallback\r\n      this.logger.warn('Limit order not filled within timeout', {\r\n        orderId: limitResult.orderId,\r\n        timeoutMs: this.config.timeoutMs,\r\n      });\r\n\r\n      await this.cancelOrder(limitResult.orderId);\r\n\r\n      if (this.config.fallbackToMarket) {\r\n        this.logger.info('Fallback to market order enabled, executing market order');\r\n        return await this.fallbackToMarket(direction, quantity, leverage);\r\n      }\r\n\r\n      // No fallback - return unfilled result\r\n      this.logger.warn('Fallback to market disabled - entry failed');\r\n      return {\r\n        ...limitResult,\r\n        filled: false,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Limit order execution failed', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      // If fallback enabled, try market order\r\n      if (this.config.fallbackToMarket) {\r\n        this.logger.info('Attempting market order fallback due to error');\r\n        return await this.fallbackToMarket(direction, quantity, leverage);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Sleep for specified milliseconds\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\logger.service.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1505,1561],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 7.","line":73,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":73,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":73,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":73,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":73,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":73,"endColumn":45},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":85,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":89,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":87,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":87,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":87,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":87,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":87,"endColumn":66},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2339,2410],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2466,2530],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[2581,2636],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":104,"column":10,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":104,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2814,2820],"text":"today.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2814,2820],"text":"today === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2814,2820],"text":"!Boolean(today)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":115,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":115,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3098,3111],"text":"(entry.context != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":151,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":151,"endColumn":36},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":168,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":168,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[4753,4818],"text":""},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":192,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":192,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[5344,5397],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":195,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":195,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"info"},"fix":{"range":[5452,5504],"text":""},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":198,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":198,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5560,5612],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":201,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":201,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"error"},"fix":{"range":[5670,5723],"text":""},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Logger Service\r\n *\r\n * Centralized logging service with file and console support\r\n * Features:\r\n * - File logging with daily rotation\r\n * - Console logging with colors\r\n * - Async queue-based file writes\r\n * - 7-day log cleanup\r\n *\r\n * RULE: NO fallbacks, FAIL FAST\r\n */\r\n\r\nimport { existsSync, mkdirSync } from 'fs';\r\nimport { appendFile } from 'fs/promises';\r\nimport { join } from 'path';\r\nimport { LogLevel, LogEntry } from '../types';\r\n\r\nconst LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {\r\n  [LogLevel.DEBUG]: 0,\r\n  [LogLevel.INFO]: 1,\r\n  [LogLevel.WARN]: 2,\r\n  [LogLevel.ERROR]: 3,\r\n};\r\n\r\ninterface WriteQueueItem {\r\n  filePath: string;\r\n  content: string;\r\n}\r\n\r\nexport class LoggerService {\r\n  private readonly minLevel: LogLevel;\r\n  private readonly logDir: string;\r\n  private readonly logToFile: boolean;\r\n  private logs: LogEntry[] = [];\r\n  private writeQueue: WriteQueueItem[] = [];\r\n  private isProcessingQueue: boolean = false;\r\n\r\n  constructor(\r\n    minLevel: LogLevel = LogLevel.INFO,\r\n    logDir: string = './logs',\r\n    logToFile: boolean = true,\r\n  ) {\r\n    this.minLevel = minLevel;\r\n    this.logDir = logDir;\r\n    this.logToFile = logToFile;\r\n\r\n    if (this.logToFile) {\r\n      this.ensureLogDirectory();\r\n      // Start cleanup in background\r\n      void this.cleanOldLogs();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure log directory exists\r\n   */\r\n  private ensureLogDirectory(): void {\r\n    if (!existsSync(this.logDir)) {\r\n      mkdirSync(this.logDir, { recursive: true });\r\n      console.log(`üìÅ Created log directory: ${this.logDir}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean old log files (>7 days)\r\n   */\r\n  private async cleanOldLogs(): Promise<void> {\r\n    try {\r\n      const { readdir, stat, unlink } = await import('fs/promises');\r\n      const files = await readdir(this.logDir);\r\n      const now = Date.now();\r\n      const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\r\n\r\n      for (const file of files) {\r\n        if (!file.endsWith('.log')) {\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          const filePath = join(this.logDir, file);\r\n          const stats = await stat(filePath);\r\n          const age = now - stats.mtime.getTime();\r\n\r\n          if (age > maxAge) {\r\n            await unlink(filePath);\r\n            const daysOld = Math.floor(age / (24 * 60 * 60 * 1000));\r\n            console.log(`üóëÔ∏è Deleted old log file: ${file} (${daysOld} days old)`);\r\n          }\r\n        } catch (fileError) {\r\n          console.error(`Failed to process log file ${file}:`, fileError);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to clean old log files:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get today's date string for filename\r\n   */\r\n  private getTodayString(): string {\r\n    const today = new Date().toISOString().split('T')[0];\r\n    if (!today) {\r\n      throw new Error('Failed to get date string');\r\n    }\r\n    return today;\r\n  }\r\n\r\n  /**\r\n   * Format log entry as string\r\n   */\r\n  private formatLogEntry(entry: LogEntry): string {\r\n    const timestamp = new Date(entry.timestamp).toISOString();\r\n    const contextStr = entry.context ? ` | ${JSON.stringify(entry.context)}` : '';\r\n    return `[${timestamp}] [${entry.level}] ${entry.message}${contextStr}`;\r\n  }\r\n\r\n  /**\r\n   * Write log entry to file (async queue)\r\n   */\r\n  private writeToFile(entry: LogEntry): void {\r\n    if (!this.logToFile) {\r\n      return;\r\n    }\r\n\r\n    const today = this.getTodayString();\r\n    const fileName = `trading-bot-${today}.log`;\r\n    const filePath = join(this.logDir, fileName);\r\n    const logLine = this.formatLogEntry(entry) + '\\n';\r\n\r\n    this.writeQueue.push({ filePath, content: logLine });\r\n    void this.processWriteQueue();\r\n  }\r\n\r\n  /**\r\n   * Process write queue asynchronously\r\n   */\r\n  private async processWriteQueue(): Promise<void> {\r\n    if (this.isProcessingQueue || this.writeQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.isProcessingQueue = true;\r\n\r\n    try {\r\n      // Group writes by file for efficiency\r\n      const fileGroups = new Map<string, string[]>();\r\n\r\n      // Process up to 10 entries at a time\r\n      const batchSize = Math.min(10, this.writeQueue.length);\r\n      const batch = this.writeQueue.splice(0, batchSize);\r\n\r\n      for (const { filePath, content } of batch) {\r\n        if (!fileGroups.has(filePath)) {\r\n          fileGroups.set(filePath, []);\r\n        }\r\n        fileGroups.get(filePath)!.push(content);\r\n      }\r\n\r\n      // Write all groups in parallel\r\n      const writePromises = Array.from(fileGroups.entries()).map(\r\n        async ([filePath, contents]) => {\r\n          try {\r\n            const combinedContent = contents.join('');\r\n            await appendFile(filePath, combinedContent);\r\n          } catch (error) {\r\n            console.error(`Failed to write to log file ${filePath}:`, error);\r\n          }\r\n        },\r\n      );\r\n\r\n      await Promise.all(writePromises);\r\n    } finally {\r\n      this.isProcessingQueue = false;\r\n\r\n      // Process remaining queue\r\n      if (this.writeQueue.length > 0) {\r\n        setImmediate(() => void this.processWriteQueue());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write log entry to console with colors\r\n   */\r\n  private writeToConsole(entry: LogEntry): void {\r\n    const formattedMessage = this.formatLogEntry(entry);\r\n\r\n    switch (entry.level) {\r\n    case LogLevel.DEBUG:\r\n      console.debug('\\x1b[36m%s\\x1b[0m', formattedMessage); // Cyan\r\n      break;\r\n    case LogLevel.INFO:\r\n      console.info('\\x1b[32m%s\\x1b[0m', formattedMessage); // Green\r\n      break;\r\n    case LogLevel.WARN:\r\n      console.warn('\\x1b[33m%s\\x1b[0m', formattedMessage); // Yellow\r\n      break;\r\n    case LogLevel.ERROR:\r\n      console.error('\\x1b[31m%s\\x1b[0m', formattedMessage); // Red\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log debug message\r\n   */\r\n  debug(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.DEBUG, message, context);\r\n  }\r\n\r\n  /**\r\n   * Log info message\r\n   */\r\n  info(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.INFO, message, context);\r\n  }\r\n\r\n  /**\r\n   * Log warning message\r\n   */\r\n  warn(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.WARN, message, context);\r\n  }\r\n\r\n  /**\r\n   * Log error message\r\n   */\r\n  error(message: string, context?: Record<string, unknown>): void {\r\n    this.log(LogLevel.ERROR, message, context);\r\n  }\r\n\r\n  /**\r\n   * Internal log method\r\n   */\r\n  private log(level: LogLevel, message: string, context?: Record<string, unknown>): void {\r\n    const levelPriority = LOG_LEVEL_PRIORITY[level];\r\n    const minPriority = LOG_LEVEL_PRIORITY[this.minLevel];\r\n\r\n    if (levelPriority < minPriority) {\r\n      return; // Skip logs below minimum level\r\n    }\r\n\r\n    const entry: LogEntry = {\r\n      level,\r\n      message,\r\n      timestamp: Date.now(),\r\n      context,\r\n    };\r\n\r\n    this.logs.push(entry);\r\n    this.writeToConsole(entry);\r\n    this.writeToFile(entry);\r\n  }\r\n\r\n  /**\r\n   * Get all logs\r\n   */\r\n  getLogs(): LogEntry[] {\r\n    return [...this.logs];\r\n  }\r\n\r\n  /**\r\n   * Get logs by level\r\n   */\r\n  getLogsByLevel(level: LogLevel): LogEntry[] {\r\n    return this.logs.filter((log) => log.level === level);\r\n  }\r\n\r\n  /**\r\n   * Clear logs\r\n   */\r\n  clear(): void {\r\n    this.logs = [];\r\n  }\r\n\r\n  /**\r\n   * Get current log file path\r\n   */\r\n  getLogFilePath(): string | null {\r\n    if (!this.logToFile) {\r\n      return null;\r\n    }\r\n    const today = this.getTodayString();\r\n    const fileName = `trading-bot-${today}.log`;\r\n    return join(this.logDir, fileName);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\loss-streak.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":68,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":68,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2060,2087],"text":"(this.config.stopAfterLosses != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2060,2087],"text":"(this.config.stopAfterLosses ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2060,2087],"text":"(Boolean(this.config.stopAfterLosses))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.","line":86,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":86,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":90,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":90,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":94,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":94,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":125,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":125,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3470,3497],"text":"(this.config.stopAfterLosses != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3470,3497],"text":"(this.config.stopAfterLosses ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3470,3497],"text":"(Boolean(this.config.stopAfterLosses))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Loss Streak Service (PHASE 5)\r\n *\r\n * Reduces position size after consecutive losses to limit drawdown.\r\n *\r\n * Problem:\r\n * - Bot continues trading at full size after losses\r\n * - Can amplify drawdown during bad market conditions\r\n *\r\n * Solution: Adaptive Position Sizing\r\n * - After 1 loss: Normal size (100%)\r\n * - After 2 losses in a row: Reduce to 75%\r\n * - After 3 losses in a row: Reduce to 50%\r\n * - After 4+ losses in a row: Reduce to 25% (or stop)\r\n * - After 1 win: Reset to normal\r\n *\r\n * Features:\r\n * - Tracks consecutive wins/losses\r\n * - Progressive size reduction\r\n * - Optional emergency stop after N losses\r\n * - Automatic reset after win\r\n */\r\n\r\nimport { LossStreakConfig, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// LOSS STREAK SERVICE\r\n// ============================================================================\r\n\r\nexport class LossStreakService {\r\n  private consecutiveLosses: number = 0;\r\n  private consecutiveWins: number = 0;\r\n\r\n  constructor(\r\n    private config: LossStreakConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Record trade result\r\n   * Call after each trade closes\r\n   *\r\n   * @param isWin - True if trade was profitable, false if loss\r\n   */\r\n  recordTrade(isWin: boolean): void {\r\n    if (isWin) {\r\n      this.consecutiveWins++;\r\n      this.consecutiveLosses = 0; // Reset loss streak\r\n\r\n      this.logger.info('‚úÖ Win recorded - loss streak reset (PHASE 5)', {\r\n        consecutiveWins: this.consecutiveWins,\r\n        sizeMultiplier: '100%',\r\n      });\r\n    } else {\r\n      this.consecutiveLosses++;\r\n      this.consecutiveWins = 0; // Reset win streak\r\n\r\n      const multiplier = this.getSizeMultiplier();\r\n\r\n      this.logger.warn('‚ùå Loss recorded (PHASE 5)', {\r\n        consecutiveLosses: this.consecutiveLosses,\r\n        sizeMultiplier: (multiplier * PERCENT_MULTIPLIER).toFixed(0) + '%',\r\n      });\r\n\r\n      // Check if need to stop\r\n      if (\r\n        this.config.stopAfterLosses &&\r\n        this.consecutiveLosses >= this.config.stopAfterLosses\r\n      ) {\r\n        this.logger.error(\r\n          `‚õî ${this.config.stopAfterLosses} consecutive losses - EMERGENCY STOP (PHASE 5)`,\r\n        );\r\n        process.exit(1); // Stop bot\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current position size multiplier\r\n   * Apply this to calculated position size before opening trade\r\n   *\r\n   * @returns Multiplier (0.25 to 1.0)\r\n   */\r\n  getSizeMultiplier(): number {\r\n    if (this.consecutiveLosses >= 4) {\r\n      return this.config.reductions.after4Losses;\r\n    }\r\n\r\n    if (this.consecutiveLosses >= 3) {\r\n      return this.config.reductions.after3Losses;\r\n    }\r\n\r\n    if (this.consecutiveLosses >= 2) {\r\n      return this.config.reductions.after2Losses;\r\n    }\r\n\r\n    return 1.0; // Normal size\r\n  }\r\n\r\n  /**\r\n   * Get consecutive losses count\r\n   * @returns Number of consecutive losses\r\n   */\r\n  getConsecutiveLosses(): number {\r\n    return this.consecutiveLosses;\r\n  }\r\n\r\n  /**\r\n   * Get consecutive wins count\r\n   * @returns Number of consecutive wins\r\n   */\r\n  getConsecutiveWins(): number {\r\n    return this.consecutiveWins;\r\n  }\r\n\r\n  /**\r\n   * Check if trading should be blocked\r\n   * Returns true if stop limit reached\r\n   *\r\n   * @returns Object with blocked flag and optional reason\r\n   */\r\n  canTrade(): { allowed: boolean; reason?: string } {\r\n    if (\r\n      this.config.stopAfterLosses &&\r\n      this.consecutiveLosses >= this.config.stopAfterLosses\r\n    ) {\r\n      return {\r\n        allowed: false,\r\n        reason: `${this.consecutiveLosses} consecutive losses (limit: ${this.config.stopAfterLosses})`,\r\n      };\r\n    }\r\n\r\n    return { allowed: true };\r\n  }\r\n\r\n  /**\r\n   * Manually reset streak (for testing)\r\n   * Should not be used in production\r\n   */\r\n  reset(): void {\r\n    this.logger.warn('‚ö†Ô∏è Loss streak manually reset');\r\n    this.consecutiveLosses = 0;\r\n    this.consecutiveWins = 0;\r\n  }\r\n\r\n  /**\r\n   * Get config for testing/debugging\r\n   * @returns Deep copy of config\r\n   */\r\n  getConfig(): LossStreakConfig {\r\n    return {\r\n      ...this.config,\r\n      reductions: { ...this.config.reductions }, // Deep copy\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\market-data-collector.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":62,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":62,"endColumn":46,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2330,2367],"text":"(config.indicators.stochastic?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2330,2367],"text":"(config.indicators.stochastic?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":69,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":69,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2686,2727],"text":"(config.indicators.bollingerBands?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2686,2727],"text":"(config.indicators.bollingerBands?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":83,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":83,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3336,3363],"text":"(config.tfAlignment?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3336,3363],"text":"(config.tfAlignment?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'collect' has a complexity of 39. Maximum allowed is 10.","line":96,"column":16,"nodeType":"FunctionExpression","messageId":"complex","endLine":300,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":113,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":113,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4449,4475],"text":"(ema[TimeframeRole.PRIMARY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":116,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":116,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4674,4698],"text":"(ema[TimeframeRole.ENTRY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":123,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":123,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":157,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":157,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6338,6362],"text":"(this.stochasticIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":157,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":157,"endColumn":72,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6366,6399],"text":"(this.config.indicators.stochastic != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":180,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":180,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7319,7342],"text":"(this.bollingerIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":180,"column":38,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":180,"endColumn":75,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7346,7383],"text":"(this.config.indicators.bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":183,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":190,"endColumn":12},{"ruleId":"max-len","severity":1,"message":"This line has a length of 123. Maximum allowed is 120.","line":221,"column":1,"nodeType":"Program","messageId":"max","endLine":221,"endColumn":124},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9077,9100],"text":"(this.tfAlignmentService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":38,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9104,9128],"text":"(ema[TimeframeRole.ENTRY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":66,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":92,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9132,9158],"text":"(ema[TimeframeRole.PRIMARY] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":221,"column":96,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":221,"endColumn":121,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9162,9187],"text":"(ema[TimeframeRole.TREND1] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'entryCandles' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":256,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":256,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":259,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":259,"endColumn":27},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":263,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":265,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":263,"column":15,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":263,"endColumn":28}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES } from '../constants';\r\n/**\r\n * Market Data Collector Service\r\n *\r\n * Collects market data from multiple sources:\r\n * - Current price (Bybit)\r\n * - RSI data (Multi-timeframe)\r\n * - EMA data (Multi-timeframe)\r\n * - ZigZag swing points (Highs/Lows)\r\n * - Market structure (Pattern/Bias)\r\n * - Stochastic oscillator (optional)\r\n * - Bollinger Bands (optional)\r\n * - ATR for adaptive BB params\r\n *\r\n * Extracted from SignalGeneratorService for better testability and SRP.\r\n */\r\n\r\nimport {\r\n  SwingPoint,\r\n  Candle,\r\n  TimeframeRole,\r\n  LoggerService,\r\n  MarketData,\r\n  Config,\r\n  RSIValues,\r\n  EMAValues,\r\n} from '../types';\r\nimport { MultiTimeframeRSIAnalyzer } from '../analyzers/multi-timeframe-rsi.analyzer';\r\nimport { MultiTimeframeEMAAnalyzer } from '../analyzers/multi-timeframe-ema.analyzer';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { StochasticIndicator } from '../indicators/stochastic.indicator';\r\nimport { BollingerBandsIndicator } from '../indicators/bollinger.indicator';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { VWAPIndicator } from '../indicators/vwap.indicator';\r\nimport { MarketStructureAnalyzer } from '../analyzers/market-structure.analyzer';\r\nimport { TFAlignmentService } from './tf-alignment.service';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { BybitService } from './bybit';\r\n\r\n// ============================================================================\r\n// MARKET DATA COLLECTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class MarketDataCollector {\r\n  private stochasticIndicator?: StochasticIndicator;\r\n  private bollingerIndicator?: BollingerBandsIndicator;\r\n  private atrIndicator: ATRIndicator;\r\n  private vwapIndicator: VWAPIndicator;\r\n  private tfAlignmentService?: TFAlignmentService;\r\n\r\n  constructor(\r\n    private rsiAnalyzer: MultiTimeframeRSIAnalyzer,\r\n    private emaAnalyzer: MultiTimeframeEMAAnalyzer,\r\n    private zigzagIndicator: ZigZagIndicator,\r\n    private structureAnalyzer: MarketStructureAnalyzer,\r\n    private candleProvider: CandleProvider,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n    private config: Config,\r\n  ) {\r\n    // Initialize Stochastic if enabled\r\n    if (config.indicators.stochastic?.enabled) {\r\n      const { kPeriod, dPeriod, smooth } = config.indicators.stochastic;\r\n      this.stochasticIndicator = new StochasticIndicator(kPeriod, dPeriod, smooth);\r\n      this.logger.info('‚úÖ StochasticIndicator initialized', { kPeriod, dPeriod, smooth });\r\n    }\r\n\r\n    // Initialize Bollinger Bands if enabled\r\n    if (config.indicators.bollingerBands?.enabled) {\r\n      const { period, stdDev } = config.indicators.bollingerBands;\r\n      this.bollingerIndicator = new BollingerBandsIndicator(period, stdDev);\r\n      this.logger.info('‚úÖ BollingerBandsIndicator initialized', { period, stdDev });\r\n    }\r\n\r\n    // Always initialize ATR (used for adaptive BB and strategies)\r\n    this.atrIndicator = new ATRIndicator(config.indicators.atrPeriod);\r\n\r\n    // Always initialize VWAP (PHASE 6)\r\n    this.vwapIndicator = new VWAPIndicator();\r\n    this.logger.info('‚úÖ VWAPIndicator initialized (PHASE 6)');\r\n\r\n    // Initialize TFAlignmentService if enabled (PHASE 6)\r\n    if (config.tfAlignment?.enabled) {\r\n      this.tfAlignmentService = new TFAlignmentService(config.tfAlignment, logger);\r\n      this.logger.info('‚úÖ TFAlignmentService initialized (PHASE 6)', {\r\n        minAlignmentScore: config.tfAlignment.minAlignmentScore,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collect all market data from sources\r\n   *\r\n   * @returns MarketData object or null if collection fails\r\n   */\r\n  async collect(): Promise<MarketData | null> {\r\n    try {\r\n      // Get current price\r\n      const currentPrice = await this.getCurrentPrice();\r\n      this.logger.debug('Current price', { price: currentPrice });\r\n\r\n      // Get RSI data\r\n      const rsi = await this.getRSIData();\r\n      this.logger.debug('RSI data collected', {\r\n        primary: rsi[TimeframeRole.PRIMARY]?.toFixed(DECIMAL_PLACES.PERCENT),\r\n        entry: rsi[TimeframeRole.ENTRY]?.toFixed(DECIMAL_PLACES.PERCENT),\r\n        trend1: rsi[TimeframeRole.TREND1]?.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Get EMA data\r\n      const ema = await this.getEMAData();\r\n      this.logger.debug('EMA data collected', {\r\n        primary: ema[TimeframeRole.PRIMARY]\r\n          ? `fast=${ema[TimeframeRole.PRIMARY].fast?.toFixed(DECIMAL_PLACES.PERCENT)}, slow=${ema[TimeframeRole.PRIMARY].slow?.toFixed(DECIMAL_PLACES.PERCENT)}`\r\n          : 'N/A',\r\n        entry: ema[TimeframeRole.ENTRY]\r\n          ? `fast=${ema[TimeframeRole.ENTRY].fast?.toFixed(DECIMAL_PLACES.PERCENT)}, slow=${ema[TimeframeRole.ENTRY].slow?.toFixed(DECIMAL_PLACES.PERCENT)}`\r\n          : 'N/A',\r\n      });\r\n\r\n      // Get ZigZag data (PRIMARY timeframe)\r\n      const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n      if (!primaryCandles || primaryCandles.length === 0) {\r\n        this.logger.warn('No PRIMARY candles available');\r\n        return null;\r\n      }\r\n\r\n      const { highs: zigzagHighs, lows: zigzagLows } = this.getZigZagData(primaryCandles);\r\n\r\n      this.logger.debug('ZigZag data collected', {\r\n        highs: zigzagHighs.length,\r\n        lows: zigzagLows.length,\r\n        recentHigh: zigzagHighs.length > 0 ? zigzagHighs[zigzagHighs.length - 1].price : 'N/A',\r\n        recentLow: zigzagLows.length > 0 ? zigzagLows[zigzagLows.length - 1].price : 'N/A',\r\n      });\r\n\r\n      // Analyze structure\r\n      const pattern = this.structureAnalyzer.getLastPattern(zigzagHighs, zigzagLows);\r\n      const bias = this.structureAnalyzer.getTrendBias(zigzagHighs, zigzagLows);\r\n\r\n      this.logger.info('üìä Market structure', {\r\n        pattern,\r\n        bias,\r\n      });\r\n\r\n      // Calculate ATR (always available)\r\n      let atr: number | undefined;\r\n      try {\r\n        atr = this.atrIndicator.calculate(primaryCandles);\r\n        this.logger.debug('ATR calculated', { atr: atr?.toFixed(DECIMAL_PLACES.PRICE) });\r\n      } catch (error) {\r\n        this.logger.warn('ATR calculation failed', { error });\r\n      }\r\n\r\n      // Calculate Stochastic if enabled\r\n      let stochastic: MarketData['stochastic'];\r\n      if (this.stochasticIndicator && this.config.indicators.stochastic) {\r\n        try {\r\n          const result = this.stochasticIndicator.calculate(primaryCandles);\r\n          const { oversoldThreshold, overboughtThreshold } = this.config.indicators.stochastic;\r\n          stochastic = {\r\n            k: result.k,\r\n            d: result.d,\r\n            isOversold: result.k < oversoldThreshold,\r\n            isOverbought: result.k > overboughtThreshold,\r\n          };\r\n          this.logger.debug('Stochastic calculated', {\r\n            k: result.k.toFixed(DECIMAL_PLACES.PERCENT),\r\n            d: result.d.toFixed(DECIMAL_PLACES.PERCENT),\r\n            oversold: stochastic.isOversold,\r\n            overbought: stochastic.isOverbought,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Stochastic calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate Bollinger Bands if enabled\r\n      let bollingerBands: MarketData['bollingerBands'];\r\n      if (this.bollingerIndicator && this.config.indicators.bollingerBands) {\r\n        try {\r\n          // Apply adaptive params if enabled and ATR available\r\n          if (this.config.indicators.bollingerBands.adaptiveParams && atr !== undefined) {\r\n            const adaptiveParams = this.bollingerIndicator.getAdaptiveParams(atr, currentPrice);\r\n            this.bollingerIndicator.applyAdaptiveParams(adaptiveParams);\r\n            this.logger.debug('BB adaptive params applied', {\r\n              period: adaptiveParams.period,\r\n              stdDev: adaptiveParams.stdDev,\r\n            });\r\n          }\r\n\r\n          const result = this.bollingerIndicator.calculate(primaryCandles);\r\n          const isSqueeze = this.bollingerIndicator.isSqueeze(\r\n            this.config.indicators.bollingerBands.squeezeThreshold,\r\n          );\r\n\r\n          bollingerBands = {\r\n            upper: result.upper,\r\n            middle: result.middle,\r\n            lower: result.lower,\r\n            width: result.width,\r\n            percentB: result.percentB,\r\n            isSqueeze,\r\n          };\r\n\r\n          this.logger.debug('Bollinger Bands calculated', {\r\n            upper: result.upper.toFixed(DECIMAL_PLACES.PERCENT),\r\n            middle: result.middle.toFixed(DECIMAL_PLACES.PERCENT),\r\n            lower: result.lower.toFixed(DECIMAL_PLACES.PERCENT),\r\n            width: result.width.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n            percentB: result.percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n            squeeze: isSqueeze,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Bollinger Bands calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate TF Alignment (PHASE 6)\r\n      let tfAlignment: MarketData['tfAlignment'];\r\n      if (this.tfAlignmentService && ema[TimeframeRole.ENTRY] && ema[TimeframeRole.PRIMARY] && ema[TimeframeRole.TREND1]) {\r\n        try {\r\n          const longAlignment = this.tfAlignmentService.calculateAlignment('LONG', currentPrice, {\r\n            entry: { ema20: ema[TimeframeRole.ENTRY]?.fast ?? 0 },\r\n            primary: { ema20: ema[TimeframeRole.PRIMARY]?.fast ?? 0, ema50: ema[TimeframeRole.PRIMARY]?.slow ?? 0 },\r\n            trend1: { ema20: ema[TimeframeRole.TREND1]?.fast ?? 0, ema50: ema[TimeframeRole.TREND1]?.slow ?? 0 },\r\n          });\r\n\r\n          const shortAlignment = this.tfAlignmentService.calculateAlignment(\r\n            'SHORT',\r\n            currentPrice,\r\n            {\r\n              entry: { ema20: ema[TimeframeRole.ENTRY]?.fast ?? 0 },\r\n              primary: { ema20: ema[TimeframeRole.PRIMARY]?.fast ?? 0, ema50: ema[TimeframeRole.PRIMARY]?.slow ?? 0 },\r\n              trend1: { ema20: ema[TimeframeRole.TREND1]?.fast ?? 0, ema50: ema[TimeframeRole.TREND1]?.slow ?? 0 },\r\n            },\r\n          );\r\n\r\n          tfAlignment = {\r\n            long: longAlignment,\r\n            short: shortAlignment,\r\n          };\r\n\r\n          this.logger.debug('TF Alignment calculated (PHASE 6)', {\r\n            long: `${longAlignment.score.toFixed(0)}% (${longAlignment.aligned ? 'aligned' : 'not aligned'})`,\r\n            short: `${shortAlignment.score.toFixed(0)}% (${shortAlignment.aligned ? 'aligned' : 'not aligned'})`,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('TF Alignment calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate VWAP (PHASE 6)\r\n      let vwap: MarketData['vwap'];\r\n      try {\r\n        const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n        const trend1Candles = await this.candleProvider.getCandles(TimeframeRole.TREND1);\r\n\r\n        if (primaryCandles && primaryCandles.length > 0) {\r\n          const vwapPrimary = this.vwapIndicator.calculate(primaryCandles);\r\n\r\n          let vwapTrend1 = 0;\r\n          if (trend1Candles && trend1Candles.length > 0) {\r\n            vwapTrend1 = this.vwapIndicator.calculate(trend1Candles);\r\n          }\r\n\r\n          vwap = {\r\n            primary: vwapPrimary,\r\n            trend1: vwapTrend1,\r\n          };\r\n\r\n          this.logger.debug('VWAP calculated (PHASE 6)', {\r\n            primary: vwapPrimary.toFixed(DECIMAL_PLACES.PERCENT),\r\n            trend1: vwapTrend1.toFixed(DECIMAL_PLACES.PERCENT),\r\n          });\r\n        }\r\n      } catch (error) {\r\n        this.logger.warn('VWAP calculation failed', { error });\r\n      }\r\n\r\n      return {\r\n        rsi,\r\n        ema,\r\n        zigzagHighs,\r\n        zigzagLows,\r\n        currentPrice,\r\n        candles: primaryCandles,\r\n        pattern,\r\n        bias,\r\n        stochastic,\r\n        bollingerBands,\r\n        atr,\r\n        tfAlignment,\r\n        vwap,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error collecting market data', { error });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current price from exchange\r\n   *\r\n   * @returns Current price\r\n   * @throws Error if fetch fails\r\n   */\r\n  async getCurrentPrice(): Promise<number> {\r\n    return await this.bybitService.getCurrentPrice();\r\n  }\r\n\r\n  /**\r\n   * Get RSI data from all timeframes\r\n   *\r\n   * @returns RSI values from all timeframes\r\n   */\r\n  async getRSIData(): Promise<RSIValues> {\r\n    return (await this.rsiAnalyzer.calculateAll()) as RSIValues;\r\n  }\r\n\r\n  /**\r\n   * Get EMA data from all timeframes\r\n   *\r\n   * @returns EMA values from all timeframes\r\n   */\r\n  async getEMAData(): Promise<EMAValues> {\r\n    return (await this.emaAnalyzer.calculateAll()) as EMAValues;\r\n  }\r\n\r\n  /**\r\n   * Get ZigZag swing points from candles\r\n   *\r\n   * @param candles - Candle data\r\n   * @returns Object with highs and lows arrays\r\n   */\r\n  getZigZagData(candles: Candle[]): { highs: SwingPoint[]; lows: SwingPoint[] } {\r\n    const highs = this.zigzagIndicator.findSwingHighs(candles);\r\n    const lows = this.zigzagIndicator.findSwingLows(candles);\r\n\r\n    return { highs, lows };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\max-concurrent-risk.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\micro-wall-detector.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":77,"column":21,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":77,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":78,"column":21,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":78,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":79,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":79,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":114,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":114,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":147,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":147,"endColumn":39},{"ruleId":"max-len","severity":1,"message":"This line has a length of 142. Maximum allowed is 120.","line":163,"column":1,"nodeType":"Program","messageId":"max","endLine":163,"endColumn":143},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":164,"column":89,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":91},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":164,"column":93,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":95},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":168,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 25.","line":168,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":168,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":294,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":294,"endColumn":55}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Micro Wall Detector Service - Scalping Strategy\r\n *\r\n * Detects small orderbook walls (5-10% of total volume) for scalping\r\n * Unlike WhaleDetector (15-20% walls), MicroWall targets frequent small movements\r\n *\r\n * Strategy:\r\n * - Detect micro walls (5-10% of orderbook)\r\n * - Wait for price to break through wall\r\n * - Enter quickly with tight TP (0.15%) and SL (0.08%)\r\n * - Exit within 1-2 minutes\r\n *\r\n * IMPORTANT: Requires WebSocket orderbook for real-time data\r\n */\r\n\r\nimport { LoggerService, SignalDirection, MicroWallDetectorConfig, MicroWall, OrderBook, OrderbookLevel } from '../types';\r\n\r\n// ============================================================================\r\n// MICRO WALL DETECTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class MicroWallDetectorService {\r\n  private trackedWalls: Map<string, MicroWall> = new Map();\r\n  private brokenWalls: Map<string, number> = new Map(); // wall key ‚Üí broken timestamp\r\n\r\n  constructor(\r\n    private config: MicroWallDetectorConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('üîç MicroWallDetectorService initialized', {\r\n      minWallSizePercent: config.minWallSizePercent,\r\n      breakConfirmationMs: config.breakConfirmationMs,\r\n      maxConfidence: config.maxConfidence,\r\n      wallExpiryMs: config.wallExpiryMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Detect micro walls in current orderbook\r\n   * @param orderbook - Current orderbook snapshot\r\n   * @returns Array of detected micro walls\r\n   */\r\n  detectMicroWalls(orderbook: OrderBook): MicroWall[] {\r\n    const now = Date.now();\r\n    const detectedWalls: MicroWall[] = [];\r\n\r\n    // Helper to extract price and size from OrderbookLevel union type\r\n    const getPrice = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n    };\r\n    const getSize = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n    };\r\n\r\n    // Calculate total orderbook volume\r\n    const totalBidVolume = orderbook.bids.reduce((sum: number, level: OrderbookLevel) => {\r\n      const price = getPrice(level);\r\n      const size = getSize(level);\r\n      return sum + price * size;\r\n    }, 0);\r\n    const totalAskVolume = orderbook.asks.reduce((sum: number, level: OrderbookLevel) => {\r\n      const price = getPrice(level);\r\n      const size = getSize(level);\r\n      return sum + price * size;\r\n    }, 0);\r\n    const totalVolume = totalBidVolume + totalAskVolume;\r\n\r\n    if (totalVolume === 0) {\r\n      this.logger.debug('‚ùå MicroWall: Empty orderbook, skipping detection');\r\n      return [];\r\n    }\r\n\r\n    // Get current price (midpoint)\r\n    const firstBid = orderbook.bids[0];\r\n    const firstAsk = orderbook.asks[0];\r\n    const bestBid = firstBid ? getPrice(firstBid) : 0;\r\n    const bestAsk = firstAsk ? getPrice(firstAsk) : 0;\r\n    const currentPrice = (bestBid + bestAsk) / 2;\r\n\r\n    if (currentPrice === 0) {\r\n      this.logger.debug('‚ùå MicroWall: Invalid price, skipping detection');\r\n      return [];\r\n    }\r\n\r\n    // Check bids for micro walls\r\n    for (const level of orderbook.bids) {\r\n      const price = getPrice(level);\r\n      const qty = getSize(level);\r\n      const volumeUSDT = price * qty;\r\n      const percentOfTotal = (volumeUSDT / totalVolume) * PERCENT_MULTIPLIER;\r\n\r\n      if (percentOfTotal >= this.config.minWallSizePercent) {\r\n        const distance = ((currentPrice - price) / currentPrice) * PERCENT_MULTIPLIER;\r\n        const wallKey = `BID_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n        const wall: MicroWall = {\r\n          side: 'BID',\r\n          price,\r\n          size: volumeUSDT,\r\n          percentOfTotal,\r\n          distance,\r\n          timestamp: now,\r\n          broken: false,\r\n        };\r\n\r\n        detectedWalls.push(wall);\r\n        this.trackedWalls.set(wallKey, wall);\r\n\r\n        this.logger.debug('üü¢ MicroWall detected (BID)', {\r\n          price,\r\n          size: volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n          percent: percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n          distance: distance.toFixed(3),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Check asks for micro walls\r\n    for (const level of orderbook.asks) {\r\n      const price = getPrice(level);\r\n      const qty = getSize(level);\r\n      const volumeUSDT = price * qty;\r\n      const percentOfTotal = (volumeUSDT / totalVolume) * PERCENT_MULTIPLIER;\r\n\r\n      if (percentOfTotal >= this.config.minWallSizePercent) {\r\n        const distance = ((price - currentPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n        const wallKey = `ASK_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n        const wall: MicroWall = {\r\n          side: 'ASK',\r\n          price,\r\n          size: volumeUSDT,\r\n          percentOfTotal,\r\n          distance,\r\n          timestamp: now,\r\n          broken: false,\r\n        };\r\n\r\n        detectedWalls.push(wall);\r\n        this.trackedWalls.set(wallKey, wall);\r\n\r\n        this.logger.debug('üî¥ MicroWall detected (ASK)', {\r\n          price,\r\n          size: volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n          percent: percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n          distance: distance.toFixed(3),\r\n        });\r\n      }\r\n    }\r\n\r\n    return detectedWalls;\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for a micro wall\r\n   * Based on wall size and distance from current price\r\n   * @param wall - Micro wall to evaluate\r\n   * @returns Confidence score (0-100)\r\n   */\r\n  calculateWallConfidence(wall: MicroWall): number {\r\n    // Size score: 0-60 points (based on % of orderbook)\r\n    // 5% = PERCENTAGE_THRESHOLDS.MODERATE points, 10% = PERCENTAGE_THRESHOLDS.VERY_HIGH points, 15%+ = PERCENTAGE_THRESHOLDS.VERY_HIGH points\r\n    const sizeScore = Math.min((wall.percentOfTotal / this.config.minWallSizePercent) * 30, 60);\r\n\r\n    // Distance score: 0-30 points (closer = higher score)\r\n    // 0.1% distance = 25 points, 0.5% = 15 points, 1%+ = 5 points\r\n    const distanceScore = Math.max(30 - wall.distance * 25, 5);\r\n\r\n    const confidence = Math.min(sizeScore + distanceScore, this.config.maxConfidence);\r\n\r\n    this.logger.debug('üìä MicroWall confidence calculated', {\r\n      side: wall.side,\r\n      price: wall.price,\r\n      sizeScore: sizeScore.toFixed(1),\r\n      distanceScore: distanceScore.toFixed(1),\r\n      confidence: confidence.toFixed(1),\r\n    });\r\n\r\n    return confidence;\r\n  }\r\n\r\n  /**\r\n   * Check if a micro wall was broken by current price\r\n   * @param wall - Micro wall to check\r\n   * @param currentPrice - Current market price\r\n   * @returns True if wall was broken\r\n   */\r\n  isWallBroken(wall: MicroWall, currentPrice: number): boolean {\r\n    const now = Date.now();\r\n\r\n    // Check if wall was already marked as broken\r\n    if (wall.broken) {\r\n      return true;\r\n    }\r\n\r\n    // BID wall broken = price moved DOWN through wall\r\n    if (wall.side === 'BID' && currentPrice < wall.price) {\r\n      const wallKey = `BID_${wall.price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n      // Check if this wall was already broken previously (skip duplicate)\r\n      if (this.brokenWalls.has(wallKey)) {\r\n        this.logger.debug('‚è≠Ô∏è MicroWall already broken previously (BID)', {\r\n          price: wall.price,\r\n          wallKey,\r\n        });\r\n        return false; // Wall already processed, skip to avoid duplicate signals\r\n      }\r\n\r\n      // Wait for confirmation period\r\n      const timeSinceDetection = now - wall.timestamp;\r\n      if (timeSinceDetection < this.config.breakConfirmationMs) {\r\n        this.logger.debug('‚è≥ MicroWall break confirmation pending (BID)', {\r\n          price: wall.price,\r\n          currentPrice,\r\n          waitMs: this.config.breakConfirmationMs - timeSinceDetection,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      wall.broken = true;\r\n      wall.brokenAt = now;\r\n      this.brokenWalls.set(wallKey, now);\r\n\r\n      this.logger.info('üí• MicroWall BROKEN (BID ‚Üí SHORT signal)', {\r\n        wallPrice: wall.price,\r\n        currentPrice,\r\n        size: wall.size.toFixed(DECIMAL_PLACES.PERCENT),\r\n        percent: wall.percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    // ASK wall broken = price moved UP through wall\r\n    if (wall.side === 'ASK' && currentPrice > wall.price) {\r\n      const wallKey = `ASK_${wall.price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n      // Check if this wall was already broken previously (skip duplicate)\r\n      if (this.brokenWalls.has(wallKey)) {\r\n        this.logger.debug('‚è≠Ô∏è MicroWall already broken previously (ASK)', {\r\n          price: wall.price,\r\n          wallKey,\r\n        });\r\n        return false; // Wall already processed, skip to avoid duplicate signals\r\n      }\r\n\r\n      // Wait for confirmation period\r\n      const timeSinceDetection = now - wall.timestamp;\r\n      if (timeSinceDetection < this.config.breakConfirmationMs) {\r\n        this.logger.debug('‚è≥ MicroWall break confirmation pending (ASK)', {\r\n          price: wall.price,\r\n          currentPrice,\r\n          waitMs: this.config.breakConfirmationMs - timeSinceDetection,\r\n        });\r\n        return false;\r\n      }\r\n\r\n      wall.broken = true;\r\n      wall.brokenAt = now;\r\n      this.brokenWalls.set(wallKey, now);\r\n\r\n      this.logger.info('üí• MicroWall BROKEN (ASK ‚Üí LONG signal)', {\r\n        wallPrice: wall.price,\r\n        currentPrice,\r\n        size: wall.size.toFixed(DECIMAL_PLACES.PERCENT),\r\n        percent: wall.percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired walls from tracking\r\n   * Removes walls older than wallExpiryMs\r\n   */\r\n  cleanupExpiredWalls(): void {\r\n    const now = Date.now();\r\n    let cleanedCount = 0;\r\n\r\n    // Cleanup tracked walls\r\n    for (const [key, wall] of this.trackedWalls.entries()) {\r\n      const age = now - wall.timestamp;\r\n      if (age > this.config.wallExpiryMs) {\r\n        this.trackedWalls.delete(key);\r\n        cleanedCount++;\r\n      }\r\n    }\r\n\r\n    // Cleanup broken walls (prevent re-detection for longer period)\r\n    const breakExpiryMs = this.config.wallExpiryMs * 5; // 5x longer for broken walls\r\n    for (const [key, brokenAt] of this.brokenWalls.entries()) {\r\n      const age = now - brokenAt;\r\n      if (age > breakExpiryMs) {\r\n        this.brokenWalls.delete(key);\r\n      }\r\n    }\r\n\r\n    if (cleanedCount > 0) {\r\n      this.logger.debug('üßπ MicroWall cleanup', {\r\n        removed: cleanedCount,\r\n        remaining: this.trackedWalls.size,\r\n        brokenTracked: this.brokenWalls.size,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all currently tracked micro walls\r\n   * @returns Array of tracked walls\r\n   */\r\n  getTrackedWalls(): MicroWall[] {\r\n    return Array.from(this.trackedWalls.values());\r\n  }\r\n\r\n  /**\r\n   * Check if wall was recently broken (prevents re-entry)\r\n   * @param side - Wall side\r\n   * @param price - Wall price\r\n   * @returns True if wall was recently broken\r\n   */\r\n  wasRecentlyBroken(side: 'BID' | 'ASK', price: number): boolean {\r\n    const wallKey = `${side}_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n    return this.brokenWalls.has(wallKey);\r\n  }\r\n\r\n  /**\r\n   * Get signal direction from broken wall\r\n   * @param wall - Broken wall\r\n   * @returns Signal direction (LONG or SHORT)\r\n   */\r\n  getSignalDirection(wall: MicroWall): SignalDirection {\r\n    // ASK wall broken = price went UP ‚Üí LONG\r\n    if (wall.side === 'ASK') {\r\n      return SignalDirection.LONG;\r\n    }\r\n    // BID wall broken = price went DOWN ‚Üí SHORT\r\n    return SignalDirection.SHORT;\r\n  }\r\n\r\n  /**\r\n   * Reset detector state (for testing)\r\n   */\r\n  reset(): void {\r\n    this.trackedWalls.clear();\r\n    this.brokenWalls.clear();\r\n    this.logger.debug('üîÑ MicroWallDetector reset');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\order-flow-analyzer.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":65,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":65,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2197,2216],"text":"(this.lastOrderbook == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":65,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":65,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2220,2238],"text":"(this.lastMidPrice == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2221,2238],"text":"(this.lastMidPrice ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2220,2238],"text":"(!Boolean(this.lastMidPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":93,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":93,"endColumn":52},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":118,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":118,"endColumn":52},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 999.","line":168,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 999.","line":172,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":172,"endColumn":22},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":193,"column":88,"nodeType":"Literal","messageId":"noMagic","endLine":193,"endColumn":90},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":193,"column":92,"nodeType":"Literal","messageId":"noMagic","endLine":193,"endColumn":95},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":194,"column":78,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":80},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":194,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":194,"endColumn":84},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 999.","line":231,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":231,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.001.","line":234,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":234,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":244,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":244,"endColumn":68},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":287,"column":21,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":287,"endColumn":122,"fix":{"range":[8980,8990],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":287,"column":93,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":287,"endColumn":106,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[8961,8974],"text":"((firstBid?.[0]) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[8961,8974],"text":"(!Number.isNaN((firstBid?.[0])))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8961,8974],"text":"(Boolean((firstBid?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":288,"column":21,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":288,"endColumn":122,"fix":{"range":[9104,9114],"text":""}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":288,"column":93,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":288,"endColumn":106,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[9085,9098],"text":"((firstAsk?.[0]) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[9085,9098],"text":"(!Number.isNaN((firstAsk?.[0])))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9085,9098],"text":"(Boolean((firstAsk?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":289,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":289,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'side' is defined but never used. Allowed unused args must match /^_/u.","line":306,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":306,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":330,"column":23,"nodeType":"CallExpression","messageId":"conditionErrorNullableNumber","endLine":330,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10562,10587],"text":"(newPriceMap.get(oldPrice) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10562,10587],"text":"(newPriceMap.get(oldPrice) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10562,10587],"text":"(Boolean(newPriceMap.get(oldPrice)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":330,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":330,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[10588,10590],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Order Flow Analyzer Service (Phase 5)\r\n *\r\n * Analyzes order flow imbalance by tracking aggressive buy/sell activity\r\n * from orderbook changes.\r\n *\r\n * Logic:\r\n * - Aggressive Buy: Price moved UP + asks removed ‚Üí buyers taking liquidity\r\n * - Aggressive Sell: Price moved DOWN + bids removed ‚Üí sellers taking liquidity\r\n * - Flow Ratio: aggressive_buy_volume / aggressive_sell_volume\r\n * - Threshold: 3.0x (buy:sell or sell:buy)\r\n *\r\n * Detection Window: 3000ms (3 seconds)\r\n * Min Volume: 5000 USDT\r\n */\r\n\r\nimport {\r\n  OrderFlowAnalyzerConfig,\r\n  AggressiveFlow,\r\n  FlowImbalance,\r\n  SignalDirection,\r\n  LoggerService,\r\n  OrderBook,\r\n  OrderbookLevel,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_FLOW_HISTORY = 500; // Max aggressive flow events to keep\r\nconst PRICE_MOVE_THRESHOLD = 0.01; // 0.01% price change to detect direction\r\n\r\n// ============================================================================\r\n// ORDER FLOW ANALYZER SERVICE\r\n// ============================================================================\r\n\r\nexport class OrderFlowAnalyzerService {\r\n  private flowHistory: AggressiveFlow[] = [];\r\n  private lastOrderbook: OrderBook | null = null;\r\n  private lastMidPrice: number | null = null;\r\n\r\n  constructor(\r\n    private config: OrderFlowAnalyzerConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('‚úÖ OrderFlowAnalyzerService initialized', {\r\n      aggressiveBuyThreshold: config.aggressiveBuyThreshold,\r\n      detectionWindow: config.detectionWindow,\r\n      minVolumeUSDT: config.minVolumeUSDT,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Process orderbook update and detect aggressive flow\r\n   *\r\n   * @param orderbook - Current orderbook snapshot\r\n   */\r\n  processOrderbookUpdate(orderbook: OrderBook): void {\r\n    if (!this.lastOrderbook || !this.lastMidPrice) {\r\n      // First update - just store\r\n      this.lastOrderbook = orderbook;\r\n      this.lastMidPrice = this.calculateMidPrice(orderbook);\r\n      return;\r\n    }\r\n\r\n    const currentMidPrice = this.calculateMidPrice(orderbook);\r\n    const priceChangePercent = ((currentMidPrice - this.lastMidPrice) / this.lastMidPrice) * PERCENT_MULTIPLIER;\r\n\r\n    // Detect aggressive buy (price up + asks removed)\r\n    if (priceChangePercent > PRICE_MOVE_THRESHOLD) {\r\n      const removedAsksVolume = this.calculateRemovedVolume(\r\n        this.lastOrderbook.asks,\r\n        orderbook.asks,\r\n        'asks',\r\n      );\r\n\r\n      if (removedAsksVolume > 0) {\r\n        const flow: AggressiveFlow = {\r\n          direction: 'BUY',\r\n          volumeUSDT: removedAsksVolume * currentMidPrice,\r\n          timestamp: Date.now(),\r\n          price: currentMidPrice,\r\n        };\r\n        this.addFlow(flow);\r\n\r\n        this.logger.debug('üü¢ Aggressive BUY detected', {\r\n          priceChange: priceChangePercent.toFixed(3),\r\n          volumeRemoved: removedAsksVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n          volumeUSDT: flow.volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Detect aggressive sell (price down + bids removed)\r\n    if (priceChangePercent < -PRICE_MOVE_THRESHOLD) {\r\n      const removedBidsVolume = this.calculateRemovedVolume(\r\n        this.lastOrderbook.bids,\r\n        orderbook.bids,\r\n        'bids',\r\n      );\r\n\r\n      if (removedBidsVolume > 0) {\r\n        const flow: AggressiveFlow = {\r\n          direction: 'SELL',\r\n          volumeUSDT: removedBidsVolume * currentMidPrice,\r\n          timestamp: Date.now(),\r\n          price: currentMidPrice,\r\n        };\r\n        this.addFlow(flow);\r\n\r\n        this.logger.debug('üî¥ Aggressive SELL detected', {\r\n          priceChange: priceChangePercent.toFixed(3),\r\n          volumeRemoved: removedBidsVolume.toFixed(DECIMAL_PLACES.PERCENT),\r\n          volumeUSDT: flow.volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update last snapshot\r\n    this.lastOrderbook = orderbook;\r\n    this.lastMidPrice = currentMidPrice;\r\n  }\r\n\r\n  /**\r\n   * Detect flow imbalance (aggressive buy/sell ratio)\r\n   *\r\n   * @returns FlowImbalance if detected, null otherwise\r\n   */\r\n  detectFlowImbalance(): FlowImbalance | null {\r\n    const cutoffTime = Date.now() - this.config.detectionWindow;\r\n    const recentFlow = this.flowHistory.filter((f) => f.timestamp >= cutoffTime);\r\n\r\n    if (recentFlow.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Calculate buy/sell volumes\r\n    let buyVolume = 0;\r\n    let sellVolume = 0;\r\n\r\n    for (const flow of recentFlow) {\r\n      if (flow.direction === 'BUY') {\r\n        buyVolume += flow.volumeUSDT;\r\n      } else {\r\n        sellVolume += flow.volumeUSDT;\r\n      }\r\n    }\r\n\r\n    const totalVolume = buyVolume + sellVolume;\r\n\r\n    // Check minimum volume\r\n    if (totalVolume < this.config.minVolumeUSDT) {\r\n      return null;\r\n    }\r\n\r\n    // Calculate flow ratio\r\n    let flowRatio: number;\r\n    let direction: SignalDirection;\r\n\r\n    if (sellVolume === 0) {\r\n      // Only buy flow\r\n      flowRatio = buyVolume > 0 ? 999 : MULTIPLIERS.NEUTRAL;\r\n      direction = SignalDirection.LONG;\r\n    } else if (buyVolume === 0) {\r\n      // Only sell flow\r\n      flowRatio = 999;\r\n      direction = SignalDirection.SHORT;\r\n    } else {\r\n      const buyToSellRatio = buyVolume / sellVolume;\r\n      const sellToBuyRatio = sellVolume / buyVolume;\r\n\r\n      if (buyToSellRatio >= this.config.aggressiveBuyThreshold) {\r\n        // Aggressive buy dominance\r\n        flowRatio = buyToSellRatio;\r\n        direction = SignalDirection.LONG;\r\n      } else if (sellToBuyRatio >= this.config.aggressiveBuyThreshold) {\r\n        // Aggressive sell dominance\r\n        flowRatio = sellToBuyRatio;\r\n        direction = SignalDirection.SHORT;\r\n      } else {\r\n        // No clear imbalance\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Calculate confidence (ratio-based, capped at max)\r\n    const baseConfidence = Math.min((flowRatio / this.config.aggressiveBuyThreshold) * 70, 100);\r\n    const volumeBoost = Math.min((totalVolume / this.config.minVolumeUSDT) * 10, 20);\r\n    const confidence = Math.min(baseConfidence + volumeBoost, this.config.maxConfidence);\r\n\r\n    return {\r\n      direction,\r\n      ratio: flowRatio,\r\n      confidence,\r\n      totalVolumeUSDT: totalVolume,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate flow ratio (for testing/debugging)\r\n   *\r\n   * @param windowMs - Time window (default: config.detectionWindow)\r\n   * @returns Flow ratio (buy/sell or sell/buy)\r\n   */\r\n  calculateFlowRatio(windowMs: number = this.config.detectionWindow): number {\r\n    const cutoffTime = Date.now() - windowMs;\r\n    const recentFlow = this.flowHistory.filter((f) => f.timestamp >= cutoffTime);\r\n\r\n    if (recentFlow.length === 0) {\r\n      return 1.0; // Neutral\r\n    }\r\n\r\n    let buyVolume = 0;\r\n    let sellVolume = 0;\r\n\r\n    for (const flow of recentFlow) {\r\n      if (flow.direction === 'BUY') {\r\n        buyVolume += flow.volumeUSDT;\r\n      } else {\r\n        sellVolume += flow.volumeUSDT;\r\n      }\r\n    }\r\n\r\n    if (sellVolume === 0) {\r\n      return buyVolume > 0 ? 999 : MULTIPLIERS.NEUTRAL;\r\n    }\r\n    if (buyVolume === 0) {\r\n      return 0.001;\r\n    }\r\n\r\n    return buyVolume / sellVolume;\r\n  }\r\n\r\n  /**\r\n   * Cleanup old flow data (beyond 2x detection window)\r\n   */\r\n  cleanupOldFlow(): void {\r\n    const cutoffTime = Date.now() - this.config.detectionWindow * 2;\r\n    this.flowHistory = this.flowHistory.filter((f) => f.timestamp >= cutoffTime);\r\n  }\r\n\r\n  /**\r\n   * Clear all flow history (for testing)\r\n   */\r\n  clearHistory(): void {\r\n    this.flowHistory = [];\r\n    this.lastOrderbook = null;\r\n    this.lastMidPrice = null;\r\n  }\r\n\r\n  /**\r\n   * Get flow history (for testing)\r\n   */\r\n  getFlowHistory(): AggressiveFlow[] {\r\n    return this.flowHistory;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Add aggressive flow event to history\r\n   */\r\n  private addFlow(flow: AggressiveFlow): void {\r\n    this.flowHistory.push(flow);\r\n\r\n    // Limit history size\r\n    if (this.flowHistory.length > MAX_FLOW_HISTORY) {\r\n      this.flowHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate mid price from orderbook\r\n   * Supports both OrderbookManagerService format {price, size} and tuple format [price, qty]\r\n   */\r\n  private calculateMidPrice(orderbook: OrderBook): number {\r\n    const firstBid = orderbook.bids[0];\r\n    const firstAsk = orderbook.asks[0];\r\n    const bestBid = (typeof firstBid === 'object' && 'price' in firstBid ? firstBid.price : firstBid?.[0] || 0) as number;\r\n    const bestAsk = (typeof firstAsk === 'object' && 'price' in firstAsk ? firstAsk.price : firstAsk?.[0] || 0) as number;\r\n    return (bestBid + bestAsk) / 2;\r\n  }\r\n\r\n  /**\r\n   * Calculate volume removed from orderbook side\r\n   *\r\n   * Compares old and new orderbook to find removed volume\r\n   * Supports both OrderbookManagerService format {price, size} and tuple format [price, qty]\r\n   *\r\n   * @param oldSide - Old orderbook side (bids or asks)\r\n   * @param newSide - New orderbook side\r\n   * @param side - 'bids' or 'asks'\r\n   * @returns Total volume removed\r\n   */\r\n  private calculateRemovedVolume(\r\n    oldSide: OrderbookLevel[],\r\n    newSide: OrderbookLevel[],\r\n    side: 'bids' | 'asks',\r\n  ): number {\r\n    // Helper to extract price and size from OrderbookLevel union type\r\n    const getPrice = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n    };\r\n    const getSize = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n    };\r\n\r\n    // Build map of new prices ‚Üí sizes\r\n    const newPriceMap = new Map<number, number>();\r\n    for (const level of newSide) {\r\n      const price = getPrice(level);\r\n      const size = getSize(level);\r\n      newPriceMap.set(price, size);\r\n    }\r\n\r\n    let removedVolume = 0;\r\n\r\n    // Check old levels that disappeared or reduced\r\n    for (const oldLevel of oldSide) {\r\n      const oldPrice = getPrice(oldLevel);\r\n      const oldSize = getSize(oldLevel);\r\n      const newSize = newPriceMap.get(oldPrice) || 0;\r\n\r\n      if (newSize < oldSize) {\r\n        // Volume was removed\r\n        removedVolume += oldSize - newSize;\r\n      }\r\n    }\r\n\r\n    return removedVolume;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\orderbook-imbalance.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":72,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":72,"endColumn":55}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Orderbook Imbalance Service (PHASE 4 Feature 4)\r\n *\r\n * Analyzes bid/ask volume ratio in orderbook to detect buying/selling pressure.\r\n *\r\n * Imbalance = (bidVolume - askVolume) / totalVolume * PERCENT_MULTIPLIER\r\n *\r\n * Use Cases:\r\n * - Entry timing (enter when imbalance matches direction)\r\n * - Reversal signals (sudden imbalance flip)\r\n * - Confirmation filter (strong BID imbalance confirms LONG)\r\n *\r\n * Data Source: Orderbook depth (top N levels from OrderbookManagerService)\r\n */\r\n\r\nimport { OrderbookImbalanceConfig, ImbalanceAnalysis, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// ORDERBOOK IMBALANCE SERVICE\r\n// ============================================================================\r\n\r\nexport class OrderbookImbalanceService {\r\n  constructor(\r\n    private config: OrderbookImbalanceConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('OrderbookImbalanceService initialized', {\r\n      enabled: config.enabled,\r\n      levels: config.levels,\r\n      minImbalancePercent: config.minImbalancePercent,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyze orderbook imbalance from bids/asks\r\n   *\r\n   * @param orderbook - Orderbook with bids [[price, size]] and asks [[price, size]]\r\n   * @returns Imbalance analysis with direction and strength\r\n   */\r\n  analyze(orderbook: { bids: [number, number][]; asks: [number, number][] }): ImbalanceAnalysis {\r\n    if (!this.config.enabled) {\r\n      // Disabled - return neutral\r\n      return this.getNeutralAnalysis();\r\n    }\r\n\r\n    const levels = this.config.levels;\r\n\r\n    // Get top N levels\r\n    const bids = orderbook.bids.slice(0, levels);\r\n    const asks = orderbook.asks.slice(0, levels);\r\n\r\n    // Calculate volumes\r\n    const bidVolume = bids.reduce((sum, [_, qty]) => sum + qty, 0);\r\n    const askVolume = asks.reduce((sum, [_, qty]) => sum + qty, 0);\r\n    const totalVolume = bidVolume + askVolume;\r\n\r\n    // Calculate imbalance\r\n    const imbalance = totalVolume > 0 ? ((bidVolume - askVolume) / totalVolume) * PERCENT_MULTIPLIER : 0;\r\n\r\n    // Determine direction\r\n    let direction: 'BID' | 'ASK' | 'NEUTRAL';\r\n    if (Math.abs(imbalance) < this.config.minImbalancePercent) {\r\n      direction = 'NEUTRAL';\r\n    } else if (imbalance > 0) {\r\n      direction = 'BID'; // More bid volume ‚Üí bullish pressure\r\n    } else {\r\n      direction = 'ASK'; // More ask volume ‚Üí bearish pressure\r\n    }\r\n\r\n    // Calculate strength (0-100)\r\n    const strength = Math.min(Math.abs(imbalance), 100);\r\n\r\n    const analysis: ImbalanceAnalysis = {\r\n      timestamp: Date.now(),\r\n      bidVolume,\r\n      askVolume,\r\n      totalVolume,\r\n      imbalance,\r\n      direction,\r\n      strength,\r\n    };\r\n\r\n    /* this.logger.debug('Orderbook imbalance analyzed', {\r\n      bidVol: bidVolume.toFixed(0),\r\n      askVol: askVolume.toFixed(0),\r\n      imbalance: imbalance.toFixed(1) + '%',\r\n      direction,\r\n      strength: strength.toFixed(0),\r\n    });\r\n*/\r\n    return analysis;\r\n  }\r\n\r\n  /**\r\n   * Get neutral analysis (no imbalance)\r\n   */\r\n  private getNeutralAnalysis(): ImbalanceAnalysis {\r\n    return {\r\n      timestamp: Date.now(),\r\n      bidVolume: 0,\r\n      askVolume: 0,\r\n      totalVolume: 0,\r\n      imbalance: 0,\r\n      direction: 'NEUTRAL',\r\n      strength: 0,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\orderbook-manager.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":241,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":241,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6976,6992],"text":"this.wallTracker != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":249,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":249,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7222,7238],"text":"this.wallTracker != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TIME_UNITS } from '../constants';\r\n/**\r\n * Orderbook Manager Service\r\n *\r\n * Maintains local orderbook snapshot from WebSocket updates:\r\n * - Receives snapshot on initial subscription\r\n * - Applies delta updates to maintain current state\r\n * - Provides full orderbook on demand for whale detection\r\n *\r\n * Responsibilities:\r\n * - Snapshot storage and management\r\n * - Delta application logic\r\n * - Memory management (prevent leaks)\r\n *\r\n * Single Responsibility: Orderbook state management\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\nimport { WallTrackerService } from './wall-tracker.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MAX_ORDERBOOK_LEVELS = 100; // Max levels to store (prevents memory leak)\r\nconst SNAPSHOT_RESET_THRESHOLD_MS = TIME_UNITS.MINUTE; // Reset if no snapshot for 1 min\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface OrderbookLevel {\r\n  price: number;\r\n  size: number;\r\n}\r\n\r\nexport interface OrderbookSnapshot {\r\n  bids: OrderbookLevel[];\r\n  asks: OrderbookLevel[];\r\n  timestamp: number;\r\n  updateId: number;\r\n}\r\n\r\nexport interface OrderbookUpdate {\r\n  type: 'snapshot' | 'delta';\r\n  bids: Array<[string, string]>; // [price, size] from Bybit\r\n  asks: Array<[string, string]>;\r\n  updateId: number;\r\n  timestamp: number;\r\n}\r\n\r\n// ============================================================================\r\n// ORDERBOOK MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class OrderbookManagerService {\r\n  // Snapshot storage (Map for O(1) lookup/update/delete)\r\n  private bidsMap: Map<number, number> = new Map(); // price -> size\r\n  private asksMap: Map<number, number> = new Map();\r\n  private lastUpdateId: number = 0;\r\n  private lastSnapshotTime: number = 0;\r\n  private isInitialized: boolean = false;\r\n\r\n  constructor(\r\n    private readonly symbol: string,\r\n    private readonly logger: LoggerService,\r\n    private readonly wallTracker?: WallTrackerService,\r\n  ) {}\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Process orderbook update from WebSocket\r\n   * Handles both snapshot and delta messages\r\n   */\r\n  processUpdate(update: OrderbookUpdate): void {\r\n    if (update.type === 'snapshot') {\r\n      this.handleSnapshot(update);\r\n    } else {\r\n      this.handleDelta(update);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current orderbook snapshot\r\n   * Returns sorted bids (descending) and asks (ascending)\r\n   */\r\n  getSnapshot(): OrderbookSnapshot | null {\r\n    if (!this.isInitialized) {\r\n      this.logger.warn('Orderbook not initialized yet', { symbol: this.symbol });\r\n      return null;\r\n    }\r\n\r\n    // Check if snapshot is stale\r\n    const now = Date.now();\r\n    if (now - this.lastSnapshotTime > SNAPSHOT_RESET_THRESHOLD_MS) {\r\n      this.logger.warn('Orderbook snapshot is stale, waiting for new data', {\r\n        symbol: this.symbol,\r\n        ageMs: now - this.lastSnapshotTime,\r\n      });\r\n      return null;\r\n    }\r\n\r\n    // Convert Maps to sorted arrays\r\n    const bids = this.getSortedBids();\r\n    const asks = this.getSortedAsks();\r\n\r\n    return {\r\n      bids,\r\n      asks,\r\n      timestamp: this.lastSnapshotTime,\r\n      updateId: this.lastUpdateId,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if orderbook is initialized and ready\r\n   */\r\n  isReady(): boolean {\r\n    return this.isInitialized && this.bidsMap.size > 0 && this.asksMap.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Get current orderbook statistics\r\n   */\r\n  getStats(): {\r\n    bidsCount: number;\r\n    asksCount: number;\r\n    initialized: boolean;\r\n    lastUpdate: number;\r\n    } {\r\n    return {\r\n      bidsCount: this.bidsMap.size,\r\n      asksCount: this.asksMap.size,\r\n      initialized: this.isInitialized,\r\n      lastUpdate: this.lastSnapshotTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset orderbook state\r\n   * Used when connection is lost or on explicit reset\r\n   */\r\n  reset(): void {\r\n    this.bidsMap.clear();\r\n    this.asksMap.clear();\r\n    this.lastUpdateId = 0;\r\n    this.lastSnapshotTime = 0;\r\n    this.isInitialized = false;\r\n\r\n    this.logger.info('Orderbook reset', { symbol: this.symbol });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Handle snapshot message (full orderbook)\r\n   * Reset local state and store new snapshot\r\n   */\r\n  private handleSnapshot(update: OrderbookUpdate): void {\r\n    this.logger.info('üì∏ Orderbook snapshot received', {\r\n      symbol: this.symbol,\r\n      bids: update.bids.length,\r\n      asks: update.asks.length,\r\n      updateId: update.updateId,\r\n    });\r\n\r\n    // Reset existing data\r\n    this.bidsMap.clear();\r\n    this.asksMap.clear();\r\n\r\n    // Store snapshot\r\n    this.applyLevels(this.bidsMap, update.bids, true);\r\n    this.applyLevels(this.asksMap, update.asks, false);\r\n\r\n    this.lastUpdateId = update.updateId;\r\n    this.lastSnapshotTime = Date.now();\r\n    this.isInitialized = true;\r\n\r\n    this.logger.debug('Snapshot applied', {\r\n      bidsCount: this.bidsMap.size,\r\n      asksCount: this.asksMap.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle delta message (incremental update)\r\n   * Apply changes to existing snapshot\r\n   */\r\n  private handleDelta(update: OrderbookUpdate): void {\r\n    if (!this.isInitialized) {\r\n      this.logger.warn('Received delta before snapshot, ignoring', {\r\n        symbol: this.symbol,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Apply delta to bids and asks\r\n    this.applyLevels(this.bidsMap, update.bids, true);\r\n    this.applyLevels(this.asksMap, update.asks, false);\r\n\r\n    this.lastUpdateId = update.updateId;\r\n    this.lastSnapshotTime = Date.now();\r\n\r\n    // Log periodically (1% of updates to avoid spam)\r\n    /*if (Math.random() < 0.01) {\r\n      this.logger.debug('Delta applied', {\r\n        bidsCount: this.bidsMap.size,\r\n        asksCount: this.asksMap.size,\r\n        updateId: update.updateId,\r\n      });\r\n    }*/\r\n  }\r\n\r\n  /**\r\n   * Apply price levels to map\r\n   * Rules:\r\n   * - size = 0 ‚Üí delete level\r\n   * - size > 0 ‚Üí insert or update level\r\n   */\r\n  private applyLevels(\r\n    map: Map<number, number>,\r\n    levels: Array<[string, string]>,\r\n    isBids: boolean = true,\r\n  ): void {\r\n    const side: 'BID' | 'ASK' = isBids ? 'BID' : 'ASK';\r\n\r\n    for (const [priceStr, sizeStr] of levels) {\r\n      const price = parseFloat(priceStr);\r\n      const size = parseFloat(sizeStr);\r\n\r\n      if (size === 0) {\r\n        // Delete level\r\n        map.delete(price);\r\n\r\n        // PHASE 4: Notify Wall Tracker (wall removed)\r\n        if (this.wallTracker) {\r\n          this.wallTracker.removeWall(price, side);\r\n        }\r\n      } else {\r\n        // Insert or update level\r\n        map.set(price, size);\r\n\r\n        // PHASE 4: Notify Wall Tracker (wall detected/updated)\r\n        if (this.wallTracker) {\r\n          this.wallTracker.detectWall(price, size, side);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Memory leak protection: trim if too large\r\n    if (map.size > MAX_ORDERBOOK_LEVELS) {\r\n      this.trimOrderbook(map, isBids);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trim orderbook to prevent memory leaks\r\n   * Keep only best N levels\r\n   * For bids: keep highest prices\r\n   * For asks: keep lowest prices\r\n   */\r\n  private trimOrderbook(map: Map<number, number>, isBids: boolean = true): void {\r\n    if (map.size <= MAX_ORDERBOOK_LEVELS) {\r\n      return;\r\n    }\r\n\r\n    // Convert to array and sort\r\n    // Bids: descending (highest first), Asks: ascending (lowest first)\r\n    const sorted = Array.from(map.entries()).sort((a, b) => {\r\n      return isBids ? b[0] - a[0] : a[0] - b[0];\r\n    });\r\n\r\n    const toKeep = sorted.slice(0, MAX_ORDERBOOK_LEVELS);\r\n\r\n    map.clear();\r\n    for (const [price, size] of toKeep) {\r\n      map.set(price, size);\r\n    }\r\n\r\n    this.logger.warn('Orderbook trimmed to prevent memory leak', {\r\n      symbol: this.symbol,\r\n      side: isBids ? 'bids' : 'asks',\r\n      previousSize: sorted.length,\r\n      newSize: map.size,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get sorted bids (highest price first)\r\n   */\r\n  private getSortedBids(): OrderbookLevel[] {\r\n    return Array.from(this.bidsMap.entries())\r\n      .sort((a, b) => b[0] - a[0]) // Descending price\r\n      .map(([price, size]) => ({ price, size }));\r\n  }\r\n\r\n  /**\r\n   * Get sorted asks (lowest price first)\r\n   */\r\n  private getSortedAsks(): OrderbookLevel[] {\r\n    return Array.from(this.asksMap.entries())\r\n      .sort((a, b) => a[0] - b[0]) // Ascending price\r\n      .map(([price, size]) => ({ price, size }));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\pnl-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'directionMultiplier' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":131,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":131,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * PnL Calculator Service\r\n *\r\n * Calculates profit/loss for trades with correct fees.\r\n * Separated for testability and reusability.\r\n *\r\n * Formula:\r\n * - pnlGross = (exitPrice - entryPrice) √ó quantity √ó directionMultiplier\r\n * - fees = (entryValue + exitValue) √ó feeRate\r\n * - pnlNet = pnlGross - fees\r\n *\r\n * Where directionMultiplier:\r\n * - LONG: +1 (profit when price goes up)\r\n * - SHORT: -1 (profit when price goes down)\r\n */\r\n\r\nimport { PositionSide } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nexport const BYBIT_TAKER_FEE = 0.00055; // 0.055% for non-VIP users\r\nexport const BYBIT_MAKER_FEE = 0.0002; // 0.02% for non-VIP users\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface PnLResult {\r\n  pnlGross: number; // PnL before fees\r\n  fees: number; // Trading fees\r\n  pnlNet: number; // PnL after fees\r\n  pnlPercent: number; // PnL as percentage of entry value\r\n}\r\n\r\n// ============================================================================\r\n// PNL CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class PnLCalculatorService {\r\n  /**\r\n   * Calculate PnL for a trade\r\n   * @param side - Position side (LONG or SHORT)\r\n   * @param entryPrice - Entry price\r\n   * @param exitPrice - Exit price\r\n   * @param quantity - Quantity traded\r\n   * @param feeRate - Fee rate (default: taker fee 0.055%)\r\n   */\r\n  static calculate(\r\n    side: PositionSide,\r\n    entryPrice: number,\r\n    exitPrice: number,\r\n    quantity: number,\r\n    feeRate: number = BYBIT_TAKER_FEE,\r\n  ): PnLResult {\r\n    // Calculate gross PnL\r\n    const priceDiff = exitPrice - entryPrice;\r\n    const directionMultiplier = side === PositionSide.LONG ? 1 : -1;\r\n    const pnlGross = priceDiff * quantity * directionMultiplier;\r\n\r\n    // Calculate fees\r\n    const entryValue = entryPrice * quantity;\r\n    const exitValue = exitPrice * quantity;\r\n    const fees = (entryValue + exitValue) * feeRate;\r\n\r\n    // Calculate net PnL\r\n    const pnlNet = pnlGross - fees;\r\n\r\n    // Calculate percentage\r\n    const pnlPercent = (priceDiff / entryPrice) * PERCENT_MULTIPLIER * directionMultiplier;\r\n\r\n    return {\r\n      pnlGross,\r\n      fees,\r\n      pnlNet,\r\n      pnlPercent,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate total PnL from multiple partial closes\r\n   */\r\n  static calculatePartialCloses(\r\n    side: PositionSide,\r\n    entryPrice: number,\r\n    closes: Array<{ quantity: number; exitPrice: number }>,\r\n    feeRate: number = BYBIT_TAKER_FEE,\r\n  ): PnLResult {\r\n    let totalPnlGross = 0;\r\n    let totalFees = 0;\r\n\r\n    closes.forEach((close) => {\r\n      const result = this.calculate(side, entryPrice, close.exitPrice, close.quantity, feeRate);\r\n      totalPnlGross += result.pnlGross;\r\n      totalFees += result.fees;\r\n    });\r\n\r\n    const totalPnlNet = totalPnlGross - totalFees;\r\n\r\n    // Calculate weighted average percentage\r\n    const totalQuantity = closes.reduce((sum, c) => sum + c.quantity, 0);\r\n    const weightedAvgExitPrice =\r\n      closes.reduce((sum, c) => sum + c.exitPrice * c.quantity, 0) / totalQuantity;\r\n    const priceDiff = weightedAvgExitPrice - entryPrice;\r\n    const directionMultiplier = side === PositionSide.LONG ? 1 : -1;\r\n    const pnlPercent = (priceDiff / entryPrice) * PERCENT_MULTIPLIER * directionMultiplier;\r\n\r\n    return {\r\n      pnlGross: totalPnlGross,\r\n      fees: totalFees,\r\n      pnlNet: totalPnlNet,\r\n      pnlPercent,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate break-even price (price at which PnL = 0 after fees)\r\n   */\r\n  static calculateBreakeven(\r\n    side: PositionSide,\r\n    entryPrice: number,\r\n    feeRate: number = BYBIT_TAKER_FEE,\r\n  ): number {\r\n    // Break-even: pnlGross = fees\r\n    // (exitPrice - entryPrice) √ó qty √ó mult = (entryPrice √ó qty + exitPrice √ó qty) √ó feeRate\r\n    // Simplify (divide by qty):\r\n    // (exitPrice - entryPrice) √ó mult = (entryPrice + exitPrice) √ó feeRate\r\n\r\n    const directionMultiplier = side === PositionSide.LONG ? 1 : -1;\r\n\r\n    // For LONG: exitPrice - entryPrice = (entryPrice + exitPrice) √ó feeRate\r\n    // For SHORT: -(exitPrice - entryPrice) = (entryPrice + exitPrice) √ó feeRate\r\n\r\n    // Solve for exitPrice:\r\n    // LONG: exitPrice √ó (1 - feeRate) = entryPrice √ó (1 + feeRate)\r\n    // SHORT: exitPrice √ó (1 + feeRate) = entryPrice √ó (1 - feeRate)\r\n\r\n    if (side === PositionSide.LONG) {\r\n      return (entryPrice * (1 + feeRate)) / (1 - feeRate);\r\n    } else {\r\n      return (entryPrice * (1 - feeRate)) / (1 + feeRate);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\position-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PRECISION_MULTIPLIER_BASE' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":123,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":123,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3995,4013],"text":"limits.maxOrderQty != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3995,4013],"text":"limits.maxOrderQty ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3995,4013],"text":"Boolean(limits.maxOrderQty)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Position Calculator Service\r\n *\r\n * Centralizes ALL position sizing calculations:\r\n * - Quantity calculation with leverage\r\n * - Rounding to exchange precision (qtyStep, tickSize)\r\n * - Validation against exchange limits\r\n * - Position value and margin calculations\r\n *\r\n * Single Responsibility: Position sizing mathematics\r\n *\r\n * Rules:\r\n * - NO hardcoded values (qtyStep, tickSize must be provided)\r\n * - ONE place for rounding logic\r\n * - Strict validation before returning\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface ExchangeLimits {\r\n  qtyStep: string;      // Min quantity increment (e.g., \"0.1\", \"0.01\")\r\n  tickSize: string;     // Min price increment (e.g., \"0.0001\")\r\n  minOrderQty: string;  // Minimum order quantity\r\n  maxOrderQty?: string; // Maximum order quantity (optional)\r\n}\r\n\r\nexport interface QuantityCalculation {\r\n  quantity: number;          // Raw calculated quantity\r\n  roundedQuantity: string;   // Rounded to qtyStep precision\r\n  notionalValue: number;     // Total position value (qty * price)\r\n  marginUsed: number;        // USDT locked as margin\r\n  isValid: boolean;          // Passes all validations\r\n  validationErrors: string[]; // List of validation errors\r\n}\r\n\r\nexport interface PriceRounding {\r\n  price: number;\r\n  roundedPrice: string;\r\n  isValid: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PRECISION_MULTIPLIER_BASE = 10;\r\n\r\n// ============================================================================\r\n// POSITION CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class PositionCalculatorService {\r\n  constructor(private readonly logger: LoggerService) {}\r\n\r\n  // ==========================================================================\r\n  // QUANTITY CALCULATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate position quantity with leverage\r\n   *\r\n   * Formula: quantity = (positionSizeUsdt * leverage) / price\r\n   *\r\n   * Example:\r\n   * - positionSizeUsdt: 10 USDT\r\n   * - leverage: 10x\r\n   * - price: 1.20 USDT\r\n   * - Result: (10 * 10) / 1.20 = 83.33 coins\r\n   *\r\n   * @param positionSizeUsdt - Amount of USDT to use as margin\r\n   * @param leverage - Leverage multiplier\r\n   * @param price - Current market price\r\n   * @param limits - Exchange limits for validation\r\n   * @returns Quantity calculation with validation\r\n   */\r\n  calculateQuantity(\r\n    positionSizeUsdt: number,\r\n    leverage: number,\r\n    price: number,\r\n    limits: ExchangeLimits,\r\n  ): QuantityCalculation {\r\n    const validationErrors: string[] = [];\r\n\r\n    // Input validation\r\n    if (positionSizeUsdt <= 0) {\r\n      validationErrors.push('Position size must be positive');\r\n    }\r\n    if (leverage <= 0) {\r\n      validationErrors.push('Leverage must be positive');\r\n    }\r\n    if (price <= 0) {\r\n      validationErrors.push('Price must be positive');\r\n    }\r\n\r\n    if (validationErrors.length > 0) {\r\n      return {\r\n        quantity: 0,\r\n        roundedQuantity: '0',\r\n        notionalValue: 0,\r\n        marginUsed: 0,\r\n        isValid: false,\r\n        validationErrors,\r\n      };\r\n    }\r\n\r\n    // Calculate raw quantity\r\n    const quantity = (positionSizeUsdt * leverage) / price;\r\n\r\n    // Round to exchange precision\r\n    const roundedQuantity = this.roundToStep(quantity, limits.qtyStep);\r\n    const roundedQtyNum = parseFloat(roundedQuantity);\r\n\r\n    // Validate against limits\r\n    const minQty = parseFloat(limits.minOrderQty);\r\n    if (roundedQtyNum < minQty) {\r\n      validationErrors.push(`Quantity ${roundedQuantity} below minimum ${limits.minOrderQty}`);\r\n    }\r\n\r\n    if (limits.maxOrderQty) {\r\n      const maxQty = parseFloat(limits.maxOrderQty);\r\n      if (roundedQtyNum > maxQty) {\r\n        validationErrors.push(`Quantity ${roundedQuantity} exceeds maximum ${limits.maxOrderQty}`);\r\n      }\r\n    }\r\n\r\n    // Calculate position values\r\n    const notionalValue = roundedQtyNum * price;\r\n    const marginUsed = notionalValue / leverage;\r\n\r\n    this.logger.debug('Quantity calculated', {\r\n      positionSizeUsdt,\r\n      leverage,\r\n      price,\r\n      rawQuantity: quantity,\r\n      roundedQuantity,\r\n      notionalValue,\r\n      marginUsed,\r\n      qtyStep: limits.qtyStep,\r\n    });\r\n\r\n    return {\r\n      quantity,\r\n      roundedQuantity,\r\n      notionalValue,\r\n      marginUsed,\r\n      isValid: validationErrors.length === 0,\r\n      validationErrors,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ROUNDING UTILITIES\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Round value to exchange step precision\r\n   *\r\n   * Rules:\r\n   * - Always round DOWN (Math.floor) to avoid exceeding balance\r\n   * - Respect step precision (e.g., 0.1, 0.01, 1.0)\r\n   *\r\n   * Example:\r\n   * - value: 83.577, step: \"0.1\" ‚Üí \"83.5\"\r\n   * - value: 83.577, step: \"0.01\" ‚Üí \"83.57\"\r\n   * - value: 83.577, step: \"1.0\" ‚Üí \"83\"\r\n   *\r\n   * @param value - Number to round\r\n   * @param step - Exchange step size (as string)\r\n   * @returns Rounded value as string with correct precision\r\n   */\r\n  roundToStep(value: number, step: string): string {\r\n    const stepNum = parseFloat(step);\r\n\r\n    if (stepNum <= 0) {\r\n      this.logger.error('Invalid step size', { step });\r\n      throw new Error(`Invalid step size: ${step}`);\r\n    }\r\n\r\n    // Round down to nearest step\r\n    const rounded = Math.floor(value / stepNum) * stepNum;\r\n\r\n    // Format to match step precision (count decimals in step)\r\n    const decimals = this.getDecimalPlaces(step);\r\n    const result = rounded.toFixed(decimals);\r\n\r\n    this.logger.debug('Rounded to step', {\r\n      input: value,\r\n      step,\r\n      stepNum,\r\n      rounded,\r\n      decimals,\r\n      result,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Round price to tick size\r\n   *\r\n   * Example:\r\n   * - price: 1.00249, tickSize: \"0.0001\" ‚Üí \"1.0024\"\r\n   * - price: 1.00249, tickSize: \"0.01\" ‚Üí \"1.00\"\r\n   *\r\n   * @param price - Price to round\r\n   * @param tickSize - Exchange tick size\r\n   * @returns Rounded price as string\r\n   */\r\n  roundPrice(price: number, tickSize: string): PriceRounding {\r\n    try {\r\n      const rounded = this.roundToStep(price, tickSize);\r\n      return {\r\n        price,\r\n        roundedPrice: rounded,\r\n        isValid: true,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Failed to round price', {\r\n        price,\r\n        tickSize,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      return {\r\n        price,\r\n        roundedPrice: price.toString(),\r\n        isValid: false,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // POSITION VALUE CALCULATIONS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate position value and margin\r\n   *\r\n   * @param quantity - Position quantity\r\n   * @param price - Entry price\r\n   * @param leverage - Leverage multiplier\r\n   * @returns Notional value and margin used\r\n   */\r\n  calculatePositionValue(quantity: number, price: number, leverage: number): {\r\n    notionalValue: number;\r\n    marginUsed: number;\r\n  } {\r\n    const notionalValue = quantity * price;\r\n    const marginUsed = notionalValue / leverage;\r\n\r\n    return {\r\n      notionalValue,\r\n      marginUsed,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get number of decimal places in a number string\r\n   *\r\n   * Example:\r\n   * - \"0.1\" ‚Üí 1\r\n   * - \"0.01\" ‚Üí 2\r\n   * - \"0.0001\" ‚Üí 4\r\n   * - \"1\" ‚Üí 0\r\n   *\r\n   * @param numStr - Number as string\r\n   * @returns Number of decimal places\r\n   */\r\n  private getDecimalPlaces(numStr: string): number {\r\n    const parts = numStr.split('.');\r\n    if (parts.length === 1) {\r\n      return 0;\r\n    }\r\n\r\n    // Count ALL decimals (do NOT trim trailing zeros)\r\n    // \"0.1\" must return 1, not 0!\r\n    return parts[1].length;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\position-manager.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConfirmationResult' is defined but never used. Allowed unused vars must match /^_/u.","line":44,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":103,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":103,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4505,4533],"text":"(smartTrailingConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4505,4533],"text":"(smartTrailingConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":109,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":109,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4802,4828],"text":"(adaptiveTP3Config?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4802,4828],"text":"(adaptiveTP3Config?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'getStrategySmartBreakevenConfig' has a complexity of 15. Maximum allowed is 10.","line":123,"column":42,"nodeType":"FunctionExpression","messageId":"complex","endLine":147,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":124,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":124,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5436,5449],"text":"strategyType == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5437,5449],"text":"(strategyType ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5436,5449],"text":"!Boolean(strategyType)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":130,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":131,"endColumn":98},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":131,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":131,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5629,5678],"text":"((this.fullConfig.scalpingMicroWall?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":131,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":131,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5679,5681],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":132,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":133,"endColumn":98},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":133,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":133,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5770,5819],"text":"((this.fullConfig.scalpingTickDelta?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":133,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":133,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5820,5822],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":134,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":135,"endColumn":98},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":135,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":135,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5911,5960],"text":"((this.fullConfig.scalpingOrderFlow?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":135,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":135,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5961,5963],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":136,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":137,"endColumn":99},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":137,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":137,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6053,6103],"text":"((this.fullConfig.scalpingLimitOrder?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":137,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":137,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6104,6106],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":138,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":139,"endColumn":97},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":139,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":139,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6194,6242],"text":"((this.fullConfig.scalpingLadderTp?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":139,"column":63,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":139,"endColumn":65,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6243,6245],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":140,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":140,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The case statement does not have a shared enum type with the switch predicate.","line":141,"column":5,"nodeType":"SwitchCase","messageId":"mismatchedCase","endLine":142,"endColumn":92},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":142,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":142,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6369,6412],"text":"((this.fullConfig.whaleHunter?.smartBreakeven) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":142,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":142,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6413,6415],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"complexity","severity":1,"message":"Async method 'openPosition' has a complexity of 28. Maximum allowed is 10.","line":158,"column":21,"nodeType":"FunctionExpression","messageId":"complex","endLine":483,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":171,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":171,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7648,7679],"text":"(this.compoundInterestCalculator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":193,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":193,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8799,8826],"text":"this.riskBasedSizingService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":212,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":212,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9627,9649],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'slOrderId' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":295,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":295,"endColumn":20},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":306,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":306,"endColumn":28},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":332,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":338,"endColumn":12},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":343,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":354,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":407,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":407,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17477,17490],"text":"(tpOrderIds[i] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[17477,17490],"text":"(tpOrderIds[i] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[17477,17490],"text":"(Boolean(tpOrderIds[i]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":407,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":407,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[17491,17493],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (1055). Maximum allowed is 300.","line":413,"column":1,"nodeType":null,"messageId":"exceed","endLine":1514,"endColumn":1},{"ruleId":"max-len","severity":1,"message":"This line has a length of 135. Maximum allowed is 120.","line":447,"column":1,"nodeType":"Program","messageId":"max","endLine":447,"endColumn":136},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":447,"column":22,"nodeType":"TSAsExpression","messageId":"conditionErrorObject","endLine":447,"endColumn":66},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":448,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":448,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19058,19072],"text":"(signal.btcData != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":448,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":448,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19073,19075],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":456,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":456,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19393,19410],"text":"(this.sessionStats != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":456,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":456,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19414,19427],"text":"(entrySnapshot != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'onTakeProfitHit' has a complexity of 35. Maximum allowed is 10.","line":488,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":707,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":495,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":495,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20930,20939],"text":"(tpConfig == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":516,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":516,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21671,21687],"text":"tpConfig.orderId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[21671,21687],"text":"tpConfig.orderId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[21671,21687],"text":"Boolean(tpConfig.orderId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":525,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":525,"endColumn":49},{"ruleId":"max-len","severity":1,"message":"This line has a length of 130. Maximum allowed is 120.","line":526,"column":1,"nodeType":"Program","messageId":"max","endLine":526,"endColumn":131},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":526,"column":28,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":526,"endColumn":50},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":531,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":531,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22523,22549],"text":"(this.smartBreakevenService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":531,"column":41,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":531,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22553,22569],"text":"(strategyBEConfig != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":541,"column":31,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":541,"endColumn":67,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[23001,23007],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 135. Maximum allowed is 120.","line":545,"column":1,"nodeType":"Program","messageId":"max","endLine":545,"endColumn":136},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":610,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":610,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26123,26150],"text":"this.smartTrailingV2Service != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":618,"column":78,"nodeType":"Literal","messageId":"noMagic","endLine":618,"endColumn":79},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":619,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":619,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26525,26548],"text":"(this.adaptiveTP3Service != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":619,"column":38,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":619,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26552,26555],"text":"(tp3 != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 134. Maximum allowed is 120.","line":620,"column":1,"nodeType":"Program","messageId":"max","endLine":620,"endColumn":135},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":631,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":631,"endColumn":28,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[27123,27140],"text":"((smartTP3?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[27123,27140],"text":"((smartTP3?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":631,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":631,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27144,27156],"text":"((tp3?.orderId) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[27144,27156],"text":"((tp3?.orderId) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27144,27156],"text":"(Boolean((tp3?.orderId)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":639,"column":18,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":639,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27512,27524],"text":"(tp3?.orderId) != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[27512,27524],"text":"(tp3?.orderId) ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27512,27524],"text":"Boolean((tp3?.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":718,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":718,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30603,30624],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":718,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":718,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30628,30656],"text":"(this.smartTrailingV2Service == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":738,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":738,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31202,31222],"text":"this.currentPosition != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":763,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":763,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31932,31953],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":763,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":763,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31957,31985],"text":"(this.smartTrailingV2Service == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'updateSmartTP3' has a complexity of 19. Maximum allowed is 10.","line":801,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":940,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":803,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":803,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33159,33180],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":809,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":809,"endColumn":27,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[33349,33366],"text":"((smartTP3?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[33348,33366],"text":"(smartTP3?.enabled) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":814,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":814,"endColumn":77},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":815,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":815,"endColumn":18,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[33533,33541],"text":"((tp2?.hit) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[33532,33541],"text":"(tp2?.hit) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":820,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":820,"endColumn":77},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":821,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":821,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33714,33718],"text":"(tp3 == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":821,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":821,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33733,33745],"text":"(tp3.orderId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[33734,33745],"text":"(tp3.orderId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[33733,33745],"text":"(!Boolean(tp3.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":827,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":827,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[33920,33936],"text":"activationPrice == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[33921,33936],"text":"(activationPrice ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[33920,33936],"text":"!Boolean(activationPrice)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":843,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":843,"endColumn":69,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[34453,34496],"text":"(this.currentPosition.stopLoss.tp3MovedTicks != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[34453,34496],"text":"(this.currentPosition.stopLoss.tp3MovedTicks ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[34453,34496],"text":"(Boolean(this.currentPosition.stopLoss.tp3MovedTicks))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":843,"column":70,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":843,"endColumn":72,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[34497,34499],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":849,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":849,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[34750,34761],"text":"(tp3.orderId.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[34750,34761],"text":"(tp3.orderId !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[34750,34761],"text":"(Boolean(tp3.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'checkAdaptiveTP3Extension' has a complexity of 13. Maximum allowed is 10.","line":951,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":1033,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":958,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":958,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[38876,38900],"text":"this.adaptiveTP3Service == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":963,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":963,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39000,39021],"text":"(this.currentPosition == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":968,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":968,"endColumn":77},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":969,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":969,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39225,39229],"text":"(tp3 == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":969,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":969,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39244,39256],"text":"(tp3.orderId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[39245,39256],"text":"(tp3.orderId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[39244,39256],"text":"(!Boolean(tp3.orderId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":982,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":982,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[39528,39548],"text":"(result.newTP3Percent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[39528,39548],"text":"(result.newTP3Percent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[39528,39548],"text":"(Boolean(result.newTP3Percent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1154,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1154,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[45523,45532],"text":"openTrade != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":1178,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":1178,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[46640,46656],"text":"position.status.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[46640,46656],"text":"position.status === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[46640,46656],"text":"!Boolean(position.status)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1212,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1212,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47959,47982],"text":"(this.adaptiveTP3Service != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1212,"column":36,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1212,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47986,48006],"text":"(this.currentPosition != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'recordPositionClose' has a complexity of 16. Maximum allowed is 10.","line":1223,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":1363,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1230,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1230,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48429,48450],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1254,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1254,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[49259,49281],"text":"this.takeProfitManager != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.00055.","line":1280,"column":48,"nodeType":"Literal","messageId":"noMagic","endLine":1280,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":1292,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":1292,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51135,51166],"text":"this.currentPosition.journalId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[51136,51166],"text":"(this.currentPosition.journalId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[51135,51166],"text":"!Boolean(this.currentPosition.journalId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":1319,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":1319,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":1320,"column":23,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":1320,"endColumn":47,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[52061,52072],"text":"ExitType.STOP_LOSS"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1336,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1336,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[52717,52734],"text":"(this.sessionStats != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":1336,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":1336,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[52738,52768],"text":"(this.currentPosition.journalId.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[52738,52768],"text":"(this.currentPosition.journalId !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[52738,52768],"text":"(Boolean(this.currentPosition.journalId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1345,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1345,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[53052,53094],"text":"(this.currentPosition.stopLoss.initialPrice !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[53052,53094],"text":"(!Number.isNaN(this.currentPosition.stopLoss.initialPrice))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[53052,53094],"text":"(Boolean(this.currentPosition.stopLoss.initialPrice))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1355,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1355,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[53547,53570],"text":"this.adaptiveTP3Service != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1381,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1381,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[54449,54470],"text":"this.currentPosition == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1391,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1391,"endColumn":49,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[54700,54739],"text":"((this.riskConfig.bbTrailingStop?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[54699,54739],"text":"(this.riskConfig.bbTrailingStop?.enabled) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":1429,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1429,"endColumn":43},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":1446,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1446,"endColumn":43}],"suppressedMessages":[],"errorCount":89,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Position Manager Service\r\n * Manages trading positions for futures with TP/SL\r\n *\r\n * Features:\r\n * - Open positions with multiple take-profit levels\r\n * - Automatic stop-loss and take-profit order placement\r\n * - Breakeven stop-loss after TP1\r\n * - Trailing stop activation after TP2\r\n * - Position size calculation based on fixed USDT amount\r\n *\r\n * Risk Management:\r\n * - Fixed position size in USDT (e.g., 10 USDT)\r\n * - Quantity calculation via PositionCalculatorService\r\n *   Example: (10 USDT * 10x) / 1.20 = 83.33 coins\r\n *   This gives total position notional = 100 USDT, margin used = 10 USDT\r\n * - Multiple TP levels with partial closes\r\n * - Automatic SL management\r\n */\r\n\r\nimport {\r\n  Position,\r\n  PositionSide,\r\n  Signal,\r\n  SignalDirection,\r\n  TradingConfig,\r\n  RiskManagementConfig,\r\n  LoggerService,\r\n  EntryConfirmationConfig,\r\n  ExitType,\r\n  SessionEntryCondition,\r\n  SessionTradeRecord,\r\n  SmartTrailingConfig,\r\n  AdaptiveTP3Config,\r\n  Config,\r\n  SmartBreakevenConfig,\r\n  SignalType,\r\n} from '../types';\r\nimport { BybitService } from './bybit';\r\nimport { TelegramService } from './telegram.service';\r\nimport { TradingJournalService } from './trading-journal.service';\r\nimport { TakeProfitManagerService, PartialClose } from './take-profit-manager.service';\r\nimport { EntryConfirmationManager, ConfirmationResult } from './entry-confirmation.service';\r\nimport { PositionCalculatorService } from './position-calculator.service';\r\nimport { CompoundInterestCalculatorService } from './compound-interest-calculator.service';\r\nimport { SessionStatsService } from './session-stats.service';\r\nimport { SmartBreakevenService } from './smart-breakeven.service';\r\nimport { SmartTrailingV2Service } from './smart-trailing-v2.service';\r\nimport { AdaptiveTP3Service } from './adaptive-tp3.service';\r\nimport { RiskBasedSizingService } from './risk-based-sizing.service';\r\nimport { LossStreakService } from './loss-streak.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PERCENT_TO_DECIMAL = 100;\r\n\r\n// ============================================================================\r\n// POSITION MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class PositionManagerService {\r\n  private currentPosition: Position | null = null;\r\n  private takeProfitManager: TakeProfitManagerService | null = null;\r\n  private entryConfirmation: EntryConfirmationManager;\r\n  private readonly positionCalculator: PositionCalculatorService;\r\n  private readonly compoundInterestCalculator?: CompoundInterestCalculatorService;\r\n  private readonly sessionStats?: SessionStatsService;\r\n  private readonly smartBreakevenService?: SmartBreakevenService;\r\n  private readonly smartTrailingV2Service?: SmartTrailingV2Service;\r\n  private readonly adaptiveTP3Service?: AdaptiveTP3Service;\r\n  private readonly riskBasedSizingService?: RiskBasedSizingService;\r\n  private readonly lossStreakService?: LossStreakService;\r\n\r\n  constructor(\r\n    private readonly bybitService: BybitService,\r\n    private readonly tradingConfig: TradingConfig,\r\n    private readonly riskConfig: RiskManagementConfig,\r\n    private readonly telegram: TelegramService,\r\n    private readonly logger: LoggerService,\r\n    private readonly journal: TradingJournalService,\r\n    private readonly entryConfirmationConfig: EntryConfirmationConfig,\r\n    private readonly fullConfig: Config,\r\n    compoundInterestCalculator?: CompoundInterestCalculatorService,\r\n    sessionStats?: SessionStatsService,\r\n    smartBreakevenService?: SmartBreakevenService,\r\n    smartTrailingConfig?: SmartTrailingConfig,\r\n    adaptiveTP3Config?: AdaptiveTP3Config,\r\n    riskBasedSizingService?: RiskBasedSizingService,\r\n    lossStreakService?: LossStreakService,\r\n  ) {\r\n    this.entryConfirmation = new EntryConfirmationManager(entryConfirmationConfig, logger);\r\n    this.positionCalculator = new PositionCalculatorService(logger);\r\n    this.compoundInterestCalculator = compoundInterestCalculator;\r\n    this.sessionStats = sessionStats;\r\n    this.smartBreakevenService = smartBreakevenService;\r\n    this.riskBasedSizingService = riskBasedSizingService;\r\n    this.lossStreakService = lossStreakService;\r\n\r\n    // Phase 3: Initialize SmartTrailingV2Service if config provided and enabled\r\n    if (smartTrailingConfig?.enabled) {\r\n      this.smartTrailingV2Service = new SmartTrailingV2Service(smartTrailingConfig, logger);\r\n      this.logger.info('‚úÖ SmartTrailingV2Service initialized (Phase 3)');\r\n    }\r\n\r\n    // Phase 3: Initialize AdaptiveTP3Service if config provided and enabled\r\n    if (adaptiveTP3Config?.enabled) {\r\n      this.adaptiveTP3Service = new AdaptiveTP3Service(adaptiveTP3Config, logger);\r\n      this.logger.info('‚úÖ AdaptiveTP3Service initialized (Phase 3)');\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get strategy-specific SmartBreakeven config\r\n   * Falls back to global config if strategy doesn't have specific config\r\n   */\r\n  private getStrategySmartBreakevenConfig(strategyType?: string): SmartBreakevenConfig | undefined {\r\n    if (!strategyType) {\r\n      return this.fullConfig.smartBreakeven;\r\n    }\r\n\r\n    // Map strategy type to config\r\n    switch (strategyType) {\r\n    case SignalType.SCALPING_MICRO_WALL:\r\n      return this.fullConfig.scalpingMicroWall?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_TICK_DELTA:\r\n      return this.fullConfig.scalpingTickDelta?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_ORDER_FLOW:\r\n      return this.fullConfig.scalpingOrderFlow?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_LIMIT_ORDER:\r\n      return this.fullConfig.scalpingLimitOrder?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.SCALPING_LADDER_TP:\r\n      return this.fullConfig.scalpingLadderTp?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    case SignalType.WHALE_HUNTER:\r\n    case SignalType.WHALE_HUNTER_FOLLOW:\r\n      return this.fullConfig.whaleHunter?.smartBreakeven || this.fullConfig.smartBreakeven;\r\n    default:\r\n      // For basic strategies (TrendFollowing, LevelBased, CounterTrend), use global config\r\n      return this.fullConfig.smartBreakeven;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Open a new position based on signal\r\n   * @param signal - Trading signal with entry details\r\n   * @param entrySnapshot - Optional full entry condition snapshot for session stats\r\n   */\r\n  async openPosition(signal: Signal, entrySnapshot?: SessionEntryCondition): Promise<Position> {\r\n    if (this.currentPosition !== null) {\r\n      throw new Error('Position already exists. Close existing position first.');\r\n    }\r\n\r\n    // IMPORTANT: Cancel any hanging conditional orders from previous position\r\n    // This prevents old SL/TP orders from triggering on the new position\r\n    this.logger.debug('üßπ Cancelling any hanging conditional orders before opening position...');\r\n    await this.bybitService.cancelAllConditionalOrders();\r\n\r\n    // Determine position size (fixed or compound interest)\r\n    let positionSizeUsdt: number;\r\n\r\n    if (this.compoundInterestCalculator && this.compoundInterestCalculator.isEnabled()) {\r\n      // Use compound interest calculator for dynamic position sizing\r\n      const compoundResult = await this.compoundInterestCalculator.calculatePositionSize();\r\n      positionSizeUsdt = compoundResult.positionSize;\r\n\r\n      this.logger.info('üí∞ Compound interest position sizing', {\r\n        currentBalance: compoundResult.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\r\n        totalProfit: compoundResult.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\r\n        positionSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n        growthFactor: (positionSizeUsdt / this.riskConfig.positionSizeUsdt).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n        protectionActive: compoundResult.protectionActive,\r\n      });\r\n    } else {\r\n      // Use fixed position size from config\r\n      positionSizeUsdt = this.riskConfig.positionSizeUsdt;\r\n\r\n      this.logger.debug('üìä Fixed position sizing', {\r\n        positionSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n    }\r\n\r\n    // PHASE 5: Apply Risk-Based Sizing (overrides compound/fixed size)\r\n    if (this.riskBasedSizingService) {\r\n      const currentBalance = await this.bybitService.getBalance();\r\n      const riskBasedSize = this.riskBasedSizingService.calculatePositionSize(\r\n        currentBalance,\r\n        signal.price,\r\n        signal.stopLoss,\r\n      );\r\n\r\n      this.logger.info('üéØ Risk-Based Sizing applied (PHASE 5)', {\r\n        originalSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n        riskBasedSize: riskBasedSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        slDistance: Math.abs(signal.price - signal.stopLoss).toFixed(DECIMAL_PLACES.PERCENT),\r\n        slPercent: (Math.abs(signal.price - signal.stopLoss) / signal.price * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      positionSizeUsdt = riskBasedSize;\r\n    }\r\n\r\n    // PHASE 5: Apply Loss Streak multiplier\r\n    if (this.lossStreakService) {\r\n      const multiplier = this.lossStreakService.getSizeMultiplier();\r\n      const originalSize = positionSizeUsdt;\r\n      positionSizeUsdt = positionSizeUsdt * multiplier;\r\n\r\n      this.logger.info('üîª Loss Streak multiplier applied (PHASE 5)', {\r\n        consecutiveLosses: this.lossStreakService.getConsecutiveLosses(),\r\n        multiplier: (multiplier * PERCENT_MULTIPLIER).toFixed(0) + '%',\r\n        originalSize: originalSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        adjustedSize: positionSizeUsdt.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n    }\r\n\r\n    // Calculate quantity using PositionCalculatorService\r\n    const limits = this.bybitService.getExchangeLimits();\r\n    const calculation = this.positionCalculator.calculateQuantity(\r\n      positionSizeUsdt,\r\n      this.tradingConfig.leverage,\r\n      signal.price,\r\n      limits,\r\n    );\r\n\r\n    if (!calculation.isValid) {\r\n      this.logger.error('‚ùå Position calculation failed - quantity invalid', {\r\n        errors: calculation.validationErrors,\r\n        positionSizeUsdt: this.riskConfig.positionSizeUsdt,\r\n        leverage: this.tradingConfig.leverage,\r\n        price: signal.price,\r\n        limits,\r\n      });\r\n      throw new Error(`Position calculation failed: ${calculation.validationErrors.join(', ')}`);\r\n    }\r\n\r\n    const quantity = parseFloat(calculation.roundedQuantity);\r\n\r\n    this.logger.info('‚úÖ Position quantity calculated', {\r\n      quantity,\r\n      roundedQuantity: calculation.roundedQuantity,\r\n      marginUsed: calculation.marginUsed,\r\n      notionalValue: calculation.notionalValue,\r\n    });\r\n\r\n    // Determine position side\r\n    const isLong = signal.direction === SignalDirection.LONG;\r\n    const side = isLong ? PositionSide.LONG : PositionSide.SHORT;\r\n\r\n    // 1. Open position with limit order\r\n    const orderId = await this.bybitService.openPosition({\r\n      side,\r\n      quantity,\r\n      leverage: this.tradingConfig.leverage,\r\n    });\r\n\r\n    // 2. Place take-profit levels\r\n    const tpOrderIds = await this.bybitService.placeTakeProfitLevels({\r\n      side,\r\n      entryPrice: signal.price,\r\n      totalQuantity: quantity,\r\n      levels: signal.takeProfits,\r\n    });\r\n\r\n    // 3. Set position-level stop-loss\r\n    // Recalculate SL based on actual market price to avoid slippage issues\r\n    const isLongPosition = signal.direction === SignalDirection.LONG;\r\n    const slDistancePercent = Math.abs((signal.stopLoss - signal.price) / signal.price * PERCENT_MULTIPLIER);\r\n\r\n    // Get current market price (after position opened)\r\n    const currentPrice = await this.bybitService.getCurrentPrice();\r\n    const slDistance = currentPrice * (slDistancePercent / PERCENT_MULTIPLIER);\r\n    const actualStopLoss = isLongPosition\r\n      ? currentPrice - slDistance\r\n      : currentPrice + slDistance;\r\n\r\n    this.logger.info('üìä SL recalculated for actual entry', {\r\n      signalPrice: signal.price,\r\n      signalSL: signal.stopLoss,\r\n      currentPrice,\r\n      slDistancePercent: slDistancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      actualStopLoss,\r\n    });\r\n\r\n    // Use setTradingStop instead of conditional order\r\n    await this.bybitService.updateStopLoss(actualStopLoss);\r\n    const slOrderId = null; // No orderId for position-level SL\r\n\r\n    // üö® CRITICAL: Verify protection is actually set (double-check)\r\n    const MAX_VERIFICATION_RETRIES = 3;\r\n    let verificationAttempt = 0;\r\n    let protectionVerified = false;\r\n\r\n    while (verificationAttempt < MAX_VERIFICATION_RETRIES && !protectionVerified) {\r\n      verificationAttempt++;\r\n\r\n      // Wait 1 second before verification to allow orders to propagate\r\n      await this.sleep(1000);\r\n\r\n      this.logger.debug(`üîç Verifying protection (attempt ${verificationAttempt}/${MAX_VERIFICATION_RETRIES})...`);\r\n\r\n      const verification = await this.bybitService.verifyProtectionSet(side);\r\n\r\n      if (verification.verified) {\r\n        protectionVerified = true;\r\n        this.logger.info('‚úÖ Protection verified successfully', {\r\n          hasStopLoss: verification.hasStopLoss,\r\n          hasTakeProfit: verification.hasTakeProfit,\r\n          stopLossPrice: verification.stopLossPrice,\r\n          takeProfitCount: verification.takeProfitPrices?.length,\r\n          activeOrders: verification.activeOrders,\r\n          hasTrailingStop: verification.hasTrailingStop,\r\n        });\r\n      } else {\r\n        this.logger.warn(`‚ö†Ô∏è Protection verification failed (attempt ${verificationAttempt})`, {\r\n          hasStopLoss: verification.hasStopLoss,\r\n          hasTakeProfit: verification.hasTakeProfit,\r\n          activeOrders: verification.activeOrders,\r\n        });\r\n\r\n        // Retry setting protection if missing\r\n        if (!verification.hasStopLoss && verificationAttempt < MAX_VERIFICATION_RETRIES) {\r\n          this.logger.warn('üîÑ Retrying SL placement...');\r\n          try {\r\n            await this.bybitService.updateStopLoss(actualStopLoss);\r\n          } catch (error) {\r\n            this.logger.error('Failed to retry SL placement', {\r\n              error: error instanceof Error ? error.message : String(error),\r\n            });\r\n          }\r\n        }\r\n\r\n        if (!verification.hasTakeProfit && verificationAttempt < MAX_VERIFICATION_RETRIES) {\r\n          this.logger.warn('üîÑ Retrying TP placement...');\r\n          try {\r\n            await this.bybitService.placeTakeProfitLevels({\r\n              side,\r\n              entryPrice: signal.price,\r\n              totalQuantity: quantity,\r\n              levels: signal.takeProfits,\r\n            });\r\n          } catch (error) {\r\n            this.logger.error('Failed to retry TP placement', {\r\n              error: error instanceof Error ? error.message : String(error),\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // üö® CRITICAL ERROR: Protection still missing after retries\r\n    if (!protectionVerified) {\r\n      this.logger.error('üö® CRITICAL: Failed to verify protection after retries!', {\r\n        side,\r\n        entryPrice: signal.price,\r\n        quantity,\r\n      });\r\n\r\n      // Emergency: Close position immediately (better to lose fees than leave unprotected)\r\n      this.logger.error('üö® EMERGENCY: Closing position without protection!');\r\n      try {\r\n        await this.bybitService.closePosition(side, quantity);\r\n        await this.telegram.sendAlert('üö® EMERGENCY: Position closed due to missing TP/SL protection!');\r\n      } catch (closeError) {\r\n        this.logger.error('Failed to emergency close position!', {\r\n          error: closeError instanceof Error ? closeError.message : String(closeError),\r\n        });\r\n        await this.telegram.sendAlert('üö®üö®üö® CRITICAL: Position open WITHOUT PROTECTION - MANUAL INTERVENTION REQUIRED!');\r\n      }\r\n\r\n      throw new Error('Failed to set protection for position - position closed for safety');\r\n    }\r\n\r\n    // 4. Create Position object\r\n    const timestamp = Date.now();\r\n    const sideName = side === PositionSide.LONG ? 'Buy' : 'Sell';\r\n    const exchangeId = `${this.bybitService['symbol']}_${sideName}`;\r\n    const journalId = `${exchangeId}_${timestamp}`;\r\n\r\n    this.currentPosition = {\r\n      id: exchangeId, // Exchange ID for WebSocket sync (e.g., \"APEXUSDT_Sell\")\r\n      journalId, // Unique ID for trade history (e.g., \"APEXUSDT_Sell_1761696424935\")\r\n      symbol: this.bybitService['symbol'],\r\n      side,\r\n      quantity,\r\n      entryPrice: signal.price,\r\n      leverage: this.tradingConfig.leverage,\r\n      marginUsed: this.riskConfig.positionSizeUsdt,\r\n      stopLoss: {\r\n        price: actualStopLoss,\r\n        initialPrice: actualStopLoss,\r\n        orderId: undefined, // Position-level SL doesn't have orderId\r\n        isBreakeven: false,\r\n        isTrailing: false,\r\n        updatedAt: Date.now(),\r\n      },\r\n      takeProfits: signal.takeProfits.map((tp, i) => ({\r\n        ...tp,\r\n        orderId: tpOrderIds[i] || undefined, // Use undefined if orderId not returned (order failed)\r\n        hit: false,\r\n      })),\r\n      openedAt: timestamp,\r\n      unrealizedPnL: 0,\r\n      orderId,\r\n      reason: signal.reason,\r\n      confidence: signal.confidence,\r\n      strategy: signal.type,\r\n      protectionVerifiedOnce: true, // Protection already verified during opening\r\n      status: 'OPEN', // Initialize as OPEN\r\n    };\r\n\r\n    // 5. Initialize Take Profit Manager for partial close tracking\r\n    this.takeProfitManager = new TakeProfitManagerService(\r\n      {\r\n        positionId: this.currentPosition.id,\r\n        symbol: this.currentPosition.symbol,\r\n        side,\r\n        entryPrice: signal.price,\r\n        totalQuantity: quantity,\r\n        leverage: this.tradingConfig.leverage,\r\n      },\r\n      this.logger,\r\n    );\r\n\r\n    // Send Telegram notification\r\n    await this.telegram.notifyPositionOpened(this.currentPosition);\r\n\r\n    // Record trade opening in journal\r\n    // Simplified: just serialize the entire Signal object + any additional data\r\n    this.journal.recordTradeOpen({\r\n      id: this.currentPosition.journalId!, // Use unique journal ID\r\n      symbol: this.currentPosition.symbol,\r\n      side,\r\n      entryPrice: signal.price,\r\n      quantity,\r\n      leverage: this.tradingConfig.leverage,\r\n      entryCondition: {\r\n        signal, // Complete Signal object with all data (includes marketData and btcData)\r\n        marketData: (signal.marketData as Record<string, unknown>) || undefined, // Already included in signal, but keeping for clarity\r\n        btcData: signal.btcData || undefined, // BTC confirmation data (if BTC filter was enabled)\r\n        // Add any other data needed for ML:\r\n        // indicators: allIndicatorValues,\r\n        // rawData: { candles, swingPoints, etc. }\r\n      },\r\n    });\r\n\r\n    // Record trade entry in session stats (if available and snapshot provided)\r\n    if (this.sessionStats && entrySnapshot) {\r\n      const sessionTrade: SessionTradeRecord = {\r\n        tradeId: this.currentPosition.journalId!,\r\n        timestamp: new Date(timestamp).toISOString(),\r\n        direction: signal.direction,\r\n        entryPrice: signal.price,\r\n        exitPrice: 0, // Will be updated on close\r\n        quantity,\r\n        pnl: 0, // Will be updated on close\r\n        pnlPercent: 0, // Will be updated on close\r\n        exitType: ExitType.MANUAL, // Will be updated on close\r\n        tpHitLevels: [], // Will be updated on close\r\n        holdingTimeMs: 0, // Will be updated on close\r\n        entryCondition: entrySnapshot,\r\n        stopLoss: {\r\n          initial: actualStopLoss,\r\n          final: actualStopLoss, // Will be updated if SL moves\r\n          movedToBreakeven: false,\r\n          trailingActivated: false,\r\n        },\r\n      };\r\n\r\n      this.sessionStats.recordTradeEntry(sessionTrade);\r\n      this.logger.debug('üìä Trade entry recorded in session stats', { tradeId: this.currentPosition.journalId });\r\n    }\r\n\r\n    return this.currentPosition;\r\n  }\r\n\r\n  /**\r\n   * Handle take-profit hit - adjust SL to breakeven or activate trailing\r\n   */\r\n  async onTakeProfitHit(tpLevel: number, currentPrice: number): Promise<void> {\r\n    if (this.currentPosition === null || this.takeProfitManager === null) {\r\n      return;\r\n    }\r\n\r\n    // Check if this TP level was already hit (prevent duplicate processing)\r\n    const tpConfig = this.currentPosition.takeProfits.find((tp) => tp.level === tpLevel);\r\n    if (!tpConfig || tpConfig.hit) {\r\n      this.logger.debug('üßπ TP event ignored - already hit or not found', {\r\n        tpLevel,\r\n        alreadyHit: tpConfig?.hit,\r\n        positionId: this.currentPosition.id,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Record partial close in TakeProfitManager\r\n    // Calculate quantity for this TP level\r\n    const partialQuantity = (this.currentPosition.quantity * tpConfig.sizePercent) / PERCENT_MULTIPLIER;\r\n\r\n    // Record the partial close\r\n    this.takeProfitManager.recordPartialClose(tpLevel, partialQuantity, currentPrice);\r\n\r\n    // Mark TP as hit\r\n    tpConfig.hit = true;\r\n    tpConfig.hitAt = Date.now();\r\n\r\n    // Clear orderId to prevent Smart TP3 from trying to update a filled order\r\n    if (tpConfig.orderId) {\r\n      tpConfig.orderId = undefined;\r\n    }\r\n\r\n    // Breakeven after TP1\r\n    // Race condition: check position still exists before accessing stopLoss\r\n    if (tpLevel === 1 && this.currentPosition !== null && !this.currentPosition.stopLoss.isBreakeven) {\r\n      // PHASE 1: Smart Breakeven - Activate Pre-BE mode instead of immediate breakeven\r\n      // FIX: Pass realized PnL and remaining quantity to account for TP1 profit\r\n      const realizedPnL = this.takeProfitManager ? this.takeProfitManager.getTotalRealizedPnL() : 0;\r\n      const remainingQty = this.takeProfitManager ? this.takeProfitManager.getRemainingQuantity() : this.currentPosition.quantity;\r\n\r\n      // Get strategy-specific SmartBreakeven config\r\n      const strategyBEConfig = this.getStrategySmartBreakevenConfig(this.currentPosition.strategy);\r\n\r\n      if (this.smartBreakevenService && strategyBEConfig && this.smartBreakevenService.shouldActivate(\r\n        this.currentPosition,\r\n        currentPrice,\r\n        realizedPnL,\r\n        remainingQty,\r\n        strategyBEConfig, // Pass strategy-specific config\r\n      )) {\r\n        this.smartBreakevenService.activatePreBE(this.currentPosition.symbol);\r\n\r\n        // Calculate total profit for logging (realized + unrealized)\r\n        const pnlMultiplier = this.currentPosition.side === 'LONG' ? 1 : -1;\r\n        const priceDiff = currentPrice - this.currentPosition.entryPrice;\r\n        const unrealizedPnL = priceDiff * remainingQty * pnlMultiplier * this.currentPosition.leverage;\r\n        const totalPnL = realizedPnL + unrealizedPnL;\r\n        const totalProfitPercent = (totalPnL / (this.currentPosition.entryPrice * this.currentPosition.quantity)) * PERCENT_MULTIPLIER;\r\n\r\n        this.logger.info('‚ö° TP1 hit - Pre-Breakeven mode activated (not moving SL yet)', {\r\n          positionId: this.currentPosition.id,\r\n          realizedPnL: realizedPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\r\n          unrealizedPnL: unrealizedPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\r\n          totalProfit: totalProfitPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        });\r\n        return; // Don't move SL immediately - wait for impulse confirmation\r\n      }\r\n\r\n      // Legacy behavior: Immediate breakeven (when Smart Breakeven disabled)\r\n      const breakevenPrice = this.calculateBreakevenPrice(\r\n        this.currentPosition.entryPrice,\r\n        this.currentPosition.side,\r\n        this.riskConfig.breakevenOffsetPercent,\r\n      );\r\n\r\n      this.logger.info('üéØ Moving SL to breakeven after TP1 (legacy mode)', {\r\n        positionId: this.currentPosition.id,\r\n        side: this.currentPosition.side,\r\n        entryPrice: this.currentPosition.entryPrice,\r\n        currentSL: this.currentPosition.stopLoss.price,\r\n        newSL: breakevenPrice,\r\n      });\r\n\r\n      // Update stop-loss to breakeven (setTradingStop automatically replaces previous SL)\r\n      await this.bybitService.updateStopLoss(breakevenPrice);\r\n\r\n      // Race condition check: position might have been closed during async operation\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('üßπ Position closed during breakeven update, skipping');\r\n        return;\r\n      }\r\n\r\n      this.currentPosition.stopLoss.price = breakevenPrice;\r\n      this.currentPosition.stopLoss.isBreakeven = true;\r\n      this.currentPosition.stopLoss.updatedAt = Date.now();\r\n\r\n      this.logger.info('‚úÖ SL moved to breakeven successfully', {\r\n        positionId: this.currentPosition.id,\r\n        newSL: breakevenPrice,\r\n      });\r\n\r\n      // Send Telegram notification\r\n      await this.telegram.notifyBreakeven(this.currentPosition, breakevenPrice);\r\n\r\n      // Race condition check after telegram notification\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('üßπ Position closed during breakeven notification, skipping');\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Activate trailing stop after TP2\r\n    // Race condition: check position still exists before accessing stopLoss\r\n    // IMPORTANT: Do NOT activate trailing if SL is already in breakeven!\r\n    if (\r\n      tpLevel === this.riskConfig.trailingStopActivationLevel &&\r\n      this.riskConfig.trailingStopEnabled &&\r\n      this.currentPosition !== null &&\r\n      !this.currentPosition.stopLoss.isTrailing &&\r\n      !this.currentPosition.stopLoss.isBreakeven // Protect breakeven SL\r\n    ) {\r\n      // Phase 3: Activate SmartTrailingV2 if enabled\r\n      if (this.smartTrailingV2Service) {\r\n        this.smartTrailingV2Service.activateOnTP2(this.currentPosition.id);\r\n        this.logger.info('üöÄ Phase 3: SmartTrailingV2 activated on TP2', {\r\n          positionId: this.currentPosition.id,\r\n        });\r\n      }\r\n\r\n      // Phase 3: Initialize AdaptiveTP3 if enabled\r\n      const tp3 = this.currentPosition.takeProfits.find((tp) => tp.level === 3);\r\n      if (this.adaptiveTP3Service && tp3) {\r\n        const baseTP3Percent = ((tp3.price - this.currentPosition.entryPrice) / this.currentPosition.entryPrice) * PERCENT_MULTIPLIER;\r\n        this.adaptiveTP3Service.initialize(this.currentPosition.id, Math.abs(baseTP3Percent));\r\n        this.logger.info('üöÄ Phase 3: AdaptiveTP3 initialized on TP2', {\r\n          positionId: this.currentPosition.id,\r\n          baseTP3: baseTP3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        });\r\n      }\r\n\r\n      // Check if smart TP3 movement is enabled\r\n      const smartTP3 = this.riskConfig.smartTP3;\r\n\r\n      if (smartTP3?.enabled && tp3?.orderId) {\r\n        // Smart TP3: Keep TP3 active, will move it by ticks\r\n        this.logger.info('üéØ Trailing activated - TP3 will move smartly by ticks', {\r\n          positionId: this.currentPosition.id,\r\n          tp3Price: tp3.price,\r\n          tickSize: smartTP3.tickSizePercent + '%',\r\n          maxTicks: smartTP3.maxTicks,\r\n        });\r\n      } else if (tp3?.orderId) {\r\n        // Legacy behavior: Cancel TP3 immediately\r\n        await this.bybitService.cancelTakeProfit(tp3.orderId);\r\n\r\n        // Race condition check: position might have been closed during async operation\r\n        if (this.currentPosition === null) {\r\n          this.logger.debug('üßπ Position closed during TP3 cancellation, skipping');\r\n          return;\r\n        }\r\n\r\n        this.logger.info('üéØ TP3 cancelled - trailing stop activated', {\r\n          positionId: this.currentPosition.id,\r\n          tp3Price: tp3.price,\r\n        });\r\n      }\r\n\r\n      // Activate server-side trailing stop\r\n      await this.bybitService.setTrailingStop({\r\n        side: this.currentPosition.side,\r\n        activationPrice: currentPrice,\r\n        trailingPercent: this.riskConfig.trailingStopPercent,\r\n      });\r\n\r\n      // Race condition check: position might have been closed during async operation\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('üßπ Position closed during trailing stop activation, skipping');\r\n        return;\r\n      }\r\n\r\n      this.currentPosition.stopLoss.isTrailing = true;\r\n      this.currentPosition.stopLoss.trailingPercent = this.riskConfig.trailingStopPercent;\r\n      this.currentPosition.stopLoss.trailingActivationPrice = currentPrice; // Store TP2 hit price\r\n      this.currentPosition.stopLoss.tp3MovedTicks = 0; // Initialize tick counter\r\n      this.currentPosition.stopLoss.updatedAt = Date.now();\r\n\r\n      // Calculate new stop price (trailing distance from current price)\r\n      const newStopPrice = this.calculateTrailingStopPrice(\r\n        currentPrice,\r\n        this.currentPosition.side,\r\n        this.riskConfig.trailingStopPercent,\r\n      );\r\n\r\n      // Send Telegram notification\r\n      await this.telegram.notifyTrailingActivated(\r\n        this.currentPosition,\r\n        currentPrice,\r\n        newStopPrice,\r\n        this.riskConfig.trailingStopPercent,\r\n      );\r\n\r\n      // Race condition check after telegram notification\r\n      if (this.currentPosition === null) {\r\n        this.logger.debug('üßπ Position closed during trailing notification, skipping');\r\n        return;\r\n      }\r\n    } else if (\r\n      tpLevel === this.riskConfig.trailingStopActivationLevel &&\r\n      this.riskConfig.trailingStopEnabled &&\r\n      this.currentPosition !== null &&\r\n      this.currentPosition.stopLoss.isBreakeven\r\n    ) {\r\n      // Trailing NOT activated because SL is already in breakeven\r\n      this.logger.info('‚úÖ Trailing activation skipped - SL already in breakeven (protecting profit)', {\r\n        positionId: this.currentPosition.id,\r\n        breakevenSL: this.currentPosition.stopLoss.price.toFixed(DECIMAL_PLACES.PRICE),\r\n        tpLevel,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update SmartTrailingV2 stop loss (Phase 3)\r\n   * Called from TradingOrchestrator on candle close\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param ema20 - Current EMA20 value\r\n   * @param atr - Current ATR value\r\n   */\r\n  async updateSmartTrailingV2(currentPrice: number, ema20: number, atr: number): Promise<void> {\r\n    if (!this.currentPosition || !this.smartTrailingV2Service) {\r\n      return;\r\n    }\r\n\r\n    // Check if trailing is active\r\n    if (!this.smartTrailingV2Service.isActive(this.currentPosition.id)) {\r\n      return;\r\n    }\r\n\r\n    // Update trailing stop via SmartTrailingV2Service\r\n    await this.smartTrailingV2Service.updateTrailingStop(\r\n      this.currentPosition,\r\n      currentPrice,\r\n      ema20,\r\n      atr,\r\n      async (newSL: number) => {\r\n        // Callback to update stop loss on exchange\r\n        await this.bybitService.updateStopLoss(newSL);\r\n\r\n        // Update local position\r\n        if (this.currentPosition) {\r\n          this.currentPosition.stopLoss.price = newSL;\r\n          this.currentPosition.stopLoss.updatedAt = Date.now();\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if SmartTrailingV2 impulse activation should trigger (Phase 3)\r\n   * Called from TradingOrchestrator on candle close\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param ema20 - Current EMA20 value\r\n   * @param currentVolume - Current candle volume\r\n   * @param avgVolume - Average volume\r\n   * @param emaAngle - EMA angle (slope)\r\n   */\r\n  checkSmartTrailingImpulse(\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number,\r\n  ): boolean {\r\n    if (!this.currentPosition || !this.smartTrailingV2Service) {\r\n      return false;\r\n    }\r\n\r\n    // Don't check if already active\r\n    if (this.smartTrailingV2Service.isActive(this.currentPosition.id)) {\r\n      return false;\r\n    }\r\n\r\n    // Check impulse activation\r\n    const result = this.smartTrailingV2Service.checkImpulseActivation(\r\n      this.currentPosition,\r\n      currentPrice,\r\n      ema20,\r\n      currentVolume,\r\n      avgVolume,\r\n      emaAngle,\r\n    );\r\n\r\n    // Activate if conditions met\r\n    if (result.shouldActivate) {\r\n      this.smartTrailingV2Service.activateOnTP2(this.currentPosition.id); // Use activateOnTP2 for impulse too\r\n      this.logger.info('üöÄ Phase 3: SmartTrailingV2 activated on IMPULSE', {\r\n        positionId: this.currentPosition.id,\r\n        reason: result.reason,\r\n      });\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Update Smart TP3 - Move TP3 by ticks as price moves favorably\r\n   * Called from orderbook updates when trailing is active\r\n   *\r\n   * @param currentPrice - Current market price (mid price from orderbook)\r\n   */\r\n  async updateSmartTP3(currentPrice: number): Promise<void> {\r\n    // Check if we have an active position with trailing stop\r\n    if (!this.currentPosition || !this.currentPosition.stopLoss.isTrailing) {\r\n      return;\r\n    }\r\n\r\n    // Check if smart TP3 is enabled\r\n    const smartTP3 = this.riskConfig.smartTP3;\r\n    if (!smartTP3?.enabled) {\r\n      return;\r\n    }\r\n\r\n    // CRITICAL: Check that TP2 is actually hit\r\n    const tp2 = this.currentPosition.takeProfits.find((tp) => tp.level === 2);\r\n    if (!tp2?.hit) {\r\n      return;\r\n    }\r\n\r\n    // Check that TP3 exists, not hit, and has orderId\r\n    const tp3 = this.currentPosition.takeProfits.find((tp) => tp.level === 3);\r\n    if (!tp3 || tp3.hit || !tp3.orderId) {\r\n      return;\r\n    }\r\n\r\n    // Get trailing activation price (TP2 hit price)\r\n    const activationPrice = this.currentPosition.stopLoss.trailingActivationPrice;\r\n    if (!activationPrice) {\r\n      return;\r\n    }\r\n\r\n    // Calculate profit since trailing activation (TP2 hit)\r\n    const side = this.currentPosition.side;\r\n    let profitPercent: number;\r\n\r\n    if (side === PositionSide.LONG) {\r\n      profitPercent = ((currentPrice - activationPrice) / activationPrice) * PERCENT_MULTIPLIER;\r\n    } else {\r\n      // SHORT\r\n      profitPercent = ((activationPrice - currentPrice) / activationPrice) * PERCENT_MULTIPLIER;\r\n    }\r\n\r\n    // Calculate how many ticks we should be at\r\n    const currentTicks = this.currentPosition.stopLoss.tp3MovedTicks || 0;\r\n    const newTicks = Math.floor(profitPercent / smartTP3.tickSizePercent);\r\n\r\n    // Check if we reached max ticks\r\n    if (newTicks >= smartTP3.maxTicks) {\r\n      // Max ticks reached - stop moving TP3\r\n      if (smartTP3.cancelAfterMaxTicks && tp3.orderId) {\r\n        // Cancel TP3, let trailing stop close the position\r\n        this.logger.info('üéØ Smart TP3: Max ticks reached, cancelling TP3', {\r\n          positionId: this.currentPosition.id,\r\n          maxTicks: smartTP3.maxTicks,\r\n          currentPrice,\r\n          tp3Price: tp3.price,\r\n        });\r\n\r\n        await this.bybitService.cancelTakeProfit(tp3.orderId);\r\n        tp3.orderId = undefined; // Mark as cancelled\r\n      } else {\r\n        // Keep TP3 active at final position - let it compete with trailing stop\r\n        this.logger.debug('üéØ Smart TP3: Max ticks reached, TP3 stays active', {\r\n          positionId: this.currentPosition.id,\r\n          maxTicks: smartTP3.maxTicks,\r\n          tp3Price: tp3.price,\r\n          currentPrice,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Check if we need to move TP3 to a new tick\r\n    if (newTicks > currentTicks) {\r\n      // Calculate new TP3 price (move it further by tick size)\r\n      const ticksToMove = newTicks - currentTicks;\r\n      let newTP3Price: number;\r\n\r\n      if (side === PositionSide.LONG) {\r\n        // LONG: TP3 higher than current, move it higher\r\n        newTP3Price = tp3.price * (1 + (smartTP3.tickSizePercent / PERCENT_MULTIPLIER) * ticksToMove);\r\n      } else {\r\n        // SHORT: TP3 lower than current, move it lower\r\n        newTP3Price = tp3.price * (1 - (smartTP3.tickSizePercent / PERCENT_MULTIPLIER) * ticksToMove);\r\n      }\r\n\r\n      this.logger.info('üéØ Smart TP3: Moving TP3 by ticks', {\r\n        positionId: this.currentPosition.id,\r\n        currentPrice,\r\n        activationPrice,\r\n        profitPercent: profitPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        oldTicks: currentTicks,\r\n        newTicks,\r\n        ticksMoved: ticksToMove,\r\n        oldTP3Price: tp3.price,\r\n        newTP3Price: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n\r\n      // Update position state BEFORE exchange call to prevent duplicate attempts\r\n      // (If exchange call fails but order was updated, we won't retry with same price)\r\n      const oldPrice = tp3.price;\r\n      tp3.price = newTP3Price;\r\n      this.currentPosition.stopLoss.tp3MovedTicks = newTicks;\r\n      this.currentPosition.stopLoss.updatedAt = Date.now();\r\n\r\n      // Update TP3 order on exchange\r\n      try {\r\n        await this.bybitService.updateTakeProfit(tp3.orderId, newTP3Price);\r\n      } catch (error) {\r\n        // TP3 may have been filled/cancelled during update (race condition)\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n\r\n        // Check if error is \"order not modified\" - this means price is already set correctly\r\n        if (errorMsg.includes('not modified')) {\r\n          this.logger.debug('TP3 already at target price, ignoring error', {\r\n            targetPrice: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return; // Keep new price in memory\r\n        }\r\n\r\n        // For other errors (order filled/cancelled), revert state and stop updates\r\n        this.logger.warn('Failed to update TP3 - may have been filled', {\r\n          error: errorMsg,\r\n          tp3OrderId: tp3.orderId,\r\n        });\r\n\r\n        // Revert price change\r\n        tp3.price = oldPrice;\r\n\r\n        // Mark orderId as invalid to stop future update attempts\r\n        tp3.orderId = undefined;\r\n        return;\r\n      }\r\n\r\n      this.logger.info('‚úÖ Smart TP3: TP3 moved successfully', {\r\n        positionId: this.currentPosition.id,\r\n        newTP3Price: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalTicks: newTicks,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check Adaptive TP3 Extension (Phase 3)\r\n   * Called on candle close to check if TP3 should be extended based on momentum\r\n   *\r\n   * @param currentPrice - Current market price\r\n   * @param currentVolume - Current candle volume\r\n   * @param avgVolume - Average volume\r\n   * @param emaAngle - EMA slope angle in degrees\r\n   */\r\n  async checkAdaptiveTP3Extension(\r\n    currentPrice: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number,\r\n  ): Promise<void> {\r\n    // Check if AdaptiveTP3 is enabled\r\n    if (!this.adaptiveTP3Service) {\r\n      return;\r\n    }\r\n\r\n    // Check if we have an active position with trailing stop\r\n    if (!this.currentPosition || !this.currentPosition.stopLoss.isTrailing) {\r\n      return;\r\n    }\r\n\r\n    // Check that TP3 exists and not hit\r\n    const tp3 = this.currentPosition.takeProfits.find((tp) => tp.level === 3);\r\n    if (!tp3 || tp3.hit || !tp3.orderId) {\r\n      return;\r\n    }\r\n\r\n    // Check extension conditions\r\n    const result = this.adaptiveTP3Service.checkExtension(\r\n      this.currentPosition,\r\n      currentPrice,\r\n      currentVolume,\r\n      avgVolume,\r\n      emaAngle,\r\n    );\r\n\r\n    if (result.shouldExtend && result.newTP3Percent) {\r\n      // Calculate new TP3 price\r\n      const side = this.currentPosition.side;\r\n      const entryPrice = this.currentPosition.entryPrice;\r\n      let newTP3Price: number;\r\n\r\n      if (side === PositionSide.LONG) {\r\n        newTP3Price = entryPrice * (1 + result.newTP3Percent / PERCENT_MULTIPLIER);\r\n      } else {\r\n        newTP3Price = entryPrice * (1 - result.newTP3Percent / PERCENT_MULTIPLIER);\r\n      }\r\n\r\n      this.logger.info('üìà Phase 3: Extending TP3', {\r\n        positionId: this.currentPosition.id,\r\n        reason: result.reason,\r\n        oldTP3: tp3.price.toFixed(DECIMAL_PLACES.PRICE),\r\n        newTP3: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n        newTP3Percent: result.newTP3Percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      // Update TP3 on exchange\r\n      try {\r\n        await this.bybitService.updateTakeProfit(tp3.orderId, newTP3Price);\r\n\r\n        // Update service state\r\n        this.adaptiveTP3Service.extendTP3(this.currentPosition.id, newTP3Price);\r\n\r\n        // Update local position state\r\n        tp3.price = newTP3Price;\r\n\r\n        this.logger.info('‚úÖ Phase 3: TP3 extended successfully', {\r\n          positionId: this.currentPosition.id,\r\n          newTP3Price: newTP3Price.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : String(error);\r\n        this.logger.warn('‚ö†Ô∏è Failed to extend TP3', {\r\n          error: errorMsg,\r\n          tp3OrderId: tp3.orderId,\r\n        });\r\n\r\n        // Mark orderId as invalid to stop future update attempts\r\n        if (!errorMsg.includes('not modified')) {\r\n          tp3.orderId = undefined;\r\n        }\r\n      }\r\n    } else {\r\n      this.logger.debug('Phase 3: TP3 extension not needed', {\r\n        reason: result.reason,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close current position\r\n   */\r\n  async closePosition(): Promise<boolean> {\r\n    if (this.currentPosition === null) {\r\n      throw new Error('No position to close');\r\n    }\r\n\r\n    await this.bybitService.closePosition(\r\n      this.currentPosition.side,\r\n      this.currentPosition.quantity,\r\n    );\r\n\r\n    // Cancel any remaining conditional orders (SL/TP) after closing position\r\n    this.logger.debug('üßπ Cancelling conditional orders after position close...');\r\n    await this.bybitService.cancelAllConditionalOrders();\r\n\r\n    this.currentPosition = null;\r\n    this.takeProfitManager = null;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get current position\r\n   */\r\n  getCurrentPosition(): Position | null {\r\n    return this.currentPosition;\r\n  }\r\n\r\n  /**\r\n   * Check if confirmation is enabled for direction\r\n   */\r\n  isConfirmationEnabled(direction: SignalDirection): boolean {\r\n    return this.entryConfirmation.isEnabled(direction);\r\n  }\r\n\r\n  /**\r\n   * Add pending signal waiting for candle confirmation\r\n   * @param signal - Signal to be confirmed\r\n   * @param keyLevel - Support (LONG) or Resistance (SHORT) level price\r\n   * @returns Pending entry ID\r\n   */\r\n  addPendingSignal(signal: Signal, keyLevel: number): string {\r\n    return this.entryConfirmation.addPending({\r\n      symbol: this.bybitService['symbol'],\r\n      direction: signal.direction,\r\n      keyLevel,\r\n      detectedAt: Date.now(),\r\n      signalData: signal as unknown as Record<string, unknown>,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check pending signals for confirmation\r\n   * Called every trading cycle with latest 1m candle close price\r\n   * @param currentCandleClose - Current 1m candle close price\r\n   * @returns Confirmed signal or null\r\n   */\r\n  checkPendingConfirmations(currentCandleClose: number): Signal | null {\r\n    const allPending = this.entryConfirmation.getAllPending();\r\n\r\n    for (const pending of allPending) {\r\n      const result = this.entryConfirmation.checkConfirmation(pending.id, currentCandleClose);\r\n\r\n      if (result.confirmed) {\r\n        const levelType = pending.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n        this.logger.info(`‚úÖ ${pending.direction} signal confirmed - ready to enter`, {\r\n          pendingId: pending.id,\r\n          direction: pending.direction,\r\n          [`${levelType}Level`]: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n          candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n\r\n        // Return the confirmed signal\r\n        return pending.signalData as unknown as Signal;\r\n      }\r\n\r\n      // Log rejections\r\n      if (!result.confirmed) {\r\n        if (pending.direction === SignalDirection.LONG && result.reason.includes('below support')) {\r\n          this.logger.info('‚ùå LONG signal rejected - falling knife avoided', {\r\n            pendingId: pending.id,\r\n            supportLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n            candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n        } else if (pending.direction === SignalDirection.SHORT && result.reason.includes('above resistance')) {\r\n          this.logger.info('‚ùå SHORT signal rejected - pump continues', {\r\n            pendingId: pending.id,\r\n            resistanceLevel: pending.keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n            candleClose: currentCandleClose.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Cleanup expired entries\r\n    this.entryConfirmation.cleanupExpired();\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get count of pending signals\r\n   * @param direction - Optional: filter by direction\r\n   */\r\n  getPendingCount(direction?: SignalDirection): number {\r\n    return this.entryConfirmation.getPendingCount(direction);\r\n  }\r\n\r\n  /**\r\n   * Sync position from WebSocket update\r\n   */\r\n  syncWithWebSocket(position: Position): void {\r\n    if (this.currentPosition === null) {\r\n      // Position restored from WebSocket (e.g., after bot restart)\r\n      // Try to find matching open trade in journal by symbol\r\n      const openTrade = this.journal.getOpenPositionBySymbol(position.symbol);\r\n\r\n      if (openTrade) {\r\n        // Restore journalId from open trade\r\n        position.journalId = openTrade.id;\r\n        this.logger.info('‚úÖ Position restored from WebSocket with journal ID', {\r\n          exchangeId: position.id,\r\n          journalId: position.journalId,\r\n          symbol: position.symbol,\r\n        });\r\n      } else {\r\n        // No open trade in journal - DO NOT create journal entry (Session #57 decision)\r\n        // Position will be managed (TP/SL) but NOT tracked in journal statistics\r\n        this.logger.warn('‚ö†Ô∏è Position restored from WebSocket but not found in journal - IGNORING from statistics', {\r\n          exchangeId: position.id,\r\n          symbol: position.symbol,\r\n          entryPrice: position.entryPrice,\r\n          quantity: position.quantity,\r\n          note: 'This position will be managed (TP/SL) but NOT recorded in journal. Consider closing manually if unwanted.',\r\n        });\r\n\r\n        // Set journalId to undefined - this will prevent journal recording on close\r\n        position.journalId = undefined;\r\n      }\r\n\r\n      // Initialize status for restored positions\r\n      if (!position.status) {\r\n        position.status = 'OPEN';\r\n      }\r\n\r\n      this.currentPosition = position;\r\n      return;\r\n    }\r\n\r\n    // Update existing position\r\n    this.currentPosition.quantity = position.quantity;\r\n    this.currentPosition.unrealizedPnL = position.unrealizedPnL;\r\n\r\n    // ‚ö†Ô∏è CRITICAL: Only update entryPrice if it's valid (> 0) and current is 0\r\n    // Bybit sends entryPrice=0 for MARKET orders before they're filled\r\n    // We must preserve the signal.price set during openPosition()\r\n    if (position.entryPrice > 0 && this.currentPosition.entryPrice === 0) {\r\n      this.currentPosition.entryPrice = position.entryPrice;\r\n      this.logger.info('‚úÖ Entry price updated from WebSocket', {\r\n        positionId: this.currentPosition.id,\r\n        entryPrice: position.entryPrice,\r\n      });\r\n    }\r\n    // DO NOT overwrite entryPrice if we already have it from signal!\r\n  }\r\n\r\n  /**\r\n   * Clear position (called when WebSocket reports position closed)\r\n   */\r\n  async clearPosition(): Promise<void> {\r\n    // Cancel any remaining conditional orders (SL/TP) when position closed via WebSocket\r\n    this.logger.debug('üßπ Cancelling conditional orders after WebSocket position close...');\r\n    await this.bybitService.cancelAllConditionalOrders();\r\n\r\n    // Phase 3: Reset AdaptiveTP3 state\r\n    if (this.adaptiveTP3Service && this.currentPosition) {\r\n      this.adaptiveTP3Service.reset(this.currentPosition.id);\r\n    }\r\n\r\n    this.currentPosition = null;\r\n    this.takeProfitManager = null;\r\n  }\r\n\r\n  /**\r\n   * Record position close in journal\r\n   */\r\n  recordPositionClose(\r\n    exitPrice: number,\r\n    exitReason: string,\r\n    exitType: ExitType,\r\n    tpLevelsHit: number[] = [],\r\n  ): void {\r\n    // IDEMPOTENT: Check if position is null or already closed\r\n    if (!this.currentPosition) {\r\n      this.logger.debug('recordPositionClose called but position is null');\r\n      return;\r\n    }\r\n\r\n    if (this.currentPosition.status === 'CLOSED') {\r\n      this.logger.debug('recordPositionClose called but position already closed - skipping duplicate recording', {\r\n        positionId: this.currentPosition.id,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Mark as CLOSED BEFORE any operations to prevent race conditions\r\n    this.currentPosition.status = 'CLOSED';\r\n\r\n    const holdingTimeMs = Date.now() - this.currentPosition.openedAt;\r\n    const holdingTimeMinutes = holdingTimeMs / TIME_UNITS.MINUTE;\r\n\r\n    // Calculate total PnL using TakeProfitManager\r\n    let realizedPnL: number;\r\n    let pnlGross: number;\r\n    let tradingFees: number;\r\n    let partialCloses: PartialClose[] = [];\r\n\r\n    if (this.takeProfitManager) {\r\n      // Calculate final PnL including all partial closes + remaining quantity\r\n      const finalPnL = this.takeProfitManager.calculateFinalPnL(exitPrice);\r\n      realizedPnL = finalPnL.totalPnL.pnlNet;\r\n      pnlGross = finalPnL.totalPnL.pnlGross;\r\n      tradingFees = finalPnL.totalPnL.fees;\r\n      partialCloses = this.takeProfitManager.getPartialCloses();\r\n\r\n      this.logger.info('üìä Final PnL calculated', {\r\n        positionId: this.currentPosition.id,\r\n        partialClosesCount: partialCloses.length,\r\n        partialPnL: finalPnL.partialPnL.pnlNet.toFixed(DECIMAL_PLACES.PRICE),\r\n        remainingPnL: finalPnL.remainingPnL.pnlNet.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalPnL: realizedPnL.toFixed(DECIMAL_PLACES.PRICE),\r\n        totalFees: tradingFees.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n    } else {\r\n      // Fallback: Calculate PnL the old way (no partial closes)\r\n      const priceDiff = exitPrice - this.currentPosition.entryPrice;\r\n      const isLong = this.currentPosition.side === PositionSide.LONG;\r\n      const pnlMultiplier = isLong ? 1 : -1;\r\n\r\n      pnlGross = priceDiff * this.currentPosition.quantity * pnlMultiplier * this.tradingConfig.leverage;\r\n\r\n      const entryValue = this.currentPosition.entryPrice * this.currentPosition.quantity;\r\n      const exitValue = exitPrice * this.currentPosition.quantity;\r\n      tradingFees = (entryValue + exitValue) * 0.00055;\r\n\r\n      realizedPnL = pnlGross - tradingFees;\r\n    }\r\n\r\n    const priceDiff = exitPrice - this.currentPosition.entryPrice;\r\n    const isLong = this.currentPosition.side === PositionSide.LONG;\r\n    const pnlMultiplier = isLong ? 1 : -1;\r\n    const pnlPercent = (priceDiff / this.currentPosition.entryPrice) * PERCENT_MULTIPLIER * pnlMultiplier;\r\n\r\n    try {\r\n      // Skip journal recording if position was restored without journalId\r\n      if (!this.currentPosition.journalId) {\r\n        this.logger.warn('‚ö†Ô∏è Skipping journal recording - position has no journalId', {\r\n          positionId: this.currentPosition.id,\r\n          exitType,\r\n        });\r\n        return;\r\n      }\r\n\r\n      this.journal.recordTradeClose({\r\n        id: this.currentPosition.journalId,\r\n        exitPrice,\r\n        realizedPnL,\r\n        exitCondition: {\r\n          exitType,\r\n          price: exitPrice,\r\n          timestamp: Date.now(),\r\n          reason: exitReason,\r\n          pnlUsdt: realizedPnL,\r\n          pnlPercent,\r\n          realizedPnL,\r\n          tpLevelsHit,\r\n          tpLevelsHitCount: tpLevelsHit.length,\r\n          partialCloses: partialCloses.length > 0 ? partialCloses : undefined,\r\n          pnlGross,\r\n          tradingFees,\r\n          holdingTimeMs,\r\n          holdingTimeMinutes,\r\n          holdingTimeHours: holdingTimeMinutes / 60,\r\n          stoppedOut: exitType === 'STOP_LOSS',\r\n          slMovedToBreakeven: this.currentPosition.stopLoss.isBreakeven,\r\n          trailingStopActivated: this.currentPosition.stopLoss.isTrailing,\r\n          maxProfitPercent: pnlPercent > 0 ? pnlPercent : 0,\r\n          maxDrawdownPercent: pnlPercent < 0 ? Math.abs(pnlPercent) : 0,\r\n        },\r\n      });\r\n\r\n      this.logger.info('üìù Position close recorded in journal', {\r\n        positionId: this.currentPosition.id,\r\n        exitType,\r\n        pnl: realizedPnL.toFixed(DECIMAL_PLACES.PERCENT),\r\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      // Update session stats (if available)\r\n      if (this.sessionStats && this.currentPosition.journalId) {\r\n        this.sessionStats.updateTradeExit(this.currentPosition.journalId, {\r\n          exitPrice,\r\n          pnl: realizedPnL,\r\n          pnlPercent,\r\n          exitType,\r\n          tpHitLevels: tpLevelsHit,\r\n          holdingTimeMs,\r\n          stopLoss: {\r\n            initial: this.currentPosition.stopLoss.initialPrice || this.currentPosition.stopLoss.price,\r\n            final: this.currentPosition.stopLoss.price,\r\n            movedToBreakeven: this.currentPosition.stopLoss.isBreakeven,\r\n            trailingActivated: this.currentPosition.stopLoss.isTrailing,\r\n          },\r\n        });\r\n        this.logger.debug('üìä Trade exit updated in session stats', { tradeId: this.currentPosition.journalId });\r\n      }\r\n\r\n      // Phase 3: Reset AdaptiveTP3 state\r\n      if (this.adaptiveTP3Service) {\r\n        this.adaptiveTP3Service.reset(this.currentPosition.id);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to record position close', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update trailing stop based on Bollinger Bands (BB.MD Section 3.3)\r\n   *\r\n   * Formula: newStop = bb.lower - (atr √ó multiplier)\r\n   * IMPORTANT: Only moves stop UP (LONG) or DOWN (SHORT) to protect profit\r\n   *\r\n   * @param bollingerBands - Current Bollinger Bands data\r\n   * @param atr - Current ATR value (absolute, not percent)\r\n   * @param currentPrice - Current market price\r\n   */\r\n  async updateBBTrailingStop(\r\n    bollingerBands: { lower: number; middle: number; upper: number },\r\n    atr: number,\r\n    currentPrice: number,\r\n  ): Promise<void> {\r\n    // Check if we have an open position\r\n    if (!this.currentPosition) {\r\n      return;\r\n    }\r\n\r\n    // Check if position is already closed (prevent race conditions)\r\n    if (this.currentPosition.status === 'CLOSED') {\r\n      return;\r\n    }\r\n\r\n    // Check if BB trailing stop is enabled\r\n    if (!this.riskConfig.bbTrailingStop?.enabled) {\r\n      return;\r\n    }\r\n\r\n    const config = this.riskConfig.bbTrailingStop;\r\n    const side = this.currentPosition.side;\r\n    const currentStopLoss = this.currentPosition.stopLoss.price;\r\n\r\n    // Calculate new stop based on BB.lower - (atr √ó multiplier)\r\n    let newStop: number;\r\n    if (side === PositionSide.LONG) {\r\n      newStop = bollingerBands.lower - (atr * config.atrMultiplier);\r\n    } else {\r\n      // For SHORT: use BB.upper + (atr √ó multiplier)\r\n      newStop = bollingerBands.upper + (atr * config.atrMultiplier);\r\n    }\r\n\r\n    // IMPORTANT: Only move stop in favorable direction\r\n    const shouldUpdate =\r\n      side === PositionSide.LONG\r\n        ? newStop > currentStopLoss // LONG: move SL up only\r\n        : newStop < currentStopLoss; // SHORT: move SL down only\r\n\r\n    if (!shouldUpdate) {\r\n      this.logger.debug('üîµ BB trailing: New stop not better than current', {\r\n        side,\r\n        currentSL: currentStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        newSL: newStop.toFixed(DECIMAL_PLACES.PRICE),\r\n        bbLower: bollingerBands.lower.toFixed(DECIMAL_PLACES.PRICE),\r\n        atr: atr.toFixed(DECIMAL_PLACES.PRICE),\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Check minimum move threshold\r\n    const movePercent = Math.abs((newStop - currentStopLoss) / currentStopLoss) * PERCENT_MULTIPLIER;\r\n    if (movePercent < config.minMovePercent) {\r\n      this.logger.debug('üîµ BB trailing: Move too small', {\r\n        movePercent: movePercent.toFixed(3) + '%',\r\n        minRequired: config.minMovePercent + '%',\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Update stop loss on exchange\r\n    try {\r\n      await this.bybitService.updateStopLoss(newStop);\r\n\r\n      // Update local position\r\n      this.currentPosition.stopLoss.price = newStop;\r\n\r\n      this.logger.info('üéØ BB Trailing Stop Updated', {\r\n        side,\r\n        oldSL: currentStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        newSL: newStop.toFixed(DECIMAL_PLACES.PRICE),\r\n        movePercent: movePercent.toFixed(3) + '%',\r\n        currentPrice: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        bbLower: bollingerBands.lower.toFixed(DECIMAL_PLACES.PRICE),\r\n        atr: atr.toFixed(DECIMAL_PLACES.PRICE),\r\n        multiplier: config.atrMultiplier,\r\n      });\r\n\r\n      // Send Telegram notification\r\n      await this.telegram.sendAlert(\r\n        'üéØ BB Trailing Stop Updated\\n' +\r\n        `Side: ${side}\\n` +\r\n        `Old SL: ${currentStopLoss.toFixed(DECIMAL_PLACES.PRICE)}\\n` +\r\n        `New SL: ${newStop.toFixed(DECIMAL_PLACES.PRICE)}\\n` +\r\n        `Move: +${movePercent.toFixed(DECIMAL_PLACES.PERCENT)}%\\n` +\r\n        `Current: ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      );\r\n    } catch (error) {\r\n      this.logger.error('Failed to update BB trailing stop', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate breakeven price with offset\r\n   */\r\n  private calculateBreakevenPrice(\r\n    entryPrice: number,\r\n    side: PositionSide,\r\n    offsetPercent: number,\r\n  ): number {\r\n    const offset = (offsetPercent / PERCENT_TO_DECIMAL) * entryPrice;\r\n\r\n    if (side === PositionSide.LONG) {\r\n      return entryPrice + offset;\r\n    } else {\r\n      return entryPrice - offset;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate trailing stop price\r\n   */\r\n  private calculateTrailingStopPrice(\r\n    currentPrice: number,\r\n    side: PositionSide,\r\n    trailingPercent: number,\r\n  ): number {\r\n    const offset = (trailingPercent / PERCENT_TO_DECIMAL) * currentPrice;\r\n\r\n    if (side === PositionSide.LONG) {\r\n      return currentPrice - offset;\r\n    } else {\r\n      return currentPrice + offset;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sleep helper for async delays\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\position-monitor.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30000.","line":68,"column":8,"nodeType":"Literal","messageId":"noMagic","endLine":68,"endColumn":13},{"ruleId":"complexity","severity":1,"message":"Async method 'monitorPosition' has a complexity of 14. Maximum allowed is 10.","line":111,"column":32,"nodeType":"FunctionExpression","messageId":"complex","endLine":232,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":145,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":145,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4705,4743],"text":"(currentPosition.protectionVerifiedOnce ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[4704,4743],"text":"currentPosition.protectionVerifiedOnce === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":161,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":190,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":273,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":273,"endColumn":66},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.2.","line":274,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":274,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":278,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":278,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":278,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":278,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":284,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":284,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":339,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":339,"endColumn":70},{"ruleId":"complexity","severity":1,"message":"Method 'determineExitTypeFromHistory' has a complexity of 12. Maximum allowed is 10.","line":384,"column":39,"nodeType":"FunctionExpression","messageId":"complex","endLine":440,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":419,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":419,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":422,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":422,"endColumn":24},{"ruleId":"complexity","severity":1,"message":"Async method 'deepSyncCheck' has a complexity of 14. Maximum allowed is 10.","line":479,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":608,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 120000.","line":491,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":491,"endColumn":33},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (382). Maximum allowed is 300.","line":501,"column":1,"nodeType":null,"messageId":"exceed","endLine":610,"endColumn":1},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":577,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":577,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":600,"column":77,"nodeType":"Literal","messageId":"noMagic","endLine":600,"endColumn":81}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\n/**\n * Position Monitor Service\n * Monitors open positions for TP/SL hits via WebSocket events\n *\n * Responsibilities:\n * 1. Listen to WebSocket order execution events\n * 2. Detect TP hits and trigger breakeven/trailing logic\n * 3. Periodic sync check with exchange\n *\n * Single Responsibility: Position monitoring and TP/SL event handling\n */\n\nimport { EventEmitter } from 'events';\nimport { BybitService } from './bybit';\nimport { PositionManagerService } from './position-manager.service';\nimport { Position, PositionSide, RiskManagementConfig, LoggerService, ExitType, BybitOrder, isStopLossOrder, isTakeProfitOrder } from '../types';\nimport { TelegramService } from './telegram.service';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nconst MONITOR_INTERVAL_MS = 10000; // Check every 10 seconds\nconst POSITION_SIZE_ZERO = 0;\n\n// ============================================================================\n// POSITION MONITOR SERVICE\n// ============================================================================\n\nexport class PositionMonitorService extends EventEmitter {\n  private monitorInterval: NodeJS.Timeout | null = null;\n  private deepSyncInterval: NodeJS.Timeout | null = null;\n  private isMonitoring: boolean = false;\n\n  constructor(\n    private readonly bybitService: BybitService,\n    private readonly positionManager: PositionManagerService,\n    private readonly riskConfig: RiskManagementConfig,\n    private readonly telegram: TelegramService,\n    private readonly logger: LoggerService,\n  ) {\n    super();\n  }\n\n  // ==========================================================================\n  // PUBLIC API\n  // ==========================================================================\n\n  /**\n   * Start monitoring positions\n   */\n  start(): void {\n    if (this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = true;\n\n    // Level 1: Position consistency check (every 10s)\n    this.monitorInterval = setInterval(() => {\n      void this.monitorPosition();\n    }, MONITOR_INTERVAL_MS);\n\n    // Level 2: Deep sync check (every 30s)\n    this.deepSyncInterval = setInterval(() => {\n      void this.deepSyncCheck();\n    }, 30000); // 30 seconds\n\n    this.emit('started');\n  }\n\n  /**\n   * Stop monitoring positions\n   */\n  stop(): void {\n    if (!this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = false;\n\n    if (this.monitorInterval !== null) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n\n    if (this.deepSyncInterval !== null) {\n      clearInterval(this.deepSyncInterval);\n      this.deepSyncInterval = null;\n    }\n\n    this.emit('stopped');\n  }\n\n  /**\n   * Check if monitoring is active\n   */\n  isActive(): boolean {\n    return this.isMonitoring;\n  }\n\n  // ==========================================================================\n  // PRIVATE HELPERS\n  // ==========================================================================\n\n  /**\n   * Monitor position (called periodically)\n   * This is a safety check - main logic is driven by WebSocket events\n   */\n  private async monitorPosition(): Promise<void> {\n    try {\n      // 1. Get current position from memory\n      const currentPosition = this.positionManager.getCurrentPosition();\n\n      if (currentPosition === null) {\n        return;\n      }\n\n      // FIX: Skip monitoring if position already closed (prevents duplicate external close events)\n      if (currentPosition.status === 'CLOSED') {\n        this.logger.debug('Position already closed, skipping monitor check');\n        return;\n      }\n\n      // 2. SAFETY CHECK: Verify position exists on exchange\n      const exchangePosition = await this.bybitService.getPosition();\n\n      if (exchangePosition === null || exchangePosition.quantity === POSITION_SIZE_ZERO) {\n        // Double-check: position might have been closed by WebSocket during async call\n        const pos = this.positionManager.getCurrentPosition();\n        if (pos === null || pos.status === 'CLOSED') {\n          this.logger.debug('Position closed by WebSocket during monitor check, skipping external event');\n          return;\n        }\n\n        // Position closed on exchange but WebSocket event missed - sync state\n        await this.syncClosedPosition(currentPosition);\n        return;\n      }\n\n      // üö® CRITICAL: Verify TP/SL protection is active\n      // BUT only check ONCE after position open (not every cycle!)\n      // After first successful verification, we rely on trailing stop or manual management\n      if (!currentPosition.protectionVerifiedOnce) {\n        this.logger.debug('üîç Initial protection verification check...');\n        const protection = await this.bybitService.verifyProtectionSet(currentPosition.side);\n\n        if (!protection.verified) {\n          this.logger.error('üö® UNPROTECTED POSITION DETECTED - CLOSING IMMEDIATELY!', {\n            positionId: currentPosition.id,\n            side: currentPosition.side,\n            entryPrice: currentPosition.entryPrice,\n            hasStopLoss: protection.hasStopLoss,\n            hasTakeProfit: protection.hasTakeProfit,\n            hasTrailingStop: protection.hasTrailingStop,\n            activeOrders: protection.activeOrders,\n          });\n\n          // Close position immediately - no emergency protection attempts\n          try {\n            await this.bybitService.closePosition(currentPosition.side, currentPosition.quantity);\n\n            await this.telegram.sendAlert(\n              'üö® UNPROTECTED POSITION CLOSED @ market price!\\n' +\n              `Side: ${currentPosition.side}\\n` +\n              `Entry: ${currentPosition.entryPrice}\\n` +\n              'Reason: No SL/TP protection detected',\n            );\n\n            this.emit('positionClosedEmergency', currentPosition);\n            await this.positionManager.clearPosition();\n\n            this.logger.warn('‚úÖ Unprotected position closed successfully');\n            return; // Exit monitoring - position closed\n          } catch (closeError) {\n            this.logger.error('üö®üö®üö® CRITICAL: Failed to close unprotected position!', {\n              error: closeError instanceof Error ? closeError.message : String(closeError),\n            });\n\n            await this.telegram.sendAlert(\n              'üö®üö®üö® CRITICAL ALERT üö®üö®üö®\\n' +\n              `Position ${currentPosition.id} is UNPROTECTED and CANNOT BE CLOSED!\\n` +\n              'MANUAL INTERVENTION REQUIRED IMMEDIATELY!\\n' +\n              `Side: ${currentPosition.side}\\n` +\n              `Entry: ${currentPosition.entryPrice}\\n` +\n              `Quantity: ${currentPosition.quantity}`,\n            );\n            return; // Exit monitoring - manual intervention needed\n          }\n        } else {\n          // Protection verified - set flag to skip future checks\n          currentPosition.protectionVerifiedOnce = true;\n          this.logger.info('‚úÖ Protection verified - no further checks needed', {\n            positionId: currentPosition.id,\n            hasTrailingStop: protection.hasTrailingStop,\n          });\n        }\n      }\n\n      // 3. Get current price\n      const currentPrice = await this.bybitService.getCurrentPrice();\n\n      // 4. Check if SL hit (safety backup - primary detection via WebSocket)\n      const slHit = this.checkStopLoss(currentPosition, currentPrice);\n      if (slHit) {\n        this.emit('stopLossHit', {\n          position: currentPosition,\n          currentPrice,\n          reason: `Stop Loss hit at ${currentPrice}`,\n        });\n      }\n\n      // 5. TP detection now handled via WebSocket 'order' topic\n      // No more price-based TP checking - WebSocket provides real-time TP fills\n\n      // 6. Check time-based exit (if enabled)\n      const timeBasedExit = this.checkTimeBasedExit(currentPosition, currentPrice);\n      if (timeBasedExit.shouldExit) {\n        this.emit('timeBasedExit', {\n          position: currentPosition,\n          currentPrice,\n          reason: timeBasedExit.reason,\n          openedMinutes: timeBasedExit.openedMinutes,\n          pnlPercent: timeBasedExit.pnlPercent,\n        });\n      }\n\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Check if stop-loss is hit\n   */\n  private checkStopLoss(position: Position, currentPrice: number): boolean {\n    if (position.side === PositionSide.LONG) {\n      return currentPrice <= position.stopLoss.price;\n    } else {\n      return currentPrice >= position.stopLoss.price;\n    }\n  }\n\n  // REMOVED: checkTakeProfits() - TP detection now handled via WebSocket 'order' topic\n  // Price-based TP checking was unreliable (missed TPs when price retraced before next check)\n  // Real-time TP fills now detected through WebSocket events\n\n  /**\n   * Check time-based exit conditions\n   * Exit if position is open for too long without significant profit\n   *\n   * @param position - Current position\n   * @param currentPrice - Current market price\n   * @returns Exit decision with reason\n   */\n  private checkTimeBasedExit(\n    position: Position,\n    currentPrice: number,\n  ): {\n    shouldExit: boolean;\n    reason?: string;\n    openedMinutes?: number;\n    pnlPercent?: number;\n  } {\n    // Check if time-based exit is enabled\n    const enabled = this.riskConfig.timeBasedExitEnabled ?? false;\n    if (!enabled) {\n      return { shouldExit: false };\n    }\n\n    // Get config (with defaults)\n    const maxMinutes = this.riskConfig.timeBasedExitMinutes ?? 30;\n    const minPnlPercent = this.riskConfig.timeBasedExitMinPnl ?? 0.2;\n\n    // Calculate how long position has been open (in minutes)\n    const openedMs = Date.now() - position.openedAt;\n    const openedMinutes = openedMs / 1000 / 60;\n\n    // Calculate current PnL %\n    const pnlPercent = this.calculatePnL(position, currentPrice);\n\n    // Log current state (debug)\n    if (openedMinutes > maxMinutes / 2) {\n      // Log when position is open for more than half the max time\n      this.logger.debug('Time-based exit check', {\n        openedMinutes: openedMinutes.toFixed(1),\n        maxMinutes,\n        pnlPercent: pnlPercent.toFixed(DECIMAL_PLACES.PERCENT),\n        minPnlPercent,\n      });\n    }\n\n    // Check if should exit\n    if (openedMinutes > maxMinutes && pnlPercent < minPnlPercent) {\n      return {\n        shouldExit: true,\n        reason: `Position open for ${openedMinutes.toFixed(0)} min with low PnL (${pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)`,\n        openedMinutes,\n        pnlPercent,\n      };\n    }\n\n    return { shouldExit: false };\n  }\n\n  /**\n   * Calculate current PnL percentage\n   *\n   * @param position - Current position\n   * @param currentPrice - Current market price\n   * @returns PnL in percentage\n   */\n  private calculatePnL(position: Position, currentPrice: number): number {\n    if (position.side === PositionSide.LONG) {\n      return ((currentPrice - position.entryPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\n    } else {\n      return ((position.entryPrice - currentPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\n    }\n  }\n\n  // ==========================================================================\n  // SAFETY MONITOR: SYNC WITH EXCHANGE\n  // ==========================================================================\n\n  /**\n   * Sync closed position state when WebSocket event was missed\n   * Queries order history to determine correct exitType\n   */\n  private async syncClosedPosition(position: Position): Promise<void> {\n    this.logger.warn('‚ö†Ô∏è Position closed on exchange but WebSocket event missed', {\n      positionId: position.id,\n      entryPrice: position.entryPrice,\n      side: position.side,\n    });\n\n    try {\n      // Get order history to determine exitType\n      const orderHistory = await this.bybitService.getOrderHistory(20);\n      const exitType = this.determineExitTypeFromHistory(orderHistory, position);\n\n      // Get current price for PnL calculation\n      const currentPrice = await this.bybitService.getCurrentPrice();\n\n      // Record close with correct exitType (NOT MANUAL unless truly manual)\n      this.positionManager.recordPositionClose(\n        currentPrice,\n        `Position closed on exchange (WebSocket event missed) - ${exitType}`,\n        exitType,\n        [], // TP levels unknown when syncing\n      );\n\n      // Send alert\n      await this.telegram.sendAlert(\n        '‚ö†Ô∏è SYNC: Position closed on exchange\\n' +\n        `Exit Type: ${exitType}\\n` +\n        `Entry: ${position.entryPrice}\\n` +\n        `Exit: ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)}\\n` +\n        'Reason: WebSocket event missed',\n      );\n\n      // Clear position\n      await this.positionManager.clearPosition();\n\n      this.logger.info('‚úÖ Position state synced with exchange', {\n        positionId: position.id,\n        exitType,\n      });\n    } catch (error) {\n      this.logger.error('Failed to sync closed position', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      // Fallback: emit external close event\n      this.emit('positionClosedExternally', position);\n      await this.positionManager.clearPosition();\n    }\n  }\n\n  /**\n   * Determine exitType from order history\n   * Analyzes filled orders to understand how position was closed\n   */\n  private determineExitTypeFromHistory(orderHistory: BybitOrder[], position: Position): ExitType {\n    // Find filled orders for this symbol\n    const filledOrders = orderHistory\n      .filter((o) => o.symbol === position.symbol && o.orderStatus === 'Filled')\n      .sort((a, b) => {\n        const aTime = (a as Record<string, unknown>).updatedTime as number;\n        const bTime = (b as Record<string, unknown>).updatedTime as number;\n        return bTime - aTime;\n      }); // Most recent first\n\n    if (filledOrders.length === 0) {\n      this.logger.warn('No filled orders found in history, assuming MANUAL close');\n      return ExitType.MANUAL;\n    }\n\n    // Check last filled order\n    const lastOrder = filledOrders[0];\n\n    // Stop Loss: triggerPrice exists + reduceOnly + side matches close direction\n    if (lastOrder.stopOrderType === 'Stop' || lastOrder.stopOrderType === 'StopLoss') {\n      return ExitType.STOP_LOSS;\n    }\n\n    // Trailing Stop\n    if (lastOrder.stopOrderType === 'TrailingStop') {\n      return ExitType.TRAILING_STOP;\n    }\n\n    // Take Profit: Limit order + reduceOnly\n    if (lastOrder.orderType === 'Limit' && lastOrder.reduceOnly === true) {\n      // Try to determine TP level from price\n      const tpLevel = this.identifyTPLevel(parseFloat(lastOrder.price), position);\n      if (tpLevel === 1) {\n        return ExitType.TAKE_PROFIT_1;\n      }\n      if (tpLevel === 2) {\n        return ExitType.TAKE_PROFIT_2;\n      }\n      if (tpLevel === 3) {\n        return ExitType.TAKE_PROFIT_3;\n      }\n      return ExitType.TAKE_PROFIT_1; // Fallback\n    }\n\n    // Market order + reduceOnly = likely manual close\n    if (lastOrder.orderType === 'Market' && lastOrder.reduceOnly === true) {\n      return ExitType.MANUAL;\n    }\n\n    this.logger.warn('Could not determine exitType from order history', {\n      lastOrderType: lastOrder.orderType,\n      stopOrderType: lastOrder.stopOrderType,\n      reduceOnly: lastOrder.reduceOnly,\n    });\n\n    return ExitType.MANUAL; // Fallback\n  }\n\n  /**\n   * Identify TP level from price\n   * Returns 1, 2, or 3 based on which TP level price is closest to\n   */\n  private identifyTPLevel(price: number, position: Position): number {\n    const tpLevels = position.takeProfits;\n\n    if (tpLevels.length === 0) {\n      return 1; // Default\n    }\n\n    // Find closest TP level\n    let closestLevel = 1;\n    let closestDistance = Math.abs(price - tpLevels[0].price);\n\n    for (let i = 1; i < tpLevels.length; i++) {\n      const distance = Math.abs(price - tpLevels[i].price);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestLevel = i + 1;\n      }\n    }\n\n    return closestLevel;\n  }\n\n  // ==========================================================================\n  // DEEP SYNC CHECK (Level 2 Safety)\n  // ==========================================================================\n\n  /**\n   * Deep sync check - runs every 30s for positions > 2 minutes old\n   * Verifies:\n   * 1. TP/SL orders still active on exchange\n   * 2. Stop Loss not missing (emergency close if missing)\n   * 3. Position quantity matches exchange\n   */\n  private async deepSyncCheck(): Promise<void> {\n    try {\n      const position = this.positionManager.getCurrentPosition();\n\n      // No position or already closed\n      if (position === null || position.status === 'CLOSED') {\n        return;\n      }\n\n      const positionAgeMs = Date.now() - position.openedAt;\n\n      // Only run deep check if position > 2 minutes old\n      if (positionAgeMs < 120000) {\n        return;\n      }\n\n      this.logger.debug('üîç Running deep sync check', {\n        positionId: position.id,\n        ageMinutes: Math.floor(positionAgeMs / TIME_UNITS.MINUTE),\n      });\n\n      // 1. Verify position still exists on exchange\n      const exchangePos = await this.bybitService.getPosition();\n\n      if (exchangePos === null || exchangePos.quantity === POSITION_SIZE_ZERO) {\n        // Position closed on exchange - already handled by syncClosedPosition\n        this.logger.debug('Deep sync: Position closed on exchange (will be handled by monitor)');\n        return;\n      }\n\n      // 2. Verify TP/SL orders still active\n      const activeOrders = await this.bybitService.getActiveOrders();\n\n      // Check for Stop Loss order\n      const hasStopLoss = activeOrders.some((order: BybitOrder) => {\n        const isSL = isStopLossOrder(order);\n\n        const correctSide = position.side === PositionSide.LONG\n          ? order.side === 'Sell'\n          : order.side === 'Buy';\n\n        return isSL && correctSide;\n      });\n\n      // Check for Take Profit orders\n      const hasTakeProfit = activeOrders.some((order: BybitOrder) => {\n        const isTP = isTakeProfitOrder(order);\n\n        const correctSide = position.side === PositionSide.LONG\n          ? order.side === 'Sell'\n          : order.side === 'Buy';\n\n        return isTP && correctSide;\n      });\n\n      // Check for Trailing Stop via position info\n      let hasTrailingStop = false;\n      if (position.stopLoss.isTrailing) {\n        hasTrailingStop = true;\n        this.logger.debug('Deep sync: Trailing stop active (position flag set)');\n      }\n\n      // üö® CRITICAL: Stop Loss missing!\n      if (!hasStopLoss && !hasTrailingStop) {\n        this.logger.error('üö® CRITICAL: Stop Loss order missing!', {\n          positionId: position.id,\n          hasTrailing: hasTrailingStop,\n          activeOrders: activeOrders.length,\n        });\n\n        await this.telegram.sendAlert(\n          'üö® CRITICAL: Stop Loss missing!\\n' +\n          `Position: ${position.id}\\n` +\n          `Side: ${position.side}\\n` +\n          `Entry: ${position.entryPrice}\\n` +\n          `Age: ${Math.floor(positionAgeMs / TIME_UNITS.MINUTE)} minutes\\n` +\n          'Action: Closing position immediately',\n        );\n\n        // Emergency close\n        try {\n          await this.bybitService.closePosition(position.side, position.quantity);\n          this.logger.warn('‚úÖ Unprotected position closed successfully (deep sync)');\n        } catch (closeError) {\n          this.logger.error('üö®üö®üö® CRITICAL: Failed to close unprotected position!', {\n            error: closeError instanceof Error ? closeError.message : String(closeError),\n          });\n\n          await this.telegram.sendAlert(\n            'üö®üö®üö® CRITICAL ALERT üö®üö®üö®\\n' +\n            `Position ${position.id} is UNPROTECTED and CANNOT BE CLOSED!\\n` +\n            'MANUAL INTERVENTION REQUIRED IMMEDIATELY!',\n          );\n        }\n        return;\n      }\n\n      // 3. Sync position quantity mismatch\n      if (Math.abs(exchangePos.quantity - position.quantity) > 0.01) {\n        this.logger.warn('Position quantity mismatch - syncing', {\n          local: position.quantity,\n          exchange: exchangePos.quantity,\n          difference: Math.abs(exchangePos.quantity - position.quantity),\n        });\n\n        // Update local position quantity\n        this.positionManager.syncWithWebSocket(exchangePos);\n\n        await this.telegram.sendAlert(\n          '‚ö†Ô∏è Position quantity synced\\n' +\n          `Position: ${position.id}\\n` +\n          `Local: ${position.quantity}\\n` +\n          `Exchange: ${exchangePos.quantity}\\n` +\n          'Updated to match exchange',\n        );\n      }\n\n      this.logger.debug('‚úÖ Deep sync check passed', {\n        hasStopLoss,\n        hasTakeProfit,\n        hasTrailingStop,\n        quantityMatch: Math.abs(exchangePos.quantity - position.quantity) < 0.01,\n      });\n\n    } catch (error) {\n      this.logger.error('Deep sync check failed', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\public-websocket.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'role' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":156,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":156,"endColumn":21},{"ruleId":"complexity","severity":1,"message":"Method 'handleMessage' has a complexity of 14. Maximum allowed is 10.","line":186,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":228,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":208,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":208,"endColumn":46,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6501,6536],"text":"((message.topic?.startsWith('kline.')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6501,6536],"text":"((message.topic?.startsWith('kline.')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":213,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":213,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6723,6762],"text":"((message.topic?.startsWith('orderbook.')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6723,6762],"text":"((message.topic?.startsWith('orderbook.')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":218,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":218,"endColumn":52,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6967,7008],"text":"((message.topic?.startsWith('publicTrade.')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6967,7008],"text":"((message.topic?.startsWith('publicTrade.')) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":224,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":224,"endColumn":36},{"ruleId":"complexity","severity":1,"message":"Method 'handleKlineUpdate' has a complexity of 12. Maximum allowed is 10.","line":233,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":273,"endColumn":4},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":257,"column":16,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":257,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Method 'handleOrderbookUpdate' has a complexity of 13. Maximum allowed is 10.","line":279,"column":32,"nodeType":"FunctionExpression","messageId":"complex","endLine":332,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":283,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":283,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9065,9081],"text":"(orderbookData.b == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":283,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":283,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9085,9101],"text":"(orderbookData.a == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":285,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":285,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9187,9203],"text":"(orderbookData.b == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":286,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":286,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9223,9239],"text":"(orderbookData.a == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 200.","line":287,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":287,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":299,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":299,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[9669,9696],"text":"(this.lastIncompleteWarning === 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[9669,9696],"text":"(Number.isNaN(this.lastIncompleteWarning))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9669,9696],"text":"(!Boolean(this.lastIncompleteWarning))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 40.","line":300,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":300,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 40.","line":301,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":301,"endColumn":38},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":344,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":344,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11033,11045],"text":"(tradeData.T == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11034,11045],"text":"(tradeData.T ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11033,11045],"text":"(!Boolean(tradeData.T))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":344,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":344,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":344,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":344,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11065,11077],"text":"(tradeData.v == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11066,11077],"text":"(tradeData.v ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11065,11077],"text":"(!Boolean(tradeData.v))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":344,"column":62,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":344,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11081,11093],"text":"(tradeData.p == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11082,11093],"text":"(tradeData.p ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11081,11093],"text":"(!Boolean(tradeData.p))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":346,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":346,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11183,11195],"text":"(tradeData.T == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11184,11195],"text":"(tradeData.T ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11183,11195],"text":"(!Boolean(tradeData.T))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":347,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":347,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":348,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":348,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11259,11271],"text":"(tradeData.v == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11260,11271],"text":"(tradeData.v ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11259,11271],"text":"(!Boolean(tradeData.v))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":349,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":349,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11297,11309],"text":"(tradeData.p == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[11298,11309],"text":"(tradeData.p ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11297,11309],"text":"(!Boolean(tradeData.p))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Public WebSocket Service\r\n * Subscribes to public market data (kline/candles)\r\n *\r\n * Responsibilities:\r\n * 1. Connect to Bybit Public WebSocket V5\r\n * 2. Subscribe to kline (candle) updates\r\n * 3. Emit events when new candle closes\r\n * 4. Handle reconnection and errors\r\n *\r\n * Single Responsibility: Public market data streaming\r\n */\r\n\r\nimport WebSocket from 'ws';\r\nimport { EventEmitter } from 'events';\r\nimport { Candle, ExchangeConfig, TimeframeRole, LoggerService, KlineData, OrderbookData, TradeData } from '../types';\r\nimport { TimeframeProvider } from '../providers/timeframe.provider';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\n// NOTE: Public WebSocket uses the same URL for both demo and live accounts\r\n// Only Private WebSocket has separate demo endpoint\r\nconst WS_PUBLIC_URL = 'wss://stream.bybit.com/v5/public/linear';\r\nconst PING_INTERVAL_MS = 20000;\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst MAX_RECONNECT_ATTEMPTS = 10;\r\n\r\n// ============================================================================\r\n// PUBLIC WEBSOCKET SERVICE\r\n// ============================================================================\r\n\r\nexport class PublicWebSocketService extends EventEmitter {\r\n  private ws: WebSocket | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts: number = 0;\r\n  private isConnecting: boolean = false;\r\n  private shouldReconnect: boolean = true;\r\n  private subscribedTopics: Set<string> = new Set();\r\n  private lastIncompleteWarning: number = 0; // Timestamp of last incomplete orderbook warning\r\n\r\n  constructor(\r\n    private readonly config: ExchangeConfig,\r\n    private readonly symbol: string,\r\n    private readonly timeframeProvider: TimeframeProvider,\r\n    private readonly logger: LoggerService,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Connect to Public WebSocket and subscribe to kline\r\n   */\r\n  connect(): void {\r\n    if (this.isConnecting || (this.ws !== null && this.ws.readyState === WebSocket.OPEN)) {\r\n      return;\r\n    }\r\n\r\n    this.isConnecting = true;\r\n    // Public WebSocket always uses the main URL (same for demo and live)\r\n    const wsUrl = WS_PUBLIC_URL;\r\n\r\n    this.logger.info('Connecting to Public WebSocket', { wsUrl });\r\n    this.ws = new WebSocket(wsUrl);\r\n\r\n    this.ws.on('open', () => {\r\n      this.isConnecting = false;\r\n      this.reconnectAttempts = 0;\r\n      this.logger.info('Public WebSocket connected');\r\n      this.subscribe();\r\n      this.startPing();\r\n      this.emit('connected');\r\n    });\r\n\r\n    this.ws.on('message', (data: WebSocket.Data) => {\r\n      let message: string;\r\n      if (typeof data === 'string') {\r\n        message = data;\r\n      } else if (Buffer.isBuffer(data)) {\r\n        message = data.toString('utf-8');\r\n      } else if (Array.isArray(data)) {\r\n        message = Buffer.concat(data).toString('utf-8');\r\n      } else {\r\n        return;\r\n      }\r\n      this.handleMessage(message);\r\n    });\r\n\r\n    this.ws.on('error', (error: Error) => {\r\n      this.logger.error('Public WebSocket error', { error: error.message });\r\n      this.emit('error', error);\r\n    });\r\n\r\n    this.ws.on('close', () => {\r\n      this.isConnecting = false;\r\n      this.stopPing();\r\n      this.logger.warn('Public WebSocket disconnected');\r\n      this.emit('disconnected');\r\n\r\n      if (this.shouldReconnect && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n        this.reconnectAttempts++;\r\n        this.logger.info('Reconnecting to Public WebSocket', {\r\n          attempt: this.reconnectAttempts,\r\n          maxAttempts: MAX_RECONNECT_ATTEMPTS,\r\n        });\r\n        setTimeout(() => {\r\n          this.connect();\r\n        }, RECONNECT_DELAY_MS);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Disconnect from Public WebSocket\r\n   */\r\n  disconnect(): void {\r\n    this.shouldReconnect = false;\r\n    this.stopPing();\r\n\r\n    if (this.ws !== null) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n\r\n    this.logger.info('Public WebSocket disconnected');\r\n  }\r\n\r\n  /**\r\n   * Check if WebSocket is connected\r\n   */\r\n  isConnected(): boolean {\r\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Subscribe to kline topics for all enabled timeframes and orderbook\r\n   */\r\n  private subscribe(): void {\r\n    if (this.ws === null || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n    const topics: string[] = [];\r\n\r\n    // Subscribe to kline (candles)\r\n    for (const [role, config] of timeframes) {\r\n      // Topic: kline.{interval}.{symbol}\r\n      // Example: kline.5.BTCUSDT\r\n      const topic = `kline.${config.interval}.${this.symbol}`;\r\n      topics.push(topic);\r\n      this.subscribedTopics.add(topic);\r\n    }\r\n\r\n    // Subscribe to orderbook (depth 50 for whale detection)\r\n    const orderbookTopic = `orderbook.50.${this.symbol}`;\r\n    topics.push(orderbookTopic);\r\n    this.subscribedTopics.add(orderbookTopic);\r\n\r\n    // Subscribe to public trades (for Delta Analysis)\r\n    const tradeTopic = `publicTrade.${this.symbol}`;\r\n    topics.push(tradeTopic);\r\n    this.subscribedTopics.add(tradeTopic);\r\n\r\n    const subscribeMessage = {\r\n      op: 'subscribe',\r\n      args: topics,\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeMessage));\r\n    this.logger.info('Subscribed to timeframes, orderbook, and public trades', { topics });\r\n  }\r\n\r\n  /**\r\n   * Handle incoming WebSocket message\r\n   */\r\n  private handleMessage(data: string): void {\r\n    try {\r\n      const message = JSON.parse(data) as {\r\n        success?: boolean;\r\n        op?: string;\r\n        topic?: string;\r\n        type?: string;\r\n        data?: unknown;\r\n      };\r\n\r\n      // Handle subscription confirmation\r\n      if (message.op === 'subscribe' && message.success === true) {\r\n        this.logger.debug('Subscription confirmed');\r\n        return;\r\n      }\r\n\r\n      // Handle pong\r\n      if (message.op === 'pong') {\r\n        return;\r\n      }\r\n\r\n      // Handle kline data\r\n      if (message.topic?.startsWith('kline.') && message.data !== undefined && message.data !== null) {\r\n        this.handleKlineUpdate(message.data as KlineData | KlineData[]);\r\n      }\r\n\r\n      // Handle orderbook data\r\n      if (message.topic?.startsWith('orderbook.') && message.data !== undefined && message.data !== null) {\r\n        this.handleOrderbookUpdate(message.data as OrderbookData);\r\n      }\r\n\r\n      // Handle public trade data (for Delta Analysis)\r\n      if (message.topic?.startsWith('publicTrade.') && message.data !== undefined && message.data !== null) {\r\n        this.handleTradeUpdate(message.data as TradeData | TradeData[]);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse Public WebSocket message', {\r\n        error: String(error),\r\n        data: data.substring(0, 200),\r\n      });\r\n      this.emit('error', new Error(`Failed to parse message: ${String(error)}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle kline update from WebSocket\r\n   */\r\n  private handleKlineUpdate(data: KlineData | KlineData[]): void {\r\n    const klines = Array.isArray(data) ? data : [data];\r\n\r\n    for (const kline of klines) {\r\n      const klineData = kline;\r\n\r\n      // Only emit on closed candles (confirm = true)\r\n      if (klineData.confirm !== true) {\r\n        continue;\r\n      }\r\n\r\n      const candle: Candle = {\r\n        timestamp: parseInt(klineData.start ?? '0'),\r\n        open: parseFloat(klineData.open ?? '0'),\r\n        high: parseFloat(klineData.high ?? '0'),\r\n        low: parseFloat(klineData.low ?? '0'),\r\n        close: parseFloat(klineData.close ?? '0'),\r\n        volume: parseFloat(klineData.volume ?? '0'),\r\n      };\r\n\r\n      // Determine timeframe role from interval\r\n      const interval = klineData.interval ?? '';\r\n      const role = this.getTimeframeRole(interval);\r\n\r\n      if (role == null) {\r\n        this.logger.warn('Unknown interval received', { interval });\r\n        continue;\r\n      }\r\n\r\n      this.logger.info('üïØÔ∏è New candle closed', {\r\n        symbol: this.symbol,\r\n        role,\r\n        interval,\r\n        timestamp: new Date(candle.timestamp).toISOString(),\r\n        close: candle.close,\r\n      });\r\n\r\n      // Emit event with role - bot will update cache and potentially trigger trading cycle\r\n      this.emit('candleClosed', { role, candle });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle orderbook update from WebSocket\r\n   * Detects snapshot vs delta and emits raw update for OrderbookManager\r\n   */\r\n  private handleOrderbookUpdate(data: OrderbookData): void {\r\n    try {\r\n      const orderbookData = data;\r\n\r\n      if (!orderbookData.b || !orderbookData.a) {\r\n        this.logger.warn('‚ö†Ô∏è Orderbook data missing b or a', {\r\n          hasB: !!orderbookData.b,\r\n          hasA: !!orderbookData.a,\r\n          rawData: JSON.stringify(data).substring(0, 200),\r\n        });\r\n        return;\r\n      }\r\n\r\n      // Detect message type:\r\n      // - \"snapshot\" type field OR\r\n      // - updateId = 1 indicates service restart (treat as snapshot) OR\r\n      // - Large number of levels (>40) on first message = snapshot\r\n      const isSnapshot =\r\n        orderbookData.type === 'snapshot' ||\r\n        orderbookData.u === 1 ||\r\n        (!this.lastIncompleteWarning && // First message\r\n          orderbookData.b.length > 40 &&\r\n          orderbookData.a.length > 40);\r\n\r\n      // Log snapshot detection\r\n      if (isSnapshot) {\r\n        this.logger.info('üì∏ Orderbook SNAPSHOT detected', {\r\n          bids: orderbookData.b.length,\r\n          asks: orderbookData.a.length,\r\n          updateId: orderbookData.u,\r\n          type: orderbookData.type,\r\n        });\r\n      }\r\n\r\n      // Emit raw orderbook update for OrderbookManager\r\n      this.emit('orderbookUpdate', {\r\n        type: isSnapshot ? 'snapshot' : 'delta',\r\n        symbol: orderbookData.s ?? this.symbol,\r\n        bids: orderbookData.b,\r\n        asks: orderbookData.a,\r\n        updateId: orderbookData.u ?? 0,\r\n        timestamp: Date.now(),\r\n      });\r\n\r\n      // Mark as initialized after first message\r\n      if (isSnapshot) {\r\n        this.lastIncompleteWarning = Date.now();\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to handle orderbook update', {\r\n        error: String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle public trade update from WebSocket (for Delta Analysis)\r\n   */\r\n  private handleTradeUpdate(data: TradeData | TradeData[]): void {\r\n    try {\r\n      const trades = Array.isArray(data) ? data : [data];\r\n\r\n      for (const trade of trades) {\r\n        const tradeData = trade;\r\n\r\n        if (!tradeData.T || !tradeData.S || !tradeData.v || !tradeData.p) {\r\n          this.logger.warn('‚ö†Ô∏è Incomplete trade data', {\r\n            hasTimestamp: !!tradeData.T,\r\n            hasSide: !!tradeData.S,\r\n            hasVolume: !!tradeData.v,\r\n            hasPrice: !!tradeData.p,\r\n          });\r\n          continue;\r\n        }\r\n\r\n        // Emit trade event for DeltaAnalyzerService\r\n        this.emit('trade', {\r\n          timestamp: tradeData.T,\r\n          price: parseFloat(tradeData.p),\r\n          quantity: parseFloat(tradeData.v),\r\n          side: tradeData.S === 'Buy' ? 'BUY' : 'SELL',\r\n        });\r\n\r\n        // Commented out: Too spammy (logs every trade tick)\r\n        // this.logger.debug('üìä Trade tick received', {\r\n        //   side: tradeData.S,\r\n        //   price: tradeData.p,\r\n        //   quantity: tradeData.v,\r\n        // });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to handle trade update', {\r\n        error: String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get timeframe role from interval string\r\n   */\r\n  private getTimeframeRole(interval: string): TimeframeRole | null {\r\n    const timeframes = this.timeframeProvider.getAllTimeframes();\r\n\r\n    for (const [role, config] of timeframes) {\r\n      if (config.interval === interval) {\r\n        return role;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Start ping interval to keep connection alive\r\n   */\r\n  private startPing(): void {\r\n    this.stopPing();\r\n\r\n    this.pingInterval = setInterval(() => {\r\n      if (this.ws !== null && this.ws.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ op: 'ping' }));\r\n      }\r\n    }, PING_INTERVAL_MS);\r\n  }\r\n\r\n  /**\r\n   * Stop ping interval\r\n   */\r\n  private stopPing(): void {\r\n    if (this.pingInterval !== null) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\retest-entry.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":37,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":37,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":56,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":56,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":137,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":55},{"ruleId":"complexity","severity":1,"message":"Method 'checkRetest' has a complexity of 13. Maximum allowed is 10.","line":146,"column":14,"nodeType":"FunctionExpression","messageId":"complex","endLine":242,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":156,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":156,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5096,5101],"text":"zone == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":164,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'volumeThreshold' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":188,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":201,"column":25,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":201,"endColumn":50,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[6703,6709],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":209,"column":96,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":209,"endColumn":121,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[6991,6997],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":214,"column":29,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":214,"endColumn":54,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7157,7163],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":222,"column":72,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":222,"endColumn":97,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7431,7437],"text":"SignalDirection.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":263,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":263,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8497,8501],"text":"zone != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Retest Entry Service\r\n *\r\n * Enter on Fibonacci retest after missing initial impulse.\r\n *\r\n * Problem:\r\n * - Signal generated but price already moved (impulse happened before signal)\r\n * - Example: Price breaks resistance at 10:00, bot generates signal at 10:02 when price already +0.5%\r\n *   ‚Üí Enter late at worse price ‚Üí Often hit SL immediately\r\n *\r\n * Solution:\r\n * - Detect if impulse already happened (>0.5% move in recent candles)\r\n * - Create Fibonacci retest zone (50-61.8% retracement)\r\n * - Wait for price to return to zone\r\n * - Enter on calm retest (low volume + structure intact)\r\n *\r\n * Benefits:\r\n * - Better entry price (closer to impulse start)\r\n * - +10-15% more trades (captures retests)\r\n * - Higher win rate (structured entries)\r\n */\r\n\r\nimport { RetestConfig, RetestZone, Signal, Candle, LoggerService, SignalDirection } from '../types';\r\n\r\nexport class RetestEntryService {\r\n  private retestZones: Map<string, RetestZone> = new Map();\r\n\r\n  constructor(\r\n    private config: RetestConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('RetestEntryService initialized', {\r\n      enabled: config.enabled,\r\n      minImpulse: `${config.minImpulsePercent}%`,\r\n      fibZone: `${config.retestZoneFibStart}%-${config.retestZoneFibEnd}%`,\r\n      maxWait: `${config.maxRetestWaitMs / 1000}s`,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Detect if impulse already happened\r\n   *\r\n   * Looks back at recent candles (last 5) to check for large price move\r\n   */\r\n  detectImpulse(\r\n    symbol: string,\r\n    currentPrice: number,\r\n    candles: Candle[],\r\n  ): { hasImpulse: boolean; impulseStart: number; impulseEnd: number } {\r\n    if (!this.config.enabled) {\r\n      return { hasImpulse: false, impulseStart: 0, impulseEnd: 0 };\r\n    }\r\n\r\n    // Look back 5 candles for impulse\r\n    const lookback = Math.min(5, candles.length);\r\n    if (lookback === 0) {\r\n      return { hasImpulse: false, impulseStart: 0, impulseEnd: 0 };\r\n    }\r\n\r\n    const recentCandles = candles.slice(-lookback);\r\n    const startPrice = recentCandles[0].open;\r\n    const endPrice = currentPrice;\r\n\r\n    const priceChange = Math.abs((endPrice - startPrice) / startPrice) * PERCENT_MULTIPLIER;\r\n\r\n    const hasImpulse = priceChange >= this.config.minImpulsePercent;\r\n\r\n    if (hasImpulse) {\r\n      this.logger.info('üìä Impulse detected!', {\r\n        symbol,\r\n        startPrice: startPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        endPrice: endPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        change: `${priceChange.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n        direction: endPrice > startPrice ? 'UP' : 'DOWN',\r\n        candlesAgo: lookback,\r\n      });\r\n    }\r\n\r\n    return {\r\n      hasImpulse,\r\n      impulseStart: startPrice,\r\n      impulseEnd: endPrice,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Fibonacci retest zone\r\n   *\r\n   * Zone = CONFIDENCE_THRESHOLDS.MODERATE-61.8% retracement of impulse\r\n   */\r\n  createRetestZone(\r\n    symbol: string,\r\n    signal: Signal,\r\n    impulseStart: number,\r\n    impulseEnd: number,\r\n  ): RetestZone {\r\n    const impulseRange = Math.abs(impulseEnd - impulseStart);\r\n\r\n    // Fibonacci levels\r\n    const fibStart = this.config.retestZoneFibStart / PERCENT_MULTIPLIER; // 0.50\r\n    const fibEnd = this.config.retestZoneFibEnd / PERCENT_MULTIPLIER; // 0.618\r\n\r\n    let zoneLow: number;\r\n    let zoneHigh: number;\r\n\r\n    if (signal.direction === SignalDirection.LONG) {\r\n      // LONG: impulse UP, retest DOWN (back to zone)\r\n      zoneLow = impulseEnd - (impulseRange * fibEnd); // 61.8% retrace\r\n      zoneHigh = impulseEnd - (impulseRange * fibStart); // 50% retrace\r\n    } else {\r\n      // SHORT: impulse DOWN, retest UP (back to zone)\r\n      zoneLow = impulseEnd + (impulseRange * fibStart); // 50% retrace\r\n      zoneHigh = impulseEnd + (impulseRange * fibEnd); // 61.8% retrace\r\n    }\r\n\r\n    const zone: RetestZone = {\r\n      symbol,\r\n      direction: signal.direction,\r\n      impulseStart,\r\n      impulseEnd,\r\n      zoneLow,\r\n      zoneHigh,\r\n      createdAt: Date.now(),\r\n      expiresAt: Date.now() + this.config.maxRetestWaitMs,\r\n      originalSignal: signal,\r\n    };\r\n\r\n    this.retestZones.set(symbol, zone);\r\n\r\n    this.logger.info('üéØ Retest zone created', {\r\n      symbol,\r\n      direction: signal.direction,\r\n      impulseRange: `${impulseStart.toFixed(DECIMAL_PLACES.PRICE)} ‚Üí ${impulseEnd.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      zoneRange: `${zoneLow.toFixed(DECIMAL_PLACES.PRICE)} - ${zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      fibLevels: `${this.config.retestZoneFibStart}% - ${this.config.retestZoneFibEnd}%`,\r\n      expiresIn: `${this.config.maxRetestWaitMs / 1000}s`,\r\n    });\r\n\r\n    return zone;\r\n  }\r\n\r\n  /**\r\n   * Check if price in retest zone and conditions met\r\n   */\r\n  checkRetest(\r\n    symbol: string,\r\n    currentPrice: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    ema20: number,\r\n    seniorTFTrend: 'UP' | 'DOWN' | 'NEUTRAL',\r\n  ): { inZone: boolean; shouldEnter: boolean; reason: string } {\r\n    const zone = this.retestZones.get(symbol);\r\n\r\n    if (!zone) {\r\n      return { inZone: false, shouldEnter: false, reason: 'No retest zone' };\r\n    }\r\n\r\n    // Check expiry\r\n    if (Date.now() > zone.expiresAt) {\r\n      this.logger.debug('Retest zone expired', {\r\n        symbol,\r\n        age: `${(Date.now() - zone.createdAt) / 1000}s`,\r\n      });\r\n      this.retestZones.delete(symbol);\r\n      return { inZone: false, shouldEnter: false, reason: 'Retest zone expired' };\r\n    }\r\n\r\n    // Check if price in zone\r\n    const inZone = currentPrice >= zone.zoneLow && currentPrice <= zone.zoneHigh;\r\n\r\n    if (!inZone) {\r\n      return {\r\n        inZone: false,\r\n        shouldEnter: false,\r\n        reason: `Price ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} outside zone [${zone.zoneLow.toFixed(DECIMAL_PLACES.PRICE)}, ${zone.zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}]`,\r\n      };\r\n    }\r\n\r\n    this.logger.debug('Price in retest zone!', {\r\n      symbol,\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      zone: `${zone.zoneLow.toFixed(DECIMAL_PLACES.PRICE)} - ${zone.zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n    });\r\n\r\n    // Check volume (should be calm, not aggressive)\r\n    const volumeThreshold = avgVolume * this.config.volumeMultiplier;\r\n\r\n    if (currentVolume > avgVolume) {\r\n      return {\r\n        inZone: true,\r\n        shouldEnter: false,\r\n        reason: `Volume too high: ${currentVolume.toFixed(0)} > ${avgVolume.toFixed(0)} (aggressive, not calm retest)`,\r\n      };\r\n    }\r\n\r\n    // Check structure (EMA + senior TF)\r\n    if (this.config.requireStructureIntact) {\r\n      // EMA structure\r\n      const emaIntact = zone.direction === 'LONG'\r\n        ? currentPrice > ema20\r\n        : currentPrice < ema20;\r\n\r\n      if (!emaIntact) {\r\n        return {\r\n          inZone: true,\r\n          shouldEnter: false,\r\n          reason: `EMA structure broken: price ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} ${zone.direction === 'LONG' ? '<' : '>'} EMA ${ema20.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n\r\n      // Senior TF alignment\r\n      const seniorAligned = zone.direction === 'LONG'\r\n        ? seniorTFTrend === 'UP'\r\n        : seniorTFTrend === 'DOWN';\r\n\r\n      if (!seniorAligned) {\r\n        return {\r\n          inZone: true,\r\n          shouldEnter: false,\r\n          reason: `Senior TF not aligned: ${seniorTFTrend} (expected ${zone.direction === 'LONG' ? 'UP' : 'DOWN'})`,\r\n        };\r\n      }\r\n    }\r\n\r\n    this.logger.info('‚úÖ Retest entry conditions met!', {\r\n      symbol,\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      zone: `${zone.zoneLow.toFixed(DECIMAL_PLACES.PRICE)} - ${zone.zoneHigh.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n      volume: currentVolume.toFixed(0),\r\n      volumeRatio: (currentVolume / avgVolume).toFixed(DECIMAL_PLACES.PERCENT) + 'x',\r\n      ema20: ema20.toFixed(DECIMAL_PLACES.PRICE),\r\n      seniorTF: seniorTFTrend,\r\n    });\r\n\r\n    return {\r\n      inZone: true,\r\n      shouldEnter: true,\r\n      reason: 'Calm retest with structure intact',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get retest zone\r\n   */\r\n  getRetestZone(symbol: string): RetestZone | undefined {\r\n    return this.retestZones.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Check if retest zone exists\r\n   */\r\n  hasRetestZone(symbol: string): boolean {\r\n    return this.retestZones.has(symbol);\r\n  }\r\n\r\n  /**\r\n   * Clear retest zone\r\n   */\r\n  clearZone(symbol: string): void {\r\n    const zone = this.retestZones.get(symbol);\r\n    if (zone) {\r\n      this.logger.debug('Retest zone cleared', {\r\n        symbol,\r\n        reason: 'Entry executed or zone invalidated',\r\n      });\r\n    }\r\n    this.retestZones.delete(symbol);\r\n  }\r\n\r\n  /**\r\n   * Get all active retest zones\r\n   */\r\n  getAllZones(): RetestZone[] {\r\n    return Array.from(this.retestZones.values());\r\n  }\r\n\r\n  /**\r\n   * Clean expired zones (call periodically)\r\n   */\r\n  cleanExpiredZones(): void {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n\r\n    for (const [symbol, zone] of this.retestZones.entries()) {\r\n      if (now > zone.expiresAt) {\r\n        this.retestZones.delete(symbol);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      this.logger.debug(`Cleaned ${cleaned} expired retest zones`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): RetestConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\risk-based-sizing.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\session-stats.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SessionEntryCondition' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -5.","line":75,"column":79,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":75,"endColumn":81},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":238,"column":12,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":238,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7117,7178],"text":"(this.database.sessions.find((s) => s.sessionId === sessionId) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":238,"column":74,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":238,"endColumn":76,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7179,7181],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":258,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":258,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7727,7734],"text":"(session != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'calculateSummary' has a complexity of 12. Maximum allowed is 10.","line":268,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":348,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":379,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":48},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":379,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":53},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":379,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":379,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":380,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":51},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":380,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":380,"column":59,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":380,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":71},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":380,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":380,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":400,"column":75,"nodeType":"Literal","messageId":"noMagic","endLine":400,"endColumn":76}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Session Statistics Service\r\n *\r\n * Manages persistent session-based trading statistics for performance analysis.\r\n * Tracks all trades with full entry context (indicators, patterns, levels, context)\r\n * and generates comparative analysis across different configurations.\r\n *\r\n * Version: v3.4.0\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport {\r\n  LoggerService,\r\n  Session,\r\n  SessionDatabase,\r\n  SessionTradeRecord,\r\n  SessionEntryCondition,\r\n  SessionSummary,\r\n  StrategyStats,\r\n  DirectionStats,\r\n  SignalDirection,\r\n  ExitType,\r\n  Config,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst DEFAULT_DATA_DIR = './data';\r\nconst SESSION_STATS_FILE = 'session-stats.json';\r\nconst BOT_VERSION = 'v3.4.0';\r\n\r\n// ============================================================================\r\n// SESSION STATS SERVICE\r\n// ============================================================================\r\n\r\nexport class SessionStatsService {\r\n  private readonly logger: LoggerService;\r\n  private readonly dataDir: string;\r\n  private readonly filePath: string;\r\n\r\n  private database: SessionDatabase = { sessions: [] };\r\n  private currentSession: Session | null = null;\r\n\r\n  constructor(logger: LoggerService, dataDir: string = DEFAULT_DATA_DIR) {\r\n    this.logger = logger;\r\n    this.dataDir = dataDir;\r\n    this.filePath = path.join(dataDir, SESSION_STATS_FILE);\r\n\r\n    // Load existing database\r\n    this.load();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // SESSION LIFECYCLE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Start a new trading session\r\n   * @param config - Full bot configuration snapshot\r\n   * @param symbol - Trading symbol (e.g., \"APEXUSDT\")\r\n   * @returns Session ID\r\n   */\r\n  startSession(config: Config, symbol: string): string {\r\n    // Close previous session if exists\r\n    if (this.currentSession !== null) {\r\n      this.logger.warn('Previous session not closed, closing now');\r\n      this.endSession();\r\n    }\r\n\r\n    // Generate session ID\r\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\r\n    const sessionId = `session_${timestamp}`;\r\n\r\n    // Create new session\r\n    this.currentSession = {\r\n      sessionId,\r\n      startTime: new Date().toISOString(),\r\n      endTime: null,\r\n      version: BOT_VERSION,\r\n      symbol,\r\n      config,\r\n      trades: [],\r\n      summary: this.createEmptySummary(),\r\n    };\r\n\r\n    // Add to database\r\n    this.database.sessions.push(this.currentSession);\r\n\r\n    this.logger.info('üìä Trading session started', {\r\n      sessionId,\r\n      symbol,\r\n      version: BOT_VERSION,\r\n    });\r\n\r\n    this.save();\r\n\r\n    return sessionId;\r\n  }\r\n\r\n  /**\r\n   * End current trading session\r\n   */\r\n  endSession(): void {\r\n    if (this.currentSession === null) {\r\n      this.logger.warn('No active session to end');\r\n      return;\r\n    }\r\n\r\n    // Update session end time\r\n    this.currentSession.endTime = new Date().toISOString();\r\n\r\n    // Recalculate summary with all trades\r\n    this.currentSession.summary = this.calculateSummary(this.currentSession.trades);\r\n\r\n    this.logger.info('üìä Trading session ended', {\r\n      sessionId: this.currentSession.sessionId,\r\n      totalTrades: this.currentSession.trades.length,\r\n      winRate: this.currentSession.summary.winRate.toFixed(1) + '%',\r\n      totalPnl: this.currentSession.summary.totalPnl.toFixed(DECIMAL_PLACES.PERCENT),\r\n      duration: this.calculateDuration(this.currentSession.startTime, this.currentSession.endTime),\r\n    });\r\n\r\n    this.save();\r\n    this.currentSession = null;\r\n  }\r\n\r\n  /**\r\n   * Get current active session\r\n   */\r\n  getCurrentSession(): Session | null {\r\n    return this.currentSession;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // TRADE RECORDING\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Record trade entry\r\n   * @param trade - Trade record with entry condition\r\n   */\r\n  recordTradeEntry(trade: SessionTradeRecord): void {\r\n    if (this.currentSession === null) {\r\n      this.logger.error('Cannot record trade - no active session');\r\n      return;\r\n    }\r\n\r\n    // Add trade to current session\r\n    this.currentSession.trades.push(trade);\r\n\r\n    this.logger.debug('üìù Trade entry recorded', {\r\n      sessionId: this.currentSession.sessionId,\r\n      tradeId: trade.tradeId,\r\n      direction: trade.direction,\r\n      strategy: trade.entryCondition.signal.type,\r\n    });\r\n\r\n    // Update summary incrementally\r\n    this.currentSession.summary = this.calculateSummary(this.currentSession.trades);\r\n\r\n    this.save();\r\n  }\r\n\r\n  /**\r\n   * Update trade exit\r\n   * @param tradeId - Trade ID to update\r\n   * @param exitData - Exit data (price, PnL, exitType, etc.)\r\n   */\r\n  updateTradeExit(\r\n    tradeId: string,\r\n    exitData: {\r\n      exitPrice: number;\r\n      pnl: number;\r\n      pnlPercent: number;\r\n      exitType: ExitType;\r\n      tpHitLevels: number[];\r\n      holdingTimeMs: number;\r\n      stopLoss: {\r\n        initial: number;\r\n        final: number;\r\n        movedToBreakeven: boolean;\r\n        trailingActivated: boolean;\r\n      };\r\n    },\r\n  ): void {\r\n    if (this.currentSession === null) {\r\n      this.logger.warn('Cannot update trade - no active session (session may have ended)');\r\n      return;\r\n    }\r\n\r\n    // Find trade by ID\r\n    const trade = this.currentSession.trades.find((t) => t.tradeId === tradeId);\r\n    if (trade === undefined) {\r\n      // GRACEFUL DEGRADATION: Don't error for missing trades (may be restored positions)\r\n      this.logger.warn('Trade not found in session (may be restored position without journalId)', {\r\n        tradeId,\r\n        sessionId: this.currentSession.sessionId,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Update trade exit data\r\n    trade.exitPrice = exitData.exitPrice;\r\n    trade.pnl = exitData.pnl;\r\n    trade.pnlPercent = exitData.pnlPercent;\r\n    trade.exitType = exitData.exitType;\r\n    trade.tpHitLevels = exitData.tpHitLevels;\r\n    trade.holdingTimeMs = exitData.holdingTimeMs;\r\n    trade.stopLoss = exitData.stopLoss;\r\n\r\n    this.logger.debug('üìù Trade exit updated', {\r\n      sessionId: this.currentSession.sessionId,\r\n      tradeId,\r\n      exitType: exitData.exitType,\r\n      pnl: exitData.pnl.toFixed(DECIMAL_PLACES.PERCENT),\r\n    });\r\n\r\n    // Recalculate summary\r\n    this.currentSession.summary = this.calculateSummary(this.currentSession.trades);\r\n\r\n    this.save();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // ANALYSIS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get session by ID\r\n   * @param sessionId - Session ID\r\n   * @returns Session or null if not found\r\n   */\r\n  getSession(sessionId: string): Session | null {\r\n    return this.database.sessions.find((s) => s.sessionId === sessionId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all sessions\r\n   * @returns All sessions sorted by start time (newest first)\r\n   */\r\n  getAllSessions(): Session[] {\r\n    return [...this.database.sessions].sort((a, b) =>\r\n      new Date(b.startTime).getTime() - new Date(a.startTime).getTime(),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get session summary\r\n   * @param sessionId - Session ID\r\n   * @returns Session summary or null if not found\r\n   */\r\n  getSessionSummary(sessionId: string): SessionSummary | null {\r\n    const session = this.getSession(sessionId);\r\n    return session ? session.summary : null;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // SUMMARY CALCULATION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate summary statistics from trades\r\n   */\r\n  private calculateSummary(trades: SessionTradeRecord[]): SessionSummary {\r\n    if (trades.length === 0) {\r\n      return this.createEmptySummary();\r\n    }\r\n\r\n    // Overall statistics\r\n    const wins = trades.filter((t) => t.pnl > 0);\r\n    const losses = trades.filter((t) => t.pnl <= 0);\r\n    const totalPnl = trades.reduce((sum, t) => sum + t.pnl, 0);\r\n    const avgWin = wins.length > 0 ? wins.reduce((sum, t) => sum + t.pnl, 0) / wins.length : 0;\r\n    const avgLoss = losses.length > 0 ? losses.reduce((sum, t) => sum + t.pnl, 0) / losses.length : 0;\r\n    const wlRatio = avgLoss !== 0 ? avgWin / Math.abs(avgLoss) : 0;\r\n\r\n    // Stop-out rate\r\n    const stopOuts = losses.filter((t) => t.exitType === ExitType.STOP_LOSS).length;\r\n    const stopOutRate = losses.length > 0 ? (stopOuts / losses.length) * PERCENT_MULTIPLIER : 0;\r\n\r\n    // Average holding time\r\n    const avgHoldingTimeMs = trades.reduce((sum, t) => sum + t.holdingTimeMs, 0) / trades.length;\r\n\r\n    // By strategy\r\n    const byStrategy: Record<string, StrategyStats> = {};\r\n    for (const trade of trades) {\r\n      const strategyType = trade.entryCondition.signal.type;\r\n      if (byStrategy[strategyType] === undefined) {\r\n        byStrategy[strategyType] = {\r\n          count: 0,\r\n          wins: 0,\r\n          losses: 0,\r\n          winRate: 0,\r\n          totalPnl: 0,\r\n        };\r\n      }\r\n\r\n      byStrategy[strategyType].count++;\r\n      byStrategy[strategyType].totalPnl += trade.pnl;\r\n\r\n      if (trade.pnl > 0) {\r\n        byStrategy[strategyType].wins++;\r\n      } else {\r\n        byStrategy[strategyType].losses++;\r\n      }\r\n    }\r\n\r\n    // Calculate win rates for strategies\r\n    for (const strategyType in byStrategy) {\r\n      const stats = byStrategy[strategyType];\r\n      stats.winRate = (stats.wins / stats.count) * PERCENT_MULTIPLIER;\r\n    }\r\n\r\n    // By direction\r\n    const byDirection: Record<string, DirectionStats> = {};\r\n    for (const direction of [SignalDirection.LONG, SignalDirection.SHORT]) {\r\n      const dirTrades = trades.filter((t) => t.direction === direction);\r\n      const dirWins = dirTrades.filter((t) => t.pnl > 0);\r\n      const dirLosses = dirTrades.filter((t) => t.pnl <= 0);\r\n\r\n      byDirection[direction] = {\r\n        count: dirTrades.length,\r\n        wins: dirWins.length,\r\n        losses: dirLosses.length,\r\n        winRate: dirTrades.length > 0 ? (dirWins.length / dirTrades.length) * PERCENT_MULTIPLIER : 0,\r\n        totalPnl: dirTrades.reduce((sum, t) => sum + t.pnl, 0),\r\n      };\r\n    }\r\n\r\n    return {\r\n      totalTrades: trades.length,\r\n      wins: wins.length,\r\n      losses: losses.length,\r\n      winRate: (wins.length / trades.length) * PERCENT_MULTIPLIER,\r\n      totalPnl,\r\n      avgWin,\r\n      avgLoss,\r\n      wlRatio,\r\n      stopOutRate,\r\n      avgHoldingTimeMs,\r\n      byStrategy,\r\n      byDirection,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create empty summary for new session\r\n   */\r\n  private createEmptySummary(): SessionSummary {\r\n    return {\r\n      totalTrades: 0,\r\n      wins: 0,\r\n      losses: 0,\r\n      winRate: 0,\r\n      totalPnl: 0,\r\n      avgWin: 0,\r\n      avgLoss: 0,\r\n      wlRatio: 0,\r\n      stopOutRate: 0,\r\n      avgHoldingTimeMs: 0,\r\n      byStrategy: {},\r\n      byDirection: {},\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate duration between two timestamps\r\n   */\r\n  private calculateDuration(startTime: string, endTime: string | null): string {\r\n    if (endTime === null) {\r\n      return 'ACTIVE';\r\n    }\r\n\r\n    const durationMs = new Date(endTime).getTime() - new Date(startTime).getTime();\r\n    const hours = Math.floor(durationMs / (1000 * 60 * 60));\r\n    const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));\r\n\r\n    return `${hours}h ${minutes}m`;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PERSISTENCE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Save database to file\r\n   */\r\n  private save(): void {\r\n    try {\r\n      // Ensure data directory exists\r\n      if (!fs.existsSync(this.dataDir)) {\r\n        fs.mkdirSync(this.dataDir, { recursive: true });\r\n      }\r\n\r\n      // Write to file\r\n      fs.writeFileSync(this.filePath, JSON.stringify(this.database, null, 2), 'utf-8');\r\n\r\n      this.logger.debug('Session stats saved', { path: this.filePath });\r\n    } catch (error) {\r\n      this.logger.error('Failed to save session stats', { error: String(error) });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load database from file\r\n   */\r\n  private load(): void {\r\n    try {\r\n      if (!fs.existsSync(this.filePath)) {\r\n        this.logger.info('Session stats file not found, creating new database');\r\n        this.database = { sessions: [] };\r\n        return;\r\n      }\r\n\r\n      const data = fs.readFileSync(this.filePath, 'utf-8');\r\n      this.database = JSON.parse(data) as SessionDatabase;\r\n\r\n      this.logger.info('Session stats loaded', {\r\n        totalSessions: this.database.sessions.length,\r\n        path: this.filePath,\r\n      });\r\n\r\n      // Resume last session if it was not closed\r\n      const lastSession = this.database.sessions[this.database.sessions.length - 1];\r\n      if (lastSession !== undefined && lastSession.endTime === null) {\r\n        this.currentSession = lastSession;\r\n        this.logger.info('Resumed active session', {\r\n          sessionId: lastSession.sessionId,\r\n          startTime: lastSession.startTime,\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to load session stats', { error: String(error) });\r\n      this.database = { sessions: [] };\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\signal-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":45,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":45,"endColumn":34,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1405,1430],"text":"(flatMarketConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1405,1430],"text":"(flatMarketConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":54,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":54,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1735,1767],"text":"(config.adaptiveStopLoss?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1735,1767],"text":"(config.adaptiveStopLoss?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3631,3654],"text":"(this.flatMarketDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":36,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3658,3665],"text":"(candles != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":47,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3669,3676],"text":"(context != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":144,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":144,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4757,4778],"text":"(evaluation.confidence != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4757,4778],"text":"(evaluation.confidence ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4757,4778],"text":"(Boolean(evaluation.confidence))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":144,"column":100,"nodeType":"Literal","messageId":"noMagic","endLine":144,"endColumn":103},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":150,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":150,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5013,5024],"text":"btcAnalysis != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'calculateStopLoss' has a complexity of 17. Maximum allowed is 10.","line":173,"column":20,"nodeType":"FunctionExpression","messageId":"complex","endLine":292,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6363,6391],"text":"(this.adaptiveStopLossService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":42,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6396,6407],"text":"(swingPoints != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":192,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":192,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6396,6425],"text":"(swingPoints ?? liquidityZones)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":57,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6411,6425],"text":"(liquidityZones != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":192,"column":72,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":192,"endColumn":74,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6411,6435],"text":"(liquidityZones ?? levels)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":192,"column":75,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":192,"endColumn":81,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6429,6435],"text":"(levels != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":192,"column":82,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":192,"endColumn":84,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6436,6438],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":192,"column":85,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":192,"endColumn":88,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6439,6442],"text":"(atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6439,6442],"text":"(atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6439,6442],"text":"(Boolean(atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":222,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":222,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7324,7338],"text":"(bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":224,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":224,"endColumn":53,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7377,7423],"text":"((this.config.indicators.bollingerBands?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7377,7423],"text":"((this.config.indicators.bollingerBands?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":226,"column":31,"nodeType":"Literal","messageId":"noMagic","endLine":226,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.95.","line":239,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":239,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.05.","line":240,"column":26,"nodeType":"Literal","messageId":"noMagic","endLine":240,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":264,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":264,"endColumn":44,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[8949,8984],"text":"(this.config.sessionBasedSL?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[8949,8984],"text":"(this.config.sessionBasedSL?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":302,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":302,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10165,10172],"text":"config == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":366,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":366,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12013,12027],"text":"(bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.65.","line":368,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":368,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":369,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":369,"endColumn":53,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12114,12160],"text":"((this.config.indicators.bollingerBands?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12114,12160],"text":"((this.config.indicators.bollingerBands?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 80.","line":374,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":374,"endColumn":34},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 65.","line":381,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":381,"endColumn":41},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (321). Maximum allowed is 300.","line":442,"column":1,"nodeType":null,"messageId":"exceed","endLine":468,"endColumn":1}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Signal Calculator Service\r\n *\r\n * Calculates signal prices:\r\n * - Entry price (current market price)\r\n * - Stop Loss (based on risk management config)\r\n * - Take Profits (multiple levels from config)\r\n *\r\n * Pure calculation logic - no external dependencies except config.\r\n * Extracted from SignalGeneratorService for better testability.\r\n */\r\n\r\nimport {\r\n  Signal,\r\n  SignalType,\r\n  SignalDirection,\r\n  Config,\r\n  LoggerService,\r\n  StrategyEvaluation,\r\n  Candle,\r\n  TradingContext,\r\n  FlatMarketConfig,\r\n  SwingPoint,\r\n  BTCAnalysis,\r\n} from '../types';\r\nimport { SessionDetector } from '../utils/session-detector';\r\nimport { FlatMarketDetector } from '../analyzers/flat-market.detector';\r\nimport { AdaptiveStopLossService } from './adaptive-stop-loss.service';\r\n\r\n// ============================================================================\r\n// SIGNAL CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class SignalCalculator {\r\n  private flatMarketDetector?: FlatMarketDetector;\r\n  private adaptiveStopLossService?: AdaptiveStopLossService;\r\n\r\n  constructor(\r\n    private config: Config,\r\n    private logger: LoggerService,\r\n    flatMarketConfig?: FlatMarketConfig,\r\n  ) {\r\n    // Initialize FlatMarketDetector if config provided\r\n    if (flatMarketConfig?.enabled) {\r\n      this.flatMarketDetector = new FlatMarketDetector(flatMarketConfig, logger);\r\n      this.logger.info('‚úÖ FlatMarketDetector initialized', {\r\n        threshold: flatMarketConfig.flatThreshold,\r\n        factors: 6,\r\n      });\r\n    }\r\n\r\n    // Initialize AdaptiveStopLossService if enabled\r\n    if (config.adaptiveStopLoss?.enabled) {\r\n      this.adaptiveStopLossService = new AdaptiveStopLossService(\r\n        config.adaptiveStopLoss,\r\n        logger,\r\n      );\r\n      this.logger.info('‚úÖ AdaptiveStopLossService initialized');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create Signal object from strategy evaluation\r\n   *\r\n   * @param evaluation - Strategy evaluation result\r\n   * @param currentPrice - Current market price\r\n   * @param btcAnalysis - Optional BTC analysis data\r\n   * @param marketBias - Market bias (BULLISH/BEARISH/NEUTRAL) for flat detection (legacy)\r\n   * @param candles - Optional candles array for advanced flat detection\r\n   * @param context - Optional trading context for advanced flat detection\r\n   * @param ema20 - Optional EMA20 value for advanced flat detection\r\n   * @param ema50 - Optional EMA50 value for advanced flat detection\r\n   * @param bollingerBands - Optional Bollinger Bands data for dynamic SL/TP\r\n   * @param atr - Optional ATR value for BB-based SL calculation\r\n   * @returns Complete Signal object\r\n   */\r\n  createSignal(\r\n    evaluation: StrategyEvaluation,\r\n    currentPrice: number,\r\n    btcAnalysis?: BTCAnalysis,\r\n    marketBias?: string,\r\n    candles?: Candle[],\r\n    context?: TradingContext,\r\n    ema20?: number,\r\n    ema50?: number,\r\n    bollingerBands?: {\r\n      upper: number;\r\n      middle: number;\r\n      lower: number;\r\n      width: number;\r\n      percentB: number;\r\n      isSqueeze: boolean;\r\n    },\r\n    atr?: number,\r\n  ): Signal {\r\n    const direction = evaluation.direction;\r\n\r\n    // Calculate Stop Loss (with BB support)\r\n    const stopLoss = this.calculateStopLoss(direction, currentPrice, bollingerBands, atr);\r\n\r\n    // Calculate Take Profits\r\n    // In FLAT market: use single TP to capture quick profit\r\n    let isFlat = false;\r\n    let flatConfidence = 0;\r\n\r\n    // Try advanced flat detection if FlatMarketDetector is available\r\n    if (this.flatMarketDetector && candles && context && ema20 !== undefined && ema50 !== undefined) {\r\n      const flatResult = this.flatMarketDetector.detect(candles, context, ema20, ema50);\r\n      isFlat = flatResult.isFlat;\r\n      flatConfidence = flatResult.confidence;\r\n\r\n      this.logger.info(\r\n        isFlat ? '‚ö° FLAT market detected (multi-factor)' : 'üìà TRENDING market (multi-factor)',\r\n        {\r\n          confidence: flatConfidence.toFixed(1) + '%',\r\n          isFlat,\r\n          factors: flatResult.explanation,\r\n        },\r\n      );\r\n    } else {\r\n      // Fallback to legacy simple check\r\n      isFlat = marketBias === 'NEUTRAL';\r\n      if (isFlat) {\r\n        this.logger.info('‚ö° FLAT market detected (legacy: marketBias=NEUTRAL)');\r\n      }\r\n    }\r\n\r\n    const takeProfits = this.calculateTakeProfits(\r\n      direction,\r\n      currentPrice,\r\n      isFlat,\r\n      bollingerBands,\r\n      evaluation.confidence,\r\n    );\r\n\r\n    // Create signal\r\n    const signal: Signal = {\r\n      type: SignalType.TREND_FOLLOWING,\r\n      direction,\r\n      price: currentPrice,\r\n      stopLoss,\r\n      takeProfits,\r\n      confidence: evaluation.confidence ? Math.round(evaluation.confidence * PERCENT_MULTIPLIER) : 100,\r\n      reason: evaluation.reason,\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    // Add BTC data if available (entire BTCAnalysis object for complete ML analysis)\r\n    if (btcAnalysis) {\r\n      signal.btcData = btcAnalysis; // Store complete BTCAnalysis object\r\n    }\r\n\r\n    return signal;\r\n  }\r\n\r\n  /**\r\n   * Calculate stop loss price\r\n   *\r\n   * BB.MD DYNAMIC SL:\r\n   * If Bollinger Bands available: SL = bb.lower - (atr √ó 0.5) for LONG\r\n   *                                SL = bb.upper + (atr √ó 0.5) for SHORT\r\n   * This places SL beyond volatility band to avoid noise stop-outs.\r\n   *\r\n   * Fallback: fixed percentage from config\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param currentPrice - Current market price\r\n   * @param bollingerBands - Optional BB data for dynamic SL\r\n   * @param atr - Optional ATR value for BB-based SL\r\n   * @returns Stop loss price\r\n   */\r\n  calculateStopLoss(\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n    bollingerBands?: {\r\n      upper: number;\r\n      middle: number;\r\n      lower: number;\r\n      width: number;\r\n      percentB: number;\r\n      isSqueeze: boolean;\r\n    },\r\n    atr?: number,\r\n    swingPoints?: SwingPoint[],\r\n    liquidityZones?: Array<{ price: number; type: 'BUY_SIDE' | 'SELL_SIDE'; timestamp: number }>,\r\n    levels?: Array<{ price: number; strength: number; touches: number }>,\r\n  ): number {\r\n    const isLong = direction === SignalDirection.LONG;\r\n\r\n    // Priority 1: Adaptive SL (structure-based) - Phase 3\r\n    if (this.adaptiveStopLossService && (swingPoints || liquidityZones || levels || atr)) {\r\n      try {\r\n        const result = this.adaptiveStopLossService.calculateStopLoss(\r\n          currentPrice,\r\n          direction,\r\n          {\r\n            swingPoints,\r\n            liquidityZones,\r\n            supportResistance: levels,\r\n            atr,\r\n          },\r\n          currentPrice,\r\n        );\r\n\r\n        this.logger.info('üéØ Adaptive SL (Phase 3)', {\r\n          type: result.type,\r\n          price: result.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          distance: result.distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n          reason: result.reason,\r\n        });\r\n\r\n        return result.price;\r\n      } catch (error) {\r\n        this.logger.warn('‚ö†Ô∏è Adaptive SL failed, using fallback', { error });\r\n        // Fall through to BB or percentage-based SL\r\n      }\r\n    }\r\n\r\n    // Priority 2: BB.MD - BB-based dynamic SL (if available)\r\n    if (\r\n      bollingerBands &&\r\n      atr !== undefined &&\r\n      this.config.indicators.bollingerBands?.enabled\r\n    ) {\r\n      const atrBuffer = atr * 0.5;\r\n      let bbStopLoss: number;\r\n\r\n      if (isLong) {\r\n        // LONG: SL below lower band\r\n        bbStopLoss = bollingerBands.lower - atrBuffer;\r\n      } else {\r\n        // SHORT: SL above upper band\r\n        bbStopLoss = bollingerBands.upper + atrBuffer;\r\n      }\r\n\r\n      // Ensure SL is reasonable (max 5% from entry per BB.MD)\r\n      const maxStopLoss = isLong\r\n        ? currentPrice * 0.95 // LONG: max 5% below entry\r\n        : currentPrice * 1.05; // SHORT: max 5% above entry\r\n\r\n      const finalStopLoss = isLong\r\n        ? Math.max(bbStopLoss, maxStopLoss) // LONG: pick higher (closer to entry)\r\n        : Math.min(bbStopLoss, maxStopLoss); // SHORT: pick lower (closer to entry)\r\n\r\n      this.logger.info('üéØ BB-based Dynamic SL', {\r\n        direction,\r\n        currentPrice,\r\n        bbBand: isLong ? bollingerBands.lower : bollingerBands.upper,\r\n        atrBuffer: atrBuffer.toFixed(DECIMAL_PLACES.PRICE),\r\n        bbStopLoss: bbStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        maxStopLoss: maxStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        finalStopLoss: finalStopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n        distance: (Math.abs((finalStopLoss - currentPrice) / currentPrice) * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      });\r\n\r\n      return finalStopLoss;\r\n    }\r\n\r\n    // Fallback: Percentage-based SL\r\n    let stopLossPercent = this.config.riskManagement.stopLossPercent;\r\n\r\n    // Apply session-based SL widening if enabled\r\n    if (this.config.sessionBasedSL?.enabled) {\r\n      const currentSession = SessionDetector.getCurrentSession();\r\n      const sessionMultiplier = this.getSessionMultiplier(currentSession);\r\n\r\n      if (sessionMultiplier > 1.0) {\r\n        stopLossPercent *= sessionMultiplier;\r\n\r\n        this.logger.debug('üìç Session-based SL widening applied', {\r\n          session: currentSession,\r\n          multiplier: sessionMultiplier,\r\n          baseSL: this.config.riskManagement.stopLossPercent + '%',\r\n          adjustedSL: stopLossPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        });\r\n      }\r\n    }\r\n\r\n    const stopLoss = isLong\r\n      ? currentPrice * (1 - stopLossPercent / PERCENT_MULTIPLIER)\r\n      : currentPrice * (1 + stopLossPercent / PERCENT_MULTIPLIER);\r\n\r\n    this.logger.debug('Stop Loss calculated (percentage-based)', {\r\n      direction,\r\n      currentPrice,\r\n      stopLossPercent,\r\n      stopLoss,\r\n    });\r\n\r\n    return stopLoss;\r\n  }\r\n\r\n  /**\r\n   * Get session-based SL multiplier\r\n   *\r\n   * @param session - Current trading session\r\n   * @returns SL multiplier for the session\r\n   */\r\n  private getSessionMultiplier(session: string): number {\r\n    const config = this.config.sessionBasedSL;\r\n    if (!config) {\r\n      return 1.0;\r\n    }\r\n\r\n    switch (session) {\r\n    case 'OVERLAP':\r\n      return config.overlapMultiplier;\r\n    case 'LONDON':\r\n      return config.londonMultiplier;\r\n    case 'NY':\r\n      return config.nyMultiplier;\r\n    case 'ASIAN':\r\n      return config.asianMultiplier;\r\n    default:\r\n      return 1.0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate take profit levels\r\n   *\r\n   * BB.MD DYNAMIC TP:\r\n   * If BB available and signal strong:\r\n   *  - Strength >= 80%: Target bb.upper (aggressive)\r\n   *  - Strength >= 65%: Target bb.middle (moderate)\r\n   *  - Strength < 65%: Conservative target (60% to middle)\r\n   *\r\n   * FLAT MARKET OPTIMIZATION:\r\n   * In neutral/flat markets, use single TP to capture quick profit\r\n   * and exit before reversal. Better to take TP1 and breakeven stop\r\n   * than wait for TP2/TP3 that may never hit.\r\n   *\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @param currentPrice - Current market price\r\n   * @param isFlat - Is market in flat/neutral bias\r\n   * @param bollingerBands - Optional BB data for dynamic TP\r\n   * @param signalConfidence - Optional signal confidence (0-1)\r\n   * @returns Array of take profit objects\r\n   */\r\n  calculateTakeProfits(\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n    isFlat: boolean = false,\r\n    bollingerBands?: {\r\n      upper: number;\r\n      middle: number;\r\n      lower: number;\r\n      width: number;\r\n      percentB: number;\r\n      isSqueeze: boolean;\r\n    },\r\n    signalConfidence?: number,\r\n  ): Array<{\r\n    level: number;\r\n    price: number;\r\n    sizePercent: number;\r\n    percent: number;\r\n    hit: boolean;\r\n  }> {\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const tpConfig = this.config.riskManagement.takeProfits;\r\n\r\n    // BB.MD: BB-based dynamic TP (if available and signal strong enough)\r\n    if (\r\n      bollingerBands &&\r\n      signalConfidence !== undefined &&\r\n      signalConfidence >= 0.65 &&\r\n      this.config.indicators.bollingerBands?.enabled\r\n    ) {\r\n      const confidencePercent = signalConfidence * PERCENT_MULTIPLIER;\r\n      let dynamicTP: number;\r\n\r\n      if (confidencePercent >= 80) {\r\n        // Very strong signal: target upper/lower band\r\n        dynamicTP = isLong ? bollingerBands.upper : bollingerBands.lower;\r\n        this.logger.info('üéØ BB Dynamic TP: AGGRESSIVE (target band)', {\r\n          confidence: confidencePercent.toFixed(1) + '%',\r\n          target: dynamicTP.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n      } else if (confidencePercent >= 65) {\r\n        // Medium signal: target middle band\r\n        dynamicTP = bollingerBands.middle;\r\n        this.logger.info('üéØ BB Dynamic TP: MODERATE (target middle)', {\r\n          confidence: confidencePercent.toFixed(1) + '%',\r\n          target: dynamicTP.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n      } else {\r\n        // Should not reach here (confidence < 65)\r\n        dynamicTP = currentPrice;\r\n      }\r\n\r\n      // Calculate TP distance\r\n      const tpDistance = Math.abs((dynamicTP - currentPrice) / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n      // Create TPs: TP1 at BB target, TP2/TP3 scaled from config\r\n      const takeProfits = tpConfig.map((tp, index) => {\r\n        let tpPrice: number;\r\n\r\n        if (index === 0) {\r\n          // TP1: Use BB-based target\r\n          tpPrice = dynamicTP;\r\n        } else {\r\n          // TP2/TP3: Scale from config percentages\r\n          tpPrice = isLong\r\n            ? currentPrice * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n            : currentPrice * (1 - tp.percent / PERCENT_MULTIPLIER);\r\n        }\r\n\r\n        return {\r\n          level: tp.level,\r\n          price: tpPrice,\r\n          sizePercent: tp.sizePercent,\r\n          percent: index === 0 ? tpDistance : tp.percent,\r\n          hit: false,\r\n        };\r\n      });\r\n\r\n      return takeProfits;\r\n    }\r\n\r\n    // FLAT MARKET: Single TP at TP1 price, close 100% position\r\n    if (isFlat) {\r\n      const firstTP = tpConfig[0];\r\n      const takeProfits = [\r\n        {\r\n          level: 1,\r\n          price: isLong\r\n            ? currentPrice * (1 + firstTP.percent / PERCENT_MULTIPLIER)\r\n            : currentPrice * (1 - firstTP.percent / PERCENT_MULTIPLIER),\r\n          sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Close 100% on TP1 in flat\r\n          percent: firstTP.percent,\r\n          hit: false,\r\n        },\r\n      ];\r\n\r\n      this.logger.info('‚ö° FLAT market detected - using single TP for quick profit', {\r\n        direction,\r\n        currentPrice,\r\n        tpPrice: takeProfits[0].price.toFixed(DECIMAL_PLACES.PRICE),\r\n        tpPercent: firstTP.percent,\r\n      });\r\n\r\n      return takeProfits;\r\n    }\r\n\r\n    // TRENDING MARKET: Multiple TPs as configured\r\n    const takeProfits = tpConfig.map((tp) => ({\r\n      level: tp.level,\r\n      price: isLong\r\n        ? currentPrice * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n        : currentPrice * (1 - tp.percent / PERCENT_MULTIPLIER),\r\n      sizePercent: tp.sizePercent,\r\n      percent: tp.percent,\r\n      hit: false,\r\n    }));\r\n\r\n    this.logger.debug('Take Profits calculated', {\r\n      direction,\r\n      currentPrice,\r\n      levels: takeProfits.length,\r\n      takeProfits: takeProfits.map((tp) => `TP${tp.level}: ${tp.price.toFixed(DECIMAL_PLACES.PRICE)}`),\r\n    });\r\n\r\n    return takeProfits;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\smart-breakeven.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":54,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":54,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1836,1844],"text":"(existing != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":90,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":90,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[2800,2806],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":139,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":139,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4191,4197],"text":"(state == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":165,"column":24,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":165,"endColumn":48,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[4956,4962],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":233,"column":27,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":233,"endColumn":51,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[7417,7423],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":263,"column":26,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":263,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8558,8572],"text":"(configOverride != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":263,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":263,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8573,8575],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":270,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":270,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8717,8722],"text":"(state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.","line":274,"column":17,"nodeType":"ConditionalExpression","messageId":"preferNullishOverTernary","endLine":274,"endColumn":78,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8831,8892],"text":"remainingQty ?? position.quantity"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":308,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":308,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9719,9724],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Smart Breakeven Service\r\n *\r\n * Pre-BE mode - only move SL to profit when impulse is confirmed.\r\n *\r\n * Problem:\r\n * - Moving SL to breakeven immediately after TP1 often results in stop-outs on micro-pullbacks\r\n * - Example: Entry 1.2000, TP1 hits at 1.2060, SL moved to 1.2000\r\n *   ‚Üí Price pulls back to 1.1995 ‚Üí Stopped out at breakeven\r\n *   ‚Üí Then price goes to 1.2100 (missed profit!)\r\n *\r\n * Solution:\r\n * - Enter \"Pre-BE mode\" after profit threshold reached (0.3%)\r\n * - Check impulse retention: EMA hold + volume normal\r\n * - Only move SL to +0.1% profit when impulse confirmed\r\n * - If impulse lost (EMA broken + volume spike) ‚Üí move to breakeven immediately\r\n *\r\n * Benefits:\r\n * - Fewer micro-pullback stop-outs\r\n * - Still protects if trend reverses\r\n * - Locks in small profit (+0.1%) instead of breakeven\r\n */\r\n\r\nimport { SmartBreakevenConfig, BreakevenMode, BreakevenState, Position, LoggerService } from '../types';\r\n\r\nexport class SmartBreakevenService {\r\n  private states: Map<string, BreakevenState> = new Map();\r\n\r\n  constructor(\r\n    private config: SmartBreakevenConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('SmartBreakevenService initialized', {\r\n      enabled: config.enabled,\r\n      activationProfit: `${config.activationProfitPercent}%`,\r\n      beProfit: `${config.breakevenProfitPercent}%`,\r\n      requireEMA: config.requireEMAHold,\r\n      requireVolume: config.requireVolumeConfirmation,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate Pre-BE mode when profit threshold reached\r\n   *\r\n   * Called when: profit >= activationProfitPercent (default 0.3%)\r\n   */\r\n  activatePreBE(symbol: string): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    const existing = this.states.get(symbol);\r\n    if (existing && existing.mode !== BreakevenMode.NONE) {\r\n      this.logger.debug('Pre-BE already active or completed', {\r\n        symbol,\r\n        currentMode: existing.mode,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.states.set(symbol, {\r\n      mode: BreakevenMode.PRE_BE,\r\n      activatedAt: Date.now(),\r\n      candlesWaited: 0,\r\n      lastCheckPrice: 0,\r\n    });\r\n\r\n    this.logger.info('‚ö° Pre-Breakeven mode activated', {\r\n      symbol,\r\n      waitingFor: 'impulse confirmation',\r\n      maxCandles: this.config.maxWaitCandles,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if impulse retained\r\n   *\r\n   * Conditions for retained impulse:\r\n   * 1. Price holding above/below EMA (LONG/SHORT)\r\n   * 2. Volume normal (no reverse spike)\r\n   */\r\n  checkImpulseRetention(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n  ): { retained: boolean; reason: string } {\r\n    const isLong = position.side === 'LONG';\r\n\r\n    // 1. Check EMA hold\r\n    if (this.config.requireEMAHold) {\r\n      const emaHolds = isLong\r\n        ? currentPrice > ema20\r\n        : currentPrice < ema20;\r\n\r\n      if (!emaHolds) {\r\n        return {\r\n          retained: false,\r\n          reason: `Price broke EMA(${this.config.emaPeriod}): ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} ${isLong ? '<' : '>'} ${ema20.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 2. Check volume (no reversal spike)\r\n    if (this.config.requireVolumeConfirmation) {\r\n      const volumeThreshold = avgVolume * this.config.volumeReverseMultiplier;\r\n\r\n      if (currentVolume > volumeThreshold) {\r\n        return {\r\n          retained: false,\r\n          reason: `Volume spike detected: ${currentVolume.toFixed(0)} > ${volumeThreshold.toFixed(0)} (reversal signal)`,\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      retained: true,\r\n      reason: 'Impulse confirmed: EMA hold + volume normal',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update breakeven state on candle close\r\n   *\r\n   * Called every candle close while in Pre-BE mode\r\n   */\r\n  async updateBreakeven(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    updateStopLossFn: (newSL: number) => Promise<void>,\r\n  ): Promise<void> {\r\n    const state = this.states.get(position.symbol);\r\n\r\n    if (!state || state.mode !== BreakevenMode.PRE_BE) {\r\n      return; // Not in Pre-BE mode\r\n    }\r\n\r\n    state.candlesWaited++;\r\n    state.lastCheckPrice = currentPrice;\r\n\r\n    this.logger.debug('Checking impulse retention...', {\r\n      symbol: position.symbol,\r\n      candlesWaited: state.candlesWaited,\r\n      maxCandles: this.config.maxWaitCandles,\r\n      price: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      ema20: ema20.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    // Check impulse\r\n    const impulse = this.checkImpulseRetention(\r\n      position,\r\n      currentPrice,\r\n      ema20,\r\n      currentVolume,\r\n      avgVolume,\r\n    );\r\n\r\n    if (impulse.retained) {\r\n      // Impulse confirmed - move SL to +0.1% profit\r\n      const profitSL = position.side === 'LONG'\r\n        ? position.entryPrice * (1 + this.config.breakevenProfitPercent / PERCENT_MULTIPLIER)\r\n        : position.entryPrice * (1 - this.config.breakevenProfitPercent / PERCENT_MULTIPLIER);\r\n\r\n      await updateStopLossFn(profitSL);\r\n\r\n      state.mode = BreakevenMode.BE_ACTIVE;\r\n\r\n      this.logger.info('‚úÖ Smart Breakeven activated!', {\r\n        symbol: position.symbol,\r\n        newSL: profitSL.toFixed(DECIMAL_PLACES.PRICE),\r\n        profit: `+${this.config.breakevenProfitPercent}%`,\r\n        candlesWaited: state.candlesWaited,\r\n        reason: impulse.reason,\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // Impulse lost - move to breakeven immediately\r\n    this.logger.warn('‚ö†Ô∏è Impulse lost - moving to breakeven', {\r\n      symbol: position.symbol,\r\n      reason: impulse.reason,\r\n      candlesWaited: state.candlesWaited,\r\n    });\r\n\r\n    await updateStopLossFn(position.entryPrice);\r\n    state.mode = BreakevenMode.BE_ACTIVE;\r\n\r\n    this.logger.info('üìç SL moved to breakeven (impulse lost)', {\r\n      symbol: position.symbol,\r\n      newSL: position.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    // Check timeout\r\n    if (state.candlesWaited >= this.config.maxWaitCandles) {\r\n      this.logger.warn('‚è±Ô∏è Pre-BE timeout reached', {\r\n        symbol: position.symbol,\r\n        candlesWaited: state.candlesWaited,\r\n        maxCandles: this.config.maxWaitCandles,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate current profit percent including realized PnL from partial closes\r\n   *\r\n   * FIX: This now accounts for partial TP closes (TP1, TP2) which were previously ignored\r\n   *\r\n   * Example (SHORT):\r\n   * - Entry: 0.8108, Qty: 100\r\n   * - TP1 @ 0.8059: Close 50 units ‚Üí +2.97 USDT realized\r\n   * - Current price: 0.8054, Remaining: 50 units ‚Üí -0.27 USDT unrealized\r\n   * - OLD: profit = -0.27 / (0.8108 * PERCENT_MULTIPLIER) = -0.33% ‚ùå (ignores TP1!)\r\n   * - NEW: profit = (2.97 - 0.27) / (0.8108 * PERCENT_MULTIPLIER) = +3.33% ‚úÖ (includes TP1)\r\n   *\r\n   * @param position Current position\r\n   * @param currentPrice Current market price\r\n   * @param realizedPnL Total PnL from partial closes (from TakeProfitManager)\r\n   * @param remainingQty Remaining position quantity\r\n   */\r\n  private calculateProfitPercent(\r\n    position: Position,\r\n    currentPrice: number,\r\n    realizedPnL: number,\r\n    remainingQty: number,\r\n  ): number {\r\n    // Calculate unrealized PnL for remaining position\r\n    const pnlMultiplier = position.side === 'LONG' ? 1 : -1;\r\n    const priceDiff = currentPrice - position.entryPrice;\r\n    const unrealizedPnL = priceDiff * remainingQty * pnlMultiplier * position.leverage;\r\n\r\n    // Total PnL = realized (from closed TPs) + unrealized (from remaining qty)\r\n    const totalPnL = realizedPnL + unrealizedPnL;\r\n\r\n    // Calculate profit percent based on initial position value\r\n    const initialValue = position.entryPrice * position.quantity;\r\n    const profitPercent = (totalPnL / initialValue) * PERCENT_MULTIPLIER;\r\n\r\n    return profitPercent;\r\n  }\r\n\r\n  /**\r\n   * Check if should activate Pre-BE mode\r\n   *\r\n   * @param position Current position\r\n   * @param currentPrice Current market price\r\n   * @param realizedPnL Total PnL from partial closes (default: 0)\r\n   * @param remainingQty Remaining position quantity (default: full position)\r\n   * @param configOverride Optional strategy-specific config (overrides this.config)\r\n   */\r\n  shouldActivate(\r\n    position: Position,\r\n    currentPrice: number,\r\n    realizedPnL: number = 0,\r\n    remainingQty?: number,\r\n    configOverride?: SmartBreakevenConfig,\r\n  ): boolean {\r\n    const activeConfig = configOverride || this.config;\r\n\r\n    if (!activeConfig.enabled) {\r\n      return false;\r\n    }\r\n\r\n    const state = this.states.get(position.symbol);\r\n    if (state && state.mode !== BreakevenMode.NONE) {\r\n      return false; // Already activated\r\n    }\r\n\r\n    const qty = remainingQty !== undefined ? remainingQty : position.quantity;\r\n    const profitPercent = this.calculateProfitPercent(position, currentPrice, realizedPnL, qty);\r\n\r\n    return profitPercent >= activeConfig.activationProfitPercent;\r\n  }\r\n\r\n  /**\r\n   * Get breakeven state\r\n   */\r\n  getState(symbol: string): BreakevenState | undefined {\r\n    return this.states.get(symbol);\r\n  }\r\n\r\n  /**\r\n   * Check if in Pre-BE mode\r\n   */\r\n  isInPreBEMode(symbol: string): boolean {\r\n    const state = this.states.get(symbol);\r\n    return state?.mode === BreakevenMode.PRE_BE;\r\n  }\r\n\r\n  /**\r\n   * Check if BE active\r\n   */\r\n  isBEActive(symbol: string): boolean {\r\n    const state = this.states.get(symbol);\r\n    return state?.mode === BreakevenMode.BE_ACTIVE;\r\n  }\r\n\r\n  /**\r\n   * Reset state (position closed)\r\n   */\r\n  reset(symbol: string): void {\r\n    const state = this.states.get(symbol);\r\n    if (state) {\r\n      this.logger.debug('Resetting breakeven state', {\r\n        symbol,\r\n        finalMode: state.mode,\r\n        candlesWaited: state.candlesWaited,\r\n      });\r\n    }\r\n    this.states.delete(symbol);\r\n  }\r\n\r\n  /**\r\n   * Get all states (for monitoring)\r\n   */\r\n  getAllStates(): Map<string, BreakevenState> {\r\n    return new Map(this.states);\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): SmartBreakevenConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\smart-trailing-v2.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":62,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":62,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2018,2026],"text":"(existing != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'checkImpulseActivation' has a complexity of 13. Maximum allowed is 10.","line":88,"column":25,"nodeType":"FunctionExpression","messageId":"complex","endLine":154,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":102,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":102,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3200,3208],"text":"(existing != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":106,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":106,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[3345,3351],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.2.","line":131,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":131,"endColumn":28},{"ruleId":"complexity","severity":1,"message":"Method 'calculateTrailingStop' has a complexity of 13. Maximum allowed is 10.","line":179,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":225,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":186,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":186,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5921,5927],"text":"(state == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":190,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":190,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[6015,6021],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":248,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":248,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7820,7825],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":273,"column":20,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":273,"endColumn":44,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[8636,8642],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":290,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":290,"endColumn":25,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[9231,9244],"text":"((state?.active) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[9231,9244],"text":"((state?.active) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":290,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":290,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9245,9247],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":305,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":305,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9554,9559],"text":"state != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Smart Trailing Stop Service v2 (Phase 3)\r\n *\r\n * Impulse-based trailing stop that activates BEFORE TP2.\r\n * Old behavior: Wait for TP2 ‚Üí then start trailing\r\n * New behavior: Detect impulse ‚Üí start trailing immediately\r\n *\r\n * Why v2 is better:\r\n * - Captures more profit on strong impulses (don't wait for TP2)\r\n * - Activates on TP2 hit (legacy mode still works)\r\n * - Reduces \"give back\" scenarios (profit ‚Üí reversal ‚Üí SL)\r\n *\r\n * Example:\r\n * Entry: 1.2000, current: 1.2085 (+0.7% profit)\r\n * - EMA hold: price > EMA20 ‚úÖ\r\n * - Strong volume: 1.8x avg ‚úÖ\r\n * - Result: Activate trailing @ 1.2083 (0.15% below) ‚úÖ\r\n * - Why: Impulse detected, protect profit early\r\n */\r\n\r\nimport {\r\n  SmartTrailingConfig,\r\n  TrailingState,\r\n  Position,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// SMART TRAILING V2 SERVICE\r\n// ============================================================================\r\n\r\nexport class SmartTrailingV2Service {\r\n  private states: Map<string, TrailingState> = new Map();\r\n\r\n  constructor(\r\n    private config: SmartTrailingConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('SmartTrailingV2Service initialized', {\r\n      enabled: config.enabled,\r\n      activateOnTP2: config.activateOnTP2,\r\n      activateOnImpulse: config.activateOnImpulse,\r\n      trailingMode: config.trailingMode,\r\n      impulseThreshold: config.impulseThreshold.minProfitPercent + '%',\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Activate trailing stop (called on TP2 hit - legacy mode)\r\n   */\r\n  activateOnTP2(positionId: string): void {\r\n    if (!this.config.enabled || !this.config.activateOnTP2) {\r\n      return;\r\n    }\r\n\r\n    const existing = this.states.get(positionId);\r\n    if (existing && existing.active) {\r\n      this.logger.debug('Trailing already active', { positionId });\r\n      return;\r\n    }\r\n\r\n    this.states.set(positionId, {\r\n      active: true,\r\n      activatedBy: 'TP2',\r\n      activatedAt: Date.now(),\r\n      lastUpdatePrice: 0,\r\n      lastStopLoss: 0,\r\n      updateCount: 0,\r\n    });\r\n\r\n    this.logger.info('‚úÖ Trailing activated on TP2', { positionId });\r\n  }\r\n\r\n  /**\r\n   * Check if should activate on impulse (NEW in v2)\r\n   *\r\n   * Conditions:\r\n   * 1. Current profit >= minProfitPercent (e.g., 0.7%)\r\n   * 2. Price holding above/below EMA (LONG/SHORT)\r\n   * 3. Volume elevated (confirming impulse)\r\n   * 4. EMA angle steep enough (momentum)\r\n   */\r\n  checkImpulseActivation(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    currentVolume: number,\r\n    avgVolume: number,\r\n    emaAngle: number, // EMA slope in degrees\r\n  ): { shouldActivate: boolean; reason: string } {\r\n    if (!this.config.enabled || !this.config.activateOnImpulse) {\r\n      return { shouldActivate: false, reason: 'Impulse activation disabled' };\r\n    }\r\n\r\n    // Already active?\r\n    const existing = this.states.get(position.id);\r\n    if (existing && existing.active) {\r\n      return { shouldActivate: false, reason: 'Already active' };\r\n    }\r\n\r\n    const isLong = position.side === 'LONG';\r\n\r\n    // 1. Check profit threshold\r\n    const profitPercent = this.calculateProfitPercent(position, currentPrice);\r\n    if (profitPercent < this.config.impulseThreshold.minProfitPercent) {\r\n      return {\r\n        shouldActivate: false,\r\n        reason: `Profit too low: ${profitPercent.toFixed(DECIMAL_PLACES.PERCENT)}% < ${this.config.impulseThreshold.minProfitPercent}%`,\r\n      };\r\n    }\r\n\r\n    // 2. Check EMA hold\r\n    if (this.config.impulseThreshold.requireEMAHold) {\r\n      const emaHolds = isLong ? currentPrice > ema20 : currentPrice < ema20;\r\n      if (!emaHolds) {\r\n        return {\r\n          shouldActivate: false,\r\n          reason: `Price broke EMA: ${currentPrice.toFixed(DECIMAL_PLACES.PRICE)} ${isLong ? '<=' : '>='} ${ema20.toFixed(DECIMAL_PLACES.PRICE)}`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 3. Check volume\r\n    if (this.config.impulseThreshold.requireVolume) {\r\n      const volumeRatio = currentVolume / avgVolume;\r\n      if (volumeRatio < 1.2) {\r\n        // Volume not elevated\r\n        return {\r\n          shouldActivate: false,\r\n          reason: `Volume too low: ${volumeRatio.toFixed(DECIMAL_PLACES.PERCENT)}x`,\r\n        };\r\n      }\r\n    }\r\n\r\n    // 4. Check EMA angle\r\n    const absAngle = Math.abs(emaAngle);\r\n    if (absAngle < this.config.impulseThreshold.emaAngleThreshold) {\r\n      return {\r\n        shouldActivate: false,\r\n        reason: `EMA angle too flat: ${absAngle.toFixed(DECIMAL_PLACES.PERCENT)}¬∞ < ${this.config.impulseThreshold.emaAngleThreshold}¬∞`,\r\n      };\r\n    }\r\n\r\n    // All checks passed - activate!\r\n    return {\r\n      shouldActivate: true,\r\n      reason: `Impulse detected: +${profitPercent.toFixed(DECIMAL_PLACES.PERCENT)}% profit, EMA hold, ${(currentVolume / avgVolume).toFixed(DECIMAL_PLACES.PERCENT)}x volume`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Activate trailing on impulse\r\n   */\r\n  activateOnImpulse(positionId: string, reason: string): void {\r\n    this.states.set(positionId, {\r\n      active: true,\r\n      activatedBy: 'IMPULSE',\r\n      activatedAt: Date.now(),\r\n      lastUpdatePrice: 0,\r\n      lastStopLoss: 0,\r\n      updateCount: 0,\r\n    });\r\n\r\n    this.logger.info('üöÄ Trailing activated on IMPULSE', { positionId, reason });\r\n  }\r\n\r\n  /**\r\n   * Calculate trailing stop price\r\n   *\r\n   * Two modes:\r\n   * 1. EMA mode: SL = EMA20 - emaDistance%\r\n   * 2. ATR mode: SL = current - (ATR * atrMultiplier)\r\n   */\r\n  calculateTrailingStop(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    atr: number,\r\n  ): number | null {\r\n    const state = this.states.get(position.id);\r\n    if (!state || !state.active) {\r\n      return null;\r\n    }\r\n\r\n    const isLong = position.side === 'LONG';\r\n    let trailingSL: number;\r\n\r\n    if (this.config.trailingMode === 'EMA') {\r\n      // EMA-based trailing\r\n      const distance = ema20 * (this.config.emaDistance / PERCENT_MULTIPLIER);\r\n      trailingSL = isLong ? ema20 - distance : ema20 + distance;\r\n    } else {\r\n      // ATR-based trailing\r\n      const distance = atr * this.config.atrMultiplier;\r\n      trailingSL = isLong ? currentPrice - distance : currentPrice + distance;\r\n    }\r\n\r\n    // Ensure minimum distance from current price\r\n    const minDistance = currentPrice * (this.config.minDistancePercent / PERCENT_MULTIPLIER);\r\n    const actualDistance = Math.abs(currentPrice - trailingSL);\r\n\r\n    if (actualDistance < minDistance) {\r\n      // Too tight, adjust\r\n      trailingSL = isLong\r\n        ? currentPrice - minDistance\r\n        : currentPrice + minDistance;\r\n    }\r\n\r\n    // Only move SL in favorable direction (never widen)\r\n    if (state.lastStopLoss > 0) {\r\n      if (isLong && trailingSL <= state.lastStopLoss) {\r\n        return null; // Don't lower SL for LONG\r\n      }\r\n      if (!isLong && trailingSL >= state.lastStopLoss) {\r\n        return null; // Don't raise SL for SHORT\r\n      }\r\n    }\r\n\r\n    return trailingSL;\r\n  }\r\n\r\n  /**\r\n   * Update trailing stop (call this periodically or on candle close)\r\n   */\r\n  async updateTrailingStop(\r\n    position: Position,\r\n    currentPrice: number,\r\n    ema20: number,\r\n    atr: number,\r\n    updateStopLossFn: (newSL: number) => Promise<void>,\r\n  ): Promise<boolean> {\r\n    const newSL = this.calculateTrailingStop(position, currentPrice, ema20, atr);\r\n\r\n    if (newSL === null) {\r\n      return false; // No update needed\r\n    }\r\n\r\n    // Update SL on exchange\r\n    await updateStopLossFn(newSL);\r\n\r\n    // Update state\r\n    const state = this.states.get(position.id);\r\n    if (state) {\r\n      state.lastUpdatePrice = currentPrice;\r\n      state.lastStopLoss = newSL;\r\n      state.updateCount++;\r\n\r\n      this.logger.info('üìà Trailing SL updated', {\r\n        positionId: position.id,\r\n        newSL: newSL.toFixed(DECIMAL_PLACES.PRICE),\r\n        currentPrice: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        mode: this.config.trailingMode,\r\n        updateCount: state.updateCount,\r\n      });\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE: HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate current profit percent\r\n   */\r\n  private calculateProfitPercent(position: Position, currentPrice: number): number {\r\n    const isLong = position.side === 'LONG';\r\n    if (isLong) {\r\n      return ((currentPrice - position.entryPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    } else {\r\n      return ((position.entryPrice - currentPrice) / position.entryPrice) * PERCENT_MULTIPLIER;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC: STATE MANAGEMENT\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Check if trailing is active\r\n   */\r\n  isActive(positionId: string): boolean {\r\n    const state = this.states.get(positionId);\r\n    return state?.active || false;\r\n  }\r\n\r\n  /**\r\n   * Get trailing state\r\n   */\r\n  getState(positionId: string): TrailingState | undefined {\r\n    return this.states.get(positionId);\r\n  }\r\n\r\n  /**\r\n   * Reset state (position closed)\r\n   */\r\n  reset(positionId: string): void {\r\n    const state = this.states.get(positionId);\r\n    if (state) {\r\n      this.logger.debug('Resetting trailing state', {\r\n        positionId,\r\n        activatedBy: state.activatedBy,\r\n        updateCount: state.updateCount,\r\n      });\r\n    }\r\n    this.states.delete(positionId);\r\n  }\r\n\r\n  /**\r\n   * Get config\r\n   */\r\n  getConfig(): SmartTrailingConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\strategy-coordinator.service.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Async method 'evaluateStrategies' has a complexity of 15. Maximum allowed is 10.","line":80,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":146,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":118,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":118,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4288,4301],"text":"(result.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":128,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":128,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4725,4738],"text":"(result.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS } from '../constants';\r\n/**\r\n * Strategy Coordinator Service\r\n *\r\n * Coordinates multiple trading strategies using priority-based selection.\r\n * Implements \"FIRST VALID WINS\" logic - returns the first strategy that produces a valid signal.\r\n *\r\n * Strategy Priority Order:\r\n * 1. Trend-Following Strategy (Priority 1 - Highest)\r\n * 2. Level-Based Strategy (Priority 2)\r\n * 3. Counter-Trend Strategy (Priority 3)\r\n * 4. Reversal-Pattern Strategy (Priority 4 - Experimental)\r\n */\r\n\r\nimport { IStrategy, StrategyMarketData, StrategySignal, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_CONFIDENCE_THRESHOLD = MULTIPLIERS.HALF;\r\n\r\n// ============================================================================\r\n// STRATEGY COORDINATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class StrategyCoordinator {\r\n  private strategies: IStrategy[] = [];\r\n\r\n  constructor(private logger: LoggerService) {}\r\n\r\n  /**\r\n   * Register a strategy\r\n   * Strategies are automatically sorted by priority (lowest number = highest priority)\r\n   */\r\n  registerStrategy(strategy: IStrategy): void {\r\n    this.strategies.push(strategy);\r\n    // Sort by priority (ascending - lower number = higher priority)\r\n    this.strategies.sort((a, b) => a.priority - b.priority);\r\n    this.logger.info(`Strategy registered: ${strategy.name} (priority ${strategy.priority})`);\r\n  }\r\n\r\n  /**\r\n   * Unregister a strategy by name\r\n   */\r\n  unregisterStrategy(strategyName: string): boolean {\r\n    const initialLength = this.strategies.length;\r\n    this.strategies = this.strategies.filter((s) => s.name !== strategyName);\r\n    const removed = this.strategies.length < initialLength;\r\n    if (removed) {\r\n      this.logger.info(`Strategy unregistered: ${strategyName}`);\r\n    }\r\n    return removed;\r\n  }\r\n\r\n  /**\r\n   * Get all registered strategies (sorted by priority)\r\n   */\r\n  getStrategies(): IStrategy[] {\r\n    return [...this.strategies];\r\n  }\r\n\r\n  /**\r\n   * Clear all strategies\r\n   */\r\n  clearStrategies(): void {\r\n    this.strategies = [];\r\n    this.logger.info('All strategies cleared');\r\n  }\r\n\r\n  /**\r\n   * Evaluate all strategies and return the first valid signal\r\n   * FIRST VALID WINS logic - stops at the first strategy that produces a valid signal\r\n   *\r\n   * @param marketData - Market data to evaluate\r\n   * @param minConfidence - Minimum confidence threshold (default: MULTIPLIERS.HALF)\r\n   * @param excludeRealtimeStrategies - If true, excludes real-time strategies (WHALE_HUNTER, WHALE_HUNTER_FOLLOW)\r\n   * @returns Strategy signal or null if no valid signals\r\n   */\r\n  async evaluateStrategies(\r\n    marketData: StrategyMarketData,\r\n    minConfidence: number = MIN_CONFIDENCE_THRESHOLD,\r\n    excludeRealtimeStrategies: boolean = true,\r\n  ): Promise<StrategySignal | null> {\r\n    if (this.strategies.length === 0) {\r\n      this.logger.warn('No strategies registered');\r\n      return null;\r\n    }\r\n\r\n    // Filter out real-time strategies (they work on orderbook updates, not candle close)\r\n    const strategiesToEvaluate = excludeRealtimeStrategies\r\n      ? this.strategies.filter(s => s.name !== 'WHALE_HUNTER' && s.name !== 'WHALE_HUNTER_FOLLOW')\r\n      : this.strategies;\r\n\r\n    if (strategiesToEvaluate.length === 0) {\r\n      this.logger.warn('No strategies to evaluate (all filtered out)');\r\n      return null;\r\n    }\r\n\r\n    this.logger.debug(`Evaluating ${strategiesToEvaluate.length} strategies`, {\r\n      timestamp: marketData.timestamp,\r\n      price: marketData.currentPrice,\r\n      excluded: excludeRealtimeStrategies ? 'WHALE_HUNTER' : 'none',\r\n    });\r\n\r\n    // FIRST VALID WINS - iterate by priority\r\n    for (const strategy of strategiesToEvaluate) {\r\n      try {\r\n        const result = await strategy.evaluate(marketData);\r\n\r\n        this.logger.debug(`Strategy ${strategy.name} evaluated`, {\r\n          valid: result.valid,\r\n          confidence: result.signal?.confidence,\r\n          reason: result.reason,\r\n        });\r\n\r\n        // Check if signal is valid and meets confidence threshold\r\n        if (result.valid && result.signal && result.signal.confidence >= minConfidence) {\r\n          this.logger.info(`‚úÖ Strategy signal accepted: ${strategy.name}`, {\r\n            direction: result.signal.direction,\r\n            confidence: result.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n            priority: strategy.priority,\r\n          });\r\n          return result;\r\n        }\r\n\r\n        // Log why signal was rejected\r\n        if (result.valid && result.signal && result.signal.confidence < minConfidence) {\r\n          this.logger.debug(`Strategy ${strategy.name} rejected: confidence too low`, {\r\n            confidence: result.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n            minRequired: minConfidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n          });\r\n        }\r\n      } catch (error) {\r\n        this.logger.error(`Strategy ${strategy.name} evaluation failed`, {\r\n          error: error instanceof Error ? error.message : String(error),\r\n          stack: error instanceof Error ? error.stack : undefined,\r\n        });\r\n        // Continue to next strategy on error\r\n      }\r\n    }\r\n\r\n    // No valid signals found\r\n    this.logger.debug('No valid signals from any strategy');\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get strategy count\r\n   */\r\n  getStrategyCount(): number {\r\n    return this.strategies.length;\r\n  }\r\n\r\n  /**\r\n   * Check if a strategy is registered\r\n   */\r\n  hasStrategy(strategyName: string): boolean {\r\n    return this.strategies.some((s) => s.name === strategyName);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\take-profit-manager.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\telegram.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":23,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":23,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[667,682],"text":"(config.botToken != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[667,682],"text":"(config.botToken ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[667,682],"text":"(Boolean(config.botToken))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":23,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":23,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[683,685],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":24,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":24,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[711,724],"text":"(config.chatId != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[711,724],"text":"(config.chatId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[711,724],"text":"(Boolean(config.chatId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":24,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":24,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[725,727],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":40,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":25,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[773,787],"text":"(this.botToken == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[774,787],"text":"(this.botToken ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[773,787],"text":"(!Boolean(this.botToken))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":59,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":25,"endColumn":70,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[792,804],"text":"(this.chatId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[793,804],"text":"(this.chatId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[792,804],"text":"(!Boolean(this.chatId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":42,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":42,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1217,1231],"text":"(this.botToken == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1218,1231],"text":"(this.botToken ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1217,1231],"text":"(!Boolean(this.botToken))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":42,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":42,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1235,1247],"text":"(this.chatId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1236,1247],"text":"(this.chatId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1235,1247],"text":"(!Boolean(this.chatId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":98,"column":3,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":98,"endColumn":9,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2623,2629],"text":"(reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2623,2629],"text":"(reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2623,2629],"text":"(Boolean(reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":130,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":130,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3674,3691],"text":"(position.strategy != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3674,3691],"text":"(position.strategy ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3674,3691],"text":"(Boolean(position.strategy))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":130,"column":34,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":130,"endColumn":36,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3692,3694],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":131,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":131,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3729,3748],"text":"(position.confidence != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3729,3748],"text":"(position.confidence ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3729,3748],"text":"(Boolean(position.confidence))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":131,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":131,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3749,3751],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":132,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":132,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[3804,3819],"text":"(position.reason.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[3804,3819],"text":"(position.reason !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3804,3819],"text":"(Boolean(position.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'notifyPositionClosed' has a complexity of 11. Maximum allowed is 10.","line":141,"column":29,"nodeType":"FunctionExpression","messageId":"complex","endLine":188,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":164,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":164,"endColumn":59},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":165,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":165,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":168,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":168,"endColumn":52},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'notifyTrailingUpdated' has no 'await' expression.","line":266,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":266,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Async method 'sendTradeNotification' has a complexity of 14. Maximum allowed is 10.","line":280,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":335,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":301,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":301,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8934,8949],"text":"params.stopLoss != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8934,8949],"text":"params.stopLoss ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8934,8949],"text":"Boolean(params.stopLoss)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":304,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":304,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9063,9081],"text":"(params.takeProfits != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":310,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":310,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9347,9364],"text":"params.confidence != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9347,9364],"text":"params.confidence ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9347,9364],"text":"Boolean(params.confidence)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":313,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":313,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9484,9497],"text":"params.reason != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[9484,9497],"text":"params.reason ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9484,9497],"text":"Boolean(params.reason)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":326,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":326,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10007,10020],"text":"params.reason != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[10007,10020],"text":"params.reason ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10007,10020],"text":"Boolean(params.reason)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Telegram Notification Service\r\n * Sends trading event notifications to Telegram\r\n */\r\n\r\nimport { Position, SignalDirection, PositionSide, LoggerService } from '../types';\r\n\r\nexport interface TelegramConfig {\r\n  botToken?: string;\r\n  chatId?: string;\r\n  enabled: boolean;\r\n}\r\n\r\nexport class TelegramService {\r\n  private readonly botToken: string | null;\r\n  private readonly chatId: string | null;\r\n  private readonly enabled: boolean;\r\n  private readonly logger: LoggerService;\r\n\r\n  constructor(config: TelegramConfig, logger: LoggerService) {\r\n    this.logger = logger;\r\n    this.botToken = config.botToken || null;\r\n    this.chatId = config.chatId || null;\r\n    this.enabled = config.enabled && !!this.botToken && !!this.chatId;\r\n\r\n    if (this.enabled) {\r\n      this.logger.info('‚úÖ Telegram notifications ENABLED', {\r\n        chatId: this.chatId,\r\n      });\r\n    } else {\r\n      this.logger.info(\r\n        '‚ö†Ô∏è Telegram notifications DISABLED (set telegram config in config.json)',\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send message to Telegram\r\n   */\r\n  private async sendMessage(message: string): Promise<void> {\r\n    if (!this.enabled || !this.botToken || !this.chatId) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const url = `https://api.telegram.org/bot${this.botToken}/sendMessage`;\r\n      const response = await fetch(url, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          chat_id: this.chatId,\r\n          text: message,\r\n          parse_mode: 'HTML',\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        throw new Error(`Telegram API error: ${response.status} ${errorText}`);\r\n      }\r\n\r\n      this.logger.debug('üì§ Telegram notification sent', {\r\n        messageLength: message.length,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('‚ùå Failed to send Telegram notification', { error });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notification: Bot started\r\n   */\r\n  async notifyBotStarted(symbol: string, timeframes: string[]): Promise<void> {\r\n    const message = `\r\nüöÄ <b>BOT STARTED</b>\r\n\r\nüìä Symbol: ${symbol}\r\n‚è∞ Timeframes: ${timeframes.join(', ')}\r\n‚è∞ Time: ${new Date().toISOString()}\r\n\r\n‚úÖ Bot is now monitoring the market...\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Bot stopped\r\n   */\r\n  async notifyBotStopped(reason?: string): Promise<void> {\r\n    const message = `\r\nüõë <b>BOT STOPPED</b>\r\n\r\n‚è∞ Time: ${new Date().toISOString()}\r\n${reason ? `üìù Reason: ${reason}` : ''}\r\n\r\n‚ùå Bot has stopped monitoring.\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Position opened\r\n   */\r\n  async notifyPositionOpened(position: Position): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'üü¢' : 'üî¥';\r\n    const leverageText = position.leverage > 1 ? ` ${position.leverage}x` : '';\r\n\r\n    const message = `\r\n${sideEmoji} <b>${position.side.toUpperCase()}${leverageText} OPENED</b>\r\n\r\nüìä Symbol: ${position.symbol}\r\nüí∞ Entry: $${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nüì¶ Size: ${position.quantity} (${position.marginUsed.toFixed(DECIMAL_PLACES.PERCENT)} USDT margin)\r\n\r\nüéØ Take Profits:\r\n${position.takeProfits\r\n    .map(\r\n      (tp) =>\r\n        `  TP${tp.level}: $${tp.price.toFixed(DECIMAL_PLACES.PRICE)} (+${tp.percent.toFixed(DECIMAL_PLACES.PERCENT)}%) - ${tp.sizePercent}%${tp.hit ? ' ‚úÖ' : ''}`,\r\n    )\r\n    .join('\\n')}\r\n\r\nüõ°Ô∏è Stop Loss: $${position.stopLoss.price.toFixed(DECIMAL_PLACES.PRICE)}\r\n\r\nüìù Strategy: ${position.strategy || 'SmartTrend'}\r\nüìù Confidence: ${((position.confidence || 0) * PERCENT_MULTIPLIER).toFixed(1)}%\r\nüìù Reason: ${position.reason || 'N/A'}\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Position closed\r\n   */\r\n  async notifyPositionClosed(\r\n    position: Position,\r\n    closeReason: string,\r\n    closePrice: number,\r\n    realizedPnL: number,\r\n    realizedPnLPercent: number,\r\n  ): Promise<void> {\r\n    const pnlEmoji = realizedPnL >= 0 ? 'üí∞' : 'üí∏';\r\n    const pnlSign = realizedPnL >= 0 ? '+' : '';\r\n\r\n    // Emoji for close type\r\n    let closeEmoji = 'üîö';\r\n    if (closeReason.includes('Stop Loss') || closeReason.includes('SL')) {\r\n      closeEmoji = 'üõ°Ô∏è';\r\n    } else if (closeReason.includes('Take Profit') || closeReason.includes('TP')) {\r\n      closeEmoji = 'üéØ';\r\n    } else if (closeReason.toLowerCase().includes('trailing')) {\r\n      closeEmoji = 'üìà';\r\n    } else if (closeReason.toLowerCase().includes('time')) {\r\n      closeEmoji = '‚è∞';\r\n    }\r\n\r\n    const holdingTimeMs = Date.now() - position.openedAt;\r\n    const holdingTimeSec = Math.floor(holdingTimeMs / 1000);\r\n    const holdingTimeMin = Math.floor(holdingTimeSec / 60);\r\n    const holdingTimeFormatted =\r\n      holdingTimeMin > 0\r\n        ? `${holdingTimeMin}m ${holdingTimeSec % 60}s`\r\n        : `${holdingTimeSec}s`;\r\n\r\n    const tpsHit = position.takeProfits.filter((tp) => tp.hit);\r\n\r\n    const message = `\r\n${closeEmoji} <b>${position.side.toUpperCase()} CLOSED</b>\r\n\r\nüìä Symbol: ${position.symbol}\r\nüí∞ Entry: $${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nüö™ Exit: $${closePrice.toFixed(DECIMAL_PLACES.PRICE)}\r\n\r\n${pnlEmoji} <b>PnL: ${pnlSign}${realizedPnL.toFixed(DECIMAL_PLACES.PERCENT)} USDT (${pnlSign}${realizedPnLPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)</b>\r\n\r\nüéØ TPs Hit: ${tpsHit.length > 0 ? tpsHit.map((tp) => `TP${tp.level}`).join(', ') : 'None'}\r\n‚è±Ô∏è Duration: ${holdingTimeFormatted}\r\nüìù Reason: ${closeReason}\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Take Profit hit\r\n   */\r\n  async notifyTakeProfitHit(\r\n    position: Position,\r\n    tpLevel: number,\r\n    tpPrice: number,\r\n    tpPercent: number,\r\n    sizePercent: number,\r\n  ): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'üü¢' : 'üî¥';\r\n\r\n    const message = `\r\nüéØ <b>TP${tpLevel} HIT!</b>\r\n\r\n${sideEmoji} ${position.symbol} ${position.side.toUpperCase()}\r\nüí∞ Price: $${tpPrice.toFixed(DECIMAL_PLACES.PRICE)} (+${tpPercent.toFixed(DECIMAL_PLACES.PERCENT)}%)\r\nüì¶ Closed: ${sizePercent}% of position\r\n\r\nüí∏ Estimated Profit: ~${(\r\n    ((position.marginUsed * sizePercent) / PERCENT_MULTIPLIER) *\r\n      (tpPercent / PERCENT_MULTIPLIER) *\r\n      position.leverage\r\n  ).toFixed(DECIMAL_PLACES.PERCENT)} USDT\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Stop moved to breakeven\r\n   */\r\n  async notifyBreakeven(position: Position, newStopPrice: number): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'üü¢' : 'üî¥';\r\n\r\n    const message = `\r\nüõ°Ô∏è <b>STOP MOVED TO BREAKEVEN!</b>\r\n\r\n${sideEmoji} ${position.symbol} ${position.side.toUpperCase()}\r\nüí∞ Entry: $${position.entryPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nüõ°Ô∏è New Stop: $${newStopPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\n\r\n‚úÖ Risk-free position! Minimum profit guaranteed.\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Trailing stop activated\r\n   */\r\n  async notifyTrailingActivated(\r\n    position: Position,\r\n    currentPrice: number,\r\n    newStopPrice: number,\r\n    trailingPercent: number,\r\n  ): Promise<void> {\r\n    const sideEmoji = position.side === PositionSide.LONG ? 'üü¢' : 'üî¥';\r\n\r\n    const message = `\r\nüìà <b>TRAILING STOP ACTIVATED!</b>\r\n\r\n${sideEmoji} ${position.symbol} ${position.side.toUpperCase()}\r\nüí∞ Current Price: $${currentPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nüõ°Ô∏è New Stop: $${newStopPrice.toFixed(DECIMAL_PLACES.PRICE)}\r\nüìä Trailing Distance: ${trailingPercent.toFixed(DECIMAL_PLACES.PERCENT)}%\r\n\r\nüéØ Locking in profits! Stop will follow price movement.\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Trailing stop updated (silent, only debug)\r\n   */\r\n  async notifyTrailingUpdated(\r\n    position: Position,\r\n    newStopPrice: number,\r\n  ): Promise<void> {\r\n    // Silent notification - only log, don't spam Telegram\r\n    this.logger.debug('üìà Trailing stop updated', {\r\n      symbol: position.symbol,\r\n      newStop: newStopPrice,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notification: Trade signal (entry/exit)\r\n   */\r\n  async sendTradeNotification(params: {\r\n    type: 'ENTRY' | 'EXIT';\r\n    direction: SignalDirection;\r\n    price: number;\r\n    stopLoss?: number;\r\n    takeProfits?: Array<{ level: number; price: number; sizePercent: number }>;\r\n    confidence?: number;\r\n    reason?: string;\r\n    pnl?: number;\r\n    pnlPercent?: number;\r\n  }): Promise<void> {\r\n    const emoji = params.type === 'ENTRY'\r\n      ? (params.direction === SignalDirection.LONG ? 'üü¢' : 'üî¥')\r\n      : '‚ö™';\r\n\r\n    let message = `\r\n${emoji} <b>${params.type}: ${params.direction}</b>\r\n\r\nüí∞ Price: $${params.price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n\r\n    if (params.type === 'ENTRY') {\r\n      if (params.stopLoss) {\r\n        message += `\\nüõ°Ô∏è Stop Loss: $${params.stopLoss.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n      }\r\n      if (params.takeProfits && params.takeProfits.length > 0) {\r\n        message += '\\nüéØ Take Profits:';\r\n        params.takeProfits.forEach(tp => {\r\n          message += `\\n  ‚Ä¢ TP${tp.level}: $${tp.price.toFixed(DECIMAL_PLACES.PRICE)} (${tp.sizePercent}%)`;\r\n        });\r\n      }\r\n      if (params.confidence) {\r\n        message += `\\nüìä Confidence: ${(params.confidence * PERCENT_MULTIPLIER).toFixed(0)}%`;\r\n      }\r\n      if (params.reason) {\r\n        message += `\\nüìù Reason: ${params.reason}`;\r\n      }\r\n    } else {\r\n      // EXIT\r\n      if (params.pnl !== undefined) {\r\n        const pnlSign = params.pnl >= 0 ? '+' : '';\r\n        message += `\\nüíµ PnL: ${pnlSign}$${params.pnl.toFixed(DECIMAL_PLACES.PERCENT)}`;\r\n      }\r\n      if (params.pnlPercent !== undefined) {\r\n        const pnlSign = params.pnlPercent >= 0 ? '+' : '';\r\n        message += `\\nüìà PnL%: ${pnlSign}${params.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)}%`;\r\n      }\r\n      if (params.reason) {\r\n        message += `\\nüìù Reason: ${params.reason}`;\r\n      }\r\n    }\r\n\r\n    message += `\\n‚è∞ Time: ${new Date().toISOString()}`;\r\n    message = message.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Notification: Critical error\r\n   */\r\n  async notifyError(errorType: string, details: string): Promise<void> {\r\n    const message = `\r\n‚ö†Ô∏è <b>ERROR: ${errorType}</b>\r\n\r\n${details}\r\n\r\n‚è∞ Time: ${new Date().toISOString()}\r\n`.trim();\r\n\r\n    await this.sendMessage(message);\r\n  }\r\n\r\n  /**\r\n   * Send critical alert message\r\n   * Used for emergency notifications (unprotected positions, etc)\r\n   */\r\n  async sendAlert(message: string): Promise<void> {\r\n    await this.sendMessage(message);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\tf-alignment.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENT_MULTIPLIER' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS } from '../constants';\r\n/**\r\n * Timeframe Alignment Service (PHASE 6)\r\n *\r\n * Calculates multi-timeframe alignment score to boost signal confidence.\r\n * When all timeframes agree on direction, signal gets higher confidence.\r\n *\r\n * Scoring Logic:\r\n * - Entry TF (M1): price > EMA20 ‚Üí +20 points\r\n * - Primary TF (M5): price > EMA20 ‚Üí +30, price > EMA50 ‚Üí +20\r\n * - Trend1 TF (M30): EMA20 > EMA50 ‚Üí +30 points\r\n *\r\n * Total: 0-100 points\r\n * If score >= minAlignmentScore ‚Üí aligned = true\r\n *\r\n * Example:\r\n * LONG signal at $100\r\n * - Entry M1: $100 > EMA20($99) ‚úÖ +20 points\r\n * - Primary M5: $100 > EMA20($98) ‚úÖ +30, $100 > EMA50($97) ‚úÖ +20\r\n * - Trend1 M30: EMA20($99) > EMA50($96) ‚úÖ +30 points\r\n * Total: 100 points ‚Üí fully aligned ‚Üí boost confidence\r\n */\r\n\r\nimport { TFAlignmentConfig, TFAlignmentResult, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PERCENT_MULTIPLIER = 100;\r\nconst PRIMARY_EMA20_WEIGHT = CONFIDENCE_THRESHOLDS.LOW; // 60% of primary weight\r\nconst PRIMARY_EMA50_WEIGHT = 0.4; // 40% of primary weight\r\n\r\n// ============================================================================\r\n// TF ALIGNMENT SERVICE\r\n// ============================================================================\r\n\r\nexport class TFAlignmentService {\r\n  constructor(\r\n    private config: TFAlignmentConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Calculate timeframe alignment score\r\n   *\r\n   * @param direction - Trade direction ('LONG' or 'SHORT')\r\n   * @param currentPrice - Current market price\r\n   * @param indicators - Indicator values from all timeframes\r\n   * @returns TFAlignmentResult with score, aligned flag, contributions, and details\r\n   */\r\n  calculateAlignment(\r\n    direction: 'LONG' | 'SHORT',\r\n    currentPrice: number,\r\n    indicators: {\r\n      entry: { ema20: number };\r\n      primary: { ema20: number; ema50: number };\r\n      trend1: { ema20: number; ema50: number };\r\n    },\r\n  ): TFAlignmentResult {\r\n    if (!this.config.enabled) {\r\n      return this.createDisabledResult();\r\n    }\r\n\r\n    let score = 0;\r\n    const contributions = { entry: 0, primary: 0, trend1: 0 };\r\n\r\n    // ========================================================================\r\n    // Entry TF (M1): Price vs EMA20\r\n    // ========================================================================\r\n    const entryAligned =\r\n      direction === 'LONG'\r\n        ? currentPrice > indicators.entry.ema20\r\n        : currentPrice < indicators.entry.ema20;\r\n\r\n    if (entryAligned) {\r\n      contributions.entry = this.config.timeframes.entry.weight;\r\n      score += contributions.entry;\r\n    }\r\n\r\n    // ========================================================================\r\n    // Primary TF (M5): Price vs EMA20 + EMA50\r\n    // ========================================================================\r\n    const primaryEMA20Aligned =\r\n      direction === 'LONG'\r\n        ? currentPrice > indicators.primary.ema20\r\n        : currentPrice < indicators.primary.ema20;\r\n\r\n    const primaryEMA50Aligned =\r\n      direction === 'LONG'\r\n        ? currentPrice > indicators.primary.ema50\r\n        : currentPrice < indicators.primary.ema50;\r\n\r\n    if (primaryEMA20Aligned) {\r\n      contributions.primary +=\r\n        this.config.timeframes.primary.weight * PRIMARY_EMA20_WEIGHT;\r\n    }\r\n\r\n    if (primaryEMA50Aligned) {\r\n      contributions.primary +=\r\n        this.config.timeframes.primary.weight * PRIMARY_EMA50_WEIGHT;\r\n    }\r\n\r\n    score += contributions.primary;\r\n\r\n    // ========================================================================\r\n    // Trend1 TF (M30): EMA20 vs EMA50 (trend direction)\r\n    // ========================================================================\r\n    const trend1Aligned =\r\n      direction === 'LONG'\r\n        ? indicators.trend1.ema20 > indicators.trend1.ema50\r\n        : indicators.trend1.ema20 < indicators.trend1.ema50;\r\n\r\n    if (trend1Aligned) {\r\n      contributions.trend1 = this.config.timeframes.trend1.weight;\r\n      score += contributions.trend1;\r\n    }\r\n\r\n    // ========================================================================\r\n    // Result\r\n    // ========================================================================\r\n    const aligned = score >= this.config.minAlignmentScore;\r\n\r\n    const details = `Entry: ${contributions.entry}, Primary: ${contributions.primary.toFixed(0)}, Trend1: ${contributions.trend1}`;\r\n\r\n    this.logger.debug('TF Alignment calculated', {\r\n      direction,\r\n      score: score.toFixed(0),\r\n      aligned,\r\n      details,\r\n    });\r\n\r\n    return {\r\n      score,\r\n      aligned,\r\n      contributions,\r\n      details,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create result for disabled service\r\n   */\r\n  private createDisabledResult(): TFAlignmentResult {\r\n    return {\r\n      score: 0,\r\n      aligned: false,\r\n      contributions: { entry: 0, primary: 0, trend1: 0 },\r\n      details: 'TF Alignment disabled',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get configuration\r\n   */\r\n  getConfig(): TFAlignmentConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\tick-delta-analyzer.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.0.","line":122,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":122,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":127,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":127,"endColumn":17},{"ruleId":"complexity","severity":1,"message":"Method 'detectMomentumSpike' has a complexity of 13. Maximum allowed is 10.","line":140,"column":22,"nodeType":"FunctionExpression","messageId":"complex","endLine":241,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.0.","line":189,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":189,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":191,"column":20,"nodeType":"Literal","messageId":"noMagic","endLine":191,"endColumn":23},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.0.","line":206,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":206,"endColumn":66},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":209,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":209,"endColumn":21},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":249,"column":67,"nodeType":"Literal","messageId":"noMagic","endLine":249,"endColumn":68}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\n/**\n * Tick Delta Analyzer Service (Phase 4)\n *\n * Analyzes buy/sell tick delta for momentum detection.\n *\n * Features:\n * - Tracks tick history (buy/sell trades)\n * - Calculates buy/sell delta ratio\n * - Detects momentum spikes (e.g., 2x more buys than sells)\n * - Automatic cleanup of old ticks\n *\n * Example:\n * - 40 buy ticks, 15 sell ticks ‚Üí deltaRatio = 2.67 ‚Üí BUY momentum spike\n * - 10 buy ticks, 35 sell ticks ‚Üí deltaRatio = 0.29 (inverse 3.5) ‚Üí SELL momentum spike\n */\n\nimport {\n  LoggerService,\n  SignalDirection,\n  Tick,\n  MomentumSpike,\n  TickDeltaAnalyzerConfig,\n} from '../types';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nconst MAX_TICK_HISTORY = 1000; // Max ticks to keep in memory\nconst CLEANUP_INTERVAL_MS = 10000; // Cleanup old ticks every 10s\n\n// ============================================================================\n// TICK DELTA ANALYZER SERVICE\n// ============================================================================\n\nexport class TickDeltaAnalyzerService {\n  private tickHistory: Tick[] = [];\n  private lastCleanupTime: number = Date.now();\n\n  constructor(\n    private config: TickDeltaAnalyzerConfig,\n    private logger: LoggerService,\n  ) {\n    this.logger.info('TickDeltaAnalyzerService initialized', {\n      minDeltaRatio: config.minDeltaRatio,\n      detectionWindow: config.detectionWindow,\n      minTickCount: config.minTickCount,\n      minVolumeUSDT: config.minVolumeUSDT,\n    });\n  }\n\n  // ==========================================================================\n  // PUBLIC METHODS\n  // ==========================================================================\n\n  /**\n   * Add new tick to history\n   *\n   * @param tick - New trade/tick\n   */\n  addTick(tick: Tick): void {\n    this.tickHistory.push(tick);\n\n    // Limit history size\n    if (this.tickHistory.length > MAX_TICK_HISTORY) {\n      this.tickHistory.shift(); // Remove oldest tick\n    }\n\n    // Periodic cleanup\n    if (Date.now() - this.lastCleanupTime > CLEANUP_INTERVAL_MS) {\n      this.cleanupOldTicks();\n    }\n\n    //     this.logger.debug('Tick added', {\n    //       side: tick.side,\n    //       price: tick.price,\n    //       size: tick.size,\n    //       historySize: this.tickHistory.length,\n    //     });\n  }\n\n  /**\n   * Calculate buy/sell delta ratio for recent window\n   *\n   * Returns ratio of buy volume to sell volume.\n   * - Ratio > 1: More buy pressure (bullish)\n   * - Ratio < 1: More sell pressure (bearish)\n   *\n   * @param windowMs - Time window to analyze (ms, default: config.detectionWindow)\n   * @returns Delta ratio (buy/sell)\n   */\n  calculateDeltaRatio(windowMs: number = this.config.detectionWindow): number {\n    const cutoffTime = Date.now() - windowMs;\n\n    // Filter ticks in window\n    const recentTicks = this.tickHistory.filter((tick) => tick.timestamp >= cutoffTime);\n\n    if (recentTicks.length === 0) {\n      return 1.0; // Neutral (no data)\n    }\n\n    // Calculate buy and sell volumes\n    let buyVolume = 0;\n    let sellVolume = 0;\n\n    for (const tick of recentTicks) {\n      if (tick.side === 'BUY') {\n        buyVolume += tick.size;\n      } else {\n        sellVolume += tick.size;\n      }\n    }\n\n    // Avoid division by zero\n    if (sellVolume === 0 && buyVolume === 0) {\n      return 1.0; // Neutral (no volume)\n    }\n\n    if (sellVolume === 0) {\n      // Only buys: strong bullish, but cap at reasonable max (10x instead of 999)\n      return 10.0;\n    }\n\n    if (buyVolume === 0) {\n      // Only sells: strong bearish (inverse will be 10x for SHORT)\n      return 0.1;\n    }\n\n    return buyVolume / sellVolume;\n  }\n\n  /**\n   * Detect momentum spike from recent ticks\n   *\n   * Checks if delta ratio exceeds threshold and meets volume requirements.\n   *\n   * @returns MomentumSpike if detected, null otherwise\n   */\n  detectMomentumSpike(): MomentumSpike | null {\n    const cutoffTime = Date.now() - this.config.detectionWindow;\n\n    // Filter recent ticks\n    const recentTicks = this.tickHistory.filter((tick) => tick.timestamp >= cutoffTime);\n\n    // Check min tick count\n    if (recentTicks.length < this.config.minTickCount) {\n      this.logger.debug('Not enough ticks for momentum detection', {\n        tickCount: recentTicks.length,\n        minRequired: this.config.minTickCount,\n      });\n      return null;\n    }\n\n    // Calculate volumes\n    let buyVolume = 0;\n    let sellVolume = 0;\n    let totalVolumeContracts = 0;\n\n    for (const tick of recentTicks) {\n      totalVolumeContracts += tick.size;\n      if (tick.side === 'BUY') {\n        buyVolume += tick.size;\n      } else {\n        sellVolume += tick.size;\n      }\n    }\n\n    // Calculate average price for USDT volume estimation\n    const avgPrice =\n      recentTicks.reduce((sum, tick) => sum + tick.price, 0) / recentTicks.length;\n    const volumeUSDT = totalVolumeContracts * avgPrice;\n\n    // Check min volume\n    if (volumeUSDT < this.config.minVolumeUSDT) {\n      this.logger.debug('Volume too low for momentum spike', {\n        volumeUSDT,\n        minRequired: this.config.minVolumeUSDT,\n      });\n      return null;\n    }\n\n    // Calculate delta ratio (with safety checks)\n    let deltaRatio: number;\n    if (sellVolume === 0 && buyVolume === 0) {\n      this.logger.debug('No volume in window', {volumeUSDT});\n      return null; // Skip if no volume\n    } else if (sellVolume === 0) {\n      deltaRatio = 10.0; // Cap at 10x instead of 999\n    } else if (buyVolume === 0) {\n      deltaRatio = 0.1; // Inverse 10x for SHORT\n    } else {\n      deltaRatio = buyVolume / sellVolume;\n    }\n\n    // Detect spike\n    let direction: SignalDirection | null = null;\n    let actualRatio = deltaRatio;\n\n    if (deltaRatio >= this.config.minDeltaRatio) {\n      // Buy momentum\n      direction = SignalDirection.LONG;\n    } else if (deltaRatio <= 1 / this.config.minDeltaRatio) {\n      // Sell momentum (inverse ratio)\n      direction = SignalDirection.SHORT;\n      actualRatio = buyVolume > 0 ? sellVolume / buyVolume : 10.0; // Safe division\n    }\n\n    if (direction == null) {\n      this.logger.debug('Delta ratio not strong enough', {\n        deltaRatio,\n        minRequired: this.config.minDeltaRatio,\n      });\n      return null;\n    }\n\n    // Calculate confidence (0-maxConfidence)\n    // Higher ratio = higher confidence\n    const confidence = Math.min(\n      this.config.maxConfidence,\n      ((actualRatio - this.config.minDeltaRatio) / this.config.minDeltaRatio) * PERCENT_MULTIPLIER,\n    );\n\n    const spike: MomentumSpike = {\n      direction,\n      deltaRatio: actualRatio,\n      confidence,\n      tickCount: recentTicks.length,\n      volumeUSDT,\n    };\n\n    this.logger.info('üöÄ Momentum spike detected!', {\n      direction,\n      deltaRatio: actualRatio.toFixed(DECIMAL_PLACES.PERCENT),\n      confidence: confidence.toFixed(1),\n      tickCount: recentTicks.length,\n      volumeUSDT: volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\n    });\n\n    return spike;\n  }\n\n  /**\n   * Cleanup old ticks beyond detection window\n   *\n   * Removes ticks older than 2x detection window\n   */\n  cleanupOldTicks(): void {\n    const cutoffTime = Date.now() - this.config.detectionWindow * 2;\n    const beforeCount = this.tickHistory.length;\n\n    this.tickHistory = this.tickHistory.filter((tick) => tick.timestamp >= cutoffTime);\n\n    const afterCount = this.tickHistory.length;\n    const removed = beforeCount - afterCount;\n\n    if (removed > 0) {\n      this.logger.debug('Old ticks cleaned up', {\n        removed,\n        remaining: afterCount,\n      });\n    }\n\n    this.lastCleanupTime = Date.now();\n  }\n\n  /**\n   * Get tick history (for testing/debugging)\n   */\n  getTickHistory(): Tick[] {\n    return this.tickHistory;\n  }\n\n  /**\n   * Clear all tick history (for testing)\n   */\n  clearHistory(): void {\n    this.tickHistory = [];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\time.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":39,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":39,"endColumn":61},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":40,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":40,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":47,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":47,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[1210,1225],"text":"(syncIntervalMs === 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[1210,1225],"text":"(Number.isNaN(syncIntervalMs))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1210,1225],"text":"(!Boolean(syncIntervalMs))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":69,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":69,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1778,1796],"text":"this.bybitService == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":198,"column":10,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":198,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[5419,5427],"text":"dateStr.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[5419,5427],"text":"dateStr === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5419,5427],"text":"!Boolean(dateStr)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Time Service\r\n * Synchronization with exchange server time\r\n *\r\n * Responsibilities:\r\n * - Time offset calculation and management\r\n * - Periodic synchronization with exchange\r\n * - Time conversion (local <-> server)\r\n * - Sync health monitoring\r\n */\r\n\r\nimport { LoggerService } from '../types';\r\nimport { BybitService } from './bybit';\r\n\r\n/**\r\n * Sync info return type\r\n */\r\ninterface SyncInfo {\r\n  offset: number;\r\n  lastSync: Date;\r\n  isRecent: boolean;\r\n  nextSyncIn: number;\r\n}\r\n\r\n/**\r\n * TimeService - Synchronization with exchange server time\r\n */\r\nexport class TimeService {\r\n  private logger: LoggerService;\r\n  private syncInterval: number;\r\n  private maxSyncFailures: number;\r\n  private bybitService?: BybitService;\r\n\r\n  private timeOffset: number = 0; // —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –ª–æ–∫–∞–ª—å–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∏ –≤—Ä–µ–º–µ–Ω–µ–º –±–∏—Ä–∂–∏\r\n  private lastSyncTime: number = 0;\r\n  private criticalSyncFailures: number = 0;\r\n\r\n  // Constants\r\n  private static readonly TIME_SYNC_DEFAULT_MAX_FAILURES = 3;\r\n  private static readonly TIME_SYNC_LATENCY_DIVISOR = 2;\r\n\r\n  constructor(\r\n    logger: LoggerService,\r\n    syncIntervalMs: number,\r\n    maxSyncFailures: number = TimeService.TIME_SYNC_DEFAULT_MAX_FAILURES,\r\n  ) {\r\n    if (!syncIntervalMs || syncIntervalMs <= 0) {\r\n      throw new Error(\r\n        'TimeService: syncIntervalMs is required and must be positive',\r\n      );\r\n    }\r\n\r\n    this.logger = logger;\r\n    this.syncInterval = syncIntervalMs;\r\n    this.maxSyncFailures = maxSyncFailures;\r\n  }\r\n\r\n  /**\r\n   * Set Bybit service for time synchronization\r\n   */\r\n  public setBybitService(bybitService: BybitService): void {\r\n    this.bybitService = bybitService;\r\n  }\r\n\r\n  /**\r\n   * Synchronize time with exchange server\r\n   */\r\n  public async syncWithExchange(): Promise<void> {\r\n    if (!this.bybitService) {\r\n      this.logger.warn('‚ö†Ô∏è Bybit service not set for time sync');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const localTimeBefore = Date.now();\r\n\r\n      // –ò—Å–ø–æ–ª—å–∑—É–µ–º getServerTime –∏–∑ bybit-api SDK\r\n      const serverTime = await this.bybitService.getServerTime();\r\n\r\n      const localTimeAfter = Date.now();\r\n      const networkLatency =\r\n        (localTimeAfter - localTimeBefore) / TimeService.TIME_SYNC_LATENCY_DIVISOR;\r\n\r\n      // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–Ω–∏—Ü—É –≤—Ä–µ–º–µ–Ω–∏ (—Å–µ—Ä–≤–µ—Ä–Ω–æ–µ - –ª–æ–∫–∞–ª—å–Ω–æ–µ)\r\n      if (serverTime === undefined) {\r\n        throw new Error('CRITICAL: Server time is undefined');\r\n      }\r\n\r\n      this.timeOffset = serverTime - localTimeAfter;\r\n      this.lastSyncTime = localTimeAfter;\r\n\r\n      // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏\r\n      this.criticalSyncFailures = 0;\r\n\r\n      this.logger.info('‚è∞ Time synchronized with Bybit', {\r\n        serverTime: new Date(Number(serverTime)).toISOString(),\r\n        localTime: new Date(localTimeAfter).toISOString(),\r\n        offset: this.timeOffset,\r\n        latency: networkLatency,\r\n      });\r\n    } catch (error) {\r\n      this.criticalSyncFailures++;\r\n\r\n      this.logger.error('‚ùå Failed to sync time with exchange', {\r\n        error,\r\n        failureCount: this.criticalSyncFailures,\r\n        maxAllowed: this.maxSyncFailures,\r\n      });\r\n\r\n      if (this.criticalSyncFailures >= this.maxSyncFailures) {\r\n        this.logger.warn('‚ö†Ô∏è Time sync failed, continuing with local time', {\r\n          failureCount: this.criticalSyncFailures,\r\n          note: 'Demo trading can continue without precise time sync',\r\n        });\r\n        // Continue without throwing - demo trading is more resilient\r\n      }\r\n\r\n      // –ù–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º timeOffset = 0 - –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∏–∑–≤–µ—Å—Ç–Ω—ã–π offset\r\n      this.logger.warn(\r\n        `‚ö†Ô∏è Using last known time offset: ${this.timeOffset}ms`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure time is synchronized (auto-sync if needed)\r\n   */\r\n  public async ensureSync(): Promise<void> {\r\n    const now = Date.now();\r\n\r\n    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ –±–æ–ª—å—à–µ syncInterval –∏–ª–∏ –µ—â–µ –Ω–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–ª–∏—Å—å\r\n    if (\r\n      now - this.lastSyncTime > this.syncInterval ||\r\n      this.lastSyncTime === 0\r\n    ) {\r\n      await this.syncWithExchange();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current timestamp synchronized with exchange\r\n   */\r\n  public now(): number {\r\n    return Date.now() + this.timeOffset;\r\n  }\r\n\r\n  /**\r\n   * Get Date object synchronized with exchange\r\n   */\r\n  public nowDate(): Date {\r\n    return new Date(this.now());\r\n  }\r\n\r\n  /**\r\n   * Convert local timestamp to server time\r\n   */\r\n  public toServerTime(localTimestamp: number): number {\r\n    return localTimestamp + this.timeOffset;\r\n  }\r\n\r\n  /**\r\n   * Convert server timestamp to local time\r\n   */\r\n  public toLocalTime(serverTimestamp: number): number {\r\n    return serverTimestamp - this.timeOffset;\r\n  }\r\n\r\n  /**\r\n   * Check if sync is recent (within sync interval)\r\n   */\r\n  public isSyncRecent(): boolean {\r\n    return Date.now() - this.lastSyncTime < this.syncInterval;\r\n  }\r\n\r\n  /**\r\n   * Get synchronization information\r\n   */\r\n  public getSyncInfo(): SyncInfo {\r\n    const now = Date.now();\r\n    const nextSyncIn = Math.max(\r\n      0,\r\n      this.syncInterval - (now - this.lastSyncTime),\r\n    );\r\n\r\n    return {\r\n      offset: this.timeOffset,\r\n      lastSync: new Date(this.lastSyncTime),\r\n      isRecent: this.isSyncRecent(),\r\n      nextSyncIn,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get today's date string (for logging filenames)\r\n   */\r\n  public getTodayString(): string {\r\n    const dateStr = this.nowDate().toISOString().split('T')[0];\r\n    if (!dateStr) {\r\n      throw new Error('Failed to get date string');\r\n    }\r\n    return dateStr;\r\n  }\r\n\r\n  /**\r\n   * Get bot uptime (for trading statistics)\r\n   */\r\n  public getUptime(startTime: number): number {\r\n    return this.now() - startTime;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\trade-history.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":152,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":152,"endColumn":71},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'appendTrade' has no 'await' expression.","line":258,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":258,"endColumn":20},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'readAllTrades' has no 'await' expression.","line":316,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":316,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":330,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":330,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9233,9236],"text":"row != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":353,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":353,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[9812,9821],"text":"(values[i].length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[9812,9821],"text":"(values[i] !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9812,9821],"text":"(Boolean(values[i]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":369,"column":27,"nodeType":"CallExpression","messageId":"conditionErrorNumber","endLine":369,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[10206,10223],"text":"(parseFloat(value) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[10206,10223],"text":"(!Number.isNaN(parseFloat(value)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10206,10223],"text":"(Boolean(parseFloat(value)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":371,"column":27,"nodeType":"CallExpression","messageId":"conditionErrorNumber","endLine":371,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[10299,10314],"text":"(parseInt(value) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[10299,10314],"text":"(!Number.isNaN(parseInt(value)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10299,10314],"text":"(Boolean(parseInt(value)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":371,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":371,"endColumn":48},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":377,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":381,"endColumn":12},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getTotalTrades' has no 'await' expression.","line":437,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":437,"endColumn":23},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (334). Maximum allowed is 300.","line":463,"column":1,"nodeType":null,"messageId":"exceed","endLine":507,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":478,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":478,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[12888,12914],"text":"(byStrategy[trade.strategy] !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[12888,12914],"text":"(!Number.isNaN(byStrategy[trade.strategy]))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12888,12914],"text":"(Boolean(byStrategy[trade.strategy]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":479,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":479,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[12978,13009],"text":"(bySession[trade.sessionVersion] !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[12978,13009],"text":"(!Number.isNaN(bySession[trade.sessionVersion]))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12978,13009],"text":"(Boolean(bySession[trade.sessionVersion]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":500,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":500,"endColumn":42,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13547,13563],"text":"(Boolean(trade[fieldName]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":501,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":501,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[13599,13609],"text":"(stats[key] !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[13599,13609],"text":"(!Number.isNaN(stats[key]))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13599,13609],"text":"(Boolean(stats[key]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\n/**\n * Trade History Service with Dynamic Schema\n *\n * Manages permanent trade history in CSV format with automatic schema expansion.\n * - Append-only: never deletes data\n * - Dynamic schema: automatically adds new columns when new fields are detected\n * - Backward compatible: old records work with new schema (empty values for new fields)\n * - Auto-migration: expands CSV when new fields are added\n *\n * Usage:\n * ```typescript\n * const history = new TradeHistoryService(logger);\n * await history.appendTrade({\n *   ...coreFields,\n *   rsiEntry: 30.5,  // New field? Automatically added to schema!\n *   customIndicator: 'value'\n * });\n * ```\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { LoggerService } from '../types';\nimport { extractErrorMessage } from '../utils/error-helper';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n// Core fields (always present in every record)\nconst CORE_FIELDS = [\n  'timestamp',\n  'id',\n  'symbol',\n  'side',\n  'strategy',\n  'entryPrice',\n  'exitPrice',\n  'quantity',\n  'leverage',\n  'pnl',\n  'fees',\n  'netPnl',\n  'duration',\n  'exitType',\n  'confidence',\n  'virtualBalanceBefore',\n  'virtualBalanceAfter',\n  'sessionVersion',\n  'notes',\n];\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface TradeRecord {\n  // Core fields (required)\n  timestamp: string;\n  id: string;\n  symbol: string;\n  side: string;\n  strategy: string;\n  entryPrice: number;\n  exitPrice: number;\n  quantity: number;\n  leverage: number;\n  pnl: number;\n  fees: number;\n  netPnl: number;\n  duration: string;\n  exitType: string;\n  confidence: number;\n  virtualBalanceBefore: number;\n  virtualBalanceAfter: number;\n  sessionVersion: string;\n  notes: string;\n\n  // Dynamic fields (any additional indicators, conditions, etc)\n  [key: string]: unknown;\n}\n\n// ============================================================================\n// TRADE HISTORY SERVICE\n// ============================================================================\n\nexport class TradeHistoryService {\n  private csvPath: string;\n  private schemaPath: string;\n  private currentSchema: string[] = [];\n\n  constructor(\n    private logger: LoggerService,\n    private dataDir: string = './data',\n  ) {\n    this.csvPath = path.join(this.dataDir, 'trade-history.csv');\n    this.schemaPath = path.join(this.dataDir, 'csv-schema.json');\n    this.initialize();\n  }\n\n  /**\n   * Initialize CSV and schema\n   */\n  private initialize(): void {\n    if (!fs.existsSync(this.dataDir)) {\n      fs.mkdirSync(this.dataDir, { recursive: true });\n    }\n\n    // Load or create schema\n    this.currentSchema = this.loadSchema();\n\n    // Ensure CSV exists\n    if (!fs.existsSync(this.csvPath)) {\n      this.createCSV();\n    } else {\n      // Verify schema matches CSV header\n      this.verifyAndMigrateSchema();\n    }\n  }\n\n  /**\n   * Load schema from file\n   */\n  private loadSchema(): string[] {\n    try {\n      if (fs.existsSync(this.schemaPath)) {\n        const content = fs.readFileSync(this.schemaPath, 'utf-8');\n        const schema = JSON.parse(content) as string[];\n\n        this.logger.info('‚úÖ CSV schema loaded', {\n          fields: schema.length,\n          coreFields: CORE_FIELDS.length,\n          customFields: schema.length - CORE_FIELDS.length,\n        });\n\n        return schema;\n      }\n    } catch (error: unknown) {\n      this.logger.error('‚ùå Failed to load schema', { error, errorMessage: extractErrorMessage(error) });\n    }\n\n    // Return core fields as default\n    return [...CORE_FIELDS];\n  }\n\n  /**\n   * Save schema to file\n   */\n  private saveSchema(schema: string[]): void {\n    try {\n      fs.writeFileSync(this.schemaPath, JSON.stringify(schema, null, 2), 'utf-8');\n\n      this.logger.debug('üìù Schema saved', { fields: schema.length });\n    } catch (error: unknown) {\n      this.logger.error('‚ùå Failed to save schema', { error, errorMessage: extractErrorMessage(error) });\n    }\n  }\n\n  /**\n   * Create new CSV with current schema\n   */\n  private createCSV(): void {\n    const header = this.currentSchema.join(',');\n    fs.writeFileSync(this.csvPath, header + '\\n', 'utf-8');\n\n    this.logger.info('‚úÖ Trade history CSV created', {\n      path: this.csvPath,\n      fields: this.currentSchema.length,\n    });\n  }\n\n  /**\n   * Verify CSV header matches schema, migrate if needed\n   */\n  private verifyAndMigrateSchema(): void {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n');\n\n      if (lines.length === 0) {\n        this.createCSV();\n        return;\n      }\n\n      const existingHeader = lines[0].split(',').map((h) => h.trim());\n\n      // Check if schema has new fields\n      const newFields = this.currentSchema.filter((field) => !existingHeader.includes(field));\n\n      if (newFields.length > 0) {\n        this.logger.warn('üîÑ CSV schema migration needed', {\n          newFields,\n          oldColumns: existingHeader.length,\n          newColumns: this.currentSchema.length,\n        });\n\n        this.migrateCSV(existingHeader, newFields);\n      }\n    } catch (error: unknown) {\n      this.logger.error('‚ùå Failed to verify schema', { error, errorMessage: extractErrorMessage(error) });\n    }\n  }\n\n  /**\n   * Migrate CSV to new schema (add columns)\n   */\n  private migrateCSV(oldHeader: string[], newFields: string[]): void {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n').filter(Boolean);\n\n      // Create backup\n      const backupPath = this.csvPath + '.backup.' + Date.now();\n      fs.writeFileSync(backupPath, content, 'utf-8');\n\n      this.logger.info('üíæ Backup created', { path: backupPath });\n\n      // Build new header\n      const newHeader = [...oldHeader, ...newFields];\n\n      // Rebuild CSV\n      const newLines: string[] = [newHeader.join(',')];\n\n      // Migrate each data line (add empty values for new fields)\n      for (let i = 1; i < lines.length; i++) {\n        const values = this.splitCSVLine(lines[i]);\n\n        // Add empty values for new fields\n        for (let j = 0; j < newFields.length; j++) {\n          values.push(''); // Empty value for new field\n        }\n\n        newLines.push(values.join(','));\n      }\n\n      // Write migrated CSV\n      fs.writeFileSync(this.csvPath, newLines.join('\\n') + '\\n', 'utf-8');\n\n      // Update schema\n      this.currentSchema = newHeader;\n      this.saveSchema(newHeader);\n\n      this.logger.info('‚úÖ CSV migrated successfully', {\n        addedFields: newFields,\n        totalRecords: lines.length - 1,\n        newColumns: newHeader.length,\n      });\n    } catch (error: unknown) {\n      this.logger.error('‚ùå CSV migration failed', { error, errorMessage: extractErrorMessage(error) });\n      throw error;\n    }\n  }\n\n  /**\n   * Append trade with dynamic fields\n   */\n  async appendTrade(record: TradeRecord): Promise<void> {\n    try {\n      // Detect new fields in this record\n      const recordFields = Object.keys(record);\n      const newFields = recordFields.filter((field) => !this.currentSchema.includes(field));\n\n      if (newFields.length > 0) {\n        this.logger.info('üÜï New fields detected', { fields: newFields });\n\n        // Add to schema\n        this.currentSchema.push(...newFields);\n        this.saveSchema(this.currentSchema);\n\n        // Migrate CSV to include new columns\n        this.verifyAndMigrateSchema();\n      }\n\n      // Build CSV row according to current schema\n      const values: string[] = [];\n\n      for (const field of this.currentSchema) {\n        const value = record[field];\n\n        if (value === undefined || value === null) {\n          values.push(''); // Empty for missing fields\n        } else if (typeof value === 'string') {\n          // Escape commas and quotes\n          const escaped = value.replace(/\"/g, '\"\"');\n          values.push(`\"${escaped}\"`);\n        } else {\n          values.push(String(value));\n        }\n      }\n\n      const csvLine = values.join(',');\n\n      // Append to CSV\n      fs.appendFileSync(this.csvPath, csvLine + '\\n', 'utf-8');\n\n      this.logger.debug('üìù Trade appended to history', {\n        id: record.id,\n        netPnl: record.netPnl,\n        fields: recordFields.length,\n        newFields: newFields.length,\n      });\n    } catch (error: unknown) {\n      this.logger.error('‚ùå Failed to append trade', {\n        error,\n        errorMessage: extractErrorMessage(error),\n        id: record.id,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Read all trades with dynamic schema\n   */\n  async readAllTrades(): Promise<TradeRecord[]> {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n').filter(Boolean);\n\n      if (lines.length <= 1) {\n        return [];\n      }\n\n      const header = lines[0].split(',').map((h) => h.trim());\n      const trades: TradeRecord[] = [];\n\n      for (let i = 1; i < lines.length; i++) {\n        const row = this.parseCSVLine(lines[i], header);\n        if (row) {\n          trades.push(row);\n        }\n      }\n\n      return trades;\n    } catch (error: unknown) {\n      this.logger.error('‚ùå Failed to read trades', { error, errorMessage: extractErrorMessage(error) });\n      return [];\n    }\n  }\n\n  /**\n   * Parse CSV line with dynamic schema\n   */\n  private parseCSVLine(line: string, header: string[]): TradeRecord | null {\n    try {\n      const values = this.splitCSVLine(line);\n\n      const record: Record<string, unknown> = {};\n\n      for (let i = 0; i < header.length; i++) {\n        const field = header[i];\n        const value = values[i] || '';\n\n        // Type conversion for known numeric fields\n        if (\n          [\n            'entryPrice',\n            'exitPrice',\n            'quantity',\n            'pnl',\n            'fees',\n            'netPnl',\n            'confidence',\n            'virtualBalanceBefore',\n            'virtualBalanceAfter',\n          ].includes(field)\n        ) {\n          record[field] = parseFloat(value) || 0;\n        } else if (field === 'leverage') {\n          record[field] = parseInt(value) || 10;\n        } else {\n          // Keep as string or try to parse as number for custom fields\n          const unquoted = value.replace(/^\"|\"$/g, '').replace(/\"\"/g, '\"');\n\n          // Try to parse as number if it looks like a number\n          if (!isNaN(Number(unquoted)) && unquoted !== '') {\n            record[field] = parseFloat(unquoted);\n          } else {\n            record[field] = unquoted;\n          }\n        }\n      }\n\n      return record as TradeRecord;\n    } catch (error: unknown) {\n      this.logger.warn('‚ö†Ô∏è Failed to parse CSV line', { line });\n      return null;\n    }\n  }\n\n  /**\n   * Split CSV line handling quoted values\n   */\n  private splitCSVLine(line: string): string[] {\n    const values: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          // Escaped quote\n          current += '\"';\n          i++;\n        } else {\n          // Toggle quotes\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        // End of value\n        values.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    // Add last value\n    values.push(current);\n\n    return values;\n  }\n\n  /**\n   * Get current schema\n   */\n  getCurrentSchema(): string[] {\n    return [...this.currentSchema];\n  }\n\n  /**\n   * Get total number of trades\n   */\n  async getTotalTrades(): Promise<number> {\n    try {\n      const content = fs.readFileSync(this.csvPath, 'utf-8');\n      const lines = content.split('\\n').filter(Boolean);\n      return Math.max(0, lines.length - 1); // Exclude header\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Get statistics from CSV\n   */\n  async getStatistics(): Promise<{\n    totalTrades: number;\n    totalPnL: number;\n    winRate: number;\n    avgPnL: number;\n    byStrategy: { [key: string]: number };\n    bySession: { [key: string]: number };\n  }> {\n    const trades = await this.readAllTrades();\n\n    if (trades.length === 0) {\n      return {\n        totalTrades: 0,\n        totalPnL: 0,\n        winRate: 0,\n        avgPnL: 0,\n        byStrategy: {},\n        bySession: {},\n      };\n    }\n\n    const wins = trades.filter((t) => t.netPnl > 0).length;\n    const totalPnL = trades.reduce((sum, t) => sum + t.netPnl, 0);\n\n    const byStrategy: { [key: string]: number } = {};\n    const bySession: { [key: string]: number } = {};\n\n    for (const trade of trades) {\n      byStrategy[trade.strategy] = (byStrategy[trade.strategy] || 0) + trade.netPnl;\n      bySession[trade.sessionVersion] = (bySession[trade.sessionVersion] || 0) + trade.netPnl;\n    }\n\n    return {\n      totalTrades: trades.length,\n      totalPnL,\n      winRate: (wins / trades.length) * PERCENT_MULTIPLIER,\n      avgPnL: totalPnL / trades.length,\n      byStrategy,\n      bySession,\n    };\n  }\n\n  /**\n   * Get statistics grouped by custom field\n   */\n  async getStatisticsByField(fieldName: string): Promise<{ [key: string]: number }> {\n    const trades = await this.readAllTrades();\n    const stats: { [key: string]: number } = {};\n\n    for (const trade of trades) {\n      const key = String(trade[fieldName] || 'unknown');\n      stats[key] = (stats[key] || 0) + trade.netPnl;\n    }\n\n    return stats;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\trading-journal.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LogLevel' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":68,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":76},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":38,"column":20,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":38,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1369,1377],"text":"(dataPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1369,1377],"text":"(dataPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1369,1377],"text":"(Boolean(dataPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":38,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":38,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1378,1380],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":47,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":47,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1676,1703],"text":"(tradeHistoryConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1676,1703],"text":"(tradeHistoryConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":48,"column":59,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":48,"endColumn":85,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[1765,1791],"text":"(tradeHistoryConfig.dataDir.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[1765,1791],"text":"(tradeHistoryConfig.dataDir !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1765,1791],"text":"(Boolean(tradeHistoryConfig.dataDir))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":51,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":51,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1857,1868],"text":"(baseDeposit != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1857,1868],"text":"(baseDeposit ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1857,1868],"text":"(Boolean(baseDeposit))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 121. Maximum allowed is 120.","line":52,"column":1,"nodeType":"Program","messageId":"max","endLine":52,"endColumn":122},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":52,"column":78,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":52,"endColumn":104,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[1968,1994],"text":"(tradeHistoryConfig.dataDir.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[1968,1994],"text":"(tradeHistoryConfig.dataDir !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1968,1994],"text":"(Boolean(tradeHistoryConfig.dataDir))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":55,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":55,"endColumn":40,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[2078,2078],"text":"void "},"desc":"Add void operator to ignore."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":67,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":67,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2315,2335],"text":"(this.virtualBalance == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":67,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":67,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2339,2357],"text":"(this.tradeHistory == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":139,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":139,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[4442,4452],"text":"(params.id.length === 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[4442,4452],"text":"(params.id === \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4442,4452],"text":"(!Boolean(params.id))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":189,"column":27,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":189,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5762,5802],"text":"((this.virtualBalance?.getCurrentBalance()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5762,5802],"text":"((this.virtualBalance?.getCurrentBalance()) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5762,5802],"text":"(Boolean((this.virtualBalance?.getCurrentBalance())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":189,"column":68,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":189,"endColumn":70,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5803,5805],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.0006.","line":203,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":203,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.0006.","line":204,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":204,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":209,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":209,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6484,6503],"text":"this.virtualBalance != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":213,"column":26,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":213,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6599,6639],"text":"((this.virtualBalance?.getCurrentBalance()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6599,6639],"text":"((this.virtualBalance?.getCurrentBalance()) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6599,6639],"text":"(Boolean((this.virtualBalance?.getCurrentBalance())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":213,"column":67,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":213,"endColumn":69,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6640,6642],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":216,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":216,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6706,6723],"text":"(this.tradeHistory != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":216,"column":30,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":216,"endColumn":62,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6727,6759],"text":"((this.tradeHistoryConfig?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[6727,6759],"text":"((this.tradeHistoryConfig?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":217,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":217,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6781,6819],"text":"(trade.entryCondition.signal.marketData != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":217,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":217,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6820,6822],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":299,"column":14,"nodeType":"CallExpression","messageId":"conditionErrorString","endLine":299,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[10585,10628],"text":"(params.exitCondition.tpLevelsHit.join(', ').length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[10585,10628],"text":"(params.exitCondition.tpLevelsHit.join(', ') !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10585,10628],"text":"(Boolean(params.exitCondition.tpLevelsHit.join(', ')))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":355,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":355,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11871,11884],"text":"(t.realizedPnL != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11871,11884],"text":"(t.realizedPnL ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11871,11884],"text":"(Boolean(t.realizedPnL))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":356,"column":41,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":356,"endColumn":54,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11948,11961],"text":"(t.realizedPnL != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11948,11961],"text":"(t.realizedPnL ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11948,11961],"text":"(Boolean(t.realizedPnL))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":358,"column":55,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":358,"endColumn":68,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12041,12054],"text":"(t.realizedPnL != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12041,12054],"text":"(t.realizedPnL ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12041,12054],"text":"(Boolean(t.realizedPnL))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":358,"column":69,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":358,"endColumn":71,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[12055,12057],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":362,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":362,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12146,12181],"text":"((t.exitCondition?.holdingTimeMinutes) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12146,12181],"text":"((t.exitCondition?.holdingTimeMinutes) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12146,12181],"text":"(Boolean((t.exitCondition?.holdingTimeMinutes)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":362,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":362,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[12182,12184],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":384,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":384,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":385,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":385,"endColumn":39},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 24.","line":388,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":388,"endColumn":36},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":390,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":390,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":400,"column":12,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":400,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13238,13278],"text":"((this.virtualBalance?.getCurrentBalance()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[13238,13278],"text":"((this.virtualBalance?.getCurrentBalance()) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13238,13278],"text":"(Boolean((this.virtualBalance?.getCurrentBalance())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":400,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":400,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[13279,13281],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":414,"column":21,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":414,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13570,13580],"text":"(outputPath != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[13570,13580],"text":"(outputPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13570,13580],"text":"(Boolean(outputPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":414,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":414,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[13581,13583],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (398). Maximum allowed is 300.","line":424,"column":1,"nodeType":null,"messageId":"exceed","endLine":537,"endColumn":1},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 28. Maximum allowed is 10.","line":464,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":512,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":468,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":468,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14878,14892],"text":"(sig.marketData != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":468,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":468,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14893,14895],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":475,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":475,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15064,15106],"text":"((t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[15064,15106],"text":"((t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15064,15106],"text":"(Boolean((t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":475,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":475,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15107,15109],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":490,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":490,"endColumn":29,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16043,16061],"text":"(Boolean(md.swingHighsCount))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":491,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":491,"endColumn":28,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16079,16096],"text":"(Boolean(md.swingLowsCount))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":492,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":492,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16114,16122],"text":"(Boolean(md.trend))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":493,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":493,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[16140,16148],"text":"(Boolean(md.trend))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":495,"column":27,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":495,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":496,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":496,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16245,16247],"text":"(ex != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":497,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":497,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16283,16329],"text":"((t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16283,16329],"text":"((t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16283,16329],"text":"(Boolean((t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":497,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":497,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16330,16332],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":498,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":498,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16347,16393],"text":"((ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16347,16393],"text":"((ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16347,16393],"text":"(Boolean((ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":498,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":498,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16394,16396],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":499,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":499,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16411,16444],"text":"((ex?.holdingTimeMinutes.toFixed(1)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16411,16444],"text":"((ex?.holdingTimeMinutes.toFixed(1)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16411,16444],"text":"(Boolean((ex?.holdingTimeMinutes.toFixed(1))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":499,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":499,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16445,16447],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":500,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":500,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16462,16487],"text":"((ex?.tpLevelsHit.join(';')) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16462,16487],"text":"((ex?.tpLevelsHit.join(';')) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16462,16487],"text":"(Boolean((ex?.tpLevelsHit.join(';'))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":500,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":500,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16488,16490],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":501,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":501,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16505,16525],"text":"((ex?.tpLevelsHitCount) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16505,16525],"text":"((ex?.tpLevelsHitCount) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16505,16525],"text":"(Boolean((ex?.tpLevelsHitCount)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":501,"column":32,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":501,"endColumn":34,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16526,16528],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":502,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":502,"endColumn":25,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[16542,16556],"text":"((ex?.stoppedOut) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[16542,16556],"text":"((ex?.stoppedOut) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":502,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":502,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16557,16559],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":503,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":503,"endColumn":33,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[16577,16599],"text":"((ex?.slMovedToBreakeven) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[16577,16599],"text":"((ex?.slMovedToBreakeven) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":503,"column":34,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":503,"endColumn":36,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16600,16602],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":504,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":504,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[16620,16645],"text":"((ex?.trailingStopActivated) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[16620,16645],"text":"((ex?.trailingStopActivated) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":504,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":504,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16646,16648],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":505,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":505,"endColumn":64,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16666,16719],"text":"((ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16666,16719],"text":"((ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16666,16719],"text":"(Boolean((ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":505,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":505,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16720,16722],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":506,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":506,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16737,16792],"text":"((ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT)) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[16737,16792],"text":"((ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT)) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16737,16792],"text":"(Boolean((ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":506,"column":67,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":506,"endColumn":69,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16793,16795],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":509,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":509,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16880,16890],"text":"(t.closedAt != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16880,16890],"text":"(t.closedAt ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16880,16890],"text":"(Boolean(t.closedAt))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":68,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, TIME_UNITS } from '../constants';\n/**\n * Trading Journal Service\n * Records all trades with complete entry/exit conditions for ML analysis\n *\n * Now integrated with:\n * - TradeHistoryService: permanent CSV storage with dynamic schema\n * - VirtualBalanceService: virtual balance tracking for compound interest\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { TradeRecord, EntryCondition, ExitCondition, PositionSide, LogLevel, LoggerService, TradeHistoryConfig } from '../types';\nimport { TradeHistoryService, TradeRecord as CSVTradeRecord } from './trade-history.service';\nimport { VirtualBalanceService } from './virtual-balance.service';\n\nconst JSON_INDENT = 2;\nconst DATA_DIR = 'data';\nconst JOURNAL_FILE = 'trade-journal.json';\nconst CSV_FILE = 'trade-journal.csv';\n\nexport class TradingJournalService {\n  private trades: Map<string, TradeRecord> = new Map();\n  private readonly journalPath: string;\n  private readonly dataDir: string;\n\n  // NEW: Permanent storage and virtual balance\n  private tradeHistory?: TradeHistoryService;\n  private virtualBalance?: VirtualBalanceService;\n  private sessionVersion: string = 'v2.6';\n\n  constructor(\n    private readonly logger: LoggerService,\n    dataPath?: string,\n    private tradeHistoryConfig?: TradeHistoryConfig,\n    private baseDeposit?: number,\n  ) {\n    this.dataDir = dataPath || path.join(process.cwd(), DATA_DIR);\n    this.journalPath = path.join(this.dataDir, JOURNAL_FILE);\n\n    // Create directory if not exists\n    if (!fs.existsSync(this.dataDir)) {\n      fs.mkdirSync(this.dataDir, { recursive: true });\n    }\n\n    // Initialize trade history (permanent CSV)\n    if (tradeHistoryConfig?.enabled) {\n      this.tradeHistory = new TradeHistoryService(logger, tradeHistoryConfig.dataDir || this.dataDir);\n\n      // Initialize virtual balance\n      if (baseDeposit && baseDeposit > 0) {\n        this.virtualBalance = new VirtualBalanceService(logger, baseDeposit, tradeHistoryConfig.dataDir || this.dataDir);\n\n        // Sync virtual balance from history on startup\n        this.syncVirtualBalanceAsync();\n      }\n    }\n\n    // Load existing journal\n    this.loadJournal();\n  }\n\n  /**\n   * Sync virtual balance from trade history (async)\n   */\n  private async syncVirtualBalanceAsync(): Promise<void> {\n    if (!this.virtualBalance || !this.tradeHistory) {\n      return;\n    }\n\n    try {\n      const allTrades = await this.tradeHistory.readAllTrades();\n      await this.virtualBalance.syncFromHistory(\n        allTrades.map(t => ({ id: t.id, netPnl: t.netPnl })),\n      );\n    } catch (error: unknown) {\n      this.logger.error('‚ùå Failed to sync virtual balance', { error, errorMessage: error instanceof Error ? error.message : String(error) });\n    }\n  }\n\n  /**\n   * Load journal from file\n   */\n  private loadJournal(): void {\n    try {\n      if (fs.existsSync(this.journalPath)) {\n        const data = fs.readFileSync(this.journalPath, 'utf-8');\n        const entries: TradeRecord[] = JSON.parse(data) as TradeRecord[];\n\n        for (const entry of entries) {\n          this.trades.set(entry.id, entry);\n        }\n\n        this.logger.info('üìñ Trade journal loaded', {\n          entriesCount: this.trades.size,\n          path: this.journalPath,\n        });\n      } else {\n        this.logger.info('üìñ Trade journal file not found, creating new', {\n          path: this.journalPath,\n        });\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error('‚ùå Failed to load trade journal', { error: errorMsg });\n    }\n  }\n\n  /**\n   * Save journal to file\n   */\n  private saveJournal(): void {\n    try {\n      const entries = Array.from(this.trades.values());\n      const data = JSON.stringify(entries, null, JSON_INDENT);\n      fs.writeFileSync(this.journalPath, data, 'utf-8');\n\n      this.logger.debug('üíæ Trade journal saved', {\n        entriesCount: entries.length,\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error('‚ùå Failed to save trade journal', { error: errorMsg });\n    }\n  }\n\n  /**\n   * Record trade opening - simplified to serialize entire objects\n   */\n  recordTradeOpen(params: {\n    id: string;\n    symbol: string;\n    side: PositionSide;\n    entryPrice: number;\n    quantity: number;\n    leverage: number;\n    entryCondition: EntryCondition;\n  }): void {\n    if (!params.id || params.id.length === 0) {\n      throw new Error('Trade ID is required');\n    }\n\n    if (this.trades.has(params.id)) {\n      throw new Error(`Trade ${params.id} already exists`);\n    }\n\n    const trade: TradeRecord = {\n      id: params.id,\n      symbol: params.symbol,\n      side: params.side,\n      entryPrice: params.entryPrice,\n      quantity: params.quantity,\n      leverage: params.leverage,\n      entryCondition: params.entryCondition,\n      openedAt: Date.now(),\n      status: 'OPEN',\n    };\n\n    this.trades.set(params.id, trade);\n    this.saveJournal();\n\n    this.logger.info('üìù Trade entry recorded', {\n      id: trade.id,\n      symbol: trade.symbol,\n      side: trade.side,\n      entryPrice: trade.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\n      signal: params.entryCondition.signal.reason,\n      type: params.entryCondition.signal.type,\n      confidence: params.entryCondition.signal.confidence,\n    });\n  }\n\n  /**\n   * Record trade closing\n   */\n  recordTradeClose(params: {\n    id: string;\n    exitPrice: number;\n    exitCondition: ExitCondition;\n    realizedPnL: number;\n  }): void {\n    const trade = this.trades.get(params.id);\n\n    if (trade === undefined) {\n      throw new Error(`Trade ${params.id} not found`);\n    }\n\n    // Get virtual balance BEFORE update\n    const balanceBefore = this.virtualBalance?.getCurrentBalance() || 0;\n\n    // Update trade in memory\n    trade.exitPrice = params.exitPrice;\n    trade.exitCondition = params.exitCondition;\n    trade.realizedPnL = params.realizedPnL;\n    trade.closedAt = Date.now();\n    trade.status = 'CLOSED';\n\n    this.trades.set(params.id, trade);\n    this.saveJournal();\n\n    // Calculate fees (Bybit: 0.06% taker for market orders)\n    const positionValue = trade.quantity * trade.entryPrice;\n    const entryFee = positionValue * 0.0006; // 0.06% entry\n    const exitFee = positionValue * 0.0006; // 0.06% exit\n    const totalFees = entryFee + exitFee;\n    const netPnL = params.realizedPnL - totalFees;\n\n    // Update virtual balance with NET PnL\n    if (this.virtualBalance) {\n      this.virtualBalance.updateBalance(netPnL, params.id);\n    }\n\n    const balanceAfter = this.virtualBalance?.getCurrentBalance() || balanceBefore;\n\n    // Append to permanent CSV history\n    if (this.tradeHistory && this.tradeHistoryConfig?.enabled) {\n      const md = (trade.entryCondition.signal.marketData || {}) as Record<string, unknown>;\n      const duration = this.formatDuration(trade.closedAt - trade.openedAt);\n\n      const csvRecord: CSVTradeRecord = {\n        // Core fields\n        timestamp: new Date(trade.openedAt).toISOString(),\n        id: trade.id,\n        symbol: trade.symbol,\n        side: trade.side,\n        strategy: trade.entryCondition.signal.type,\n        entryPrice: trade.entryPrice,\n        exitPrice: params.exitPrice,\n        quantity: trade.quantity,\n        leverage: trade.leverage,\n        pnl: params.realizedPnL,\n        fees: totalFees,\n        netPnl: netPnL,\n        duration: duration,\n        exitType: params.exitCondition.exitType,\n        confidence: trade.entryCondition.signal.confidence,\n        virtualBalanceBefore: balanceBefore,\n        virtualBalanceAfter: balanceAfter,\n        sessionVersion: this.sessionVersion,\n        notes: trade.entryCondition.signal.reason,\n\n        // Dynamic indicator fields (from marketData)\n        rsi: md.rsi,\n        rsiEntry: md.rsiEntry,\n        rsiTrend1: md.rsiTrend1,\n        ema: md.ema,\n        emaEntry: md.emaEntry,\n        distanceToLevel: md.distanceToLevel,\n        distanceToEma: md.distanceToEma,\n        volumeRatio: md.volumeRatio,\n        swingHighsCount: md.swingHighsCount,\n        swingLowsCount: md.swingLowsCount,\n        trend: md.trend,\n        atr: md.atr,\n        btcCorrelation: md.btcCorrelation,\n        // NEW: Stochastic indicator data\n        stochasticK: (md.stochastic as Record<string, unknown>)?.k,\n        stochasticD: (md.stochastic as Record<string, unknown>)?.d,\n        stochasticOversold: (md.stochastic as Record<string, unknown>)?.isOversold,\n        stochasticOverbought: (md.stochastic as Record<string, unknown>)?.isOverbought,\n        // NEW: Bollinger Bands data\n        bollingerUpper: (md.bollingerBands as Record<string, unknown>)?.upper,\n        bollingerMiddle: (md.bollingerBands as Record<string, unknown>)?.middle,\n        bollingerLower: (md.bollingerBands as Record<string, unknown>)?.lower,\n        bollingerWidth: (md.bollingerBands as Record<string, unknown>)?.width,\n        bollingerPercentB: (md.bollingerBands as Record<string, unknown>)?.percentB,\n        bollingerSqueeze: (md.bollingerBands as Record<string, unknown>)?.isSqueeze,\n\n        // Exit condition details\n        exitReason: params.exitCondition.reason,\n        tpLevelsHit: params.exitCondition.tpLevelsHit.join(';'),\n        tpLevelsHitCount: params.exitCondition.tpLevelsHitCount,\n        stoppedOut: params.exitCondition.stoppedOut,\n        slMovedToBreakeven: params.exitCondition.slMovedToBreakeven,\n        trailingStopActivated: params.exitCondition.trailingStopActivated,\n        maxProfitPercent: params.exitCondition.maxProfitPercent,\n        maxDrawdownPercent: params.exitCondition.maxDrawdownPercent,\n        holdingTimeMinutes: params.exitCondition.holdingTimeMinutes,\n        pnlPercent: params.exitCondition.pnlPercent,\n      };\n\n      this.tradeHistory.appendTrade(csvRecord).catch((error: unknown) => {\n        this.logger.error('‚ùå Failed to append to CSV history', {\n          error: error instanceof Error ? error.message : String(error),\n          tradeId: params.id,\n        });\n      });\n    }\n\n    this.logger.info('üìù Trade exit recorded', {\n      id: trade.id,\n      symbol: trade.symbol,\n      exitType: params.exitCondition.exitType,\n      realizedPnL: params.realizedPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n      netPnL: netPnL.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n      fees: totalFees.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n      pnlPercent: params.exitCondition.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\n      holdingTime: params.exitCondition.holdingTimeMinutes.toFixed(1) + ' min',\n      tpHit: params.exitCondition.tpLevelsHit.join(', ') || 'none',\n      virtualBalance: balanceAfter.toFixed(DECIMAL_PLACES.PERCENT) + ' USDT',\n    });\n  }\n\n  /**\n   * Get trade by ID\n   */\n  getTrade(id: string): TradeRecord | undefined {\n    return this.trades.get(id);\n  }\n\n  /**\n   * Get all trades\n   */\n  getAllTrades(): TradeRecord[] {\n    return Array.from(this.trades.values());\n  }\n\n  /**\n   * Get open trades\n   */\n  getOpenTrades(): TradeRecord[] {\n    return this.getAllTrades().filter((t) => t.status === 'OPEN');\n  }\n\n  /**\n   * Get open position by symbol\n   * Used for restoring position state from WebSocket\n   */\n  getOpenPositionBySymbol(symbol: string): TradeRecord | undefined {\n    return this.getOpenTrades().find((t) => t.symbol === symbol);\n  }\n\n  /**\n   * Get closed trades\n   */\n  getClosedTrades(): TradeRecord[] {\n    return this.getAllTrades().filter((t) => t.status === 'CLOSED');\n  }\n\n  /**\n   * Get statistics\n   */\n  getStatistics(): {\n    totalTrades: number;\n    openTrades: number;\n    closedTrades: number;\n    winningTrades: number;\n    losingTrades: number;\n    totalPnL: number;\n    averagePnL: number;\n    winRate: number;\n    averageHoldingTimeMinutes: number;\n    } {\n    const closed = this.getClosedTrades();\n    const winning = closed.filter((t) => t.realizedPnL && t.realizedPnL > 0);\n    const losing = closed.filter((t) => t.realizedPnL && t.realizedPnL <= 0);\n\n    const totalPnL = closed.reduce((sum, t) => sum + (t.realizedPnL || 0), 0);\n\n    const averageHoldingTime =\n      closed.reduce(\n        (sum, t) => sum + (t.exitCondition?.holdingTimeMinutes || 0),\n        0,\n      ) / (closed.length > 0 ? closed.length : 1);\n\n    return {\n      totalTrades: this.trades.size,\n      openTrades: this.getOpenTrades().length,\n      closedTrades: closed.length,\n      winningTrades: winning.length,\n      losingTrades: losing.length,\n      totalPnL,\n      averagePnL: closed.length > 0 ? totalPnL / closed.length : 0,\n      winRate: closed.length > 0 ? winning.length / closed.length : 0,\n      averageHoldingTimeMinutes: averageHoldingTime,\n    };\n  }\n\n  /**\n   * Format duration in human-readable format\n   */\n  private formatDuration(durationMs: number): string {\n    const minutes = Math.floor(durationMs / TIME_UNITS.MINUTE);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) {\n      return `${days}d ${hours % 24}h`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else {\n      return `${minutes}m`;\n    }\n  }\n\n  /**\n   * Get virtual balance (for compound interest calculation)\n   */\n  getVirtualBalance(): number {\n    return this.virtualBalance?.getCurrentBalance() || 0;\n  }\n\n  /**\n   * Get virtual balance service (for external access)\n   */\n  getVirtualBalanceService(): VirtualBalanceService | undefined {\n    return this.virtualBalance;\n  }\n\n  /**\n   * Export to CSV for ML analysis\n   */\n  exportToCSV(outputPath?: string): void {\n    const csvPath = outputPath || path.join(this.dataDir, CSV_FILE);\n\n    try {\n      const entries = Array.from(this.trades.values());\n\n      // CSV header\n      const header = [\n        'ID',\n        'Symbol',\n        'Side',\n        'Entry Price',\n        'Exit Price',\n        'Quantity',\n        'Leverage',\n        // Entry conditions\n        'Signal Type',\n        'Signal Reason',\n        'Confidence',\n        'RSI',\n        'RSI Entry',\n        'RSI Trend1',\n        'EMA',\n        'EMA Entry',\n        'Distance to Level %',\n        'Distance to EMA %',\n        'Volume Multiplier',\n        'Swing Highs',\n        'Swing Lows',\n        'Trend',\n        'Market Condition',\n        // Exit conditions\n        'Exit Type',\n        'Exit Reason',\n        'Realized PnL USDT',\n        'PnL %',\n        'Holding Time Min',\n        'TP Levels Hit',\n        'TP Count',\n        'Stopped Out',\n        'SL to Breakeven',\n        'Trailing Activated',\n        'Max Profit %',\n        'Max Drawdown %',\n        // Timestamps\n        'Opened At',\n        'Closed At',\n        'Status',\n      ].join(',');\n\n      // CSV rows - simplified to work with new structure\n      const rows = entries.map((t) => {\n        const ec = t.entryCondition;\n        const ex = t.exitCondition;\n        const sig = ec.signal;\n        const md = (sig.marketData || {}) as Record<string, unknown>;\n\n        return [\n          t.id,\n          t.symbol,\n          t.side,\n          t.entryPrice.toFixed(DECIMAL_PLACES.PRICE),\n          t.exitPrice?.toFixed(DECIMAL_PLACES.PRICE) || '',\n          t.quantity,\n          t.leverage,\n          // Entry - from Signal object\n          sig.type,\n          `\"${sig.reason}\"`,\n          sig.confidence,\n          typeof md.rsi === 'number' ? md.rsi.toFixed(DECIMAL_PLACES.PERCENT) : '',\n          typeof md.rsiEntry === 'number' ? md.rsiEntry.toFixed(DECIMAL_PLACES.PERCENT) : '',\n          typeof md.rsiTrend1 === 'number' ? md.rsiTrend1.toFixed(DECIMAL_PLACES.PERCENT) : '',\n          typeof md.ema === 'number' ? md.ema.toFixed(DECIMAL_PLACES.PRICE) : '',\n          typeof md.emaEntry === 'number' ? md.emaEntry.toFixed(DECIMAL_PLACES.PRICE) : '',\n          typeof md.distanceToLevel === 'number' ? md.distanceToLevel.toFixed(DECIMAL_PLACES.PERCENT) : '',\n          typeof md.distanceToEma === 'number' ? md.distanceToEma.toFixed(DECIMAL_PLACES.PERCENT) : '',\n          typeof md.volumeRatio === 'number' ? md.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT) : '',\n          md.swingHighsCount || '',\n          md.swingLowsCount || '',\n          md.trend || '',\n          md.trend || '', // marketCondition\n          // Exit\n          ((ex?.exitType) != null) || '',\n          ex ? `\"${ex.reason}\"` : '',\n          t.realizedPnL?.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          ex?.pnlPercent.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          ex?.holdingTimeMinutes.toFixed(1) || '',\n          ex?.tpLevelsHit.join(';') || '',\n          ex?.tpLevelsHitCount || 0,\n          ex?.stoppedOut || false,\n          ex?.slMovedToBreakeven || false,\n          ex?.trailingStopActivated || false,\n          ex?.maxProfitPercent?.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          ex?.maxDrawdownPercent?.toFixed(DECIMAL_PLACES.PERCENT) || '',\n          // Timestamps\n          new Date(t.openedAt).toISOString(),\n          t.closedAt ? new Date(t.closedAt).toISOString() : '',\n          t.status,\n        ].join(',');\n      });\n\n      const csv = [header, ...rows].join('\\n');\n      fs.writeFileSync(csvPath, csv, 'utf-8');\n\n      this.logger.info('üìä Trade journal exported to CSV', {\n        path: csvPath,\n        entries: entries.length,\n      });\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error('‚ùå Failed to export trade journal to CSV', {\n        error: errorMsg,\n      });\n    }\n  }\n\n  /**\n   * Clear all trades (for testing)\n   */\n  clear(): void {\n    this.trades.clear();\n    this.saveJournal();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\trading-orchestrator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TakeProfit' is defined but never used. Allowed unused vars must match /^_/u.","line":32,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TrendFollowingConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":45,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LevelBasedConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":46,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CounterTrendConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":47,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":47,"endColumn":21},{"ruleId":"complexity","severity":1,"message":"Constructor has a complexity of 35. Maximum allowed is 10.","line":242,"column":14,"nodeType":"FunctionExpression","messageId":"complex","endLine":673,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":296,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":296,"endColumn":47,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[11704,11742],"text":"(config.indicators?.stochastic?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[11704,11742],"text":"(config.indicators?.stochastic?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":311,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":311,"endColumn":51,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12208,12250],"text":"(config.indicators?.bollingerBands?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12208,12250],"text":"(config.indicators?.bollingerBands?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":329,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":329,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12884,12912],"text":"(config.weightMatrix?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12884,12912],"text":"(config.weightMatrix?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":383,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":383,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[14949,14976],"text":"(config.whaleHunter?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[14949,14976],"text":"(config.whaleHunter?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (1423). Maximum allowed is 300.","line":389,"column":1,"nodeType":null,"messageId":"exceed","endLine":1875,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":414,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":414,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[15929,15962],"text":"(config.whaleHunterFollow?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[15929,15962],"text":"(config.whaleHunterFollow?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":451,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":451,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[17184,17217],"text":"(config.scalpingMicroWall?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[17184,17217],"text":"(config.scalpingMicroWall?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":475,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":475,"endColumn":43,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[17993,18027],"text":"(config.scalpingLimitOrder?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[17993,18027],"text":"(config.scalpingLimitOrder?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":495,"column":73,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":495,"endColumn":96,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18841,18865],"text":"(config.scalpingLadderTp == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":496,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":496,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[18925,18957],"text":"(config.scalpingLadderTp?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[18925,18957],"text":"(config.scalpingLadderTp?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":516,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":516,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[19740,19773],"text":"(config.scalpingTickDelta?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[19740,19773],"text":"(config.scalpingTickDelta?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":535,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":535,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[20417,20450],"text":"(config.scalpingOrderFlow?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[20417,20450],"text":"(config.scalpingOrderFlow?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":559,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":559,"endColumn":40,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[21306,21337],"text":"(config.btcConfirmation?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[21306,21337],"text":"(config.btcConfirmation?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":568,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":568,"endColumn":42,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[21647,21680],"text":"(config.fundingRateFilter?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[21647,21680],"text":"(config.fundingRateFilter?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":582,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":582,"endColumn":44,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[22323,22358],"text":"(config.flatMarketDetection?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[22323,22358],"text":"(config.flatMarketDetection?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":593,"column":29,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":593,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22915,22931],"text":"(fastEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":593,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":593,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[22932,22934],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":594,"column":34,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":594,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22975,22996],"text":"(smartBreakevenService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":594,"column":56,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":594,"endColumn":58,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[22997,22999],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":595,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":595,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23037,23055],"text":"(retestEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":595,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":595,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23056,23058],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":598,"column":33,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":598,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23150,23170],"text":"(deltaAnalyzerService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":598,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":598,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23171,23173],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":599,"column":38,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":599,"endColumn":63,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23218,23243],"text":"(orderbookImbalanceService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":599,"column":64,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":599,"endColumn":66,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23244,23246],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":602,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":602,"endColumn":38,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[23326,23355],"text":"(config.volumeProfile?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[23326,23355],"text":"(config.volumeProfile?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":612,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":612,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23800,23818],"text":"(dailyLimitsService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":612,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":612,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23819,23821],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":613,"column":35,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":613,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23863,23885],"text":"(riskBasedSizingService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":613,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":613,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23886,23888],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":614,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":614,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23925,23942],"text":"(lossStreakService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":614,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":614,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[23943,23945],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":615,"column":37,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":615,"endColumn":61,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23989,24013],"text":"(maxConcurrentRiskService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":615,"column":62,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":615,"endColumn":64,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[24014,24016],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":617,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":617,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24034,24055],"text":"this.fastEntryService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":625,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":625,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24335,24361],"text":"this.smartBreakevenService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":633,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":633,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24684,24707],"text":"this.retestEntryService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":636,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":636,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24860,24878],"text":"(config.retestEntry != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":641,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":641,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25066,25091],"text":"this.deltaAnalyzerService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":648,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":648,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25309,25332],"text":"this.dailyLimitsService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":656,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":656,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25640,25667],"text":"this.riskBasedSizingService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":664,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":664,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26001,26023],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Async method 'onCandleClosed' has a complexity of 60. Maximum allowed is 10.","line":698,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":1054,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":726,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":726,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28248,28268],"text":"this.currentContext == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":733,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":733,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28512,28527],"text":"currentPosition != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":736,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":758,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":736,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":736,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28704,28727],"text":"(this.bollingerIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":736,"column":42,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":736,"endColumn":89,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[28731,28778],"text":"((this.config.indicators?.bollingerBands?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[28731,28778],"text":"((this.config.indicators?.bollingerBands?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":737,"column":13,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":757,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":740,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":740,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[28983,29027],"text":"(this.config.indicators.bollingerBands.period !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[28983,29027],"text":"(!Number.isNaN(this.config.indicators.bollingerBands.period))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28983,29027],"text":"(Boolean(this.config.indicators.bollingerBands.period))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":740,"column":80,"nodeType":"Literal","messageId":"noMagic","endLine":740,"endColumn":82},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":741,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":752,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":746,"column":29,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":746,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[29307,29338],"text":"((this.currentContext?.atrPercent) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[29307,29338],"text":"(!Number.isNaN((this.currentContext?.atrPercent)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[29307,29338],"text":"(Boolean((this.currentContext?.atrPercent)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":763,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":796,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":763,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":763,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30114,30140],"text":"(this.smartBreakevenService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":763,"column":45,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":763,"endColumn":80,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[30144,30179],"text":"((this.config.smartBreakeven?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[30144,30179],"text":"((this.config.smartBreakeven?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":765,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":795,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":765,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":765,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[30288,30293],"text":"(state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":765,"column":26,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":765,"endColumn":49,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[30312,30320],"text":"BreakevenMode.PRE_BE"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":766,"column":15,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":794,"endColumn":16},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 3.","line":768,"column":17,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":789,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":772,"column":60,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":772,"endColumn":63},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":783,"column":27,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":783,"endColumn":68,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31245,31286],"text":"this.positionManager.getCurrentPosition() != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":801,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":841,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":801,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":801,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32070,32093],"text":"(this.retestEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":801,"column":42,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":801,"endColumn":74,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[32097,32129],"text":"((this.config.retestEntry?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[32097,32129],"text":"((this.config.retestEntry?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":803,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":840,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":803,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":803,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32239,32243],"text":"zone != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":804,"column":15,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":839,"endColumn":16},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":809,"column":58,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":809,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":814,"column":39,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":814,"endColumn":48},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 3.","line":827,"column":17,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":834,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":827,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":827,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":853,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":853,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[34557,34572],"text":"confirmedSignal != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":872,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":872,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[35353,35364],"text":"marketData == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":881,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":881,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[35821,35844],"text":"(this.flatMarketDetector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":881,"column":40,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":881,"endColumn":59},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":882,"column":11,"nodeType":"TryStatement","messageId":"tooDeeply","endLine":896,"endColumn":12},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":886,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":893,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":886,"column":46,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":886,"endColumn":56},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":901,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":901,"endColumn":54,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[36675,36693],"text":"((flatResult?.isFlat) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[36675,36693],"text":"((flatResult?.isFlat) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":901,"column":58,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":901,"endColumn":101,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[36697,36740],"text":"((this.config.weightMatrix?.minConfidenceFlat) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[36697,36740],"text":"((this.config.weightMatrix?.minConfidenceFlat) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[36697,36740],"text":"(Boolean((this.config.weightMatrix?.minConfidenceFlat)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":903,"column":13,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":903,"endColumn":59,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[36810,36856],"text":"((this.config.weightMatrix?.minConfidenceToEnter) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[36810,36856],"text":"((this.config.weightMatrix?.minConfidenceToEnter) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[36810,36856],"text":"(Boolean((this.config.weightMatrix?.minConfidenceToEnter)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":903,"column":60,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":903,"endColumn":62,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[36857,36859],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":903,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":903,"endColumn":65},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":908,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":908,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[37027,37045],"text":"((flatResult?.isFlat) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[37027,37045],"text":"((flatResult?.isFlat) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":911,"column":19,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":911,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[37206,37224],"text":"((flatResult?.isFlat) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[37206,37224],"text":"((flatResult?.isFlat) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":926,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":926,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[37860,37874],"text":"(strategySignal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":926,"column":55,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":926,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[37902,37923],"text":"(strategySignal.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":939,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":963,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":939,"column":15,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":939,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[38615,38625],"text":"flatResult != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":940,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":962,"endColumn":14},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":971,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":997,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":971,"column":36,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":971,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[40248,40256],"text":"(keyLevel != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[40248,40256],"text":"(keyLevel ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[40248,40256],"text":"(Boolean(keyLevel))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":1007,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":1007,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[42000,42021],"text":"(strategySignal.reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[42000,42021],"text":"(strategySignal.reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[42000,42021],"text":"(Boolean(strategySignal.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1007,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1007,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[42022,42024],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1029,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1043,"endColumn":12},{"ruleId":"complexity","severity":1,"message":"Async method 'executeTrade' has a complexity of 56. Maximum allowed is 10.","line":1061,"column":29,"nodeType":"FunctionExpression","messageId":"complex","endLine":1399,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1071,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1071,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[44719,44742],"text":"this.dailyLimitsService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1082,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1082,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[45068,45090],"text":"this.lossStreakService != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1101,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1101,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[45786,45809],"text":"(this.retestEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1101,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1101,"endColumn":70,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[45813,45845],"text":"((this.config.retestEntry?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[45813,45845],"text":"((this.config.retestEntry?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1104,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1136,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":1104,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":1104,"endColumn":40},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":1113,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1135,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":1116,"column":24,"nodeType":"TSAsExpression","messageId":"conditionErrorOther","endLine":1116,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1145,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1145,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47552,47568],"text":"(this.btcAnalyzer != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1145,"column":31,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1145,"endColumn":67,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[47572,47608],"text":"((this.config.btcConfirmation?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[47572,47608],"text":"((this.config.btcConfirmation?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1148,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1148,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[47702,47713],"text":"(btcAnalysis != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1159,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1159,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48181,48192],"text":"btcAnalysis != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1170,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1170,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48563,48585],"text":"(this.fundingRateFilter != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1170,"column":37,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1170,"endColumn":75,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[48589,48627],"text":"((this.config.fundingRateFilter?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[48589,48627],"text":"((this.config.fundingRateFilter?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1177,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1177,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[48952,48976],"text":"(filterResult.fundingRate != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[48952,48976],"text":"(filterResult.fundingRate ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[48952,48976],"text":"(Boolean(filterResult.fundingRate))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1186,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1186,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[49295,49319],"text":"(filterResult.fundingRate != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[49295,49319],"text":"(filterResult.fundingRate ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[49295,49319],"text":"(Boolean(filterResult.fundingRate))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected value in conditional. A boolean expression is required.","line":1194,"column":16,"nodeType":"TSAsExpression","messageId":"conditionErrorOther","endLine":1194,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1224,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1224,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[50621,50631],"text":"marketData != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1260,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1260,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[51888,51908],"text":"(marketData.liquidity != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1298,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1298,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[53320,53341],"text":"(this.fastEntryService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1298,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1298,"endColumn":66,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[53345,53375],"text":"((this.config.fastEntry?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[53345,53375],"text":"((this.config.fastEntry?.enabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1304,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1359,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1304,"column":100,"nodeType":"Literal","messageId":"noMagic","endLine":1304,"endColumn":101},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":1308,"column":54,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":1308,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":1313,"column":72,"nodeType":"Literal","messageId":"noMagic","endLine":1313,"endColumn":73},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 3.","line":1326,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1358,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'remainingSize' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1329,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":1329,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'partialQty' is defined but never used. Allowed unused args must match /^_/u.","line":1335,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":1335,"endColumn":34},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 3.","line":1352,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1357,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1352,"column":19,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1352,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[55705,55712],"text":"partial != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1378,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1378,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[56747,56760],"text":"this.telegram != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1409,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1409,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[57867,57887],"text":"this.currentContext == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1415,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":1415,"endColumn":24},{"ruleId":"complexity","severity":1,"message":"Async method 'prepareMarketData' has a complexity of 35. Maximum allowed is 10.","line":1452,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":1686,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1456,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":1456,"endColumn":26},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1456,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":1456,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 14.","line":1488,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":1488,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":1490,"column":28,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":1490,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":1491,"column":98,"nodeType":"Literal","messageId":"noMagic","endLine":1491,"endColumn":100},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1500,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1500,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[61836,61860],"text":"(this.stochasticIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1500,"column":39,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":1500,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[61864,61898],"text":"((this.config.indicators?.stochastic) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1512,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1526,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1534,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1534,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[63386,63409],"text":"(this.bollingerIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1534,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":1534,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[63413,63451],"text":"((this.config.indicators?.bollingerBands) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1537,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1553,"endColumn":12},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.5.","line":1542,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":1542,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":1543,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1543,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.15.","line":1570,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1570,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.85.","line":1571,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":1571,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":1572,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":1572,"endColumn":39},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (4). Maximum allowed is 3.","line":1576,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1596,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1604,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1604,"endColumn":36,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[66753,66778],"text":"(bollingerBands?.isSqueeze) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[66753,66778],"text":"(bollingerBands?.isSqueeze) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -20.","line":1607,"column":54,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":1607,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1638,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1638,"endColumn":41,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[68205,68235],"text":"(this.orderbookImbalanceService != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1638,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1638,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[68239,68260],"text":"(this.currentOrderbook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1670,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1670,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[69292,69313],"text":"(this.currentOrderbook != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.9.","line":1697,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1697,"endColumn":55},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 500.","line":1714,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":1714,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":1719,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":1719,"endColumn":34},{"ruleId":"complexity","severity":1,"message":"Async method 'analyzeBTC' has a complexity of 13. Maximum allowed is 10.","line":1738,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":1780,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1739,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1739,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[71481,71498],"text":"(this.btcAnalyzer == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1739,"column":31,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":1739,"endColumn":67,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[71503,71539],"text":"((this.config.btcConfirmation?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[71502,71539],"text":"((this.config.btcConfirmation?.enabled) === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1750,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1750,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[71815,71836],"text":"(btcConfig.candleLimit !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[71815,71836],"text":"(!Number.isNaN(btcConfig.candleLimit))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[71815,71836],"text":"(Boolean(btcConfig.candleLimit))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1750,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":1750,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":1753,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":1753,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1753,"column":47,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1753,"endColumn":72,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[71903,71928],"text":"(btcConfig.lookbackCandles !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[71903,71928],"text":"(!Number.isNaN(btcConfig.lookbackCandles))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[71903,71928],"text":"(Boolean(btcConfig.lookbackCandles))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":1753,"column":76,"nodeType":"Literal","messageId":"noMagic","endLine":1753,"endColumn":78},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1755,"column":22,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":1755,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[72028,72046],"text":"((btcCandles?.length) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[72028,72046],"text":"(!Number.isNaN((btcCandles?.length)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[72028,72046],"text":"(Boolean((btcCandles?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":1756,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNumber","endLine":1756,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[72074,72099],"text":"(btcConfig.lookbackCandles !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[72074,72099],"text":"(!Number.isNaN(btcConfig.lookbackCandles))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[72074,72099],"text":"(Boolean(btcConfig.lookbackCandles))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":1756,"column":50,"nodeType":"Literal","messageId":"noMagic","endLine":1756,"endColumn":52},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":1763,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":1763,"endColumn":35,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[72266,72290],"text":"btcConfig.useCorrelation ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[72266,72290],"text":"btcConfig.useCorrelation === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":1766,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":1766,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[72397,72424],"text":"(btcConfig.correlationPeriod != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[72397,72424],"text":"(btcConfig.correlationPeriod ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[72397,72424],"text":"(Boolean(btcConfig.correlationPeriod))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1766,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1766,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[72425,72427],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1766,"column":42,"nodeType":"Literal","messageId":"noMagic","endLine":1766,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1805,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1805,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[73695,73709],"text":"whaleStrategy == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1810,"column":11,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":1810,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[73818,73859],"text":"this.positionManager.getCurrentPosition() != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1815,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1815,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[73961,73981],"text":"this.currentContext == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1822,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":1822,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[74297,74308],"text":"marketData == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":1830,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":1830,"endColumn":56,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[74555,74576],"text":"(strategySignal.signal != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":1846,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":1846,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[75304,75325],"text":"(strategySignal.reason != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[75304,75325],"text":"(strategySignal.reason ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[75304,75325],"text":"(Boolean(strategySignal.reason))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1846,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1846,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[75326,75328],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":153,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Trading Orchestrator\r\n *\r\n * The \"brain\" of the trading system. Coordinates:\r\n * - Context analysis (PRIMARY/TREND timeframes)\r\n * - Entry scanning (ENTRY timeframe)\r\n * - Trade execution\r\n *\r\n * Flow:\r\n * 1. PRIMARY candle closes ‚Üí Update context\r\n * 2. ENTRY candle closes ‚Üí Scan for entries using context\r\n * 3. Entry found ‚Üí Execute trade\r\n */\r\n\r\nimport {\r\n  TradingContext,\r\n  EntrySignal,\r\n  TimeframeRole,\r\n  Candle,\r\n  LoggerService,\r\n  SignalType,\r\n  Signal,\r\n  ContextFilteringMode,\r\n  StrategyMarketData,\r\n  SignalDirection,\r\n  BTCConfirmationConfig,\r\n  BTCAnalysis,\r\n  FundingRateFilterConfig,\r\n  SessionBasedSLConfig,\r\n  FlatMarketConfig,\r\n  TakeProfit,\r\n  SessionEntryCondition,\r\n  IndicatorSnapshot,\r\n  PatternSnapshot,\r\n  LevelSnapshot,\r\n  ContextSnapshot,\r\n  DailyLimitsConfig,\r\n  RiskBasedSizingConfig,\r\n  IStrategy,\r\n  OrderBook,\r\n  OrderbookLevel,\r\n  LossStreakConfig,\r\n  StrategiesConfig,\r\n  TrendFollowingConfig,\r\n  LevelBasedConfig,\r\n  CounterTrendConfig,\r\n  WhaleHunterConfig,\r\n  Config,\r\n  ScalpingMicroWallConfig,\r\n  ScalpingLimitOrderConfig,\r\n  ScalpingLadderTpConfig,\r\n  ScalpingTickDeltaConfig,\r\n  ScalpingOrderFlowConfig,\r\n  IndicatorsConfig,\r\n  FastEntryConfig,\r\n  SmartBreakevenConfig,\r\n  RetestConfig,\r\n  WeightMatrixConfig,\r\n  DeltaConfig,\r\n  OrderbookImbalanceConfig,\r\n  VolumeProfileConfig,\r\n} from '../types';\r\nimport { ContextAnalyzer } from '../analyzers/context.analyzer';\r\nimport { EntryScanner } from '../analyzers/entry.scanner';\r\nimport { CandleProvider } from '../providers/candle.provider';\r\nimport { BybitService } from './bybit';\r\nimport { PositionManagerService } from './position-manager.service';\r\nimport { TelegramService } from './telegram.service';\r\nimport { StrategyCoordinator } from './strategy-coordinator.service';\r\nimport { TrendFollowingStrategy } from '../strategies/trend-following.strategy';\r\nimport { LevelBasedStrategy } from '../strategies/level-based.strategy';\r\nimport { CounterTrendStrategy } from '../strategies/counter-trend.strategy';\r\nimport { WhaleHunterStrategy } from '../strategies/whale-hunter.strategy';\r\nimport { WhaleHunterFollowStrategy } from '../strategies/whale-hunter-follow.strategy';\r\nimport { ScalpingMicroWallStrategy } from '../strategies/scalping-micro-wall.strategy';\r\nimport { ScalpingLimitOrderStrategy } from '../strategies/scalping-limit-order.strategy';\r\nimport { ScalpingLadderTpStrategy } from '../strategies/scalping-ladder-tp.strategy';\r\nimport { ScalpingTickDeltaStrategy } from '../strategies/scalping-tick-delta.strategy';\r\nimport { ScalpingOrderFlowStrategy } from '../strategies/scalping-order-flow.strategy';\r\nimport { WhaleDetectorService } from './whale-detector.service';\r\nimport { WhaleDetectorFollowService } from './whale-detector-follow.service';\r\nimport { MicroWallDetectorService } from './micro-wall-detector.service';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { RSIIndicator } from '../indicators/rsi.indicator';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { StochasticIndicator } from '../indicators/stochastic.indicator';\r\nimport { BollingerBandsIndicator } from '../indicators/bollinger.indicator';\r\nimport { LiquidityDetector } from '../analyzers/liquidity.detector';\r\nimport { DivergenceDetector } from '../analyzers/divergence.detector';\r\nimport { BTCAnalyzer } from '../analyzers/btc.analyzer';\r\nimport { BreakoutPredictor } from '../analyzers/breakout-predictor';\r\nimport { MultiTimeframeRSIAnalyzer } from '../analyzers/multi-timeframe-rsi.analyzer';\r\nimport { MultiTimeframeEMAAnalyzer } from '../analyzers/multi-timeframe-ema.analyzer';\r\nimport { TimeframeProvider } from '../providers/timeframe.provider';\r\nimport { FundingRateFilterService } from './funding-rate-filter.service';\r\nimport { FlatMarketDetector } from '../analyzers/flat-market.detector';\r\nimport { FastEntryService } from './fast-entry.service';\r\nimport { SmartBreakevenService } from './smart-breakeven.service';\r\nimport { RetestEntryService } from './retest-entry.service';\r\nimport { WeightMatrixCalculatorService } from './weight-matrix-calculator.service';\r\nimport { DeltaAnalyzerService } from './delta-analyzer.service';\r\nimport { OrderbookImbalanceService } from './orderbook-imbalance.service';\r\nimport { VolumeProfileService } from './volume-profile.service';\r\nimport { DailyLimitsService } from './daily-limits.service';\r\nimport { RiskBasedSizingService } from './risk-based-sizing.service';\r\nimport { LossStreakService } from './loss-streak.service';\r\nimport { MaxConcurrentRiskService } from './max-concurrent-risk.service';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface OrchestratorConfig {\r\n  // Context config (PRIMARY)\r\n  contextConfig: {\r\n    atrPeriod: number;\r\n    emaPeriod: number;\r\n    zigzagDepth: number;\r\n    minimumATR: number;\r\n    maximumATR: number;\r\n    maxEmaDistance: number;\r\n    filteringMode: ContextFilteringMode;\r\n  };\r\n  // Entry config (ENTRY)\r\n  entryConfig: {\r\n    rsiPeriod: number;\r\n    fastEmaPeriod: number;\r\n    slowEmaPeriod: number;\r\n    zigzagDepth: number;\r\n    rsiOversold: number;\r\n    rsiOverbought: number;\r\n    stopLossPercent: number;\r\n    takeProfits: Array<{ level: number; percent: number; sizePercent: number }>;\r\n    priceAction?: {\r\n      enabled: boolean;\r\n      requireLiquiditySweep?: boolean;\r\n      divergenceBoost?: number;\r\n      chochBoost?: number;\r\n      liquiditySweepBoost?: number;\r\n    };\r\n  };\r\n  // Strategies config (NEW - no more magic numbers!)\r\n  strategiesConfig?: StrategiesConfig;\r\n  // Position config\r\n  positionSizeUsdt: number;\r\n  leverage: number;\r\n  // BTC confirmation config\r\n  btcConfirmation?: BTCConfirmationConfig;\r\n  // Whale hunter config\r\n  whaleHunter?: WhaleHunterConfig;\r\n  levelBased?: Config;\r\n  whaleHunterFollow?: WhaleHunterConfig;\r\n  scalpingMicroWall?: ScalpingMicroWallConfig;\r\n  scalpingLimitOrder?: ScalpingLimitOrderConfig;\r\n  scalpingLadderTp?: ScalpingLadderTpConfig;\r\n  scalpingTickDelta?: ScalpingTickDeltaConfig;\r\n  scalpingOrderFlow?: ScalpingOrderFlowConfig;\r\n  // Funding rate filter config\r\n  fundingRateFilter?: FundingRateFilterConfig;\r\n  // Session-based SL config\r\n  sessionBasedSL?: SessionBasedSLConfig;\r\n  // Flat market detection config\r\n  flatMarketDetection?: FlatMarketConfig;\r\n  // Indicators config (for Stochastic and Bollinger Bands)\r\n  indicators?: IndicatorsConfig;\r\n  // Phase 1: Smart Entry & Breakeven config\r\n  fastEntry?: FastEntryConfig;\r\n  smartBreakeven?: SmartBreakevenConfig;\r\n  retestEntry?: RetestConfig;\r\n  // Phase 2: Weight Matrix config\r\n  weightMatrix?: WeightMatrixConfig;\r\n  // Phase 4: Market Data Enhancement config\r\n  delta?: DeltaConfig;\r\n  orderbookImbalance?: OrderbookImbalanceConfig;\r\n  volumeProfile?: VolumeProfileConfig;\r\n  // Phase 5: Risk Management config\r\n  dailyLimits?: DailyLimitsConfig;\r\n  riskBasedSizing?: RiskBasedSizingConfig;\r\n  lossStreak?: LossStreakConfig;\r\n  // System config\r\n  system: {\r\n    timeSyncIntervalMs: number;\r\n    timeSyncMaxFailures: number;\r\n  };\r\n  // EntryScanner fallback (default: true for backward compatibility)\r\n  enableEntryScannerFallback?: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// TRADING ORCHESTRATOR\r\n// ============================================================================\r\n\r\nexport class TradingOrchestrator {\r\n  private contextAnalyzer: ContextAnalyzer;\r\n  private entryScanner: EntryScanner;\r\n  private strategyCoordinator: StrategyCoordinator;\r\n  private currentContext: TradingContext | null = null;\r\n\r\n  // Multi-timeframe analyzers\r\n  private rsiAnalyzer: MultiTimeframeRSIAnalyzer;\r\n  private emaAnalyzer: MultiTimeframeEMAAnalyzer;\r\n\r\n  // Single-timeframe indicators (still needed for specific tasks)\r\n  private atrIndicator: ATRIndicator;\r\n  private zigzagIndicator: ZigZagIndicator;\r\n  private stochasticIndicator?: StochasticIndicator;\r\n  private bollingerIndicator?: BollingerBandsIndicator;\r\n  private liquidityDetector: LiquidityDetector;\r\n  private divergenceDetector: DivergenceDetector;\r\n  private breakoutPredictor: BreakoutPredictor;\r\n\r\n  // BTC confirmation\r\n  private btcAnalyzer: BTCAnalyzer | null = null;\r\n\r\n  // Funding rate filter\r\n  private fundingRateFilter: FundingRateFilterService | null = null;\r\n\r\n  // Flat market detector\r\n  private flatMarketDetector: FlatMarketDetector | null = null;\r\n\r\n  // Phase 1: Smart Entry & Breakeven services\r\n  private fastEntryService: FastEntryService | null = null;\r\n  private smartBreakevenService: SmartBreakevenService | null = null;\r\n  private retestEntryService: RetestEntryService | null = null;\r\n\r\n  // Phase 4: Market Data Enhancement services\r\n  private deltaAnalyzerService: DeltaAnalyzerService | null = null;\r\n  private orderbookImbalanceService: OrderbookImbalanceService | null = null;\r\n  private volumeProfileService: VolumeProfileService | null = null;\r\n\r\n  // Phase 5: Risk Management services\r\n  private dailyLimitsService: DailyLimitsService | null = null;\r\n  private riskBasedSizingService: RiskBasedSizingService | null = null;\r\n  private lossStreakService: LossStreakService | null = null;\r\n  private maxConcurrentRiskService: MaxConcurrentRiskService | null = null;\r\n\r\n  // Orderbook data (for whale detection)\r\n  private currentOrderbook: OrderBook | null = null;\r\n\r\n  constructor(\r\n    private config: OrchestratorConfig,\r\n    private candleProvider: CandleProvider,\r\n    private timeframeProvider: TimeframeProvider,\r\n    private bybitService: BybitService,\r\n    private positionManager: PositionManagerService,\r\n    private telegram: TelegramService | null,\r\n    private logger: LoggerService,\r\n    fastEntryService?: FastEntryService,\r\n    smartBreakevenService?: SmartBreakevenService,\r\n    retestEntryService?: RetestEntryService,\r\n    deltaAnalyzerService?: DeltaAnalyzerService,\r\n    orderbookImbalanceService?: OrderbookImbalanceService,\r\n    dailyLimitsService?: DailyLimitsService,\r\n    riskBasedSizingService?: RiskBasedSizingService,\r\n    lossStreakService?: LossStreakService,\r\n    maxConcurrentRiskService?: MaxConcurrentRiskService,\r\n  ) {\r\n    this.contextAnalyzer = new ContextAnalyzer(\r\n      config.contextConfig,\r\n      candleProvider,\r\n      logger,\r\n    );\r\n    this.entryScanner = new EntryScanner(\r\n      config.entryConfig,\r\n      candleProvider,\r\n      logger,\r\n    );\r\n\r\n    // Initialize multi-timeframe analyzers\r\n    this.rsiAnalyzer = new MultiTimeframeRSIAnalyzer(\r\n      timeframeProvider,\r\n      candleProvider,\r\n      logger,\r\n      config.entryConfig.rsiPeriod, // Use same period for all timeframes\r\n      true, // Enable caching\r\n    );\r\n    this.emaAnalyzer = new MultiTimeframeEMAAnalyzer(\r\n      timeframeProvider,\r\n      candleProvider,\r\n      logger,\r\n      config.entryConfig.fastEmaPeriod, // Fast EMA period\r\n      config.entryConfig.slowEmaPeriod, // Slow EMA period\r\n      true, // Enable caching\r\n    );\r\n\r\n    // Initialize single-timeframe indicators\r\n    this.atrIndicator = new ATRIndicator(config.contextConfig.atrPeriod);\r\n    this.zigzagIndicator = new ZigZagIndicator(config.entryConfig.zigzagDepth);\r\n    this.liquidityDetector = new LiquidityDetector(logger);\r\n    this.divergenceDetector = new DivergenceDetector(logger);\r\n    this.breakoutPredictor = new BreakoutPredictor(logger);\r\n\r\n    // Initialize Stochastic indicator if enabled\r\n    if (config.indicators?.stochastic?.enabled) {\r\n      const stochConfig = config.indicators.stochastic;\r\n      this.stochasticIndicator = new StochasticIndicator(\r\n        stochConfig.kPeriod,\r\n        stochConfig.dPeriod,\r\n        stochConfig.smooth,\r\n      );\r\n      logger.info('‚úÖ Stochastic indicator initialized', {\r\n        k: stochConfig.kPeriod,\r\n        d: stochConfig.dPeriod,\r\n        smooth: stochConfig.smooth,\r\n      });\r\n    }\r\n\r\n    // Initialize Bollinger Bands indicator if enabled\r\n    if (config.indicators?.bollingerBands?.enabled) {\r\n      const bbConfig = config.indicators.bollingerBands;\r\n      this.bollingerIndicator = new BollingerBandsIndicator(\r\n        bbConfig.period,\r\n        bbConfig.stdDev,\r\n      );\r\n      logger.info('‚úÖ Bollinger Bands indicator initialized', {\r\n        period: bbConfig.period,\r\n        stdDev: bbConfig.stdDev,\r\n        adaptiveParams: bbConfig.adaptiveParams,\r\n      });\r\n    }\r\n\r\n    // Initialize Strategy Coordinator\r\n    this.strategyCoordinator = new StrategyCoordinator(logger);\r\n\r\n    // Initialize Weight Matrix Calculator (Phase 2)\r\n    let weightMatrixCalculator: WeightMatrixCalculatorService | undefined;\r\n    if (config.weightMatrix?.enabled) {\r\n      weightMatrixCalculator = new WeightMatrixCalculatorService(config.weightMatrix, logger);\r\n      logger.info('‚úÖ Weight Matrix Calculator initialized', {\r\n        enabled: config.weightMatrix.enabled,\r\n        minConfidenceToEnter: config.weightMatrix.minConfidenceToEnter,\r\n        minConfidenceForReducedSize: config.weightMatrix.minConfidenceForReducedSize,\r\n      });\r\n    }\r\n\r\n    // Register strategies (sorted by priority automatically)\r\n    // Load strategy configs from parent config\r\n    const strategiesConfig = this.config.strategiesConfig!;\r\n\r\n    // ============================================================================\r\n    // TRADITIONAL STRATEGIES (LevelBased, TrendFollowing, CounterTrend)\r\n    // ============================================================================\r\n\r\n    if (strategiesConfig?.trendFollowing?.enabled) {\r\n      this.strategyCoordinator.registerStrategy(\r\n        new TrendFollowingStrategy(\r\n          strategiesConfig.trendFollowing,\r\n          logger,\r\n          weightMatrixCalculator,\r\n        ),\r\n      );\r\n      this.logger.info('üìä Trend Following Strategy registered');\r\n    }\r\n\r\n    if (strategiesConfig?.levelBased?.enabled) {\r\n      this.strategyCoordinator.registerStrategy(\r\n        new LevelBasedStrategy(\r\n          strategiesConfig.levelBased,\r\n          logger,\r\n          weightMatrixCalculator,\r\n        ),\r\n      );\r\n      this.logger.info('üìä Level Based Strategy registered');\r\n    }\r\n\r\n    if (strategiesConfig?.counterTrend?.enabled) {\r\n      this.strategyCoordinator.registerStrategy(\r\n        new CounterTrendStrategy(\r\n          strategiesConfig.counterTrend,\r\n          logger,\r\n          weightMatrixCalculator,\r\n        ),\r\n      );\r\n      this.logger.info('üìä Counter Trend Strategy registered');\r\n    }\r\n\r\n    // ============================================================================\r\n    // WHALE STRATEGIES (WhaleHunter, WhaleHunterFollow)\r\n    // ============================================================================\r\n\r\n    if (config.whaleHunter?.enabled) {\r\n      const whaleDetector = new WhaleDetectorService(config.whaleHunter.detector, logger);\r\n\r\n      // OrderBookAnalyzer config (use from main config or defaults)\r\n      const orderbookConfig = {\r\n        enabled: true,\r\n        depth: 50,\r\n        wallThreshold: 0.1,\r\n        imbalanceThreshold: MULTIPLIERS.ONE_AND_HALF,\r\n        updateIntervalMs: 5000,\r\n      };\r\n      const orderbookAnalyzer = new OrderBookAnalyzer(orderbookConfig, logger);\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new WhaleHunterStrategy(\r\n          {\r\n            ...config.whaleHunter,\r\n            sessionBasedSL: config.sessionBasedSL,\r\n          },\r\n          whaleDetector,\r\n          orderbookAnalyzer,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üêã Whale Hunter Strategy registered', {\r\n        priority: config.whaleHunter.priority,\r\n        minConfidence: config.whaleHunter.minConfidence,\r\n      });\r\n    }\r\n\r\n    if (config.whaleHunterFollow?.enabled) {\r\n      const whaleDetectorFollow = new WhaleDetectorFollowService(\r\n        config.whaleHunterFollow.detector,\r\n        logger,\r\n      );\r\n\r\n      const orderbookConfig = {\r\n        enabled: true,\r\n        depth: 50,\r\n        wallThreshold: 0.1,\r\n        imbalanceThreshold: MULTIPLIERS.ONE_AND_HALF,\r\n        updateIntervalMs: 5000,\r\n      };\r\n      const orderbookAnalyzer = new OrderBookAnalyzer(orderbookConfig, logger);\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new WhaleHunterFollowStrategy(\r\n          {\r\n            ...config.whaleHunterFollow,\r\n            sessionBasedSL: config.sessionBasedSL,\r\n          },\r\n          whaleDetectorFollow,\r\n          orderbookAnalyzer,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üêã Whale Hunter Follow Strategy registered', {\r\n        priority: config.whaleHunterFollow.priority,\r\n        minConfidence: config.whaleHunterFollow.minConfidence,\r\n      });\r\n    }\r\n\r\n    // ============================================================================\r\n    // SCALPING STRATEGIES (MicroWall, TickDelta, LadderTp, LimitOrder, OrderFlow)\r\n    // ============================================================================\r\n\r\n    if (config.scalpingMicroWall?.enabled) {\r\n      this.logger.info('üìä Registering Scalping Micro Wall Strategy...');\r\n\r\n      const microWallDetector = new MicroWallDetectorService(\r\n        config.scalpingMicroWall.detector,\r\n        logger,\r\n      );\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingMicroWallStrategy(\r\n          config.scalpingMicroWall,\r\n          microWallDetector,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üìä Scalping Micro Wall Strategy registered', {\r\n        priority: config.scalpingMicroWall.priority,\r\n        minConfidence: config.scalpingMicroWall.minConfidence,\r\n        takeProfitPercent: config.scalpingMicroWall.takeProfitPercent,\r\n        stopLossPercent: config.scalpingMicroWall.stopLossPercent,\r\n      });\r\n    }\r\n\r\n    if (config.scalpingLimitOrder?.enabled) {\r\n      this.logger.info('üí∞ Registering Scalping Limit Order Strategy (fee optimization wrapper)...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingLimitOrderStrategy(\r\n          config.scalpingLimitOrder,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üí∞ Scalping Limit Order Strategy registered', {\r\n        priority: config.scalpingLimitOrder.priority,\r\n        baseSignalSource: config.scalpingLimitOrder.baseSignalSource,\r\n        timeoutMs: config.scalpingLimitOrder.executor.timeoutMs,\r\n        slippagePercent: config.scalpingLimitOrder.executor.slippagePercent,\r\n        feeSavings: '0.05% per trade',\r\n      });\r\n    }\r\n\r\n    // Register Scalping Ladder TP Strategy (if enabled)\r\n    this.logger.info(`üîç DEBUG: Checking scalpingLadderTp - exists: ${!!config.scalpingLadderTp}, enabled: ${config.scalpingLadderTp?.enabled}`);\r\n    if (config.scalpingLadderTp?.enabled) {\r\n      this.logger.info('üéØ Registering Scalping Ladder TP Strategy (multi-level exit wrapper)...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingLadderTpStrategy(\r\n          config.scalpingLadderTp,\r\n          this.bybitService,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üéØ Scalping Ladder TP Strategy registered', {\r\n        priority: config.scalpingLadderTp.priority,\r\n        baseSignalSource: config.scalpingLadderTp.baseSignalSource,\r\n        levels: config.scalpingLadderTp.ladderManager.levels.length,\r\n        tpLevels: config.scalpingLadderTp.ladderManager.levels.map((l: { pricePercent: number; closePercent: number }) => `${l.pricePercent}%`).join(', '),\r\n        rrRatio: '~1.26:1',\r\n      });\r\n    }\r\n\r\n    if (config.scalpingTickDelta?.enabled) {\r\n      this.logger.info('üìä Registering Scalping Tick Delta Strategy...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingTickDeltaStrategy(\r\n          config.scalpingTickDelta,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üìä Scalping Tick Delta Strategy registered', {\r\n        priority: config.scalpingTickDelta.priority,\r\n        minDeltaRatio: config.scalpingTickDelta.analyzer.minDeltaRatio,\r\n        takeProfitPercent: config.scalpingTickDelta.takeProfitPercent,\r\n        stopLossPercent: config.scalpingTickDelta.stopLossPercent,\r\n        rrRatio: '2:1',\r\n      });\r\n    }\r\n\r\n    if (config.scalpingOrderFlow?.enabled) {\r\n      this.logger.info('üìä Registering Scalping Order Flow Strategy...');\r\n\r\n      this.strategyCoordinator.registerStrategy(\r\n        new ScalpingOrderFlowStrategy(\r\n          config.scalpingOrderFlow,\r\n          logger,\r\n        ),\r\n      );\r\n\r\n      this.logger.info('üìä Scalping Order Flow Strategy registered', {\r\n        priority: config.scalpingOrderFlow.priority,\r\n        aggressiveBuyThreshold: config.scalpingOrderFlow.analyzer.aggressiveBuyThreshold,\r\n        takeProfitPercent: config.scalpingOrderFlow.takeProfitPercent,\r\n        stopLossPercent: config.scalpingOrderFlow.stopLossPercent,\r\n        rrRatio: '2:1',\r\n      });\r\n    }\r\n\r\n    this.logger.info('‚úÖ Strategy Coordinator initialized', {\r\n      strategies: this.strategyCoordinator.getStrategies().map(s => s.name),\r\n    });\r\n\r\n    // Initialize BTC confirmation filter\r\n    if (config.btcConfirmation?.enabled) {\r\n      this.btcAnalyzer = new BTCAnalyzer(config.btcConfirmation, logger);\r\n      this.logger.info('BTC confirmation filter enabled', {\r\n        symbol: config.btcConfirmation.symbol,\r\n        timeframe: config.btcConfirmation.timeframe,\r\n      });\r\n    }\r\n\r\n    // Initialize funding rate filter\r\n    if (config.fundingRateFilter?.enabled) {\r\n      this.fundingRateFilter = new FundingRateFilterService(\r\n        config.fundingRateFilter,\r\n        async () => await bybitService.getFundingRate(),\r\n        logger,\r\n      );\r\n      this.logger.info('üí∞ Funding Rate Filter enabled', {\r\n        blockLongThreshold: (config.fundingRateFilter.blockLongThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n        blockShortThreshold: (config.fundingRateFilter.blockShortThreshold * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%',\r\n        cacheTimeMs: config.fundingRateFilter.cacheTimeMs,\r\n      });\r\n    }\r\n\r\n    // Initialize flat market detector\r\n    if (config.flatMarketDetection?.enabled) {\r\n      this.flatMarketDetector = new FlatMarketDetector(config.flatMarketDetection, logger);\r\n      this.logger.info('üìä Flat Market Detector enabled', {\r\n        flatThreshold: config.flatMarketDetection.flatThreshold,\r\n        emaThreshold: config.flatMarketDetection.emaThreshold,\r\n        atrThreshold: config.flatMarketDetection.atrThreshold,\r\n      });\r\n    }\r\n\r\n    // Initialize Phase 1 services (Smart Entry & Breakeven)\r\n    // Services are passed from bot.ts to ensure single instance shared with PositionManager\r\n    this.fastEntryService = fastEntryService || null;\r\n    this.smartBreakevenService = smartBreakevenService || null;\r\n    this.retestEntryService = retestEntryService || null;\r\n\r\n    // Phase 4: Market Data Enhancement services\r\n    this.deltaAnalyzerService = deltaAnalyzerService || null;\r\n    this.orderbookImbalanceService = orderbookImbalanceService || null;\r\n\r\n    // Initialize Volume Profile Service (PHASE 4 Feature 3)\r\n    if (config.volumeProfile?.enabled) {\r\n      this.volumeProfileService = new VolumeProfileService(config.volumeProfile, logger);\r\n      this.logger.info('üìä Volume Profile Service initialized', {\r\n        lookbackCandles: config.volumeProfile.lookbackCandles,\r\n        valueAreaPercent: config.volumeProfile.valueAreaPercent,\r\n        priceTickSize: config.volumeProfile.priceTickSize,\r\n      });\r\n    }\r\n\r\n    // Phase 5: Risk Management services\r\n    this.dailyLimitsService = dailyLimitsService || null;\r\n    this.riskBasedSizingService = riskBasedSizingService || null;\r\n    this.lossStreakService = lossStreakService || null;\r\n    this.maxConcurrentRiskService = maxConcurrentRiskService || null;\r\n\r\n    if (this.fastEntryService) {\r\n      this.logger.info('‚ö° Fast Entry Service enabled', {\r\n        partialSizePercent: config.fastEntry?.partialSizePercent,\r\n        minBodyPercent: config.fastEntry?.minBodyPercent,\r\n        volumeMultiplier: config.fastEntry?.volumeMultiplier,\r\n      });\r\n    }\r\n\r\n    if (this.smartBreakevenService) {\r\n      this.logger.info('üéØ Smart Breakeven Service enabled', {\r\n        activationProfitPercent: config.smartBreakeven?.activationProfitPercent,\r\n        breakevenProfitPercent: config.smartBreakeven?.breakevenProfitPercent,\r\n        requireEMAHold: config.smartBreakeven?.requireEMAHold,\r\n      });\r\n    }\r\n\r\n    if (this.retestEntryService) {\r\n      this.logger.info('üéØ Retest Entry Service enabled', {\r\n        minImpulsePercent: config.retestEntry?.minImpulsePercent,\r\n        retestZone: config.retestEntry ? `${config.retestEntry.retestZoneFibStart}%-${config.retestEntry.retestZoneFibEnd}%` : 'N/A',\r\n        maxRetestWaitMs: config.retestEntry?.maxRetestWaitMs,\r\n      });\r\n    }\r\n\r\n    if (this.deltaAnalyzerService) {\r\n      this.logger.info('üìä Delta Analyzer Service enabled (PHASE 4)', {\r\n        windowSizeMs: config.delta?.windowSizeMs,\r\n        minDeltaThreshold: config.delta?.minDeltaThreshold,\r\n      });\r\n    }\r\n\r\n    if (this.dailyLimitsService) {\r\n      this.logger.info('üõ°Ô∏è Daily Limits Service enabled (PHASE 5)', {\r\n        maxDailyLossPercent: config.dailyLimits?.maxDailyLossPercent,\r\n        maxDailyProfitPercent: config.dailyLimits?.maxDailyProfitPercent,\r\n        resetTimeUTC: config.dailyLimits?.resetTimeUTC,\r\n      });\r\n    }\r\n\r\n    if (this.riskBasedSizingService) {\r\n      this.logger.info('üí∞ Risk-Based Sizing Service enabled (PHASE 5)', {\r\n        riskPerTradePercent: config.riskBasedSizing?.riskPerTradePercent,\r\n        minPositionSizeUsdt: config.riskBasedSizing?.minPositionSizeUsdt,\r\n        maxPositionSizeUsdt: config.riskBasedSizing?.maxPositionSizeUsdt,\r\n      });\r\n    }\r\n\r\n    if (this.lossStreakService) {\r\n      this.logger.info('üìâ Loss Streak Service enabled (PHASE 5)', {\r\n        reductions: config.lossStreak?.reductions,\r\n        stopAfterLosses: config.lossStreak?.stopAfterLosses,\r\n      });\r\n    }\r\n\r\n    // Initialize context on startup (async)\r\n    void this.initializeContext();\r\n  }\r\n\r\n  /**\r\n   * Initialize context on startup\r\n   */\r\n  private async initializeContext(): Promise<void> {\r\n    try {\r\n      this.logger.info('üîÑ Initializing trading context...');\r\n      this.currentContext = await this.contextAnalyzer.analyze();\r\n      this.logger.info('‚úÖ Trading context initialized', {\r\n        trend: this.currentContext.trend,\r\n        overallModifier: this.currentContext.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        warnings: this.currentContext.warnings,\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize context', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle candle close event\r\n   * Called by Bot when candle closes on any timeframe\r\n   */\r\n  async onCandleClosed(role: TimeframeRole, candle: Candle): Promise<void> {\r\n    try {\r\n      // PRIMARY closed ‚Üí Update context\r\n      if (role === TimeframeRole.PRIMARY) {\r\n        this.logger.info('üìä PRIMARY candle closed - updating context');\r\n        this.currentContext = await this.contextAnalyzer.analyze();\r\n\r\n        this.logger.info('Context updated', {\r\n          trend: this.currentContext.trend,\r\n          overallModifier: this.currentContext.overallModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n          warnings: this.currentContext.warnings,\r\n        });\r\n      }\r\n\r\n      // ENTRY closed ‚Üí Scan for entry\r\n      if (role === TimeframeRole.ENTRY) {\r\n        // üïê SYNC TIME before analysis (critical for preventing timestamp errors)\r\n        try {\r\n          await this.syncTimeWithExchange();\r\n        } catch (error) {\r\n          this.logger.warn('Time sync failed before analysis, continuing...', {\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n\r\n        this.logger.info('üîç ENTRY candle closed - scanning for entry');\r\n\r\n        // Need context first\r\n        if (!this.currentContext) {\r\n          this.logger.warn('No context available yet, skipping entry scan');\r\n          return;\r\n        }\r\n\r\n        // Check if already in position\r\n        const currentPosition = this.positionManager.getCurrentPosition();\r\n        if (currentPosition) {\r\n          // Update BB trailing stop if enabled (BB.MD Section 3.3)\r\n          // BB indicator enabled is sufficient check (BB config contains enabled flag)\r\n          if (this.bollingerIndicator && this.config.indicators?.bollingerBands?.enabled) {\r\n            try {\r\n              // Get entry candles for BB calculation\r\n              const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n              const bbPeriod = this.config.indicators.bollingerBands.period || 20;\r\n              if (entryCandles.length >= bbPeriod) {\r\n                // Calculate current BB\r\n                const bb = this.bollingerIndicator.calculate(entryCandles);\r\n\r\n                // Get ATR (convert from percent to absolute value)\r\n                const atr = this.currentContext?.atrPercent\r\n                  ? (this.currentContext.atrPercent / PERCENT_MULTIPLIER) * candle.close\r\n                  : 0;\r\n\r\n                // Update BB trailing stop (method checks its own enabled flag)\r\n                await this.positionManager.updateBBTrailingStop(bb, atr, candle.close);\r\n              }\r\n            } catch (error) {\r\n              this.logger.warn('Failed to update BB trailing stop', {\r\n                error: error instanceof Error ? error.message : String(error),\r\n              });\r\n            }\r\n          }\r\n\r\n          // ====================================================================\r\n          // PHASE 1: Smart Breakeven - Update Pre-BE mode\r\n          // ====================================================================\r\n          if (this.smartBreakevenService && this.config.smartBreakeven?.enabled) {\r\n            const state = this.smartBreakevenService.getState(currentPosition.symbol);\r\n            if (state && state.mode === 'PRE_BE') {\r\n              try {\r\n                const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n                if (entryCandles.length >= PERCENTAGE_THRESHOLDS.LOW_MODERATE) {\r\n                  const emaFast = await this.emaAnalyzer.calculate(TimeframeRole.ENTRY);\r\n                  const ema20 = emaFast?.fast ?? 0;\r\n\r\n                  const recentVolumes = entryCandles.slice(-20).map(c => c.volume);\r\n                  const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n\r\n                  await this.smartBreakevenService.updateBreakeven(\r\n                    currentPosition,\r\n                    candle.close,\r\n                    ema20,\r\n                    candle.volume,\r\n                    avgVolume,\r\n                    async (newSL: number) => {\r\n                      await this.bybitService.updateStopLoss(newSL);\r\n                      if (this.positionManager.getCurrentPosition()) {\r\n                        this.positionManager.getCurrentPosition()!.stopLoss.price = newSL;\r\n                        this.positionManager.getCurrentPosition()!.stopLoss.updatedAt = Date.now();\r\n                      }\r\n                    },\r\n                  );\r\n                }\r\n              } catch (error) {\r\n                this.logger.warn('Failed to update smart breakeven', {\r\n                  error: error instanceof Error ? error.message : String(error),\r\n                });\r\n              }\r\n            }\r\n          }\r\n\r\n          // ====================================================================\r\n          // PHASE 1: Retest Entry - Check for retest entry\r\n          // ====================================================================\r\n          if (this.retestEntryService && this.config.retestEntry?.enabled) {\r\n            const zone = this.retestEntryService.getRetestZone(currentPosition.symbol);\r\n            if (zone) {\r\n              try {\r\n                const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n                const emaFast = await this.emaAnalyzer.calculate(TimeframeRole.ENTRY);\r\n                const ema20 = emaFast?.fast ?? 0;\r\n\r\n                const recentVolumes = entryCandles.slice(-20).map(c => c.volume);\r\n                const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n\r\n                // Get senior TF trend (TREND1)\r\n                const trend1Ema = await this.emaAnalyzer.calculate(TimeframeRole.TREND1);\r\n                const seniorTFTrend = trend1Ema\r\n                  ? (trend1Ema.fast > trend1Ema.slow ? 'UP' : trend1Ema.fast < trend1Ema.slow ? 'DOWN' : 'NEUTRAL')\r\n                  : 'NEUTRAL';\r\n\r\n                const retest = this.retestEntryService.checkRetest(\r\n                  currentPosition.symbol,\r\n                  candle.close,\r\n                  candle.volume,\r\n                  avgVolume,\r\n                  ema20,\r\n                  seniorTFTrend as 'UP' | 'DOWN' | 'NEUTRAL',\r\n                );\r\n\r\n                if (retest.shouldEnter && zone.originalSignal) {\r\n                  this.logger.info('‚úÖ Retest entry triggered - NOT executing (position already open)', {\r\n                    symbol: currentPosition.symbol,\r\n                    price: candle.close,\r\n                    reason: retest.reason,\r\n                  });\r\n                  this.retestEntryService.clearZone(currentPosition.symbol);\r\n                }\r\n              } catch (error) {\r\n                this.logger.warn('Failed to check retest entry', {\r\n                  error: error instanceof Error ? error.message : String(error),\r\n                });\r\n              }\r\n            }\r\n          }\r\n\r\n          this.logger.info('Already in position, skipping entry scan', {\r\n            positionId: currentPosition.id,\r\n          });\r\n          return;\r\n        }\r\n\r\n        // ========================================================================\r\n        // STEP 1: Check pending confirmations (candle close confirmation)\r\n        // ========================================================================\r\n        const confirmedSignal = this.positionManager.checkPendingConfirmations(candle.close);\r\n        if (confirmedSignal) {\r\n          this.logger.info(`‚úÖ Pending ${confirmedSignal.direction} confirmed - executing trade`);\r\n          const entrySignal: EntrySignal = {\r\n            shouldEnter: true,\r\n            direction: confirmedSignal.direction,\r\n            confidence: confirmedSignal.confidence,\r\n            entryPrice: confirmedSignal.price,\r\n            stopLoss: confirmedSignal.stopLoss,\r\n            takeProfits: confirmedSignal.takeProfits,\r\n            reason: confirmedSignal.reason + ' [CONFIRMED]',\r\n            timestamp: confirmedSignal.timestamp,\r\n          };\r\n          await this.executeTrade(entrySignal);\r\n          return; // Exit early\r\n        }\r\n\r\n        // Prepare market data for strategies\r\n        const marketData = await this.prepareMarketData();\r\n\r\n        if (!marketData) {\r\n          this.logger.warn('Failed to prepare market data, skipping entry scan');\r\n          return;\r\n        }\r\n\r\n        // ========================================================================\r\n        // FLAT MARKET DETECTION: Determine adaptive confidence threshold\r\n        // ========================================================================\r\n        let flatResult: { isFlat: boolean; confidence: number } | null = null;\r\n        if (this.flatMarketDetector && this.currentContext) {\r\n          try {\r\n            const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n            const primaryEma = await this.emaAnalyzer.calculate(TimeframeRole.PRIMARY);\r\n\r\n            if (primaryCandles.length > 0 && primaryEma) {\r\n              flatResult = this.flatMarketDetector.detect(\r\n                primaryCandles,\r\n                this.currentContext,\r\n                primaryEma.fast,\r\n                primaryEma.slow,\r\n              );\r\n            }\r\n          } catch (error) {\r\n            this.logger.warn('Flat market detection failed', { error });\r\n          }\r\n        }\r\n\r\n        // Calculate adaptive min confidence threshold\r\n        // Use minConfidenceFlat for flat markets, minConfidenceToEnter for trending\r\n        const minConfidenceValue = flatResult?.isFlat && this.config.weightMatrix?.minConfidenceFlat\r\n          ? this.config.weightMatrix.minConfidenceFlat\r\n          : this.config.weightMatrix?.minConfidenceToEnter || 50;\r\n\r\n        const minConfidence = minConfidenceValue / PERCENT_MULTIPLIER;\r\n\r\n        this.logger.info('üéØ Adaptive Confidence Threshold', {\r\n          marketType: flatResult?.isFlat ? 'FLAT' : 'TRENDING',\r\n          flatConfidence: flatResult?.confidence.toFixed(1) + '%',\r\n          minRequired: minConfidenceValue + '%',\r\n          source: flatResult?.isFlat ? 'minConfidenceFlat' : 'minConfidenceToEnter',\r\n        });\r\n\r\n        // ========================================================================\r\n        // USE STRATEGY COORDINATOR (FIRST VALID WINS)\r\n        // ========================================================================\r\n        this.logger.info('üìã Evaluating Strategies', {\r\n          strategies: this.strategyCoordinator.getStrategies().map(s => ({ name: s.name, priority: s.priority })),\r\n        });\r\n\r\n        const strategySignal = await this.strategyCoordinator.evaluateStrategies(\r\n          marketData,\r\n          minConfidence,\r\n        );\r\n\r\n        if (strategySignal && strategySignal.valid && strategySignal.signal) {\r\n          this.logger.info('‚úÖ STRATEGY SIGNAL FOUND!', {\r\n            strategy: strategySignal.strategyName,\r\n            priority: strategySignal.priority,\r\n            direction: strategySignal.signal.direction,\r\n            confidence: strategySignal.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n            reason: strategySignal.reason,\r\n          });\r\n\r\n          // ====================================================================\r\n          // FLAT MARKET DETECTION: Adjust TPs based on market conditions\r\n          // ====================================================================\r\n          // Reuse flatResult from earlier detection (line 662)\r\n          if (flatResult) {\r\n            if (flatResult.isFlat) {\r\n              // FLAT MARKET: Adjust to single TP (100% close at TP1 price)\r\n              const firstTP = strategySignal.signal.takeProfits[0];\r\n              strategySignal.signal.takeProfits = [{\r\n                level: 1,\r\n                price: firstTP.price,\r\n                sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Close 100% on TP1\r\n                percent: firstTP.percent,\r\n                hit: false,\r\n              }];\r\n\r\n              this.logger.info('‚ö° FLAT market - adjusted to single TP', {\r\n                confidence: flatResult.confidence.toFixed(1) + '%',\r\n                tpPrice: firstTP.price.toFixed(DECIMAL_PLACES.PRICE),\r\n                tpPercent: firstTP.percent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n              });\r\n            } else {\r\n              // TRENDING MARKET: Keep multi-TP strategy\r\n              this.logger.info('üìà TRENDING market - keeping multi-TP strategy', {\r\n                confidence: flatResult.confidence.toFixed(1) + '%',\r\n                tpCount: strategySignal.signal.takeProfits.length,\r\n              });\r\n            }\r\n          }\r\n\r\n          // ====================================================================\r\n          // Entry Confirmation: Check if confirmation is enabled for direction\r\n          // ====================================================================\r\n          const needsConfirmation = this.positionManager.isConfirmationEnabled(strategySignal.signal.direction);\r\n          const keyLevel = strategySignal.signal.marketData?.nearestLevel;\r\n\r\n          if (needsConfirmation && keyLevel) {\r\n            const levelType = strategySignal.signal.direction === SignalDirection.LONG ? 'support' : 'resistance';\r\n\r\n            this.logger.info(`‚è≥ ${strategySignal.signal.direction} signal detected - adding to pending queue for candle confirmation`, {\r\n              direction: strategySignal.signal.direction,\r\n              [`${levelType}Level`]: keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n              currentPrice: strategySignal.signal.price.toFixed(DECIMAL_PLACES.PRICE),\r\n            });\r\n\r\n            const pendingId = this.positionManager.addPendingSignal(\r\n              strategySignal.signal,\r\n              keyLevel,\r\n            );\r\n\r\n            const confirmCondition = strategySignal.signal.direction === SignalDirection.LONG\r\n              ? 'Next 1m candle close above support'\r\n              : 'Next 1m candle close below resistance';\r\n\r\n            this.logger.info(`‚è≥ ${strategySignal.signal.direction} signal added to pending queue`, {\r\n              pendingId,\r\n              direction: strategySignal.signal.direction,\r\n              [`${levelType}Level`]: keyLevel.toFixed(DECIMAL_PLACES.PRICE),\r\n              waitingFor: confirmCondition,\r\n            });\r\n\r\n            return; // Exit early - signal pending confirmation\r\n          }\r\n\r\n          // Convert Strategy Signal to Entry Signal for execution (immediate entry)\r\n          const entrySignal: EntrySignal = {\r\n            shouldEnter: true,\r\n            direction: strategySignal.signal.direction,\r\n            confidence: strategySignal.signal.confidence,\r\n            entryPrice: strategySignal.signal.price,\r\n            stopLoss: strategySignal.signal.stopLoss,\r\n            takeProfits: strategySignal.signal.takeProfits,\r\n            reason: strategySignal.reason || strategySignal.strategyName,\r\n            timestamp: strategySignal.signal.timestamp,\r\n            strategyName: strategySignal.strategyName, // Preserve strategy name for journal\r\n          };\r\n\r\n          // Execute trade immediately (confirmation disabled or no key level)\r\n          this.logger.info(`‚ö° ${strategySignal.signal.direction} entering immediately (confirmation ${needsConfirmation ? 'needs key level' : 'disabled'})`);\r\n          await this.executeTrade(entrySignal, marketData);\r\n          return; // Exit early, strategy found\r\n        }\r\n\r\n        // ========================================================================\r\n        // FALLBACK: Use Entry Scanner (legacy)\r\n        // ========================================================================\r\n        // Check if fallback is enabled (default: true for backward compatibility)\r\n        const enableFallback = this.config.enableEntryScannerFallback !== false;\r\n\r\n        if (enableFallback) {\r\n          this.logger.info('üìä No strategy signal - trying Entry Scanner (fallback)');\r\n\r\n          const entrySignal = await this.entryScanner.scan(this.currentContext);\r\n\r\n          if (entrySignal.shouldEnter) {\r\n            this.logger.info('‚úÖ ENTRY SCANNER SIGNAL FOUND! (fallback)', {\r\n              direction: entrySignal.direction,\r\n              confidence: entrySignal.confidence,\r\n              reason: entrySignal.reason,\r\n            });\r\n\r\n            // Execute trade\r\n            await this.executeTrade(entrySignal, marketData);\r\n          } else {\r\n            this.logger.info('‚ùå No entry signal from any source', {\r\n              strategyCoordinator: 'no valid signal',\r\n              entryScanner: entrySignal.reason,\r\n            });\r\n          }\r\n        } else {\r\n          this.logger.debug('‚è≠Ô∏è EntryScanner fallback disabled - skipping legacy patterns analysis');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Error in orchestrator onCandleClosed', {\r\n        role,\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute trade from entry signal\r\n   * @param entrySignal - Entry signal with trade details\r\n   * @param marketData - Market data for session stats (optional)\r\n   */\r\n  private async executeTrade(entrySignal: EntrySignal, marketData?: StrategyMarketData): Promise<void> {\r\n    try {\r\n      // PHASE 5: Check Emergency Kill-Switch\r\n      const fs = await import('fs');\r\n      if (fs.existsSync('data/STOP_TRADING')) {\r\n        this.logger.warn('‚õî Trading halted by emergency kill-switch (data/STOP_TRADING exists)');\r\n        return;\r\n      }\r\n\r\n      // PHASE 5: Check Daily Limits\r\n      if (this.dailyLimitsService) {\r\n        const limitsCheck = this.dailyLimitsService.canTrade();\r\n        if (!limitsCheck.allowed) {\r\n          this.logger.warn('‚ùå Trade blocked by daily limits (PHASE 5)', {\r\n            reason: limitsCheck.reason,\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      // PHASE 5: Check Loss Streak\r\n      if (this.lossStreakService) {\r\n        const streakCheck = this.lossStreakService.canTrade();\r\n        if (!streakCheck.allowed) {\r\n          this.logger.warn('‚ùå Trade blocked by loss streak (PHASE 5)', {\r\n            reason: streakCheck.reason,\r\n          });\r\n          return;\r\n        }\r\n      }\r\n\r\n      this.logger.info('üöÄ Executing trade...', {\r\n        direction: entrySignal.direction,\r\n        entry: entrySignal.entryPrice,\r\n        sl: entrySignal.stopLoss,\r\n      });\r\n\r\n      // ======================================================================\r\n      // PHASE 1: Check for missed impulse - Create retest zone\r\n      // ======================================================================\r\n      if (this.retestEntryService && this.config.retestEntry?.enabled) {\r\n        try {\r\n          const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n          if (entryCandles.length >= 10) {\r\n            const currentPrice = entryCandles[entryCandles.length - 1].close;\r\n            const symbol = this.bybitService['symbol'];\r\n            const impulse = this.retestEntryService.detectImpulse(\r\n              symbol,\r\n              currentPrice,\r\n              entryCandles,\r\n            );\r\n\r\n            if (impulse.hasImpulse) {\r\n              // Convert EntrySignal to Signal format\r\n              const signal: Signal = {\r\n                type: (entrySignal.strategyName as SignalType) || SignalType.LEVEL_BASED,\r\n                direction: entrySignal.direction,\r\n                price: entrySignal.entryPrice,\r\n                stopLoss: entrySignal.stopLoss,\r\n                takeProfits: entrySignal.takeProfits,\r\n                confidence: entrySignal.confidence,\r\n                reason: entrySignal.reason,\r\n                timestamp: entrySignal.timestamp,\r\n              };\r\n\r\n              this.retestEntryService.createRetestZone(\r\n                symbol,\r\n                signal,\r\n                impulse.impulseStart,\r\n                impulse.impulseEnd,\r\n              );\r\n\r\n              this.logger.info('‚è≥ Impulse detected - waiting for retest (not entering immediately)');\r\n              return; // Don't enter immediately, wait for retest\r\n            }\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Failed to check for missed impulse', {\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n        }\r\n      }\r\n\r\n      // BTC confirmation check\r\n      if (this.btcAnalyzer && this.config.btcConfirmation?.enabled) {\r\n        const btcAnalysis = await this.analyzeBTC(entrySignal.direction);\r\n\r\n        if (btcAnalysis && !this.btcAnalyzer.shouldConfirm(btcAnalysis)) {\r\n          this.logger.info('‚ùå BTC confirmation FAILED - signal blocked', {\r\n            direction: entrySignal.direction,\r\n            btcDirection: btcAnalysis.direction,\r\n            btcMomentum: btcAnalysis.momentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n            isAligned: btcAnalysis.isAligned,\r\n            reason: btcAnalysis.reason,\r\n          });\r\n          return; // Block trade\r\n        }\r\n\r\n        if (btcAnalysis) {\r\n          this.logger.info('‚úÖ BTC confirmation PASSED', {\r\n            direction: entrySignal.direction,\r\n            btcDirection: btcAnalysis.direction,\r\n            btcMomentum: btcAnalysis.momentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n            isAligned: btcAnalysis.isAligned,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Funding rate filter check\r\n      if (this.fundingRateFilter && this.config.fundingRateFilter?.enabled) {\r\n        const filterResult = await this.fundingRateFilter.checkSignal(entrySignal.direction);\r\n\r\n        if (!filterResult.allowed) {\r\n          this.logger.warn('üö´ Funding Rate Filter BLOCKED signal', {\r\n            direction: entrySignal.direction,\r\n            reason: filterResult.reason,\r\n            fundingRate: filterResult.fundingRate\r\n              ? (filterResult.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%'\r\n              : 'N/A',\r\n          });\r\n          return; // Block signal\r\n        }\r\n\r\n        this.logger.debug('‚úÖ Funding Rate Filter PASSED', {\r\n          direction: entrySignal.direction,\r\n          fundingRate: filterResult.fundingRate\r\n            ? (filterResult.fundingRate * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PRICE) + '%'\r\n            : 'N/A',\r\n        });\r\n      }\r\n\r\n      // Convert EntrySignal to Signal format\r\n      const signal: Signal = {\r\n        type: (entrySignal.strategyName as SignalType) || SignalType.LEVEL_BASED,\r\n        direction: entrySignal.direction,\r\n        price: entrySignal.entryPrice,\r\n        stopLoss: entrySignal.stopLoss,\r\n        takeProfits: entrySignal.takeProfits,\r\n        confidence: entrySignal.confidence,\r\n        reason: entrySignal.reason,\r\n        timestamp: entrySignal.timestamp,\r\n      };\r\n\r\n      // Get account balance\r\n      const balance = await this.bybitService.getBalance();\r\n      this.logger.info('üí∞ Current balance', {\r\n        balance: balance.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Calculate position size\r\n      const qty = this.calculatePositionSize(\r\n        signal.price,\r\n        balance,\r\n        this.config.positionSizeUsdt,\r\n      );\r\n\r\n      this.logger.info('üìê Position size calculated', {\r\n        qty,\r\n        value: (qty * signal.price).toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n\r\n      // Create entry snapshot for session stats (if marketData available)\r\n      let entrySnapshot: SessionEntryCondition | undefined;\r\n      if (marketData) {\r\n        // Extract indicators from marketData\r\n        const rsiAll = await this.rsiAnalyzer.calculateAll();\r\n        const emaAll = await this.emaAnalyzer.calculateAll();\r\n\r\n        const indicatorsEntry: IndicatorSnapshot = {\r\n          rsi: rsiAll.entry ?? 0,\r\n          ema20: emaAll.entry?.fast ?? 0,\r\n          ema50: emaAll.entry?.slow ?? 0,\r\n          atr: marketData.atr ?? 0,\r\n          volume: marketData.candles[marketData.candles.length - 1]?.volume ?? 0,\r\n        };\r\n\r\n        const indicatorsPrimary: IndicatorSnapshot = {\r\n          rsi: rsiAll.primary ?? 0,\r\n          ema20: emaAll.primary?.fast ?? 0,\r\n          ema50: emaAll.primary?.slow ?? 0,\r\n          atr: marketData.atr ?? 0,\r\n        };\r\n\r\n        const indicatorsTrend1: IndicatorSnapshot = {\r\n          rsi: rsiAll.trend1 ?? 0,\r\n          ema20: emaAll.trend1?.fast ?? 0,\r\n          ema50: emaAll.trend1?.slow ?? 0,\r\n          atr: marketData.atr ?? 0,\r\n        };\r\n\r\n        const patterns: PatternSnapshot = {\r\n          chartPattern: null, // TODO: Add chart pattern detection\r\n          engulfing: false,\r\n          triple: false,\r\n          triangle: false,\r\n          wedge: false,\r\n          flag: false,\r\n        };\r\n\r\n        const levels: LevelSnapshot | null = marketData.liquidity\r\n          ? {\r\n            nearestSupport: marketData.liquidity.nearestSupportZone?.priceLevel ?? signal.price,\r\n            nearestResistance: marketData.liquidity.nearestResistanceZone?.priceLevel ?? signal.price,\r\n            distanceToLevel: 0, // TODO: Calculate\r\n            levelStrength: marketData.liquidity.nearestSupportZone?.strength ?? 0,\r\n            touches: marketData.liquidity.nearestSupportZone?.touches ?? 0,\r\n          }\r\n          : null;\r\n\r\n        const context: ContextSnapshot = {\r\n          btcCorrelation: null, // TODO: Add BTC correlation\r\n          btcDirection: null,\r\n          fundingRate: null,\r\n          flatMarketScore: 0, // TODO: Add flat market score\r\n        };\r\n\r\n        entrySnapshot = {\r\n          signal: {\r\n            type: signal.type,\r\n            direction: signal.direction,\r\n            confidence: signal.confidence,\r\n            reason: signal.reason,\r\n          },\r\n          indicators: {\r\n            entry: indicatorsEntry,\r\n            primary: indicatorsPrimary,\r\n            trend1: indicatorsTrend1,\r\n          },\r\n          patterns,\r\n          levels,\r\n          context,\r\n        };\r\n      }\r\n\r\n      // ======================================================================\r\n      // PHASE 1: Fast Entry - Check for partial entry before candle close\r\n      // ======================================================================\r\n      if (this.fastEntryService && this.config.fastEntry?.enabled) {\r\n        try {\r\n          // Get current candle data\r\n          const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n          const trend1Candles = await this.candleProvider.getCandles(TimeframeRole.TREND1);\r\n\r\n          if (entryCandles.length >= PERCENTAGE_THRESHOLDS.LOW_MODERATE && trend1Candles.length >= 2) {\r\n            const currentCandle = entryCandles[entryCandles.length - 1];\r\n\r\n            // Calculate volume SMA\r\n            const recentVolumes = entryCandles.slice(-20).map((c) => c.volume);\r\n            const volumeSMA = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n\r\n            // Determine senior TF trend\r\n            const trend1Ema = trend1Candles[trend1Candles.length - 1];\r\n            const trend1EmaPrev = trend1Candles[trend1Candles.length - 2];\r\n            const seniorTFTrend: 'UP' | 'DOWN' | 'NEUTRAL' =\r\n              trend1Ema.close > trend1EmaPrev.close ? 'UP' : trend1Ema.close < trend1EmaPrev.close ? 'DOWN' : 'NEUTRAL';\r\n\r\n            // Check fast trigger conditions\r\n            const fastTrigger = this.fastEntryService.checkFastTrigger(\r\n              signal,\r\n              currentCandle,\r\n              currentCandle.volume,\r\n              volumeSMA,\r\n              seniorTFTrend,\r\n            );\r\n\r\n            if (fastTrigger) {\r\n              // Execute partial entry (40%)\r\n              const partialSize = qty * (this.config.fastEntry.partialSizePercent / PERCENT_MULTIPLIER);\r\n              const remainingSize = qty - partialSize;\r\n\r\n              const partial = await this.fastEntryService.executePartialEntry(\r\n                this.bybitService['symbol'],\r\n                signal,\r\n                qty,\r\n                async (partialQty) => {\r\n                  // Open partial position\r\n                  const partialPosition = await this.positionManager.openPosition(\r\n                    {\r\n                      ...signal,\r\n                      // Adjust for partial size (no need to change signal itself)\r\n                    },\r\n                    entrySnapshot,\r\n                  );\r\n\r\n                  return {\r\n                    orderId: partialPosition.id,\r\n                    avgPrice: partialPosition.entryPrice,\r\n                  };\r\n                },\r\n              );\r\n\r\n              if (partial) {\r\n                this.logger.info('‚ö° Fast Entry executed (40%), waiting for candle close to add remaining 60%');\r\n                // Note: Remaining 60% will be added by entry confirmation service\r\n                // TODO: Schedule confirmation check for remaining size\r\n                return; // Don't execute full entry immediately\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Failed to check Fast Entry conditions', {\r\n            error: error instanceof Error ? error.message : String(error),\r\n          });\r\n          // Continue with standard entry if Fast Entry fails\r\n        }\r\n      }\r\n\r\n      // Open position (standard entry or Fast Entry fallback)\r\n      const position = await this.positionManager.openPosition(signal, entrySnapshot);\r\n\r\n      this.logger.info('‚úÖ Position opened successfully!', {\r\n        positionId: position.id,\r\n        side: position.side,\r\n        entry: position.entryPrice,\r\n      });\r\n\r\n      // Send Telegram notification\r\n      if (this.telegram) {\r\n        await this.telegram.sendTradeNotification({\r\n          type: 'ENTRY',\r\n          direction: signal.direction,\r\n          price: signal.price,\r\n          stopLoss: signal.stopLoss,\r\n          takeProfits: signal.takeProfits,\r\n          confidence: signal.confidence,\r\n          reason: signal.reason,\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Failed to execute trade', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n\r\n      // TODO: Send error notification via Telegram\r\n      // if (this.telegram) {\r\n      //   await this.telegram.sendMessage(...);\r\n      // }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare lightweight market data for Whale Hunter (scalping-optimized)\r\n   * Only includes: orderbook, current price, context (ATR, BTC analysis)\r\n   * Skips: RSI, EMA, liquidity, divergence, swing points (not needed for whale detection)\r\n   */\r\n  private async prepareMarketDataForWhale(orderbook: OrderBook): Promise<StrategyMarketData | null> {\r\n    try {\r\n      // Context is required for whale hunter (ATR%, BTC analysis)\r\n      if (!this.currentContext) {\r\n        return null;\r\n      }\r\n\r\n      // Get only ENTRY candles for current price (1 candle is enough)\r\n      const entryCandles = await this.candleProvider.getCandles(TimeframeRole.ENTRY);\r\n      if (!entryCandles || entryCandles.length < 1) {\r\n        return null;\r\n      }\r\n\r\n      const currentPrice = entryCandles[entryCandles.length - 1].close;\r\n      const currentTimestamp = entryCandles[entryCandles.length - 1].timestamp;\r\n\r\n      // Return minimal market data (only what whale hunter needs)\r\n      const marketData: StrategyMarketData = {\r\n        timestamp: currentTimestamp,\r\n        currentPrice,\r\n        candles: entryCandles, // Only ENTRY candles (for current price)\r\n        swingPoints: [], // Not needed for whale\r\n        rsi: 0, // Not needed for whale\r\n        rsiTrend1: undefined,\r\n        ema: { fast: 0, slow: 0 }, // Not needed for whale\r\n        emaTrend1: undefined,\r\n        atr: undefined, // Will use from context if needed\r\n        trend: this.currentContext.trend,\r\n        liquidity: undefined, // Not needed for whale\r\n        divergence: undefined, // Not needed for whale\r\n        orderbook, // CRITICAL: Fresh orderbook data\r\n        context: this.currentContext, // Contains ATR%, BTC analysis\r\n      };\r\n\r\n      return marketData;\r\n    } catch (error) {\r\n      this.logger.error('Error preparing whale market data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare market data for strategies\r\n   */\r\n  private async prepareMarketData(): Promise<StrategyMarketData | null> {\r\n    try {\r\n      // Get PRIMARY candles for swing points and market analysis (5m timeframe)\r\n      const primaryCandles = await this.candleProvider.getCandles(TimeframeRole.PRIMARY);\r\n      if (!primaryCandles || primaryCandles.length < 50) {\r\n        this.logger.warn('Not enough PRIMARY candles for market data');\r\n        return null;\r\n      }\r\n\r\n      const currentPrice = primaryCandles[primaryCandles.length - 1].close;\r\n      const currentTimestamp = primaryCandles[primaryCandles.length - 1].timestamp;\r\n\r\n      // Calculate indicators using MultiTimeframe analyzers\r\n      const rsiAll = await this.rsiAnalyzer.calculateAll();\r\n      const emaAll = await this.emaAnalyzer.calculateAll();\r\n      const atr = this.atrIndicator.calculate(primaryCandles);\r\n\r\n      // Extract PRIMARY timeframe data\r\n      const rsi = rsiAll.primary ?? 0;\r\n      const emaFast = emaAll.primary?.fast ?? 0;\r\n      const emaSlow = emaAll.primary?.slow ?? 0;\r\n\r\n      // Extract TREND1 (30m) timeframe data for higher timeframe confirmation\r\n      const rsiTrend1 = rsiAll.trend1;\r\n      const emaTrend1 = emaAll.trend1;\r\n\r\n      // Calculate swing points on PRIMARY timeframe (5m) for better signal quality\r\n      const { swingHighs, swingLows } = this.zigzagIndicator.findSwingPoints(primaryCandles);\r\n      const swingPoints = [...swingHighs, ...swingLows].sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n      // Liquidity analysis on PRIMARY candles\r\n      const liquidityAnalysis = this.liquidityDetector.analyze(swingPoints, primaryCandles, currentTimestamp);\r\n\r\n      // RSI history for divergence using PRIMARY candles\r\n      // Note: Using simple RSIIndicator for historical calculation\r\n      // MultiTimeframeRSIAnalyzer is for current candles only\r\n      const rsiIndicator = new RSIIndicator(14);\r\n      const rsiHistory = new Map<number, number>();\r\n      primaryCandles.slice(-20).forEach((candle, idx) => {\r\n        const candleRsi = rsiIndicator.calculate(primaryCandles.slice(0, primaryCandles.length - 20 + idx + 1));\r\n        rsiHistory.set(candle.timestamp, candleRsi);\r\n      });\r\n\r\n      // Divergence analysis\r\n      const divergence = this.divergenceDetector.detect(swingPoints, rsiHistory);\r\n\r\n      // Calculate Stochastic if enabled (on PRIMARY candles)\r\n      let stochastic: StrategyMarketData['stochastic'];\r\n      if (this.stochasticIndicator && this.config.indicators?.stochastic) {\r\n        try {\r\n          const result = this.stochasticIndicator.calculate(primaryCandles);\r\n          const { oversoldThreshold, overboughtThreshold } = this.config.indicators.stochastic;\r\n          stochastic = {\r\n            k: result.k,\r\n            d: result.d,\r\n            isOversold: result.k < oversoldThreshold,\r\n            isOverbought: result.k > overboughtThreshold,\r\n          };\r\n\r\n          // Log on INFO when extreme conditions\r\n          if (stochastic.isOversold || stochastic.isOverbought) {\r\n            this.logger.info('üìä Stochastic EXTREME detected', {\r\n              k: result.k.toFixed(DECIMAL_PLACES.PERCENT),\r\n              d: result.d.toFixed(DECIMAL_PLACES.PERCENT),\r\n              condition: stochastic.isOversold ? 'OVERSOLD' : 'OVERBOUGHT',\r\n              threshold: stochastic.isOversold ? `<${oversoldThreshold}` : `>${overboughtThreshold}`,\r\n            });\r\n          } else {\r\n            this.logger.debug('Stochastic calculated for strategy', {\r\n              k: result.k.toFixed(DECIMAL_PLACES.PERCENT),\r\n              d: result.d.toFixed(DECIMAL_PLACES.PERCENT),\r\n              oversold: stochastic.isOversold,\r\n              overbought: stochastic.isOverbought,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Stochastic calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Calculate Bollinger Bands if enabled\r\n      let bollingerBands: StrategyMarketData['bollingerBands'];\r\n      if (this.bollingerIndicator && this.config.indicators?.bollingerBands) {\r\n        try {\r\n          // Apply adaptive params if enabled and ATR available\r\n          if (this.config.indicators.bollingerBands.adaptiveParams && atr !== undefined) {\r\n            const adaptiveParams = this.bollingerIndicator.getAdaptiveParams(atr, currentPrice);\r\n            this.bollingerIndicator.applyAdaptiveParams(adaptiveParams);\r\n\r\n            // Determine volatility category from stdDev\r\n            const volatilityCategory = adaptiveParams.stdDev >= 2.5 ? 'HIGH'\r\n              : adaptiveParams.stdDev >= 2.0 ? 'MEDIUM'\r\n                : 'LOW';\r\n\r\n            // Log adaptive params on INFO (volatility-based adjustments are important)\r\n            this.logger.info('üîß BB Adaptive Params Applied', {\r\n              volatility: volatilityCategory,\r\n              period: adaptiveParams.period,\r\n              stdDev: adaptiveParams.stdDev.toFixed(1),\r\n              atr: atr.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n            });\r\n          }\r\n\r\n          const result = this.bollingerIndicator.calculate(primaryCandles);\r\n          const isSqueeze = this.bollingerIndicator.isSqueeze(\r\n            this.config.indicators.bollingerBands.squeezeThreshold,\r\n          );\r\n\r\n          bollingerBands = {\r\n            upper: result.upper,\r\n            middle: result.middle,\r\n            lower: result.lower,\r\n            width: result.width,\r\n            percentB: result.percentB,\r\n            isSqueeze,\r\n          };\r\n\r\n          // Determine position within bands\r\n          const pricePosition = result.percentB <= 0.15 ? 'NEAR_LOWER'\r\n            : result.percentB >= 0.85 ? 'NEAR_UPPER'\r\n              : result.percentB >= 0.3 && result.percentB <= CONFIDENCE_THRESHOLDS.MODERATE ? 'MIDDLE_ZONE'\r\n                : 'NORMAL';\r\n\r\n          // Log on INFO when squeeze or near edges\r\n          if (isSqueeze || pricePosition === 'NEAR_LOWER' || pricePosition === 'NEAR_UPPER') {\r\n            this.logger.info('üìà Bollinger Bands EVENT', {\r\n              upper: result.upper.toFixed(DECIMAL_PLACES.PRICE),\r\n              middle: result.middle.toFixed(DECIMAL_PLACES.PRICE),\r\n              lower: result.lower.toFixed(DECIMAL_PLACES.PRICE),\r\n              currentPrice: currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n              width: result.width.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n              percentB: result.percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n              position: pricePosition,\r\n              squeeze: isSqueeze ? 'üî• YES' : 'no',\r\n            });\r\n          } else {\r\n            this.logger.debug('Bollinger Bands calculated for strategy', {\r\n              upper: result.upper.toFixed(DECIMAL_PLACES.PERCENT),\r\n              middle: result.middle.toFixed(DECIMAL_PLACES.PERCENT),\r\n              lower: result.lower.toFixed(DECIMAL_PLACES.PERCENT),\r\n              width: result.width.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n              percentB: result.percentB.toFixed(DECIMAL_PLACES.PERCENT),\r\n              squeeze: isSqueeze,\r\n            });\r\n          }\r\n        } catch (error) {\r\n          this.logger.warn('Bollinger Bands calculation failed', { error });\r\n        }\r\n      }\r\n\r\n      // Predict breakout direction if BB squeeze detected (BB.MD Section 4.4)\r\n      let breakoutPrediction: StrategyMarketData['breakoutPrediction'];\r\n      if (bollingerBands?.isSqueeze) {\r\n        try {\r\n          // Calculate volume ratio on PRIMARY candles\r\n          const recentVolumes = primaryCandles.slice(-20).map(c => c.volume);\r\n          const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;\r\n          const currentVolume = primaryCandles[primaryCandles.length - 1].volume;\r\n          const volumeRatio = currentVolume / avgVolume;\r\n\r\n          const prediction = this.breakoutPredictor.predict(emaFast, emaSlow, rsi, volumeRatio);\r\n\r\n          breakoutPrediction = {\r\n            direction: prediction.direction,\r\n            confidence: prediction.confidence,\r\n            emaTrend: prediction.factors.emaTrend,\r\n            rsiMomentum: prediction.factors.rsiMomentum,\r\n            volumeStrength: prediction.factors.volumeStrength,\r\n          };\r\n\r\n          this.logger.info('üîÆ Breakout prediction generated', {\r\n            direction: prediction.direction,\r\n            confidence: prediction.confidence.toFixed(1) + '%',\r\n            reason: prediction.reason,\r\n          });\r\n        } catch (error) {\r\n          this.logger.warn('Breakout prediction failed', { error });\r\n        }\r\n      }\r\n\r\n      // Build market data with PRIMARY candles for strategy analysis\r\n      // PHASE 4: Delta Analysis\r\n      const deltaAnalysis = this.deltaAnalyzerService?.analyze();\r\n\r\n      // PHASE 4: Orderbook Imbalance Analysis\r\n      let imbalanceAnalysis;\r\n      if (this.orderbookImbalanceService && this.currentOrderbook) {\r\n        const normalizeLevel = (level: OrderbookLevel): [number, number] => {\r\n          if (Array.isArray(level)) {\r\n            return level as [number, number];\r\n          }\r\n          // level is object with price and size properties\r\n          const objLevel = level as { price: number; size: number };\r\n          return [objLevel.price, objLevel.size];\r\n        };\r\n\r\n        imbalanceAnalysis = this.orderbookImbalanceService.analyze({\r\n          bids: this.currentOrderbook.bids.map(normalizeLevel),\r\n          asks: this.currentOrderbook.asks.map(normalizeLevel),\r\n        });\r\n      }\r\n\r\n      const marketData: StrategyMarketData = {\r\n        timestamp: currentTimestamp,\r\n        currentPrice,\r\n        candles: primaryCandles,\r\n        swingPoints,\r\n        rsi,\r\n        rsiTrend1,\r\n        ema: {\r\n          fast: emaFast,\r\n          slow: emaSlow,\r\n        },\r\n        emaTrend1,\r\n        atr,\r\n        trend: this.currentContext!.trend,\r\n        liquidity: liquidityAnalysis,\r\n        divergence,\r\n        ...(this.currentOrderbook && { orderbook: this.currentOrderbook }), // Include orderbook if available\r\n        context: this.currentContext!,\r\n        stochastic,\r\n        bollingerBands,\r\n        breakoutPrediction,\r\n        deltaAnalysis, // PHASE 4: Buy/Sell pressure\r\n        imbalanceAnalysis, // PHASE 4: Bid/Ask pressure\r\n      };\r\n\r\n      return marketData;\r\n    } catch (error) {\r\n      this.logger.error('Error preparing market data', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate position size\r\n   */\r\n  private calculatePositionSize(\r\n    price: number,\r\n    balance: number,\r\n    targetUsdt: number,\r\n  ): number {\r\n    // Use smaller of: target size or 90% of balance\r\n    const maxUsdt = Math.min(targetUsdt, balance * 0.9);\r\n    const qty = maxUsdt / price;\r\n\r\n    // Round to 2 decimals\r\n    return Math.floor(qty * PERCENT_MULTIPLIER) / PERCENT_MULTIPLIER;\r\n  }\r\n\r\n  /**\r\n   * Sync time with Bybit exchange\r\n   * CRITICAL: Prevents timestamp errors when opening positions\r\n   */\r\n  private async syncTimeWithExchange(): Promise<void> {\r\n    try {\r\n      const serverTime = await this.bybitService.getServerTime();\r\n      const localTime = Date.now();\r\n      const drift = localTime - serverTime;\r\n\r\n      if (Math.abs(drift) > 500) {\r\n        this.logger.warn('‚è∞ Clock drift detected', {\r\n          serverTime,\r\n          localTime,\r\n          driftMs: drift,\r\n          driftSec: (drift / 1000).toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      } else {\r\n        this.logger.debug('‚è∞ Time synced', { driftMs: drift });\r\n      }\r\n\r\n      // Store time offset in BybitService for timestamp correction\r\n      // This assumes BybitService has a timeOffset property\r\n      // For now, just log the drift - actual correction happens in SDK\r\n    } catch (error) {\r\n      this.logger.warn('Failed to sync time with exchange', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze BTC for signal confirmation\r\n   */\r\n  private async analyzeBTC(signalDirection: SignalDirection): Promise<BTCAnalysis | null> {\r\n    if (!this.btcAnalyzer || !this.config.btcConfirmation?.enabled) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const btcConfig = this.config.btcConfirmation;\r\n\r\n      // Fetch BTC candles directly from Bybit\r\n      const btcCandles = await this.bybitService.getCandles(\r\n        btcConfig.symbol,\r\n        btcConfig.timeframe,\r\n        btcConfig.candleLimit || 50,\r\n      );\r\n\r\n      if (!btcCandles || btcCandles.length < (btcConfig.lookbackCandles || 10)) {\r\n        this.logger.warn('Not enough BTC candles for analysis', {\r\n          available: btcCandles?.length || 0,\r\n          required: btcConfig.lookbackCandles || 10,\r\n        });\r\n        return null;\r\n      }\r\n\r\n      // Get altcoin candles for correlation (optional)\r\n      let altCandles: Candle[] | undefined;\r\n      if (btcConfig.useCorrelation) {\r\n        altCandles = await this.candleProvider.getCandles(\r\n          TimeframeRole.ENTRY,\r\n          btcConfig.correlationPeriod || 50,\r\n        );\r\n      }\r\n\r\n      // Analyze BTC\r\n      const analysis = this.btcAnalyzer.analyze(btcCandles, signalDirection, altCandles);\r\n\r\n      return analysis;\r\n    } catch (error) {\r\n      this.logger.error('BTC analysis failed', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle orderbook update from Public WebSocket\r\n   * Stores orderbook data for whale detection\r\n   */\r\n  onOrderbookUpdate(orderbook: OrderBook): void {\r\n    this.currentOrderbook = orderbook;\r\n    // Note: Orderbook updates are very frequent (~20-50ms), don't log\r\n  }\r\n\r\n  /**\r\n   * Check for Whale Hunter signals in real-time (called from bot.ts on orderbook updates)\r\n   * This bypasses the candle-close trigger for time-sensitive whale detection\r\n   *\r\n   * @param orderbook - Current orderbook snapshot\r\n   * @returns Promise<void> - Executes trade if whale signal found\r\n   */\r\n  async checkWhaleSignalRealtime(orderbook: OrderBook): Promise<void> {\r\n    try {\r\n      // Skip if no whale hunter strategy registered\r\n      const whaleStrategy = this.strategyCoordinator\r\n        .getStrategies()\r\n        .find(s => s.name === 'WHALE_HUNTER' || s.name === 'WHALE_HUNTER_FOLLOW');\r\n\r\n      if (!whaleStrategy) {\r\n        return; // Whale hunter not enabled\r\n      }\r\n\r\n      // Skip if already in position\r\n      if (this.positionManager.getCurrentPosition()) {\r\n        return; // Already in position\r\n      }\r\n\r\n      // Skip if context not ready\r\n      if (!this.currentContext) {\r\n        return; // Context not initialized yet\r\n      }\r\n\r\n      // Prepare lightweight market data for whale detection (scalping-optimized)\r\n      // Skips: RSI, EMA, liquidity, divergence - only orderbook + price + context\r\n      const marketData = await this.prepareMarketDataForWhale(orderbook);\r\n      if (!marketData) {\r\n        return; // Failed to prepare data\r\n      }\r\n\r\n      // Evaluate ONLY whale hunter strategies\r\n      const strategySignal = await whaleStrategy.evaluate(marketData);\r\n\r\n      // Check if valid signal\r\n      if (strategySignal.valid && strategySignal.signal) {\r\n        this.logger.info('üêã WHALE SIGNAL DETECTED (real-time)!', {\r\n          strategy: strategySignal.strategyName,\r\n          direction: strategySignal.signal.direction,\r\n          confidence: strategySignal.signal.confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n          reason: strategySignal.reason,\r\n        });\r\n\r\n        // Convert to EntrySignal\r\n        const entrySignal: EntrySignal = {\r\n          shouldEnter: true,\r\n          direction: strategySignal.signal.direction,\r\n          confidence: strategySignal.signal.confidence,\r\n          entryPrice: strategySignal.signal.price,\r\n          stopLoss: strategySignal.signal.stopLoss,\r\n          takeProfits: strategySignal.signal.takeProfits,\r\n          reason: strategySignal.reason || strategySignal.strategyName,\r\n          timestamp: strategySignal.signal.timestamp,\r\n          strategyName: strategySignal.strategyName,\r\n        };\r\n\r\n        // Execute trade immediately (whale signals are time-critical!)\r\n        await this.executeTrade(entrySignal, marketData);\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('Error in real-time whale signal check', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current context (for monitoring/debugging)\r\n   */\r\n  getCurrentContext(): TradingContext | null {\r\n    return this.currentContext;\r\n  }\r\n  /**\r\n   * Get all registered strategies\r\n   */\r\n  getStrategies(): IStrategy[] {\r\n    return this.strategyCoordinator.getStrategies();\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\virtual-balance.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ErrorContext' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'extractErrorMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":29},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":133,"column":68,"nodeType":"Literal","messageId":"noMagic","endLine":133,"endColumn":69},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.","line":219,"column":21,"nodeType":"ConditionalExpression","messageId":"preferNullishOverTernary","endLine":219,"endColumn":85,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6623,6687],"text":"newBaseDeposit ?? this.baseDeposit"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'syncFromHistory' has no 'await' expression.","line":241,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":241,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.01.","line":252,"column":16,"nodeType":"Literal","messageId":"noMagic","endLine":252,"endColumn":20}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\n/**\n * Virtual Balance Service\n *\n * Manages virtual trading balance independent from exchange balance.\n * Essential for:\n * - Demo mode: ignore huge demo balance (e.g., 49,614 USDT)\n * - Production: track bot's actual P&L separate from manual trades\n * - Compound interest: use bot's actual performance, not exchange balance\n *\n * State persisted to virtual-balance.json and synced on startup.\n *\n * Usage:\n * ```typescript\n * const vb = new VirtualBalanceService(logger, 50); // Start with 50 USDT\n * vb.updateBalance(+5.0, 'APEX_001'); // Add profit\n * const current = vb.getCurrentBalance(); // 55.0\n * ```\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { LoggerService, ValidatedVirtualBalanceState, ErrorContext } from '../types';\nimport { extractErrorMessage, createErrorContext } from '../utils/error-helper';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface VirtualBalanceState {\n  currentBalance: number; // Current virtual balance\n  baseDeposit: number; // Initial deposit (never changes)\n  lastUpdated: number; // Timestamp of last update\n  totalTrades: number; // Total number of trades\n  lastTradeId: string; // ID of last processed trade\n  totalProfit: number; // Total profit (currentBalance - baseDeposit)\n  allTimeHigh: number; // Highest balance achieved\n  allTimeLow: number; // Lowest balance achieved\n}\n\n// ============================================================================\n// VIRTUAL BALANCE SERVICE\n// ============================================================================\n\nexport class VirtualBalanceService {\n  private statePath: string;\n  private state: VirtualBalanceState;\n\n  constructor(\n    private logger: LoggerService,\n    private baseDeposit: number,\n    private dataDir: string = './data',\n  ) {\n    if (baseDeposit < 0) {\n      throw new Error('Base deposit cannot be negative');\n    }\n\n    this.statePath = path.join(this.dataDir, 'virtual-balance.json');\n    this.state = this.loadState();\n  }\n\n  /**\n   * Load state from file or initialize\n   */\n  private loadState(): VirtualBalanceState {\n    try {\n      if (fs.existsSync(this.statePath)) {\n        const content = fs.readFileSync(this.statePath, 'utf-8');\n        const state = JSON.parse(content) as ValidatedVirtualBalanceState;\n\n        // Update base deposit if changed in config\n        if (state.baseDeposit !== this.baseDeposit) {\n          this.logger.warn('‚ö†Ô∏è Base deposit changed in config', {\n            old: state.baseDeposit,\n            new: this.baseDeposit,\n            currentBalance: state.currentBalance,\n          });\n\n          // Option 1: Keep current balance, just update base reference\n          state.baseDeposit = this.baseDeposit;\n\n          // Recalculate profit\n          state.totalProfit = state.currentBalance - this.baseDeposit;\n        }\n\n        this.logger.info('‚úÖ Virtual balance loaded', {\n          balance: state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n          profit: state.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\n          trades: state.totalTrades,\n        });\n\n        return state;\n      }\n    } catch (error: unknown) {\n      const errorContext = createErrorContext(error);\n      this.logger.error('‚ùå Failed to load virtual balance', {\n        error: errorContext.message,\n        timestamp: errorContext.timestamp,\n      });\n    }\n\n    // Initialize new state\n    const newState: VirtualBalanceState = {\n      currentBalance: this.baseDeposit,\n      baseDeposit: this.baseDeposit,\n      lastUpdated: Date.now(),\n      totalTrades: 0,\n      lastTradeId: '',\n      totalProfit: 0,\n      allTimeHigh: this.baseDeposit,\n      allTimeLow: this.baseDeposit,\n    };\n\n    this.saveState(newState);\n\n    this.logger.info('‚úÖ Virtual balance initialized', {\n      balance: newState.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      baseDeposit: this.baseDeposit.toFixed(DECIMAL_PLACES.PERCENT),\n    });\n\n    return newState;\n  }\n\n  /**\n   * Save state to file\n   */\n  private saveState(state: VirtualBalanceState): void {\n    try {\n      if (!fs.existsSync(this.dataDir)) {\n        fs.mkdirSync(this.dataDir, { recursive: true });\n      }\n\n      fs.writeFileSync(this.statePath, JSON.stringify(state, null, 2), 'utf-8');\n    } catch (error: unknown) {\n      const errorContext = createErrorContext(error);\n      this.logger.error('‚ùå Failed to save virtual balance', {\n        error: errorContext.message,\n        timestamp: errorContext.timestamp,\n      });\n    }\n  }\n\n  /**\n   * Get current virtual balance\n   */\n  getCurrentBalance(): number {\n    return this.state.currentBalance;\n  }\n\n  /**\n   * Get base deposit\n   */\n  getBaseDeposit(): number {\n    return this.state.baseDeposit;\n  }\n\n  /**\n   * Get total profit (current - base)\n   */\n  getTotalProfit(): number {\n    return this.state.totalProfit;\n  }\n\n  /**\n   * Get profit percentage\n   */\n  getProfitPercent(): number {\n    if (this.state.baseDeposit === 0) {\n      return 0;\n    }\n    return (this.state.totalProfit / this.state.baseDeposit) * PERCENT_MULTIPLIER;\n  }\n\n  /**\n   * Get complete state\n   */\n  getState(): VirtualBalanceState {\n    return { ...this.state };\n  }\n\n  /**\n   * Update balance after trade\n   */\n  updateBalance(pnl: number, tradeId: string): void {\n    const oldBalance = this.state.currentBalance;\n\n    this.state.currentBalance += pnl;\n    this.state.lastUpdated = Date.now();\n    this.state.totalTrades++;\n    this.state.lastTradeId = tradeId;\n    this.state.totalProfit = this.state.currentBalance - this.state.baseDeposit;\n\n    // Update all-time highs/lows\n    if (this.state.currentBalance > this.state.allTimeHigh) {\n      this.state.allTimeHigh = this.state.currentBalance;\n    }\n    if (this.state.currentBalance < this.state.allTimeLow) {\n      this.state.allTimeLow = this.state.currentBalance;\n    }\n\n    this.saveState(this.state);\n\n    const emoji = pnl > 0 ? 'üí∞' : pnl < 0 ? 'üìâ' : '‚ûñ';\n\n    this.logger.info(`${emoji} Virtual balance updated`, {\n      tradeId,\n      pnl: pnl.toFixed(DECIMAL_PLACES.PERCENT),\n      oldBalance: oldBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      newBalance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      profit: this.state.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\n      profitPercent: this.getProfitPercent().toFixed(DECIMAL_PLACES.PERCENT) + '%',\n    });\n  }\n\n  /**\n   * Reset balance to base deposit\n   */\n  reset(newBaseDeposit?: number): void {\n    const deposit = newBaseDeposit !== undefined ? newBaseDeposit : this.baseDeposit;\n\n    this.state.currentBalance = deposit;\n    this.state.baseDeposit = deposit;\n    this.state.lastUpdated = Date.now();\n    this.state.totalTrades = 0;\n    this.state.lastTradeId = '';\n    this.state.totalProfit = 0;\n    this.state.allTimeHigh = deposit;\n    this.state.allTimeLow = deposit;\n\n    this.saveState(this.state);\n\n    this.logger.warn('‚ö†Ô∏è Virtual balance RESET', {\n      balance: deposit.toFixed(DECIMAL_PLACES.PERCENT),\n    });\n  }\n\n  /**\n   * Sync balance from trade history (recalculate from scratch)\n   * Useful for fixing inconsistencies\n   */\n  async syncFromHistory(trades: Array<{ id: string; netPnl: number }>): Promise<void> {\n    let calculatedBalance = this.state.baseDeposit;\n    let lastTradeId = '';\n\n    for (const trade of trades) {\n      calculatedBalance += trade.netPnl;\n      lastTradeId = trade.id;\n    }\n\n    const diff = Math.abs(calculatedBalance - this.state.currentBalance);\n\n    if (diff > 0.01) {\n      // Threshold for floating point errors\n      this.logger.warn('‚ö†Ô∏è Balance mismatch detected, syncing from history', {\n        currentBalance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n        calculatedBalance: calculatedBalance.toFixed(DECIMAL_PLACES.PERCENT),\n        difference: diff.toFixed(DECIMAL_PLACES.PERCENT),\n      });\n\n      this.state.currentBalance = calculatedBalance;\n      this.state.totalProfit = calculatedBalance - this.state.baseDeposit;\n      this.state.totalTrades = trades.length;\n      this.state.lastTradeId = lastTradeId;\n      this.state.lastUpdated = Date.now();\n\n      // Update all-time highs/lows\n      if (calculatedBalance > this.state.allTimeHigh) {\n        this.state.allTimeHigh = calculatedBalance;\n      }\n      if (calculatedBalance < this.state.allTimeLow) {\n        this.state.allTimeLow = calculatedBalance;\n      }\n\n      this.saveState(this.state);\n\n      this.logger.info('‚úÖ Virtual balance synced from history', {\n        balance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n        profit: this.state.totalProfit.toFixed(DECIMAL_PLACES.PERCENT),\n        trades: this.state.totalTrades,\n      });\n    } else {\n      this.logger.debug('‚úÖ Virtual balance in sync with history', {\n        balance: this.state.currentBalance.toFixed(DECIMAL_PLACES.PERCENT),\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\volume-profile.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":65,"column":26,"nodeType":"CallExpression","messageId":"conditionErrorNullableNumber","endLine":65,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2280,2305],"text":"(volumeMap.get(priceLevel) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2280,2305],"text":"(volumeMap.get(priceLevel) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2280,2305],"text":"(Boolean(volumeMap.get(priceLevel)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":65,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":65,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2306,2308],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 8.","line":134,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":134,"endColumn":45}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Volume Profile Service (PHASE 4 Feature 3)\r\n *\r\n * Calculates volume distribution across price levels to find:\r\n * - POC (Point of Control) = Price with highest volume\r\n * - VAH (Value Area High) = Top of 70% volume range\r\n * - VAL (Value Area Low) = Bottom of 70% volume range\r\n *\r\n * Use Cases:\r\n * - Support/Resistance levels (POC acts as magnet)\r\n * - Entry zones (near VAL for LONG, VAH for SHORT)\r\n * - Breakout targets (above VAH = bullish, below VAL = bearish)\r\n */\r\n\r\nimport { VolumeProfileConfig, VolumeProfileResult, VolumeNode, Candle, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// VOLUME PROFILE SERVICE\r\n// ============================================================================\r\n\r\nexport class VolumeProfileService {\r\n  constructor(\r\n    private config: VolumeProfileConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('VolumeProfileService initialized', {\r\n      enabled: config.enabled,\r\n      lookbackCandles: config.lookbackCandles,\r\n      valueAreaPercent: config.valueAreaPercent,\r\n      priceTickSize: config.priceTickSize,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculate volume profile from candles\r\n   * @param candles - Array of candles (oldest first)\r\n   * @returns Volume profile with POC, VAH, VAL\r\n   */\r\n  calculate(candles: Candle[]): VolumeProfileResult | null {\r\n    if (!this.config.enabled) {\r\n      return null;\r\n    }\r\n\r\n    if (candles.length === 0) {\r\n      this.logger.warn('Cannot calculate volume profile: no candles');\r\n      return null;\r\n    }\r\n\r\n    // Take last N candles\r\n    const lookback = Math.min(this.config.lookbackCandles, candles.length);\r\n    const relevantCandles = candles.slice(-lookback);\r\n\r\n    // Build volume distribution (price ‚Üí volume map)\r\n    const volumeMap = new Map<number, number>();\r\n\r\n    for (const candle of relevantCandles) {\r\n      // Get price levels within candle range\r\n      const priceLevels = this.getPriceLevels(candle);\r\n\r\n      // Distribute candle volume evenly across price levels\r\n      const volumePerLevel = candle.volume / priceLevels.length;\r\n\r\n      for (const priceLevel of priceLevels) {\r\n        const existing = volumeMap.get(priceLevel) || 0;\r\n        volumeMap.set(priceLevel, existing + volumePerLevel);\r\n      }\r\n    }\r\n\r\n    // Convert to nodes and sort by volume (descending)\r\n    const nodes: VolumeNode[] = Array.from(volumeMap.entries())\r\n      .map(([price, volume]) => ({ price, volume }))\r\n      .sort((a, b) => b.volume - a.volume);\r\n\r\n    if (nodes.length === 0) {\r\n      this.logger.warn('Cannot calculate volume profile: no volume nodes');\r\n      return null;\r\n    }\r\n\r\n    const totalVolume = nodes.reduce((sum, n) => sum + n.volume, 0);\r\n\r\n    // POC = price with highest volume\r\n    const poc = nodes[0].price;\r\n\r\n    // Value Area = range containing N% of total volume\r\n    const valueVolume = totalVolume * (this.config.valueAreaPercent / PERCENT_MULTIPLIER);\r\n    let accumulatedVolume = 0;\r\n    const valueNodes: VolumeNode[] = [];\r\n\r\n    for (const node of nodes) {\r\n      valueNodes.push(node);\r\n      accumulatedVolume += node.volume;\r\n      if (accumulatedVolume >= valueVolume) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // VAH/VAL = top/bottom of value area (sort by price)\r\n    const valuePrices = valueNodes.map((n) => n.price).sort((a, b) => a - b);\r\n    const val = valuePrices[0];\r\n    const vah = valuePrices[valuePrices.length - 1];\r\n\r\n    this.logger.debug('üìä Volume Profile calculated', {\r\n      poc: poc.toFixed(DECIMAL_PLACES.PRICE),\r\n      vah: vah.toFixed(DECIMAL_PLACES.PRICE),\r\n      val: val.toFixed(DECIMAL_PLACES.PRICE),\r\n      totalVolume: totalVolume.toFixed(0),\r\n      nodesCount: nodes.length,\r\n    });\r\n\r\n    return {\r\n      poc,\r\n      vah,\r\n      val,\r\n      totalVolume,\r\n      nodes,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get price levels within candle range based on tick size\r\n   * @param candle - Candle to extract price levels from\r\n   * @returns Array of price levels\r\n   */\r\n  private getPriceLevels(candle: Candle): number[] {\r\n    const tickSize = this.config.priceTickSize;\r\n    const levels: number[] = [];\r\n\r\n    // Start from low and go to high by tick increments\r\n    let price = Math.floor(candle.low / tickSize) * tickSize;\r\n    const high = candle.high;\r\n\r\n    while (price <= high) {\r\n      levels.push(parseFloat(price.toFixed(8))); // Round to avoid floating point issues\r\n      price += tickSize;\r\n    }\r\n\r\n    // Fallback: if no levels generated (shouldn't happen), use close price\r\n    return levels.length > 0 ? levels : [candle.close];\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\wall-tracker.service.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":54,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":54,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1958,1967],"text":"existing == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":103,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":103,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3202,3207],"text":"wall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":279,"column":45,"nodeType":"Literal","messageId":"noMagic","endLine":279,"endColumn":49},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":279,"column":56,"nodeType":"Literal","messageId":"noMagic","endLine":279,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":280,"column":87,"nodeType":"Literal","messageId":"noMagic","endLine":280,"endColumn":89},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":328,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":328,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9749,9753],"text":"(wall != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":336,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":336,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9950,9954],"text":"(wall != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":345,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":345,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10234,10239],"text":"wall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":359,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":359,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10630,10635],"text":"wall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.4.","line":372,"column":81,"nodeType":"Literal","messageId":"noMagic","endLine":372,"endColumn":84},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":378,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":378,"endColumn":42},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":383,"column":19,"nodeType":"Literal","messageId":"noMagic","endLine":383,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":398,"column":7,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":404,"endColumn":9,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11694,11915],"text":"(clusters.find((c: WallCluster) => {\r\n        if (c.side !== side) {\r\n          return false;\r\n        }\r\n        const [minPrice, maxPrice] = c.priceRange;\r\n        return price >= minPrice && price <= maxPrice;\r\n      }) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":404,"column":10,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":404,"endColumn":12,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[11916,11918],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Wall Tracker Service (PHASE 4)\r\n *\r\n * Tracks orderbook wall lifetime and detects spoofing/iceberg orders.\r\n *\r\n * Features:\r\n * - Wall lifetime tracking (how long walls stay in book)\r\n * - Spoofing detection (walls added then removed quickly <5s)\r\n * - Iceberg detection (rapid refills = hidden orders)\r\n * - Wall cluster analysis (multiple walls at same level)\r\n * - Wall absorption tracking (volume traded through wall)\r\n *\r\n * Use Cases:\r\n * - Filter fake walls (spoofing) vs real institutional walls\r\n * - Detect iceberg orders (large hidden orders)\r\n * - Identify strong support/resistance (wall clusters)\r\n */\r\n\r\nimport { WallTrackingConfig, WallEvent, WallLifetime, WallCluster, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst CLUSTER_PRICE_THRESHOLD_PERCENT = MULTIPLIERS.HALF; // Walls within 0.5% = cluster\r\nconst MIN_REFILLS_FOR_ICEBERG = 3; // 3+ refills = iceberg\r\nconst CLUSTER_MIN_WALLS = 2; // Minimum walls to form cluster\r\n\r\n// ============================================================================\r\n// WALL TRACKER SERVICE\r\n// ============================================================================\r\n\r\nexport class WallTrackerService {\r\n  private activeWalls: Map<string, WallLifetime> = new Map(); // key: `${side}_${price}`\r\n  private wallHistory: WallEvent[] = [];\r\n\r\n  constructor(\r\n    private config: WallTrackingConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect new wall in orderbook\r\n   */\r\n  detectWall(price: number, size: number, side: 'BID' | 'ASK'): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    const key = this.getKey(side, price);\r\n    const existing = this.activeWalls.get(key);\r\n\r\n    if (!existing) {\r\n      // New wall detected\r\n      const wall: WallLifetime = {\r\n        firstSeen: Date.now(),\r\n        lastSeen: Date.now(),\r\n        price,\r\n        side,\r\n        maxSize: size,\r\n        currentSize: size,\r\n        events: [\r\n          {\r\n            timestamp: Date.now(),\r\n            type: 'ADDED',\r\n            price,\r\n            size,\r\n            side,\r\n          },\r\n        ],\r\n        isSpoofing: false,\r\n        isIceberg: false,\r\n        absorbedVolume: 0,\r\n      };\r\n\r\n      this.activeWalls.set(key, wall);\r\n      this.addEvent(wall.events[0]);\r\n\r\n      // Note: Wall detection logging disabled to reduce spam\r\n      // this.logger.debug('üß± Wall detected (PHASE 4)', {\r\n      //   side,\r\n      //   price: price.toFixed(DECIMAL_PLACES.PRICE),\r\n      //   size: size.toFixed(DECIMAL_PLACES.PERCENT),\r\n      // });\r\n    } else {\r\n      // Wall still exists - update\r\n      this.updateWall(existing, size);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove wall from tracking (wall disappeared from orderbook)\r\n   */\r\n  removeWall(price: number, side: 'BID' | 'ASK'): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    const key = this.getKey(side, price);\r\n    const wall = this.activeWalls.get(key);\r\n\r\n    if (!wall) {\r\n      return; // Not tracked\r\n    }\r\n\r\n    const lifetime = Date.now() - wall.firstSeen;\r\n\r\n    // Check for spoofing (removed too quickly)\r\n    if (lifetime < this.config.spoofingThresholdMs) {\r\n      wall.isSpoofing = true;\r\n      /*this.logger.warn('‚ö†Ô∏è Spoofing detected (PHASE 4)', {\r\n        side,\r\n        price: price.toFixed(DECIMAL_PLACES.PRICE),\r\n        lifetime: `${lifetime}ms`,\r\n        size: wall.currentSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });*/\r\n    }\r\n\r\n    // Add REMOVED event\r\n    const event: WallEvent = {\r\n      timestamp: Date.now(),\r\n      type: 'REMOVED',\r\n      price,\r\n      size: wall.currentSize,\r\n      side,\r\n      reason: wall.isSpoofing ? 'spoofing' : 'filled_or_cancelled',\r\n    };\r\n\r\n    wall.events.push(event);\r\n    this.addEvent(event);\r\n\r\n    this.activeWalls.delete(key);\r\n\r\n    // Note: Wall removal logging disabled to reduce spam\r\n    // this.logger.debug('üß± Wall removed (PHASE 4)', {\r\n    //   side,\r\n    //   price: price.toFixed(DECIMAL_PLACES.PRICE),\r\n    //   lifetime: `${lifetime}ms`,\r\n    //   isSpoofing: wall.isSpoofing,\r\n    //   isIceberg: wall.isIceberg,\r\n    // });\r\n  }\r\n\r\n  /**\r\n   * Update existing wall (size changed)\r\n   */\r\n  private updateWall(wall: WallLifetime, newSize: number): void {\r\n    wall.lastSeen = Date.now();\r\n\r\n    // Check for absorption (size decreased)\r\n    if (newSize < wall.currentSize) {\r\n      const absorbed = wall.currentSize - newSize;\r\n      wall.absorbedVolume += absorbed;\r\n\r\n      const event: WallEvent = {\r\n        timestamp: Date.now(),\r\n        type: 'ABSORBED',\r\n        price: wall.price,\r\n        size: absorbed,\r\n        side: wall.side,\r\n      };\r\n\r\n      wall.events.push(event);\r\n      this.addEvent(event);\r\n    }\r\n\r\n    // Check for refill (size increased = iceberg)\r\n    if (newSize > wall.currentSize) {\r\n      const refilled = newSize - wall.currentSize;\r\n\r\n      const event: WallEvent = {\r\n        timestamp: Date.now(),\r\n        type: 'REFILLED',\r\n        price: wall.price,\r\n        size: refilled,\r\n        side: wall.side,\r\n      };\r\n\r\n      wall.events.push(event);\r\n      this.addEvent(event);\r\n\r\n      // Check for iceberg pattern (multiple refills)\r\n      const refillCount = wall.events.filter((e) => e.type === 'REFILLED').length;\r\n      if (refillCount >= MIN_REFILLS_FOR_ICEBERG && !wall.isIceberg) {\r\n        wall.isIceberg = true;\r\n        // Log only once when first detected (at exactly MIN_REFILLS_FOR_ICEBERG)\r\n        /*this.logger.info('üßä Iceberg detected (PHASE 4)', {\r\n          side: wall.side,\r\n          price: wall.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          refills: refillCount,\r\n          totalSize: newSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });*/\r\n      }\r\n    }\r\n\r\n    wall.currentSize = newSize;\r\n    wall.maxSize = Math.max(wall.maxSize, newSize);\r\n  }\r\n\r\n  /**\r\n   * Detect wall clusters (multiple walls at similar prices)\r\n   */\r\n  detectClusters(): WallCluster[] {\r\n    if (!this.config.enabled) {\r\n      return [];\r\n    }\r\n\r\n    const clusters: WallCluster[] = [];\r\n\r\n    // Group walls by side\r\n    const bidWalls = Array.from(this.activeWalls.values()).filter((w) => w.side === 'BID');\r\n    const askWalls = Array.from(this.activeWalls.values()).filter((w) => w.side === 'ASK');\r\n\r\n    // Detect BID clusters\r\n    clusters.push(...this.findClustersInWalls(bidWalls, 'BID'));\r\n\r\n    // Detect ASK clusters\r\n    clusters.push(...this.findClustersInWalls(askWalls, 'ASK'));\r\n\r\n    return clusters;\r\n  }\r\n\r\n  /**\r\n   * Find clusters in array of walls\r\n   */\r\n  private findClustersInWalls(walls: WallLifetime[], side: 'BID' | 'ASK'): WallCluster[] {\r\n    if (walls.length < CLUSTER_MIN_WALLS) {\r\n      return [];\r\n    }\r\n\r\n    // Sort by price\r\n    const sorted = walls.sort((a, b) => a.price - b.price);\r\n    const clusters: WallCluster[] = [];\r\n    let currentCluster: WallLifetime[] = [sorted[0]];\r\n\r\n    for (let i = 1; i < sorted.length; i++) {\r\n      const wall = sorted[i];\r\n      const prevWall = sorted[i - 1];\r\n\r\n      // Check if wall is within cluster threshold\r\n      const priceDiff = Math.abs(wall.price - prevWall.price);\r\n      const threshold = prevWall.price * (CLUSTER_PRICE_THRESHOLD_PERCENT / PERCENT_MULTIPLIER);\r\n\r\n      if (priceDiff <= threshold) {\r\n        // Add to current cluster\r\n        currentCluster.push(wall);\r\n      } else {\r\n        // End current cluster, start new one\r\n        if (currentCluster.length >= CLUSTER_MIN_WALLS) {\r\n          clusters.push(this.createCluster(currentCluster, side));\r\n        }\r\n        currentCluster = [wall];\r\n      }\r\n    }\r\n\r\n    // Add last cluster\r\n    if (currentCluster.length >= CLUSTER_MIN_WALLS) {\r\n      clusters.push(this.createCluster(currentCluster, side));\r\n    }\r\n\r\n    return clusters;\r\n  }\r\n\r\n  /**\r\n   * Create cluster from walls\r\n   */\r\n  private createCluster(walls: WallLifetime[], side: 'BID' | 'ASK'): WallCluster {\r\n    const prices = walls.map((w) => w.price);\r\n    const minPrice = Math.min(...prices);\r\n    const maxPrice = Math.max(...prices);\r\n\r\n    const totalSize = walls.reduce((sum, w) => sum + w.currentSize, 0);\r\n    const totalLifetime = walls.reduce((sum, w) => sum + (Date.now() - w.firstSeen), 0);\r\n    const averageLifetime = totalLifetime / walls.length;\r\n\r\n    // Calculate strength (based on size and lifetime)\r\n    const avgSize = totalSize / walls.length;\r\n    const sizeStrength = Math.min(avgSize / 1000, 1) * 50; // 0-50 points\r\n    const lifetimeStrength = Math.min(averageLifetime / TIME_UNITS.FIVE_MINUTES, 1) * 50; // 0-50 points (5min max)\r\n    const strength = sizeStrength + lifetimeStrength;\r\n\r\n    return {\r\n      priceRange: [minPrice, maxPrice],\r\n      side,\r\n      wallCount: walls.length,\r\n      totalSize,\r\n      averageLifetime,\r\n      strength: Math.round(strength),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get active walls (for analysis)\r\n   */\r\n  getActiveWalls(): WallLifetime[] {\r\n    return Array.from(this.activeWalls.values());\r\n  }\r\n\r\n  /**\r\n   * Get wall history\r\n   */\r\n  getHistory(): WallEvent[] {\r\n    return this.wallHistory;\r\n  }\r\n\r\n  /**\r\n   * Clear all walls (reset)\r\n   */\r\n  clear(): void {\r\n    this.activeWalls.clear();\r\n    this.wallHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Get wall by price\r\n   */\r\n  getWall(price: number, side: 'BID' | 'ASK'): WallLifetime | undefined {\r\n    const key = this.getKey(side, price);\r\n    return this.activeWalls.get(key);\r\n  }\r\n\r\n  /**\r\n   * Check if wall is spoofing\r\n   */\r\n  isSpoofing(price: number, side: 'BID' | 'ASK'): boolean {\r\n    const wall = this.getWall(price, side);\r\n    return wall ? wall.isSpoofing : false;\r\n  }\r\n\r\n  /**\r\n   * Check if wall is iceberg\r\n   */\r\n  isIceberg(price: number, side: 'BID' | 'ASK'): boolean {\r\n    const wall = this.getWall(price, side);\r\n    return wall ? wall.isIceberg : false;\r\n  }\r\n\r\n  /**\r\n   * Check if wall is real (not spoofing and lived long enough)\r\n   * @returns true if wall is real and trustworthy\r\n   */\r\n  isWallReal(price: number, side: 'BID' | 'ASK'): boolean {\r\n    const wall = this.getWall(price, side);\r\n    if (!wall) {\r\n      return false;\r\n    }\r\n\r\n    const lifetime = Date.now() - wall.firstSeen;\r\n    return lifetime >= this.config.minLifetimeMs && !wall.isSpoofing;\r\n  }\r\n\r\n  /**\r\n   * Get wall strength score (0-1)\r\n   * Factors: lifetime, size stability, iceberg detection\r\n   */\r\n  getWallStrength(price: number, side: 'BID' | 'ASK'): number {\r\n    const wall = this.getWall(price, side);\r\n    if (!wall) {\r\n      return 0;\r\n    }\r\n\r\n    // Spoofing walls have zero strength\r\n    if (wall.isSpoofing) {\r\n      return 0;\r\n    }\r\n\r\n    let strength = 0;\r\n\r\n    // 1. Lifetime score (0-0.4)\r\n    const lifetime = Date.now() - wall.firstSeen;\r\n    const lifetimeScore = Math.min(lifetime / this.config.minLifetimeMs, 1.0) * 0.4;\r\n    strength += lifetimeScore;\r\n\r\n    // 2. Size stability score (0-0.3)\r\n    // High if current size is close to max size\r\n    const sizeRatio = wall.currentSize / wall.maxSize;\r\n    const sizeStability = sizeRatio * 0.3;\r\n    strength += sizeStability;\r\n\r\n    // 3. Iceberg bonus (0-0.3)\r\n    if (wall.isIceberg) {\r\n      strength += 0.3;\r\n    }\r\n\r\n    return Math.min(strength, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Get wall cluster at price level\r\n   * @returns cluster info or null if no cluster found\r\n   */\r\n  getClusterAt(price: number, side: 'BID' | 'ASK'): WallCluster | null {\r\n    const clusters = this.detectClusters();\r\n\r\n    // Find cluster containing this price (check if price is within cluster's price range)\r\n    return (\r\n      clusters.find((c: WallCluster) => {\r\n        if (c.side !== side) {\r\n          return false;\r\n        }\r\n        const [minPrice, maxPrice] = c.priceRange;\r\n        return price >= minPrice && price <= maxPrice;\r\n      }) || null\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generate unique key for wall\r\n   */\r\n  private getKey(side: 'BID' | 'ASK', price: number): string {\r\n    return `${side}_${price.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n  }\r\n\r\n  /**\r\n   * Add event to history (with limit)\r\n   */\r\n  private addEvent(event: WallEvent): void {\r\n    this.wallHistory.push(event);\r\n\r\n    // Trim history to config limit\r\n    if (this.wallHistory.length > this.config.trackHistoryCount) {\r\n      this.wallHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get config (for testing)\r\n   */\r\n  getConfig(): WallTrackingConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\websocket-manager.service.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":89,"column":39,"nodeType":"Literal","messageId":"noMagic","endLine":89,"endColumn":42},{"ruleId":"complexity","severity":1,"message":"Method 'routeMessage' has a complexity of 13. Maximum allowed is 10.","line":311,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":375,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Method 'processPositionData' has a complexity of 11. Maximum allowed is 10.","line":391,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":434,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Method 'handleOrderExecution' has a complexity of 41. Maximum allowed is 10.","line":440,"column":31,"nodeType":"FunctionExpression","messageId":"complex","endLine":576,"endColumn":4},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (446). Maximum allowed is 300.","line":468,"column":1,"nodeType":null,"messageId":"exceed","endLine":665,"endColumn":1},{"ruleId":"complexity","severity":1,"message":"Method 'handleOrderUpdate' has a complexity of 17. Maximum allowed is 10.","line":581,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":640,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TIME_UNITS } from '../constants';\r\n/**\r\n * WebSocket Manager Service\r\n * Manages Bybit WebSocket connections and subscriptions\r\n *\r\n * Responsibilities:\r\n * 1. Connect to Bybit WebSocket V5\r\n * 2. Subscribe to Position updates\r\n * 3. Subscribe to Order execution updates\r\n * 4. Emit events when position opened/closed\r\n * 5. Handle reconnection and errors\r\n *\r\n * Single Responsibility: Real-time event streaming from exchange\r\n */\r\n\r\nimport WebSocket from 'ws';\r\nimport crypto from 'crypto';\r\nimport { EventEmitter } from 'events';\r\nimport {\r\n  ExchangeConfig,\r\n  Position,\r\n  PositionSide,\r\n  LoggerService,\r\n  PositionData,\r\n  OrderExecutionData,\r\n  OrderUpdateData,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst WS_BASE_URL = 'wss://stream.bybit.com/v5/private';\r\nconst WS_TESTNET_URL = 'wss://stream-testnet.bybit.com/v5/private';\r\nconst WS_DEMO_URL = 'wss://stream-demo.bybit.com/v5/private';\r\nconst PING_INTERVAL_MS = 20000;\r\nconst RECONNECT_DELAY_MS = 5000;\r\nconst MAX_RECONNECT_ATTEMPTS = 10;\r\nconst AUTH_EXPIRES_OFFSET_MS = 10000;\r\nconst POSITION_SIZE_ZERO = 0;\r\n\r\n// ============================================================================\r\n// WEBSOCKET EVENTS\r\n// ============================================================================\r\n\r\nexport interface PositionUpdateEvent {\r\n  symbol: string;\r\n  side: string;\r\n  size: string;\r\n  avgPrice: string;\r\n  leverage: string;\r\n  unrealisedPnl: string;\r\n}\r\n\r\nexport interface OrderExecutionEvent {\r\n  orderId: string;\r\n  symbol: string;\r\n  side: string;\r\n  orderStatus: string;\r\n  execQty: string;\r\n  execPrice: string;\r\n}\r\n\r\nexport interface OrderUpdateEvent {\r\n  orderId: string;\r\n  symbol: string;\r\n  orderType: string;\r\n  orderStatus: string;\r\n  avgPrice: string;\r\n  qty: string;\r\n  cumExecQty: string;\r\n}\r\n\r\n// ============================================================================\r\n// WEBSOCKET MANAGER SERVICE\r\n// ============================================================================\r\n\r\nexport class WebSocketManagerService extends EventEmitter {\r\n  private ws: WebSocket | null = null;\r\n  private pingInterval: NodeJS.Timeout | null = null;\r\n  private reconnectAttempts: number = 0;\r\n  private isConnecting: boolean = false;\r\n  private shouldReconnect: boolean = true;\r\n  private tpCounter: number = 0;\r\n  private lastCloseReason: 'SL' | 'TP' | 'TRAILING' | null = null; // Track last close reason for journal\r\n\r\n  // Event deduplication\r\n  private processedEvents = new Map<string, number>(); // eventKey ‚Üí timestamp\r\n  private readonly EVENT_CACHE_SIZE = 100;\r\n  private readonly EVENT_CACHE_TTL_MS = TIME_UNITS.MINUTE; // 1 minute\r\n\r\n  constructor(\r\n    private readonly config: ExchangeConfig,\r\n    private readonly symbol: string,\r\n    private readonly logger: LoggerService,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC API\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Connect to WebSocket and subscribe to updates\r\n   */\r\n  connect(): void {\r\n    if (this.isConnecting || (this.ws !== null && this.ws.readyState === WebSocket.OPEN)) {\r\n      return;\r\n    }\r\n\r\n    this.isConnecting = true;\r\n\r\n    // Select WebSocket URL based on mode\r\n    let wsUrl: string;\r\n    if (this.config.testnet) {\r\n      wsUrl = WS_TESTNET_URL;\r\n    } else if (this.config.demo) {\r\n      wsUrl = WS_DEMO_URL;\r\n    } else {\r\n      wsUrl = WS_BASE_URL;\r\n    }\r\n\r\n    this.logger.info('Connecting to WebSocket', { url: wsUrl, mode: this.config.demo ? 'DEMO' : this.config.testnet ? 'TESTNET' : 'MAINNET' });\r\n\r\n    this.ws = new WebSocket(wsUrl);\r\n\r\n    this.ws.on('open', () => {\r\n      this.isConnecting = false;\r\n      this.reconnectAttempts = 0;\r\n      this.authenticate();\r\n      this.startPing();\r\n      this.emit('connected');\r\n    });\r\n\r\n    this.ws.on('message', (data: WebSocket.Data) => {\r\n      let message: string;\r\n      if (typeof data === 'string') {\r\n        message = data;\r\n      } else if (Buffer.isBuffer(data)) {\r\n        message = data.toString('utf-8');\r\n      } else if (Array.isArray(data)) {\r\n        message = Buffer.concat(data).toString('utf-8');\r\n      } else {\r\n        return; // Ignore unknown data types\r\n      }\r\n      this.handleMessage(message);\r\n    });\r\n\r\n    this.ws.on('error', (error: Error) => {\r\n      this.emit('error', error);\r\n    });\r\n\r\n    this.ws.on('close', () => {\r\n      this.isConnecting = false;\r\n      this.stopPing();\r\n      this.emit('disconnected');\r\n\r\n      if (this.shouldReconnect && this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\r\n        this.reconnectAttempts++;\r\n        setTimeout(() => {\r\n          void this.connect();\r\n        }, RECONNECT_DELAY_MS);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Disconnect from WebSocket\r\n   */\r\n  disconnect(): void {\r\n    this.shouldReconnect = false;\r\n    this.stopPing();\r\n\r\n    if (this.ws !== null) {\r\n      this.ws.close();\r\n      this.ws = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if WebSocket is connected\r\n   */\r\n  isConnected(): boolean {\r\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  /**\r\n   * Get last close reason (for determining exitType in journal)\r\n   */\r\n  getLastCloseReason(): 'SL' | 'TP' | 'TRAILING' | null {\r\n    return this.lastCloseReason;\r\n  }\r\n\r\n  /**\r\n   * Reset last close reason (called after position closes)\r\n   */\r\n  resetLastCloseReason(): void {\r\n    this.lastCloseReason = null;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE HELPERS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Check if event is duplicate (already processed)\r\n   * @param eventType - Type of event (TP, SL, POSITION)\r\n   * @param orderId - Order ID\r\n   * @param timestamp - Event timestamp\r\n   * @returns true if duplicate, false if new event\r\n   */\r\n  private isDuplicateEvent(eventType: string, orderId: string, timestamp: number): boolean {\r\n    const eventKey = `${eventType}_${orderId}_${timestamp}`;\r\n\r\n    if (this.processedEvents.has(eventKey)) {\r\n      this.logger.debug('Duplicate event ignored', { eventKey });\r\n      return true;\r\n    }\r\n\r\n    // Store event\r\n    this.processedEvents.set(eventKey, Date.now());\r\n\r\n    // Cleanup old events if cache is too large\r\n    if (this.processedEvents.size > this.EVENT_CACHE_SIZE) {\r\n      const now = Date.now();\r\n      for (const [key, time] of this.processedEvents.entries()) {\r\n        if (now - time > this.EVENT_CACHE_TTL_MS) {\r\n          this.processedEvents.delete(key);\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Authenticate WebSocket connection\r\n   */\r\n  private authenticate(): void {\r\n    if (this.ws === null || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    const expires = Date.now() + AUTH_EXPIRES_OFFSET_MS;\r\n    const signature = crypto\r\n      .createHmac('sha256', this.config.apiSecret)\r\n      .update(`GET/realtime${expires}`)\r\n      .digest('hex');\r\n\r\n    const authMessage = {\r\n      op: 'auth',\r\n      args: [this.config.apiKey, expires.toString(), signature],\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(authMessage));\r\n  }\r\n\r\n  /**\r\n   * Subscribe to topics after authentication\r\n   */\r\n  private subscribe(): void {\r\n    if (this.ws === null || this.ws.readyState !== WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    // Subscribe to position updates\r\n    const positionTopic = 'position';\r\n\r\n    // Subscribe to order execution (market orders)\r\n    const executionTopic = 'execution';\r\n\r\n    // Subscribe to order updates (conditional orders: TP/SL)\r\n    const orderTopic = 'order';\r\n\r\n    const subscribeMessage = {\r\n      op: 'subscribe',\r\n      args: [positionTopic, executionTopic, orderTopic],\r\n    };\r\n\r\n    this.ws.send(JSON.stringify(subscribeMessage));\r\n    this.logger.info('Private WebSocket subscribed to topics', {\r\n      topics: [positionTopic, executionTopic, orderTopic],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle incoming WebSocket message\r\n   */\r\n  private handleMessage(data: string): void {\r\n    try {\r\n      // this.logger.debug('Data:', {\r\n      //    data: JSON.stringify(data)\r\n      // });\r\n      const message = JSON.parse(data) as {\r\n        success?: boolean;\r\n        op?: string;\r\n        topic?: string;\r\n        data?: unknown;\r\n      };\r\n\r\n      this.routeMessage(message);\r\n    } catch (error) {\r\n      this.emit('error', new Error(`Failed to parse message: ${String(error)}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Route message to appropriate handler\r\n   */\r\n  private routeMessage(message: {\r\n    success?: boolean;\r\n    op?: string;\r\n    topic?: string;\r\n    data?: unknown;\r\n  }): void {\r\n    // Log all incoming messages (DEBUG level)\r\n    /* this.logger.debug('Private WebSocket message received', {\r\n      op: message.op,\r\n      topic: message.topic,\r\n      success: message.success,\r\n      hasData: message.data !== undefined,\r\n    });\r\n*/\r\n    // Handle auth response\r\n    if (message.op === 'auth' && message.success === true) {\r\n      this.logger.info('Private WebSocket authenticated successfully');\r\n      this.subscribe();\r\n      return;\r\n    }\r\n\r\n    // Handle subscription confirmation\r\n    if (message.op === 'subscribe') {\r\n      if (message.success === true) {\r\n        this.logger.info('‚úÖ Bybit confirmed subscription', {\r\n          success: true,\r\n        });\r\n      } else {\r\n        this.logger.error('‚ùå Bybit rejected subscription', {\r\n          success: message.success,\r\n          message,\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle pong\r\n    if (message.op === 'pong') {\r\n      return;\r\n    }\r\n\r\n    // Handle topic messages\r\n    if (message.data === undefined || message.data === null) {\r\n      return;\r\n    }\r\n\r\n    const messageData = message.data;\r\n\r\n    // this.logger.debug('RECEIVE MESSAGE!!!!', {\r\n    //     data: JSON.stringify(message)\r\n    // });\r\n    if (message.topic === 'position') {\r\n      this.handlePositionUpdate(messageData as PositionData | PositionData[]);\r\n    } else if (message.topic === 'execution') {\r\n      this.logger.debug('Received execution topic event', {\r\n        executionCount: Array.isArray(messageData) ? messageData.length : 0,\r\n      });\r\n      this.handleOrderExecution(messageData as OrderExecutionData | OrderExecutionData[]);\r\n    } else if (message.topic === 'order') {\r\n      this.logger.debug('Received order topic event', {\r\n        orderCount: Array.isArray(messageData) ? messageData.length : 0,\r\n      });\r\n      this.handleOrderUpdate(messageData as OrderUpdateData | OrderUpdateData[]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle position update from WebSocket\r\n   */\r\n  private handlePositionUpdate(data: PositionData | PositionData[]): void {\r\n    const positions = Array.isArray(data) ? data : [data];\r\n\r\n    for (const pos of positions) {\r\n      this.processPositionData(pos);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process single position data\r\n   */\r\n  private processPositionData(pos: PositionData): void {\r\n    const posData = pos;\r\n\r\n    // Filter by our symbol\r\n    if (posData.symbol !== this.symbol) {\r\n      return;\r\n    }\r\n\r\n    const size = parseFloat(posData.size ?? '0');\r\n\r\n    // Position closed - reset TP counter\r\n    if (size === POSITION_SIZE_ZERO) {\r\n      this.logger.debug('Position closed - resetting TP counter', { previousCounter: this.tpCounter });\r\n      this.tpCounter = 0;\r\n      this.emit('positionClosed', { symbol: this.symbol });\r\n      return;\r\n    }\r\n\r\n    // Position opened or updated\r\n    const position: Position = {\r\n      id: `${this.symbol}_${posData.side ?? 'unknown'}`,\r\n      symbol: this.symbol,\r\n      side: posData.side === 'Buy' ? PositionSide.LONG : PositionSide.SHORT,\r\n      quantity: size,\r\n      entryPrice: parseFloat(posData.entryPrice ?? posData.avgPrice ?? '0'),\r\n      leverage: parseFloat(posData.leverage ?? '1'),\r\n      marginUsed: parseFloat(posData.positionIM ?? '0'), // Initial margin\r\n      stopLoss: {\r\n        price: 0,\r\n        initialPrice: 0,\r\n        isBreakeven: false,\r\n        isTrailing: false,\r\n        updatedAt: Date.now(),\r\n      },\r\n      takeProfits: [],\r\n      openedAt: Date.now(),\r\n      unrealizedPnL: parseFloat(posData.unrealisedPnl ?? '0'),\r\n      orderId: '',\r\n      reason: 'WebSocket position update',\r\n      status: 'OPEN', // Position from WebSocket is OPEN\r\n    };\r\n\r\n    this.emit('positionUpdate', position);\r\n  }\r\n\r\n  /**\r\n   * Handle order execution from WebSocket\r\n   * This is where TP/SL fills come through!\r\n   */\r\n  private handleOrderExecution(data: OrderExecutionData | OrderExecutionData[]): void {\r\n    const executions = Array.isArray(data) ? data : [data];\r\n\r\n    for (const exec of executions) {\r\n      const execData = exec;\r\n\r\n      // Log all executions for debugging\r\n      this.logger.debug('Processing execution event', {\r\n        orderId: execData.orderId,\r\n        symbol: execData.symbol,\r\n        execType: execData.execType,\r\n        stopOrderType: execData.stopOrderType,\r\n        orderType: execData.orderType,\r\n        createType: execData.createType,\r\n        execPrice: execData.execPrice,\r\n        execQty: execData.execQty,\r\n        closedSize: execData.closedSize,\r\n      });\r\n\r\n      // Filter by our symbol\r\n      if (execData.symbol !== this.symbol) {\r\n        continue;\r\n      }\r\n\r\n      // Detect Take Profit: stopOrderType=\"UNKNOWN\" + createType=\"CreateByUser\" + closedSize > 0\r\n      const closedSize = parseFloat(execData.closedSize ?? '0');\r\n      const isTakeProfit =\r\n        execData.stopOrderType === 'UNKNOWN' &&\r\n        execData.createType === 'CreateByUser' &&\r\n        closedSize > 0;\r\n\r\n      // Detect Stop Loss: stopOrderType=\"Stop\"\r\n      const isStopLoss = execData.stopOrderType === 'Stop';\r\n\r\n      // Detect Trailing Stop: stopOrderType=\"TrailingStop\" (should not happen in execution, but just in case)\r\n      const isTrailingStop = execData.stopOrderType === 'TrailingStop';\r\n\r\n      if (isTakeProfit) {\r\n        // Check for duplicate event\r\n        const eventKey = `${execData.orderId ?? 'unknown'}_${execData.execPrice ?? '0'}_${closedSize}`;\r\n        if (this.isDuplicateEvent('TP', eventKey, Date.now())) {\r\n          continue; // Skip duplicate\r\n        }\r\n\r\n        // Increment TP counter\r\n        this.tpCounter++;\r\n\r\n        this.logger.info(`üéØ TP${this.tpCounter} execution detected from WebSocket`, {\r\n          tpLevel: this.tpCounter,\r\n          orderId: execData.orderId,\r\n          execPrice: execData.execPrice,\r\n          execQty: execData.execQty,\r\n          closedSize: execData.closedSize,\r\n        });\r\n\r\n        // Track close reason for journal\r\n        this.lastCloseReason = 'TP';\r\n\r\n        this.emit('takeProfitFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          avgPrice: execData.execPrice ?? '0',\r\n          qty: execData.execQty ?? '0',\r\n          cumExecQty: execData.closedSize ?? execData.execQty ?? '0',\r\n        });\r\n      } else if (isStopLoss) {\r\n        // Check for duplicate event\r\n        const eventKey = `${execData.orderId ?? 'unknown'}_${execData.execPrice ?? '0'}`;\r\n        if (this.isDuplicateEvent('SL', eventKey, Date.now())) {\r\n          continue; // Skip duplicate\r\n        }\r\n\r\n        this.logger.info('üõë Stop Loss execution detected from WebSocket', {\r\n          orderId: execData.orderId,\r\n          execPrice: execData.execPrice,\r\n          execQty: execData.execQty,\r\n        });\r\n\r\n        // Reset TP counter\r\n        this.logger.debug('Stop Loss hit - resetting TP counter', { previousCounter: this.tpCounter });\r\n        this.tpCounter = 0;\r\n\r\n        // Track close reason for journal\r\n        this.lastCloseReason = 'SL';\r\n\r\n        this.emit('stopLossFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          avgPrice: execData.execPrice ?? '0',\r\n          qty: execData.execQty ?? '0',\r\n          cumExecQty: execData.closedSize ?? execData.execQty ?? '0',\r\n        });\r\n      } else if (isTrailingStop) {\r\n        // Check for duplicate event\r\n        const eventKey = `${execData.orderId ?? 'unknown'}_${execData.execPrice ?? '0'}`;\r\n        if (this.isDuplicateEvent('TRAILING', eventKey, Date.now())) {\r\n          continue; // Skip duplicate\r\n        }\r\n\r\n        this.logger.info('üìâ Trailing Stop execution detected from WebSocket', {\r\n          orderId: execData.orderId,\r\n          execPrice: execData.execPrice,\r\n          execQty: execData.execQty,\r\n        });\r\n\r\n        // Reset TP counter\r\n        this.logger.debug('Trailing Stop hit - resetting TP counter', { previousCounter: this.tpCounter });\r\n        this.tpCounter = 0;\r\n\r\n        // Track close reason for journal\r\n        this.lastCloseReason = 'TRAILING';\r\n\r\n        this.emit('stopLossFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          avgPrice: execData.execPrice ?? '0',\r\n          qty: execData.execQty ?? '0',\r\n          cumExecQty: execData.closedSize ?? execData.execQty ?? '0',\r\n        });\r\n      } else {\r\n        // Regular order fill (market/limit entry) - reset TP counter for new position\r\n        this.logger.debug('Position entry execution - resetting TP counter', { previousCounter: this.tpCounter });\r\n        this.tpCounter = 0;\r\n\r\n        this.emit('orderFilled', {\r\n          orderId: execData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: execData.side ?? '',\r\n          execQty: execData.execQty ?? '0',\r\n          execPrice: execData.execPrice ?? '0',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle order update from WebSocket (conditional orders: TP/SL)\r\n   */\r\n  private handleOrderUpdate(data: OrderUpdateData | OrderUpdateData[]): void {\r\n    const orders = Array.isArray(data) ? data : [data];\r\n\r\n    for (const order of orders) {\r\n      const orderData = order;\r\n\r\n      // Log all orders for debugging\r\n      this.logger.debug('Processing order update', {\r\n        orderId: orderData.orderId,\r\n        symbol: orderData.symbol,\r\n        status: orderData.orderStatus,\r\n        stopOrderType: orderData.stopOrderType,\r\n        avgPrice: orderData.avgPrice,\r\n      });\r\n\r\n      // Filter by our symbol\r\n      if (orderData.symbol !== this.symbol) {\r\n        continue;\r\n      }\r\n\r\n      // Only process filled orders\r\n      if (orderData.orderStatus !== 'Filled') {\r\n        continue;\r\n      }\r\n\r\n      // Check if this is a Take Profit order\r\n      const isTakeProfit = orderData.stopOrderType === 'TakeProfit';\r\n      const isStopLoss = orderData.stopOrderType === 'StopLoss';\r\n\r\n      if (isTakeProfit) {\r\n        this.logger.info('üéØ Take Profit detected from WebSocket', {\r\n          orderId: orderData.orderId,\r\n          avgPrice: orderData.avgPrice,\r\n          qty: orderData.cumExecQty,\r\n        });\r\n        this.emit('takeProfitFilled', {\r\n          orderId: orderData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: orderData.side ?? '',\r\n          avgPrice: orderData.avgPrice ?? '0',\r\n          qty: orderData.qty ?? '0',\r\n          cumExecQty: orderData.cumExecQty ?? '0',\r\n        });\r\n      } else if (isStopLoss) {\r\n        this.logger.info('üõë Stop Loss detected from WebSocket', {\r\n          orderId: orderData.orderId,\r\n          avgPrice: orderData.avgPrice,\r\n          qty: orderData.cumExecQty,\r\n        });\r\n        this.emit('stopLossFilled', {\r\n          orderId: orderData.orderId ?? '',\r\n          symbol: this.symbol,\r\n          side: orderData.side ?? '',\r\n          avgPrice: orderData.avgPrice ?? '0',\r\n          qty: orderData.qty ?? '0',\r\n          cumExecQty: orderData.cumExecQty ?? '0',\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start ping interval to keep connection alive\r\n   */\r\n  private startPing(): void {\r\n    this.stopPing();\r\n\r\n    this.pingInterval = setInterval(() => {\r\n      if (this.ws !== null && this.ws.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({ op: 'ping' }));\r\n      }\r\n    }, PING_INTERVAL_MS);\r\n  }\r\n\r\n  /**\r\n   * Stop ping interval\r\n   */\r\n  private stopPing(): void {\r\n    if (this.pingInterval !== null) {\r\n      clearInterval(this.pingInterval);\r\n      this.pingInterval = null;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\weight-matrix-calculator.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENTAGE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":47},{"ruleId":"complexity","severity":1,"message":"Method 'calculateScore' has a complexity of 41. Maximum allowed is 10.","line":46,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":271,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":313,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":313,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":315,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":315,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10880,10900],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10880,10900],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10880,10900],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":321,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":321,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11085,11100],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11085,11100],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11085,11100],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":323,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":323,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":327,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":327,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11282,11295],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11282,11295],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11282,11295],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":329,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":329,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":333,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":333,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11472,11487],"text":"(thresholds.weak != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[11472,11487],"text":"(thresholds.weak ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[11472,11487],"text":"(Boolean(thresholds.weak))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":335,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":335,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":362,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":362,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":364,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":364,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12321,12341],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12321,12341],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12321,12341],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":370,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":370,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12527,12542],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12527,12542],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12527,12542],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":372,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":372,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":376,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":376,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12725,12738],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12725,12738],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12725,12738],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":378,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":378,"endColumn":32},{"ruleId":"complexity","severity":1,"message":"Method 'calculateEMAScore' has a complexity of 11. Maximum allowed is 10.","line":396,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":444,"endColumn":4},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (777). Maximum allowed is 300.","line":417,"column":1,"nodeType":null,"messageId":"exceed","endLine":1037,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":419,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":419,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13909,13929],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[13909,13929],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13909,13929],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":425,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":425,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14149,14164],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14149,14164],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14149,14164],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":427,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":427,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":431,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":431,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14381,14394],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14381,14394],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14381,14394],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":433,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":433,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":463,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":463,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":465,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":465,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15536,15556],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15536,15556],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15536,15556],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":471,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":471,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15755,15770],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15755,15770],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15755,15770],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":473,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":473,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":477,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":477,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15966,15979],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15966,15979],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15966,15979],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":479,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":479,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":505,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":505,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16695,16715],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16695,16715],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16695,16715],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":511,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":511,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16924,16939],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16924,16939],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16924,16939],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":513,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":513,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":517,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":517,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17145,17158],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[17145,17158],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[17145,17158],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":519,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":519,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":545,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":545,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17896,17916],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[17896,17916],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[17896,17916],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":551,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":551,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18128,18143],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18128,18143],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18128,18143],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":553,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":553,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":557,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":557,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18352,18365],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18352,18365],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18352,18365],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":559,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":559,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":563,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":563,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18569,18584],"text":"(thresholds.weak != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18569,18584],"text":"(thresholds.weak ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18569,18584],"text":"(Boolean(thresholds.weak))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":565,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":565,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":594,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":594,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19556,19576],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19556,19576],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19556,19576],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":600,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":600,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19784,19799],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19784,19799],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19784,19799],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":602,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":602,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":606,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":606,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20004,20017],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[20004,20017],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[20004,20017],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":608,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":608,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":632,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":632,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20722,20742],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[20722,20742],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[20722,20742],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":638,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":638,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20949,20964],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[20949,20964],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[20949,20964],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":640,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":640,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":644,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":644,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21168,21181],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[21168,21181],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[21168,21181],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":646,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":646,"endColumn":32},{"ruleId":"complexity","severity":1,"message":"Method 'calculateImbalanceScore' has a complexity of 11. Maximum allowed is 10.","line":664,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":711,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":686,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":686,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22593,22613],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[22593,22613],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[22593,22613],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":692,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":692,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22825,22840],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[22825,22840],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[22825,22840],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":694,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":694,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":698,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":698,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23049,23062],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[23049,23062],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[23049,23062],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":700,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":700,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strength' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":722,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":722,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":724,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":724,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23793,23813],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[23793,23813],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[23793,23813],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":730,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":730,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[23999,24014],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[23999,24014],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[23999,24014],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":732,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":732,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":736,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":736,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24197,24210],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[24197,24210],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[24197,24210],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":738,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":738,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":762,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":762,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[24855,24875],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[24855,24875],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[24855,24875],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":768,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":768,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25091,25106],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[25091,25106],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[25091,25106],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":770,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":770,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":774,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":774,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25319,25332],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[25319,25332],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[25319,25332],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":776,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":776,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":780,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":780,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25540,25555],"text":"(thresholds.weak != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[25540,25555],"text":"(thresholds.weak ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[25540,25555],"text":"(Boolean(thresholds.weak))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":782,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":782,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":827,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":827,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[26850,26870],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[26850,26870],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[26850,26870],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":833,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":833,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27072,27087],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[27072,27087],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27072,27087],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":835,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":835,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":839,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":839,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[27286,27299],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[27286,27299],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[27286,27299],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":841,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":841,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":865,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":865,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28002,28022],"text":"(thresholds.excellent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[28002,28022],"text":"(thresholds.excellent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28002,28022],"text":"(Boolean(thresholds.excellent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":871,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":871,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28223,28238],"text":"(thresholds.good != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[28223,28238],"text":"(thresholds.good ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28223,28238],"text":"(Boolean(thresholds.good))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":873,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":873,"endColumn":33},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":877,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":877,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[28436,28449],"text":"(thresholds.ok != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[28436,28449],"text":"(thresholds.ok ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28436,28449],"text":"(Boolean(thresholds.ok))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":879,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":879,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 90.","line":1016,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1016,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 70.","line":1019,"column":54,"nodeType":"Literal","messageId":"noMagic","endLine":1019,"endColumn":56},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.75.","line":1021,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":1021,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":1022,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":1022,"endColumn":54},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.5.","line":1024,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":1024,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.25.","line":1027,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":1027,"endColumn":32}],"suppressedMessages":[],"errorCount":82,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Weight Matrix Calculator Service\r\n *\r\n * Calculates signal confidence using gradient scoring instead of boolean filters.\r\n * Each indicator/factor contributes points based on thresholds (excellent/good/ok/weak).\r\n *\r\n * Example:\r\n * - RSI = 25 ‚Üí 15 pts (good)\r\n * - Volume = 1.8x avg ‚Üí 20 pts (good)\r\n * - Level touches = 4 ‚Üí 20 pts (excellent)\r\n * Total: 55 pts ‚Üí Confidence: 55%\r\n */\r\n\r\nimport {\r\n  WeightMatrixConfig,\r\n  WeightMatrixInput,\r\n  IndicatorWeight,\r\n  SignalScoreBreakdown,\r\n  SignalDirection,\r\n  LoggerService,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// WEIGHT MATRIX CALCULATOR SERVICE\r\n// ============================================================================\r\n\r\nexport class WeightMatrixCalculatorService {\r\n  constructor(\r\n    private config: WeightMatrixConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.logger.info('WeightMatrixCalculatorService initialized', {\r\n      enabled: config.enabled,\r\n      minConfidenceToEnter: config.minConfidenceToEnter,\r\n      minConfidenceForReducedSize: config.minConfidenceForReducedSize,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculate signal score from market data\r\n   * @param input - Market data from analyzers/indicators\r\n   * @param direction - Signal direction (LONG/SHORT)\r\n   * @returns Score breakdown with confidence percentage\r\n   */\r\n  calculateScore(\r\n    input: WeightMatrixInput,\r\n    direction: SignalDirection,\r\n  ): SignalScoreBreakdown {\r\n    if (!this.config.enabled) {\r\n      // Weight matrix disabled - return perfect score\r\n      return {\r\n        totalScore: 100,\r\n        maxPossibleScore: 100,\r\n        confidence: 100,\r\n        contributions: {},\r\n      };\r\n    }\r\n\r\n    const contributions: SignalScoreBreakdown['contributions'] = {};\r\n    let totalScore = 0;\r\n    let maxPossibleScore = 0;\r\n\r\n    // 1. RSI\r\n    if (this.config.weights.rsi.enabled && input.rsi !== undefined) {\r\n      const score = this.calculateRSIScore(input.rsi, direction, this.config.weights.rsi);\r\n      contributions.rsi = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 2. Stochastic\r\n    if (this.config.weights.stochastic.enabled && input.stochastic !== undefined) {\r\n      const score = this.calculateStochasticScore(\r\n        input.stochastic,\r\n        direction,\r\n        this.config.weights.stochastic,\r\n      );\r\n      contributions.stochastic = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 3. EMA\r\n    if (this.config.weights.ema.enabled && input.ema !== undefined) {\r\n      const score = this.calculateEMAScore(input.ema, direction, this.config.weights.ema);\r\n      contributions.ema = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 4. Bollinger Bands\r\n    if (this.config.weights.bollingerBands.enabled && input.bollingerBands !== undefined) {\r\n      const score = this.calculateBollingerScore(\r\n        input.bollingerBands,\r\n        direction,\r\n        this.config.weights.bollingerBands,\r\n      );\r\n      contributions.bollingerBands = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 5. ATR\r\n    if (this.config.weights.atr.enabled && input.atr !== undefined) {\r\n      const score = this.calculateATRScore(input.atr, this.config.weights.atr);\r\n      contributions.atr = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 6. Volume\r\n    if (this.config.weights.volume.enabled && input.volume !== undefined) {\r\n      const score = this.calculateVolumeScore(input.volume, this.config.weights.volume);\r\n      contributions.volume = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 7. Delta (Buy/Sell pressure)\r\n    if (this.config.weights.delta.enabled && input.delta !== undefined) {\r\n      const score = this.calculateDeltaScore(input.delta, direction, this.config.weights.delta);\r\n      contributions.delta = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 8. Orderbook\r\n    if (this.config.weights.orderbook.enabled && input.orderbook !== undefined) {\r\n      const score = this.calculateOrderbookScore(input.orderbook, this.config.weights.orderbook);\r\n      contributions.orderbook = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 9. Imbalance (Bid/Ask pressure)\r\n    if (this.config.weights.imbalance.enabled && input.imbalance !== undefined) {\r\n      const score = this.calculateImbalanceScore(input.imbalance, direction, this.config.weights.imbalance);\r\n      contributions.imbalance = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 10. Level Strength\r\n    if (this.config.weights.levelStrength.enabled && input.levelStrength !== undefined) {\r\n      const score = this.calculateLevelStrengthScore(\r\n        input.levelStrength,\r\n        this.config.weights.levelStrength,\r\n      );\r\n      contributions.levelStrength = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 10. Level Distance\r\n    if (this.config.weights.levelDistance.enabled && input.levelDistance !== undefined) {\r\n      const score = this.calculateLevelDistanceScore(\r\n        input.levelDistance,\r\n        this.config.weights.levelDistance,\r\n      );\r\n      contributions.levelDistance = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 11. Swing Points\r\n    if (this.config.weights.swingPoints.enabled && input.swingPoints !== undefined) {\r\n      const score = this.calculateSwingPointsScore(\r\n        input.swingPoints,\r\n        this.config.weights.swingPoints,\r\n      );\r\n      contributions.swingPoints = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 12. Chart Patterns\r\n    if (this.config.weights.chartPatterns.enabled && input.chartPatterns !== undefined) {\r\n      const score = this.calculateChartPatternsScore(\r\n        input.chartPatterns,\r\n        this.config.weights.chartPatterns,\r\n      );\r\n      contributions.chartPatterns = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 13. Candle Patterns\r\n    if (this.config.weights.candlePatterns.enabled && input.candlePatterns !== undefined) {\r\n      const score = this.calculateCandlePatternsScore(\r\n        input.candlePatterns,\r\n        this.config.weights.candlePatterns,\r\n      );\r\n      contributions.candlePatterns = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 14. Senior TF Alignment\r\n    if (this.config.weights.seniorTFAlignment.enabled && input.seniorTFAlignment !== undefined) {\r\n      const score = this.calculateSeniorTFAlignmentScore(\r\n        input.seniorTFAlignment,\r\n        this.config.weights.seniorTFAlignment,\r\n      );\r\n      contributions.seniorTFAlignment = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 15. BTC Correlation\r\n    if (this.config.weights.btcCorrelation.enabled && input.btcCorrelation !== undefined) {\r\n      const score = this.calculateBTCCorrelationScore(\r\n        input.btcCorrelation,\r\n        this.config.weights.btcCorrelation,\r\n      );\r\n      contributions.btcCorrelation = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 16. TF Alignment (PHASE 6)\r\n    if (this.config.weights.tfAlignment.enabled && input.tfAlignmentScore !== undefined) {\r\n      const score = this.calculateTFAlignmentScore(\r\n        input.tfAlignmentScore,\r\n        this.config.weights.tfAlignment,\r\n      );\r\n      contributions.tfAlignment = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 17. Divergence\r\n    if (this.config.weights.divergence.enabled && input.divergence !== undefined) {\r\n      const score = this.calculateDivergenceScore(\r\n        input.divergence,\r\n        direction,\r\n        this.config.weights.divergence,\r\n      );\r\n      contributions.divergence = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // 17. Liquidity Sweep\r\n    if (this.config.weights.liquiditySweep.enabled && input.liquiditySweep !== undefined) {\r\n      const score = this.calculateLiquiditySweepScore(\r\n        input.liquiditySweep,\r\n        this.config.weights.liquiditySweep,\r\n      );\r\n      contributions.liquiditySweep = score;\r\n      totalScore += score.points;\r\n      maxPossibleScore += score.maxPoints;\r\n    }\r\n\r\n    // Calculate confidence as decimal (0.0-1.0) - NOT percentage!\r\n    const confidence = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) : 0;\r\n\r\n    this.logger.debug('Signal score calculated', {\r\n      totalScore,\r\n      maxPossibleScore,\r\n      confidence: (confidence * PERCENT_MULTIPLIER).toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      factorsEvaluated: Object.keys(contributions).length,\r\n    });\r\n\r\n    return {\r\n      totalScore,\r\n      maxPossibleScore,\r\n      confidence,\r\n      contributions,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if signal confidence meets entry threshold\r\n   * @param confidence - Confidence percentage (0-100)\r\n   * @returns true if meets minimum threshold\r\n   */\r\n  shouldEnter(confidence: number): boolean {\r\n    return confidence >= this.config.minConfidenceToEnter;\r\n  }\r\n\r\n  /**\r\n   * Check if signal confidence meets reduced size threshold\r\n   * @param confidence - Confidence percentage (0-100)\r\n   * @returns true if meets reduced size threshold\r\n   */\r\n  shouldEnterWithReducedSize(confidence: number): boolean {\r\n    return (\r\n      confidence >= this.config.minConfidenceForReducedSize &&\r\n      confidence < this.config.minConfidenceToEnter\r\n    );\r\n  }\r\n\r\n  // ==========================================================================\r\n  // INDIVIDUAL FACTOR SCORING METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate RSI score\r\n   * LONG: Lower RSI = Higher score (oversold)\r\n   * SHORT: Higher RSI = Higher score (overbought)\r\n   */\r\n  private calculateRSIScore(\r\n    rsi: number,\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n\r\n    // For LONG: RSI < threshold = better\r\n    // For SHORT: RSI > (100 - threshold) = better\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const targetRSI = isLong ? rsi : 100 - rsi;\r\n\r\n    if (thresholds.excellent && targetRSI <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (excellent)`,\r\n      };\r\n    } else if (thresholds.good && targetRSI <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (good)`,\r\n      };\r\n    } else if (thresholds.ok && targetRSI <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (ok)`,\r\n      };\r\n    } else if (thresholds.weak && targetRSI <= thresholds.weak) {\r\n      return {\r\n        points: maxPoints * 0.25,\r\n        maxPoints,\r\n        reason: `RSI ${rsi.toFixed(1)} (weak)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `RSI ${rsi.toFixed(1)} (not extreme)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Stochastic score\r\n   * LONG: Lower %K = Higher score (oversold)\r\n   * SHORT: Higher %K = Higher score (overbought)\r\n   */\r\n  private calculateStochasticScore(\r\n    stochastic: { k: number; d: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { k } = stochastic;\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const targetK = isLong ? k : 100 - k;\r\n\r\n    if (thresholds.excellent && targetK <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Stoch %K ${k.toFixed(1)} (excellent)`,\r\n      };\r\n    } else if (thresholds.good && targetK <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Stoch %K ${k.toFixed(1)} (good)`,\r\n      };\r\n    } else if (thresholds.ok && targetK <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Stoch %K ${k.toFixed(1)} (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Stoch %K ${k.toFixed(1)} (not extreme)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate EMA score\r\n   * LONG: Price above EMA = Higher score\r\n   * SHORT: Price below EMA = Higher score\r\n   */\r\n  private calculateEMAScore(\r\n    ema: { fast: number; slow: number; price: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { fast, slow, price } = ema;\r\n\r\n    // Check EMA alignment\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const correctAlignment = isLong ? fast > slow && price > fast : fast < slow && price < fast;\r\n\r\n    if (!correctAlignment) {\r\n      return {\r\n        points: 0,\r\n        maxPoints,\r\n        reason: 'EMA not aligned',\r\n      };\r\n    }\r\n\r\n    // Calculate distance to EMA (%)\r\n    const distance = Math.abs((price - fast) / fast) * PERCENT_MULTIPLIER;\r\n\r\n    if (thresholds.excellent && distance <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && distance <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && distance <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `EMA distance ${distance.toFixed(DECIMAL_PLACES.PERCENT)}% (too far)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Bollinger Bands score\r\n   * LONG: Price near lower band (position < 30) = Higher score\r\n   * SHORT: Price near upper band (position > PERCENTAGE_THRESHOLDS.ULTRA_HIGH) = Higher score\r\n   */\r\n  private calculateBollingerScore(\r\n    bollingerBands: { position: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { position } = bollingerBands;\r\n\r\n    // Convert position to extremity (0-100)\r\n    // For LONG: lower position = higher extremity\r\n    // For SHORT: higher position = higher extremity\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const extremity = isLong ? 100 - position : position;\r\n\r\n    if (thresholds.excellent && extremity >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `BB position ${position.toFixed(1)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && extremity >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `BB position ${position.toFixed(1)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && extremity >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `BB position ${position.toFixed(1)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `BB position ${position.toFixed(1)}% (not extreme)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate ATR score\r\n   * Higher ATR = Higher volatility = Higher score\r\n   */\r\n  private calculateATRScore(\r\n    atr: { current: number; average: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { current, average } = atr;\r\n\r\n    const ratio = current / average;\r\n\r\n    if (thresholds.excellent && ratio >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (excellent)`,\r\n      };\r\n    } else if (thresholds.good && ratio >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (good)`,\r\n      };\r\n    } else if (thresholds.ok && ratio >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `ATR ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (low volatility)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Volume score\r\n   * Higher volume = Higher score\r\n   */\r\n  private calculateVolumeScore(\r\n    volume: { current: number; average: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { current, average } = volume;\r\n\r\n    const ratio = current / average;\r\n\r\n    if (thresholds.excellent && ratio >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (excellent)`,\r\n      };\r\n    } else if (thresholds.good && ratio >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (good)`,\r\n      };\r\n    } else if (thresholds.ok && ratio >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (ok)`,\r\n      };\r\n    } else if (thresholds.weak && ratio >= thresholds.weak) {\r\n      return {\r\n        points: maxPoints * 0.25,\r\n        maxPoints,\r\n        reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (weak)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Volume ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}x avg (too low)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Delta (Buy/Sell pressure) score\r\n   * LONG: Buy pressure > Sell = Higher score\r\n   * SHORT: Sell pressure > Buy = Higher score\r\n   */\r\n  private calculateDeltaScore(\r\n    delta: { buyPressure: number; sellPressure: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { buyPressure, sellPressure } = delta;\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const ratio = isLong ? buyPressure / sellPressure : sellPressure / buyPressure;\r\n\r\n    if (thresholds.excellent && ratio >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (excellent)`,\r\n      };\r\n    } else if (thresholds.good && ratio >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (good)`,\r\n      };\r\n    } else if (thresholds.ok && ratio >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Delta ${ratio.toFixed(DECIMAL_PLACES.PERCENT)}:1 (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Orderbook (wall strength) score\r\n   * Higher wall strength = Higher score\r\n   */\r\n  private calculateOrderbookScore(\r\n    orderbook: { wallStrength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { wallStrength } = orderbook;\r\n\r\n    if (thresholds.excellent && wallStrength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Wall strength ${wallStrength.toFixed(0)} (excellent)`,\r\n      };\r\n    } else if (thresholds.good && wallStrength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Wall strength ${wallStrength.toFixed(0)} (good)`,\r\n      };\r\n    } else if (thresholds.ok && wallStrength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Wall strength ${wallStrength.toFixed(0)} (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Wall strength ${wallStrength.toFixed(0)} (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Imbalance (Bid/Ask pressure) score\r\n   * For LONG: BID imbalance (buying pressure) = Higher score\r\n   * For SHORT: ASK imbalance (selling pressure) = Higher score\r\n   */\r\n  private calculateImbalanceScore(\r\n    imbalance: { direction: 'BID' | 'ASK' | 'NEUTRAL'; strength: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { direction: imbalanceDir, strength } = imbalance;\r\n\r\n    // Check alignment: LONG wants BID imbalance, SHORT wants ASK imbalance\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const aligned = (isLong && imbalanceDir === 'BID') || (!isLong && imbalanceDir === 'ASK');\r\n\r\n    // No score if imbalance direction doesn't match signal direction or is NEUTRAL\r\n    if (!aligned) {\r\n      return {\r\n        points: 0,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (not aligned)`,\r\n      };\r\n    }\r\n\r\n    // Score based on strength thresholds\r\n    if (thresholds.excellent && strength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && strength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && strength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Imbalance ${imbalanceDir} ${strength.toFixed(0)}% (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Level Strength score\r\n   * More touches & bounces = Higher score\r\n   */\r\n  private calculateLevelStrengthScore(\r\n    levelStrength: { touches: number; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { touches, strength } = levelStrength;\r\n\r\n    if (thresholds.excellent && touches >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Level ${touches} touches (excellent)`,\r\n      };\r\n    } else if (thresholds.good && touches >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Level ${touches} touches (good)`,\r\n      };\r\n    } else if (thresholds.ok && touches >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Level ${touches} touches (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Level ${touches} touches (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Level Distance score\r\n   * Closer to level = Higher score\r\n   */\r\n  private calculateLevelDistanceScore(\r\n    levelDistance: { percent: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { percent } = levelDistance;\r\n\r\n    if (thresholds.excellent && percent <= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (excellent)`,\r\n      };\r\n    } else if (thresholds.good && percent <= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (good)`,\r\n      };\r\n    } else if (thresholds.ok && percent <= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (ok)`,\r\n      };\r\n    } else if (thresholds.weak && percent <= thresholds.weak) {\r\n      return {\r\n        points: maxPoints * 0.25,\r\n        maxPoints,\r\n        reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (weak)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Level ${percent.toFixed(DECIMAL_PLACES.PERCENT)}% away (too far)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Swing Points score\r\n   * Higher quality swing = Higher score\r\n   */\r\n  private calculateSwingPointsScore(\r\n    swingPoints: { quality: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { quality } = swingPoints;\r\n\r\n    // Quality is 0-1, map to maxPoints\r\n    const points = quality * maxPoints;\r\n\r\n    return {\r\n      points,\r\n      maxPoints,\r\n      reason: `Swing quality ${(quality * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Chart Patterns score\r\n   * Stronger pattern = Higher score\r\n   */\r\n  private calculateChartPatternsScore(\r\n    chartPatterns: { type: string; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { type, strength } = chartPatterns;\r\n\r\n    if (thresholds.excellent && strength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Pattern ${type} ${strength.toFixed(0)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && strength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Pattern ${type} ${strength.toFixed(0)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && strength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Pattern ${type} ${strength.toFixed(0)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Pattern ${type} ${strength.toFixed(0)}% (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Candle Patterns score\r\n   * Stronger pattern = Higher score\r\n   */\r\n  private calculateCandlePatternsScore(\r\n    candlePatterns: { type: string; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n    const { type, strength } = candlePatterns;\r\n\r\n    if (thresholds.excellent && strength >= thresholds.excellent) {\r\n      return {\r\n        points: maxPoints,\r\n        maxPoints,\r\n        reason: `Candle ${type} ${strength.toFixed(0)}% (excellent)`,\r\n      };\r\n    } else if (thresholds.good && strength >= thresholds.good) {\r\n      return {\r\n        points: maxPoints * 0.75,\r\n        maxPoints,\r\n        reason: `Candle ${type} ${strength.toFixed(0)}% (good)`,\r\n      };\r\n    } else if (thresholds.ok && strength >= thresholds.ok) {\r\n      return {\r\n        points: maxPoints * 0.5,\r\n        maxPoints,\r\n        reason: `Candle ${type} ${strength.toFixed(0)}% (ok)`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Candle ${type} ${strength.toFixed(0)}% (weak)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Senior TF Alignment score\r\n   * Aligned with higher timeframe = Full points\r\n   */\r\n  private calculateSeniorTFAlignmentScore(\r\n    seniorTFAlignment: { aligned: boolean; strength: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { aligned, strength } = seniorTFAlignment;\r\n\r\n    if (aligned) {\r\n      const points = maxPoints * strength;\r\n      return {\r\n        points,\r\n        maxPoints,\r\n        reason: `Senior TF aligned ${(strength * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: 'Senior TF not aligned',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate BTC Correlation score\r\n   * Aligned with BTC = Full points\r\n   */\r\n  private calculateBTCCorrelationScore(\r\n    btcCorrelation: { correlation: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { correlation } = btcCorrelation;\r\n\r\n    // Correlation is 0-1\r\n    const points = correlation * maxPoints;\r\n\r\n    return {\r\n      points,\r\n      maxPoints,\r\n      reason: `BTC correlation ${(correlation * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Divergence score\r\n   * LONG: Bullish divergence = Full points\r\n   * SHORT: Bearish divergence = Full points\r\n   */\r\n  private calculateDivergenceScore(\r\n    divergence: { type: string; strength: number },\r\n    direction: SignalDirection,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { type, strength } = divergence;\r\n\r\n    const isLong = direction === SignalDirection.LONG;\r\n    const correctType = (isLong && type === 'BULLISH') || (!isLong && type === 'BEARISH');\r\n\r\n    if (correctType) {\r\n      const points = maxPoints * strength;\r\n      return {\r\n        points,\r\n        maxPoints,\r\n        reason: `Divergence ${type} ${(strength * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: `Divergence ${type} (wrong direction)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate Liquidity Sweep score\r\n   * Sweep detected = Full points\r\n   */\r\n  private calculateLiquiditySweepScore(\r\n    liquiditySweep: { detected: boolean; confidence: number },\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints } = weight;\r\n    const { detected, confidence } = liquiditySweep;\r\n\r\n    if (detected) {\r\n      const points = maxPoints * confidence;\r\n      return {\r\n        points,\r\n        maxPoints,\r\n        reason: `Liquidity sweep ${(confidence * PERCENT_MULTIPLIER).toFixed(0)}% confidence`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      points: 0,\r\n      maxPoints,\r\n      reason: 'No liquidity sweep',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate TF Alignment score (PHASE 6)\r\n   * Higher alignment score = More points\r\n   *\r\n   * @param alignmentScore - Score from TFAlignmentService (0-100)\r\n   * @param weight - Weight configuration\r\n   * @returns Score breakdown\r\n   */\r\n  private calculateTFAlignmentScore(\r\n    alignmentScore: number,\r\n    weight: IndicatorWeight,\r\n  ): { points: number; maxPoints: number; reason: string } {\r\n    const { maxPoints, thresholds } = weight;\r\n\r\n    // Use gradient scoring based on alignment score\r\n    let points = 0;\r\n\r\n    if (alignmentScore >= (thresholds.excellent ?? 90)) {\r\n      // Excellent: 90%+ alignment ‚Üí Full points\r\n      points = maxPoints;\r\n    } else if (alignmentScore >= (thresholds.good ?? 70)) {\r\n      // Good: 70-89% alignment ‚Üí 75% points\r\n      points = maxPoints * 0.75;\r\n    } else if (alignmentScore >= (thresholds.ok ?? 50)) {\r\n      // OK: 50-69% alignment ‚Üí 50% points\r\n      points = maxPoints * 0.5;\r\n    } else {\r\n      // Weak: <50% alignment ‚Üí 25% points\r\n      points = maxPoints * 0.25;\r\n    }\r\n\r\n    return {\r\n      points,\r\n      maxPoints,\r\n      reason: `TF Alignment ${alignmentScore.toFixed(0)}%`,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\whale-detector-follow.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TIME_UNITS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":46,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OrderBookWall' is defined but never used. Allowed unused vars must match /^_/u.","line":21,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":74},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":124,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":124,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.05.","line":162,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":29},{"ruleId":"complexity","severity":1,"message":"Method 'detectWallBreak' has a complexity of 11. Maximum allowed is 10.","line":191,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":276,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":317,"column":113,"nodeType":"Literal","messageId":"noMagic","endLine":317,"endColumn":117},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":349,"column":113,"nodeType":"Literal","messageId":"noMagic","endLine":349,"endColumn":117},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":372,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":372,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":385,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":385,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14461,14480],"text":"historicalSnapshot == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":436,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":436,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16665,16673],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":457,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":457,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17358,17366],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (386). Maximum allowed is 300.","line":462,"column":1,"nodeType":null,"messageId":"exceed","endLine":604,"endColumn":1},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'breakExpiryMs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":501,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":501,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":516,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":516,"endColumn":44},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":530,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":530,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":530,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":530,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":530,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":530,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":533,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":533,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":533,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":533,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":533,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":533,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":543,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":543,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":543,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":543,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":543,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":543,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 120000.","line":546,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":546,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":546,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":546,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":546,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":546,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":556,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":556,"endColumn":55}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, PERCENT_MULTIPLIER, TIME_UNITS } from '../constants';\r\n/**\r\n * Whale Detector Service - FOLLOW THE WHALE Strategy\r\n *\r\n * Philosophy: Trade WITH the whale (not against momentum)\r\n *\r\n * MODE 1: WALL_BREAK (–ø—Ä–æ–±–æ–π —Å—Ç–µ–Ω—ã)\r\n * - BID wall broken ‚Üí SHORT (whale sold = distribution phase)\r\n * - ASK wall broken ‚Üí LONG (whale bought = accumulation phase)\r\n *\r\n * MODE 2: WALL_DISAPPEARANCE (–∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ —Å—Ç–µ–Ω—ã)\r\n * - Same as breakout version (reversal play)\r\n *\r\n * MODE 3: IMBALANCE_SPIKE (—Ä–µ–∑–∫–∏–π –¥–∏—Å–±–∞–ª–∞–Ω—Å)\r\n * - Same as breakout version (immediate momentum)\r\n *\r\n * IMPORTANT: Requires WebSocket orderbook for real-time data\r\n * REST API polling is too slow for whale detection!\r\n */\r\n\r\nimport { LoggerService, SignalDirection, OrderBookAnalysis, OrderBookWall } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum WhaleDetectionMode {\r\n  WALL_BREAK = 'WALL_BREAK', // –ü—Ä–æ–±–æ–π —Å—Ç–µ–Ω—ã\r\n  WALL_DISAPPEARANCE = 'WALL_DISAPPEARANCE', // –ò—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ —Å—Ç–µ–Ω—ã\r\n  IMBALANCE_SPIKE = 'IMBALANCE_SPIKE', // –†–µ–∑–∫–∏–π –¥–∏—Å–±–∞–ª–∞–Ω—Å\r\n}\r\n\r\nexport interface WhaleDetectorConfig {\r\n  modes: {\r\n    wallBreak: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 15%)\r\n      breakConfirmationMs: number; // Time to confirm break (e.g., 3000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 85)\r\n    };\r\n    wallDisappearance: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 20%)\r\n      minWallDuration: number; // Min time wall existed (e.g., TIME_UNITS.MINUTEms = 1min)\r\n      wallGoneThresholdMs: number; // Time without seeing wall = gone (e.g., 15000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 80)\r\n    };\r\n    imbalanceSpike: {\r\n      enabled: boolean;\r\n      minRatioChange: number; // Min ratio change (e.g., 1.5 = CONFIDENCE_THRESHOLDS.MODERATE% change)\r\n      detectionWindow: number; // Time window for spike (e.g., 10000ms = 10s)\r\n      maxConfidence: number; // Max confidence % (e.g., 90)\r\n    };\r\n  };\r\n  maxImbalanceHistory: number; // Max imbalance snapshots to keep (e.g., 20)\r\n  wallExpiryMs: number; // Time before wall is removed from tracking (e.g., TIME_UNITS.MINUTEms)\r\n  breakExpiryMs: number; // Time before broken wall can be re-detected (e.g., TIME_UNITS.FIVE_MINUTESms)\r\n}\r\n\r\nexport interface WhaleWall {\r\n  side: 'BID' | 'ASK';\r\n  price: number;\r\n  quantity: number;\r\n  percentOfTotal: number;\r\n  distance: number;\r\n  detectedAt: number;\r\n  lastSeenAt: number;\r\n}\r\n\r\nexport interface ImbalanceSnapshot {\r\n  ratio: number;\r\n  timestamp: number;\r\n  bidVolume: number;\r\n  askVolume: number;\r\n}\r\n\r\nexport interface WhaleSignal {\r\n  detected: boolean;\r\n  mode: WhaleDetectionMode | null;\r\n  direction: SignalDirection | null;\r\n  confidence: number; // 0-100\r\n  reason: string;\r\n  metadata: {\r\n    wall?: WhaleWall;\r\n    breakPrice?: number;\r\n    imbalanceChange?: number;\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// WHALE DETECTOR FOLLOW SERVICE\r\n// ============================================================================\r\n\r\nexport class WhaleDetectorFollowService {\r\n  // Mode 1: Wall tracking (for breaks and disappearances)\r\n  private trackedBidWalls: Map<number, WhaleWall> = new Map();\r\n  private trackedAskWalls: Map<number, WhaleWall> = new Map();\r\n\r\n  // Mode 2: Recently broken walls (to avoid re-detecting same break)\r\n  private recentlyBrokenWalls: Set<string> = new Set(); // \"BID_1.5000\" or \"ASK_1.5200\"\r\n\r\n  // Mode 3: Imbalance history (for spike detection)\r\n  private imbalanceHistory: ImbalanceSnapshot[] = [];\r\n\r\n  constructor(\r\n    private config: WhaleDetectorConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect whale activity from order book analysis\r\n   *\r\n   * @param analysis - Current order book analysis\r\n   * @param currentPrice - Current market price\r\n   * @returns Whale signal (detected or not)\r\n   */\r\n  detectWhale(analysis: OrderBookAnalysis, currentPrice: number): WhaleSignal {\r\n    // Update tracked data\r\n    this.updateTrackedWalls(analysis);\r\n    this.updateImbalanceHistory(analysis);\r\n    this.cleanupExpiredData();\r\n\r\n    // Log current orderbook state (every 10th call to avoid spam)\r\n    if (Math.random() < 0.1) {\r\n      this.logger.debug('üêã Whale Detector FOLLOW State', {\r\n        trackedBids: this.trackedBidWalls.size,\r\n        trackedAsks: this.trackedAskWalls.size,\r\n        imbalanceHistory: this.imbalanceHistory.length,\r\n        currentRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        walls: analysis.walls.length,\r\n      });\r\n    }\r\n\r\n    // MODE 3: Imbalance Spike (highest priority - immediate action)\r\n    if (this.config.modes.imbalanceSpike.enabled) {\r\n      const spikeSignal = this.detectImbalanceSpike(analysis);\r\n      if (spikeSignal.detected) {\r\n        this.logWhaleDetection(spikeSignal);\r\n        return spikeSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 1: Wall Break (medium priority - momentum play)\r\n    if (this.config.modes.wallBreak.enabled) {\r\n      const breakSignal = this.detectWallBreak(currentPrice);\r\n      if (breakSignal.detected) {\r\n        this.logWhaleDetection(breakSignal);\r\n        return breakSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 2: Wall Disappearance (lower priority - reversal play)\r\n    if (this.config.modes.wallDisappearance.enabled) {\r\n      const disappearanceSignal = this.detectWallDisappearance();\r\n      if (disappearanceSignal.detected) {\r\n        this.logWhaleDetection(disappearanceSignal);\r\n        return disappearanceSignal;\r\n      }\r\n    }\r\n\r\n    // No whale detected - log summary (every 20th call)\r\n    if (Math.random() < 0.05) {\r\n      this.logger.debug('üêã No whale activity (FOLLOW mode)', {\r\n        wallsDetected: analysis.walls.length,\r\n        imbalanceRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        imbalanceDirection: analysis.imbalance.direction,\r\n      });\r\n    }\r\n\r\n    return {\r\n      detected: false,\r\n      mode: null,\r\n      direction: null,\r\n      confidence: 0,\r\n      reason: 'No whale activity detected',\r\n      metadata: {},\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 1: WALL BREAK DETECTION (FOLLOW THE WHALE)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when price breaks through a large wall - FOLLOW WHALE logic\r\n   *\r\n   * Logic:\r\n   * - BID wall broken (price went below) ‚Üí SHORT signal (whale sold = distribution)\r\n   * - ASK wall broken (price went above) ‚Üí LONG signal (whale bought = accumulation)\r\n   */\r\n  private detectWallBreak(currentPrice: number): WhaleSignal {\r\n    const now = Date.now();\r\n    const confirmationMs = this.config.modes.wallBreak.breakConfirmationMs;\r\n\r\n    // Check if any BID walls were broken (price dropped below)\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now BELOW the wall\r\n      if (currentPrice < wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `BID_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - BID wall broken ‚Üí SHORT signal (FOLLOW WHALE)\r\n        // Logic: Whale SOLD through BID wall ‚Üí distribution phase ‚Üí price goes DOWN\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.SHORT,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `BID wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale SOLD, follow SHORT`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check if any ASK walls were broken (price rose above)\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now ABOVE the wall\r\n      if (currentPrice > wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `ASK_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - ASK wall broken ‚Üí LONG signal (FOLLOW WHALE)\r\n        // Logic: Whale BOUGHT through ASK wall ‚Üí accumulation phase ‚Üí price goes UP\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.LONG,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `ASK wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale BOUGHT, follow LONG`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 2: WALL DISAPPEARANCE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when a large wall suddenly disappears\r\n   *\r\n   * Logic:\r\n   * - BID wall disappears ‚Üí whale done accumulating ‚Üí SHORT signal (distribution next)\r\n   * - ASK wall disappears ‚Üí whale done distributing ‚Üí LONG signal (accumulation next)\r\n   */\r\n  private detectWallDisappearance(): WhaleSignal {\r\n    const now = Date.now();\r\n    const wallGoneThresholdMs = this.config.modes.wallDisappearance.wallGoneThresholdMs;\r\n\r\n    // Check BID walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - BID wall gone ‚Üí SHORT signal\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction: SignalDirection.SHORT,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason: `BID wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - Accumulation done, distribution likely`,\r\n          metadata: {\r\n            wall,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check ASK walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - ASK wall gone ‚Üí LONG signal\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction: SignalDirection.LONG,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason: `ASK wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - Distribution done, accumulation likely`,\r\n          metadata: {\r\n            wall,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 3: IMBALANCE SPIKE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect sudden bid/ask imbalance shift\r\n   *\r\n   * Logic:\r\n   * - Sudden increase in bid ratio ‚Üí LONG signal (buying pressure)\r\n   * - Sudden increase in ask ratio ‚Üí SHORT signal (selling pressure)\r\n   */\r\n  private detectImbalanceSpike(analysis: OrderBookAnalysis): WhaleSignal {\r\n    if (this.imbalanceHistory.length < 3) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const currentRatio = analysis.imbalance.ratio;\r\n    const detectionWindow = this.config.modes.imbalanceSpike.detectionWindow;\r\n    const now = Date.now();\r\n\r\n    // Get imbalance from N seconds ago\r\n    const historicalSnapshot = this.imbalanceHistory.find(\r\n      (snap) => now - snap.timestamp <= detectionWindow,\r\n    );\r\n\r\n    if (!historicalSnapshot) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const historicalRatio = historicalSnapshot.ratio;\r\n    const ratioChange = currentRatio / historicalRatio;\r\n\r\n    // Check for BULLISH spike (bid ratio increased)\r\n    if (ratioChange >= 1 + this.config.modes.imbalanceSpike.minRatioChange) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.LONG,\r\n        confidence: this.calculateSpikeConfidence(ratioChange),\r\n        reason: `BULLISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} ‚Üí ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, +${((ratioChange - 1) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Check for BEARISH spike (ask ratio increased = bid ratio decreased)\r\n    if (ratioChange <= 1 / (1 + this.config.modes.imbalanceSpike.minRatioChange)) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.SHORT,\r\n        confidence: this.calculateSpikeConfidence(1 / ratioChange),\r\n        reason: `BEARISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} ‚Üí ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, ${((1 - ratioChange) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Data Tracking\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Update tracked walls with current order book\r\n   */\r\n  private updateTrackedWalls(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    // Update BID walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'BID')) {\r\n      const existing = this.trackedBidWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedBidWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update ASK walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'ASK')) {\r\n      const existing = this.trackedAskWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedAskWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update imbalance history for spike detection\r\n   */\r\n  private updateImbalanceHistory(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    this.imbalanceHistory.push({\r\n      ratio: analysis.imbalance.ratio,\r\n      timestamp: now,\r\n      bidVolume: analysis.imbalance.bidVolume,\r\n      askVolume: analysis.imbalance.askVolume,\r\n    });\r\n\r\n    // Keep only recent history\r\n    if (this.imbalanceHistory.length > this.config.maxImbalanceHistory) {\r\n      this.imbalanceHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired data\r\n   */\r\n  private cleanupExpiredData(): void {\r\n    const now = Date.now();\r\n    const wallExpiryMs = this.config.wallExpiryMs;\r\n    const breakExpiryMs = this.config.breakExpiryMs;\r\n\r\n    // Remove old walls\r\n    for (const [price, wall] of this.trackedBidWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedBidWalls.delete(price);\r\n      }\r\n    }\r\n    for (const [price, wall] of this.trackedAskWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedAskWalls.delete(price);\r\n      }\r\n    }\r\n\r\n    // Remove old broken walls (allow re-detection after 5 min)\r\n    if (this.recentlyBrokenWalls.size > 100) {\r\n      this.recentlyBrokenWalls.clear(); // Prevent memory leak\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Confidence Calculation\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate confidence for wall break (0-100)\r\n   */\r\n  private calculateBreakConfidence(wall: WhaleWall): number {\r\n    // Factor: Wall size (bigger = higher confidence)\r\n    const sizeScore = Math.min((wall.percentOfTotal / 15) * 60, 60);\r\n\r\n    // Factor: Distance (closer break = higher confidence)\r\n    const distanceScore = Math.max(30 - wall.distance * 5, 10);\r\n\r\n    return Math.min(sizeScore + distanceScore, this.config.modes.wallBreak.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for wall disappearance (0-100)\r\n   */\r\n  private calculateDisappearanceConfidence(wall: WhaleWall, wallLifetime: number): number {\r\n    // Factor: Wall size\r\n    const sizeScore = Math.min((wall.percentOfTotal / 20) * 50, 50);\r\n\r\n    // Factor: Lifetime (longer = higher confidence)\r\n    const lifetimeScore = Math.min((wallLifetime / 120000) * 30, 30); // Max at 2 minutes\r\n\r\n    return Math.min(sizeScore + lifetimeScore, this.config.modes.wallDisappearance.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for imbalance spike (0-100)\r\n   */\r\n  private calculateSpikeConfidence(ratioChange: number): number {\r\n    // Larger spike = higher confidence\r\n    const confidence = Math.min((ratioChange - 1) * 50, this.config.modes.imbalanceSpike.maxConfidence);\r\n    return confidence;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Log whale detection\r\n   */\r\n  private logWhaleDetection(signal: WhaleSignal): void {\r\n    this.logger.info(`üêã WHALE DETECTED [FOLLOW][${signal.mode}]`, {\r\n      direction: signal.direction,\r\n      confidence: `${signal.confidence.toFixed(0)}%`,\r\n      reason: signal.reason,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  getStats(): {\r\n    trackedWalls: { bids: number; asks: number };\r\n    recentBreaks: number;\r\n    imbalanceHistory: number;\r\n    } {\r\n    return {\r\n      trackedWalls: {\r\n        bids: this.trackedBidWalls.size,\r\n        asks: this.trackedAskWalls.size,\r\n      },\r\n      recentBreaks: this.recentlyBrokenWalls.size,\r\n      imbalanceHistory: this.imbalanceHistory.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all tracked data\r\n   */\r\n  clear(): void {\r\n    this.trackedBidWalls.clear();\r\n    this.trackedAskWalls.clear();\r\n    this.recentlyBrokenWalls.clear();\r\n    this.imbalanceHistory = [];\r\n    this.logger.debug('WhaleDetectorFollow data cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\services\\whale-detector.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TIME_UNITS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":82,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":92},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OrderBookWall' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":74},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":137,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":137,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.05.","line":177,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":177,"endColumn":29},{"ruleId":"complexity","severity":1,"message":"Method 'detectWallBreak' has a complexity of 11. Maximum allowed is 10.","line":206,"column":26,"nodeType":"FunctionExpression","messageId":"complex","endLine":291,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Method 'detectWallDisappearance' has a complexity of 11. Maximum allowed is 10.","line":312,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":411,"endColumn":4},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":344,"column":23,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":344,"endColumn":25},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":391,"column":23,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":391,"endColumn":25},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":425,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":425,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":438,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":438,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15981,16000],"text":"historicalSnapshot == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (482). Maximum allowed is 300.","line":473,"column":1,"nodeType":null,"messageId":"exceed","endLine":759,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":489,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":489,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18185,18193],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":510,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":510,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18878,18886],"text":"existing != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'breakExpiryMs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":554,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":554,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":569,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":569,"endColumn":44},{"ruleId":"complexity","severity":1,"message":"Method 'determineWallDisappearanceDirection' has a complexity of 18. Maximum allowed is 10.","line":588,"column":46,"nodeType":"FunctionExpression","messageId":"complex","endLine":674,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":601,"column":124,"nodeType":"Literal","messageId":"noMagic","endLine":601,"endColumn":128},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":613,"column":124,"nodeType":"Literal","messageId":"noMagic","endLine":613,"endColumn":128},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":626,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":626,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":634,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":634,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":642,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":642,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":656,"column":126,"nodeType":"Literal","messageId":"noMagic","endLine":656,"endColumn":130},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":670,"column":122,"nodeType":"Literal","messageId":"noMagic","endLine":670,"endColumn":126},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":685,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":685,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":685,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":685,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 60.","line":685,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":685,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":688,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":688,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":688,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":688,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 10.","line":688,"column":60,"nodeType":"Literal","messageId":"noMagic","endLine":688,"endColumn":62},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 20.","line":698,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":698,"endColumn":57},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":698,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":698,"endColumn":63},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":698,"column":65,"nodeType":"Literal","messageId":"noMagic","endLine":698,"endColumn":67},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 120000.","line":701,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":701,"endColumn":58},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":701,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":701,"endColumn":64},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 30.","line":701,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":701,"endColumn":68},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":711,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":711,"endColumn":55}],"suppressedMessages":[],"errorCount":32,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS, TIME_UNITS } from '../constants';\r\n/**\r\n * Whale Detector Service - Combined Approach\r\n *\r\n * Detects whale activity using 3 modes:\r\n *\r\n * MODE 1: WALL_BREAK (–ø—Ä–æ–±–æ–π —Å—Ç–µ–Ω—ã)\r\n * - Detects when price breaks through a large wall\r\n * - High momentum signal (stop-losses triggered)\r\n * - Entry: After break, on pullback\r\n *\r\n * MODE 2: WALL_DISAPPEARANCE (–∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ —Å—Ç–µ–Ω—ã)\r\n * - Tracks walls that suddenly disappear\r\n * - Indicates whale completed accumulation/distribution\r\n * - Entry: After wall removed (whale done = reversal)\r\n *\r\n * MODE 3: IMBALANCE_SPIKE (—Ä–µ–∑–∫–∏–π –¥–∏—Å–±–∞–ª–∞–Ω—Å)\r\n * - Detects sudden bid/ask imbalance shifts\r\n * - Indicates large player entering market\r\n * - Entry: Ride the momentum (highest priority)\r\n *\r\n * IMPORTANT: Requires WebSocket orderbook for real-time data\r\n * REST API polling is too slow for whale detection!\r\n */\r\n\r\nimport { LoggerService, SignalDirection, OrderBookAnalysis, OrderBookWall } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport enum WhaleDetectionMode {\r\n  WALL_BREAK = 'WALL_BREAK', // –ü—Ä–æ–±–æ–π —Å—Ç–µ–Ω—ã\r\n  WALL_DISAPPEARANCE = 'WALL_DISAPPEARANCE', // –ò—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ —Å—Ç–µ–Ω—ã\r\n  IMBALANCE_SPIKE = 'IMBALANCE_SPIKE', // –†–µ–∑–∫–∏–π –¥–∏—Å–±–∞–ª–∞–Ω—Å\r\n}\r\n\r\nexport interface WhaleDetectorConfig {\r\n  modes: {\r\n    wallBreak: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 15%)\r\n      breakConfirmationMs: number; // Time to confirm break (e.g., 3000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 85)\r\n    };\r\n    wallDisappearance: {\r\n      enabled: boolean;\r\n      minWallSize: number; // Min % of total volume (e.g., 20%)\r\n      minWallDuration: number; // Min time wall existed (e.g., TIME_UNITS.MINUTEms = 1min)\r\n      wallGoneThresholdMs: number; // Time without seeing wall = gone (e.g., 15000ms)\r\n      maxConfidence: number; // Max confidence % (e.g., 80)\r\n    };\r\n    imbalanceSpike: {\r\n      enabled: boolean;\r\n      minRatioChange: number; // Min ratio change (e.g., 1.5 = CONFIDENCE_THRESHOLDS.MODERATE% change)\r\n      detectionWindow: number; // Time window for spike (e.g., 10000ms = 10s)\r\n      maxConfidence: number; // Max confidence % (e.g., 90)\r\n    };\r\n  };\r\n  maxImbalanceHistory: number; // Max imbalance snapshots to keep (e.g., 20)\r\n  wallExpiryMs: number; // Time before wall is removed from tracking (e.g., TIME_UNITS.MINUTEms)\r\n  breakExpiryMs: number; // Time before broken wall can be re-detected (e.g., TIME_UNITS.FIVE_MINUTESms)\r\n}\r\n\r\nexport interface WhaleWall {\r\n  side: 'BID' | 'ASK';\r\n  price: number;\r\n  quantity: number;\r\n  percentOfTotal: number;\r\n  distance: number;\r\n  detectedAt: number;\r\n  lastSeenAt: number;\r\n}\r\n\r\nexport interface ImbalanceSnapshot {\r\n  ratio: number;\r\n  timestamp: number;\r\n  bidVolume: number;\r\n  askVolume: number;\r\n}\r\n\r\nexport interface WhaleSignal {\r\n  detected: boolean;\r\n  mode: WhaleDetectionMode | null;\r\n  direction: SignalDirection | null;\r\n  confidence: number; // 0-100\r\n  reason: string;\r\n  metadata: {\r\n    wall?: WhaleWall;\r\n    breakPrice?: number;\r\n    imbalanceChange?: number;\r\n    trendInverted?: boolean; // Whether signal was inverted due to strong trend\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// WHALE DETECTOR SERVICE\r\n// ============================================================================\r\n\r\nexport class WhaleDetectorService {\r\n  // Mode 1: Wall tracking (for breaks and disappearances)\r\n  private trackedBidWalls: Map<number, WhaleWall> = new Map();\r\n  private trackedAskWalls: Map<number, WhaleWall> = new Map();\r\n\r\n  // Mode 2: Recently broken walls (to avoid re-detecting same break)\r\n  private recentlyBrokenWalls: Set<string> = new Set(); // \"BID_1.5000\" or \"ASK_1.5200\"\r\n\r\n  // Mode 3: Imbalance history (for spike detection)\r\n  private imbalanceHistory: ImbalanceSnapshot[] = [];\r\n\r\n  constructor(\r\n    private config: WhaleDetectorConfig,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Detect whale activity from order book analysis\r\n   *\r\n   * @param analysis - Current order book analysis\r\n   * @param currentPrice - Current market price\r\n   * @param btcMomentum - BTC momentum (0-1, from BTCAnalysis)\r\n   * @param btcDirection - BTC direction ('UP'/'DOWN'/'NEUTRAL')\r\n   * @returns Whale signal (detected or not)\r\n   */\r\n  detectWhale(\r\n    analysis: OrderBookAnalysis,\r\n    currentPrice: number,\r\n    btcMomentum?: number,\r\n    btcDirection?: string,\r\n  ): WhaleSignal {\r\n    // Update tracked data\r\n    this.updateTrackedWalls(analysis);\r\n    this.updateImbalanceHistory(analysis);\r\n    this.cleanupExpiredData();\r\n\r\n    // Log current orderbook state (every 10th call to avoid spam)\r\n    if (Math.random() < 0.1) {\r\n      this.logger.debug('üêã Whale Detector State', {\r\n        trackedBids: this.trackedBidWalls.size,\r\n        trackedAsks: this.trackedAskWalls.size,\r\n        imbalanceHistory: this.imbalanceHistory.length,\r\n        currentRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        walls: analysis.walls.length,\r\n        btcMomentum: btcMomentum?.toFixed(DECIMAL_PLACES.PERCENT),\r\n        btcDirection,\r\n      });\r\n    }\r\n\r\n    // MODE 3: Imbalance Spike (highest priority - immediate action)\r\n    if (this.config.modes.imbalanceSpike.enabled) {\r\n      const spikeSignal = this.detectImbalanceSpike(analysis);\r\n      if (spikeSignal.detected) {\r\n        this.logWhaleDetection(spikeSignal);\r\n        return spikeSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 1: Wall Break (medium priority - momentum play)\r\n    if (this.config.modes.wallBreak.enabled) {\r\n      const breakSignal = this.detectWallBreak(currentPrice);\r\n      if (breakSignal.detected) {\r\n        this.logWhaleDetection(breakSignal);\r\n        return breakSignal;\r\n      }\r\n    }\r\n\r\n    // MODE 2: Wall Disappearance (lower priority - reversal play)\r\n    if (this.config.modes.wallDisappearance.enabled) {\r\n      const disappearanceSignal = this.detectWallDisappearance(btcMomentum, btcDirection);\r\n      if (disappearanceSignal.detected) {\r\n        this.logWhaleDetection(disappearanceSignal);\r\n        return disappearanceSignal;\r\n      }\r\n    }\r\n\r\n    // No whale detected - log summary (every 20th call)\r\n    if (Math.random() < 0.05) {\r\n      this.logger.debug('üêã No whale activity', {\r\n        wallsDetected: analysis.walls.length,\r\n        imbalanceRatio: analysis.imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        imbalanceDirection: analysis.imbalance.direction,\r\n      });\r\n    }\r\n\r\n    return {\r\n      detected: false,\r\n      mode: null,\r\n      direction: null,\r\n      confidence: 0,\r\n      reason: 'No whale activity detected',\r\n      metadata: {},\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 1: WALL BREAK DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when price breaks through a large wall\r\n   *\r\n   * Logic:\r\n   * - BID wall broken (price went below) ‚Üí SHORT signal (momentum down)\r\n   * - ASK wall broken (price went above) ‚Üí LONG signal (momentum up)\r\n   */\r\n  private detectWallBreak(currentPrice: number): WhaleSignal {\r\n    const now = Date.now();\r\n    const confirmationMs = this.config.modes.wallBreak.breakConfirmationMs;\r\n\r\n    // Check if any BID walls were broken (price dropped below)\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now BELOW the wall\r\n      if (currentPrice < wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `BID_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - BID wall broken ‚Üí LONG signal\r\n        // Logic: BID wall absorbed selling pressure ‚Üí buyers push price UP\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.LONG,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `BID wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale absorbed sells, Momentum UP`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check if any ASK walls were broken (price rose above)\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallBreak.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if price is now ABOVE the wall\r\n      if (currentPrice > wallPrice) {\r\n        // Check if wall was broken recently (not just now)\r\n        const timeSinceLastSeen = now - wall.lastSeenAt;\r\n        if (timeSinceLastSeen < confirmationMs) {\r\n          continue; // Too soon, wait for confirmation\r\n        }\r\n\r\n        // Check if we already detected this break\r\n        const wallKey = `ASK_${wallPrice.toFixed(DECIMAL_PLACES.PRICE)}`;\r\n        if (this.recentlyBrokenWalls.has(wallKey)) {\r\n          continue; // Already detected\r\n        }\r\n\r\n        // WALL BREAK DETECTED - ASK wall broken ‚Üí SHORT signal\r\n        // Logic: ASK wall absorbed buying pressure ‚Üí sellers push price DOWN\r\n        this.recentlyBrokenWalls.add(wallKey);\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_BREAK,\r\n          direction: SignalDirection.SHORT,\r\n          confidence: this.calculateBreakConfidence(wall),\r\n          reason: `ASK wall BROKEN @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (${wall.percentOfTotal.toFixed(1)}% volume) - Whale absorbed buys, Momentum DOWN`,\r\n          metadata: {\r\n            wall,\r\n            breakPrice: currentPrice,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 2: WALL DISAPPEARANCE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect when a large wall suddenly disappears\r\n   *\r\n   * DEFAULT Logic (neutral market):\r\n   * - BID wall disappears ‚Üí whale done accumulating ‚Üí SHORT signal (distribution next)\r\n   * - ASK wall disappears ‚Üí whale done distributing ‚Üí LONG signal (accumulation next)\r\n   *\r\n   * TREND-AWARE Logic (strong trend):\r\n   * - In BEARISH market (BTC down): BID disappears ‚Üí SHORT continuation (whales not buying = more drop)\r\n   * - In BULLISH market (BTC up): ASK disappears ‚Üí LONG continuation (whales not selling = more pump)\r\n   * - Logic is INVERTED in strong trends to trade WITH the trend!\r\n   *\r\n   * @param btcMomentum - BTC momentum (0-1, undefined if not available)\r\n   * @param btcDirection - BTC direction ('UP'/'DOWN'/'NEUTRAL', undefined if not available)\r\n   */\r\n  private detectWallDisappearance(btcMomentum?: number, btcDirection?: string): WhaleSignal {\r\n    const now = Date.now();\r\n    const wallGoneThresholdMs = this.config.modes.wallDisappearance.wallGoneThresholdMs;\r\n\r\n    // Check BID walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedBidWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - BID wall gone\r\n        this.trackedBidWalls.delete(wallPrice);\r\n\r\n        // Determine signal direction based on market trend\r\n        const { direction, reason, trendInverted } = this.determineWallDisappearanceDirection(\r\n          'BID',\r\n          wallPrice,\r\n          wallLifetime,\r\n          btcMomentum,\r\n          btcDirection,\r\n        );\r\n\r\n        if (direction == null) {\r\n          // Signal blocked by trend filter\r\n          continue;\r\n        }\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason,\r\n          metadata: {\r\n            wall,\r\n            trendInverted,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check ASK walls that disappeared\r\n    for (const [wallPrice, wall] of this.trackedAskWalls.entries()) {\r\n      // Check if wall is significant\r\n      if (wall.percentOfTotal < this.config.modes.wallDisappearance.minWallSize) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall existed long enough\r\n      const wallLifetime = wall.lastSeenAt - wall.detectedAt;\r\n      if (wallLifetime < this.config.modes.wallDisappearance.minWallDuration) {\r\n        continue;\r\n      }\r\n\r\n      // Check if wall disappeared (not seen recently)\r\n      const timeSinceLastSeen = now - wall.lastSeenAt;\r\n      if (timeSinceLastSeen > wallGoneThresholdMs) {\r\n        // WALL DISAPPEARED - ASK wall gone\r\n        this.trackedAskWalls.delete(wallPrice);\r\n\r\n        // Determine signal direction based on market trend\r\n        const { direction, reason, trendInverted } = this.determineWallDisappearanceDirection(\r\n          'ASK',\r\n          wallPrice,\r\n          wallLifetime,\r\n          btcMomentum,\r\n          btcDirection,\r\n        );\r\n\r\n        if (direction == null) {\r\n          // Signal blocked by trend filter\r\n          continue;\r\n        }\r\n\r\n        return {\r\n          detected: true,\r\n          mode: WhaleDetectionMode.WALL_DISAPPEARANCE,\r\n          direction,\r\n          confidence: this.calculateDisappearanceConfidence(wall, wallLifetime),\r\n          reason,\r\n          metadata: {\r\n            wall,\r\n            trendInverted,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // MODE 3: IMBALANCE SPIKE DETECTION\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Detect sudden bid/ask imbalance shift\r\n   *\r\n   * Logic:\r\n   * - Sudden increase in bid ratio ‚Üí LONG signal (buying pressure)\r\n   * - Sudden increase in ask ratio ‚Üí SHORT signal (selling pressure)\r\n   */\r\n  private detectImbalanceSpike(analysis: OrderBookAnalysis): WhaleSignal {\r\n    if (this.imbalanceHistory.length < 3) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const currentRatio = analysis.imbalance.ratio;\r\n    const detectionWindow = this.config.modes.imbalanceSpike.detectionWindow;\r\n    const now = Date.now();\r\n\r\n    // Get imbalance from N seconds ago\r\n    const historicalSnapshot = this.imbalanceHistory.find(\r\n      (snap) => now - snap.timestamp <= detectionWindow,\r\n    );\r\n\r\n    if (!historicalSnapshot) {\r\n      return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n    }\r\n\r\n    const historicalRatio = historicalSnapshot.ratio;\r\n    const ratioChange = currentRatio / historicalRatio;\r\n\r\n    // Check for BULLISH spike (bid ratio increased)\r\n    if (ratioChange >= 1 + this.config.modes.imbalanceSpike.minRatioChange) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.LONG,\r\n        confidence: this.calculateSpikeConfidence(ratioChange),\r\n        reason: `BULLISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} ‚Üí ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, +${((ratioChange - 1) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Check for BEARISH spike (ask ratio increased = bid ratio decreased)\r\n    if (ratioChange <= 1 / (1 + this.config.modes.imbalanceSpike.minRatioChange)) {\r\n      return {\r\n        detected: true,\r\n        mode: WhaleDetectionMode.IMBALANCE_SPIKE,\r\n        direction: SignalDirection.SHORT,\r\n        confidence: this.calculateSpikeConfidence(1 / ratioChange),\r\n        reason: `BEARISH imbalance SPIKE (ratio: ${historicalRatio.toFixed(DECIMAL_PLACES.PERCENT)} ‚Üí ${currentRatio.toFixed(DECIMAL_PLACES.PERCENT)}, ${((1 - ratioChange) * PERCENT_MULTIPLIER).toFixed(0)}%)`,\r\n        metadata: {\r\n          imbalanceChange: ratioChange,\r\n        },\r\n      };\r\n    }\r\n\r\n    return { detected: false, mode: null, direction: null, confidence: 0, reason: '', metadata: {} };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Data Tracking\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Update tracked walls with current order book\r\n   */\r\n  private updateTrackedWalls(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    // Update BID walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'BID')) {\r\n      const existing = this.trackedBidWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedBidWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update ASK walls\r\n    for (const wall of analysis.walls.filter((w) => w.side === 'ASK')) {\r\n      const existing = this.trackedAskWalls.get(wall.price);\r\n      if (existing) {\r\n        existing.lastSeenAt = now;\r\n        existing.quantity = wall.quantity;\r\n        existing.percentOfTotal = wall.percentOfTotal;\r\n        existing.distance = wall.distance;\r\n      } else {\r\n        this.trackedAskWalls.set(wall.price, {\r\n          side: wall.side,\r\n          price: wall.price,\r\n          quantity: wall.quantity,\r\n          percentOfTotal: wall.percentOfTotal,\r\n          distance: wall.distance,\r\n          detectedAt: now,\r\n          lastSeenAt: now,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update imbalance history for spike detection\r\n   */\r\n  private updateImbalanceHistory(analysis: OrderBookAnalysis): void {\r\n    const now = Date.now();\r\n\r\n    this.imbalanceHistory.push({\r\n      ratio: analysis.imbalance.ratio,\r\n      timestamp: now,\r\n      bidVolume: analysis.imbalance.bidVolume,\r\n      askVolume: analysis.imbalance.askVolume,\r\n    });\r\n\r\n    // Keep only recent history\r\n    if (this.imbalanceHistory.length > this.config.maxImbalanceHistory) {\r\n      this.imbalanceHistory.shift();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup expired data\r\n   */\r\n  private cleanupExpiredData(): void {\r\n    const now = Date.now();\r\n    const wallExpiryMs = this.config.wallExpiryMs;\r\n    const breakExpiryMs = this.config.breakExpiryMs;\r\n\r\n    // Remove old walls\r\n    for (const [price, wall] of this.trackedBidWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedBidWalls.delete(price);\r\n      }\r\n    }\r\n    for (const [price, wall] of this.trackedAskWalls.entries()) {\r\n      if (now - wall.lastSeenAt > wallExpiryMs) {\r\n        this.trackedAskWalls.delete(price);\r\n      }\r\n    }\r\n\r\n    // Remove old broken walls (allow re-detection after 5 min)\r\n    if (this.recentlyBrokenWalls.size > 100) {\r\n      this.recentlyBrokenWalls.clear(); // Prevent memory leak\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Trend-Aware Signal Direction\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Determine signal direction for WALL_DISAPPEARANCE based on market trend\r\n   *\r\n   * @param wallSide - Side of wall that disappeared ('BID' or 'ASK')\r\n   * @param wallPrice - Price level of wall\r\n   * @param wallLifetime - How long wall existed (ms)\r\n   * @param btcMomentum - BTC momentum (0-1, undefined if not available)\r\n   * @param btcDirection - BTC direction ('UP'/'DOWN'/'NEUTRAL', undefined if not available)\r\n   * @returns Object with direction, reason, and whether trend was inverted\r\n   */\r\n  private determineWallDisappearanceDirection(\r\n    wallSide: 'BID' | 'ASK',\r\n    wallPrice: number,\r\n    wallLifetime: number,\r\n    btcMomentum?: number,\r\n    btcDirection?: string,\r\n  ): { direction: SignalDirection | null; reason: string; trendInverted: boolean } {\r\n    // Default direction (neutral market logic)\r\n    const defaultDirection = wallSide === 'BID' ? SignalDirection.SHORT : SignalDirection.LONG;\r\n    const invertedDirection = wallSide === 'BID' ? SignalDirection.LONG : SignalDirection.SHORT;\r\n\r\n    // If BTC data not available, use default logic\r\n    if (btcMomentum === undefined || btcDirection === undefined) {\r\n      const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - ${\r\n        wallSide === 'BID' ? 'Accumulation done, distribution likely' : 'Distribution done, accumulation likely'\r\n      }`;\r\n      return { direction: defaultDirection, reason, trendInverted: false };\r\n    }\r\n\r\n    // Determine trend strength\r\n    const isStrongTrend = btcMomentum >= MULTIPLIERS.HALF; // Strong trend threshold\r\n    const isNeutralMarket = btcMomentum < PERCENTAGE_THRESHOLDS.MODERATE; // Neutral market threshold\r\n\r\n    // NEUTRAL MARKET: Use default logic\r\n    if (isNeutralMarket) {\r\n      const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - ${\r\n        wallSide === 'BID' ? 'Accumulation done, distribution likely' : 'Distribution done, accumulation likely'\r\n      } [NEUTRAL market]`;\r\n      return { direction: defaultDirection, reason, trendInverted: false };\r\n    }\r\n\r\n    // STRONG TREND: Apply trend-aware logic (INVERT direction to trade WITH trend)\r\n    if (isStrongTrend) {\r\n      const isBearishTrend = btcDirection === 'DOWN';\r\n      const isBullishTrend = btcDirection === 'UP';\r\n\r\n      // BID wall disappeared in BEARISH market ‚Üí INVERT to LONG (expect bounce)\r\n      if (wallSide === 'BID' && isBearishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BEARISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales not buying = potential SHORT-TERM BOUNCE ‚Üí LONG [INVERTED]`;\r\n        return { direction: invertedDirection, reason, trendInverted: true };\r\n      }\r\n\r\n      // ASK wall disappeared in BULLISH market ‚Üí INVERT to SHORT (expect pullback)\r\n      if (wallSide === 'ASK' && isBullishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BULLISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales not selling = potential SHORT-TERM PULLBACK ‚Üí SHORT [INVERTED]`;\r\n        return { direction: invertedDirection, reason, trendInverted: true };\r\n      }\r\n\r\n      // BID wall disappeared in BULLISH market ‚Üí Keep SHORT (continuation)\r\n      if (wallSide === 'BID' && isBullishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BULLISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales done accumulating ‚Üí continue UP (skip SHORT)`;\r\n        // Block this signal (it goes against trend)\r\n        this.logger.debug('‚ö†Ô∏è Wall disappearance signal BLOCKED (against strong trend)', {\r\n          wallSide,\r\n          btcDirection,\r\n          btcMomentum: btcMomentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n        return { direction: null, reason, trendInverted: false };\r\n      }\r\n\r\n      // ASK wall disappeared in BEARISH market ‚Üí Keep LONG (continuation)\r\n      if (wallSide === 'ASK' && isBearishTrend) {\r\n        const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - BEARISH trend (${(\r\n          btcMomentum * PERCENT_MULTIPLIER\r\n        ).toFixed(0)}%) - Whales done distributing ‚Üí continue DOWN (skip LONG)`;\r\n        // Block this signal (it goes against trend)\r\n        this.logger.debug('‚ö†Ô∏è Wall disappearance signal BLOCKED (against strong trend)', {\r\n          wallSide,\r\n          btcDirection,\r\n          btcMomentum: btcMomentum.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n        return { direction: null, reason, trendInverted: false };\r\n      }\r\n    }\r\n\r\n    // MODERATE TREND (0.3 <= momentum < MULTIPLIERS.HALF): Use default logic with caution\r\n    const reason = `${wallSide} wall DISAPPEARED @ ${wallPrice.toFixed(DECIMAL_PLACES.PRICE)} (existed ${(wallLifetime / 1000).toFixed(0)}s) - ${\r\n      wallSide === 'BID' ? 'Accumulation done, distribution likely' : 'Distribution done, accumulation likely'\r\n    } [MODERATE trend, BTC ${btcDirection}]`;\r\n    return { direction: defaultDirection, reason, trendInverted: false };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Confidence Calculation\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate confidence for wall break (0-100)\r\n   */\r\n  private calculateBreakConfidence(wall: WhaleWall): number {\r\n    // Factor: Wall size (bigger = higher confidence)\r\n    const sizeScore = Math.min((wall.percentOfTotal / 15) * 60, 60);\r\n\r\n    // Factor: Distance (closer break = higher confidence)\r\n    const distanceScore = Math.max(30 - wall.distance * 5, 10);\r\n\r\n    return Math.min(sizeScore + distanceScore, this.config.modes.wallBreak.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for wall disappearance (0-100)\r\n   */\r\n  private calculateDisappearanceConfidence(wall: WhaleWall, wallLifetime: number): number {\r\n    // Factor: Wall size\r\n    const sizeScore = Math.min((wall.percentOfTotal / 20) * 50, 50);\r\n\r\n    // Factor: Lifetime (longer = higher confidence)\r\n    const lifetimeScore = Math.min((wallLifetime / 120000) * 30, 30); // Max at 2 minutes\r\n\r\n    return Math.min(sizeScore + lifetimeScore, this.config.modes.wallDisappearance.maxConfidence);\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for imbalance spike (0-100)\r\n   */\r\n  private calculateSpikeConfidence(ratioChange: number): number {\r\n    // Larger spike = higher confidence\r\n    const confidence = Math.min((ratioChange - 1) * 50, this.config.modes.imbalanceSpike.maxConfidence);\r\n    return confidence;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Log whale detection\r\n   */\r\n  private logWhaleDetection(signal: WhaleSignal): void {\r\n    this.logger.info(`üêã WHALE DETECTED [${signal.mode}]`, {\r\n      direction: signal.direction,\r\n      confidence: `${signal.confidence.toFixed(0)}%`,\r\n      reason: signal.reason,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  getStats(): {\r\n    trackedWalls: { bids: number; asks: number };\r\n    recentBreaks: number;\r\n    imbalanceHistory: number;\r\n    } {\r\n    return {\r\n      trackedWalls: {\r\n        bids: this.trackedBidWalls.size,\r\n        asks: this.trackedAskWalls.size,\r\n      },\r\n      recentBreaks: this.recentlyBrokenWalls.size,\r\n      imbalanceHistory: this.imbalanceHistory.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all tracked data\r\n   */\r\n  clear(): void {\r\n    this.trackedBidWalls.clear();\r\n    this.trackedAskWalls.clear();\r\n    this.recentlyBrokenWalls.clear();\r\n    this.imbalanceHistory = [];\r\n    this.logger.debug('WhaleDetector data cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\counter-trend.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CONFIDENCE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'EXTREME_OVERSOLD_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":44,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'EXTREME_OVERBOUGHT_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":45,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MAX_DISTANCE_TO_EMA_PERCENT' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":46,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":86,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":86,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3600,3615],"text":"config.patterns != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":91,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":91,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3779,3791],"text":"weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":100,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":100,"endColumn":17},{"ruleId":"complexity","severity":1,"message":"Async method 'evaluate' has a complexity of 21. Maximum allowed is 10.","line":100,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":307,"endColumn":4},{"ruleId":"brace-style","severity":2,"message":"Closing curly brace does not appear on the same line as the subsequent block.","line":129,"column":5,"nodeType":"Punctuator","messageId":"nextLineClose","endLine":129,"endColumn":6},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":137,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":137,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":205,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":205,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8451,8468],"text":"this.weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":212,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":212,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8740,8755],"text":"(data.stochastic != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":214,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":214,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8929,8948],"text":"(data.bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":215,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":215,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9021,9029],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9021,9029],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9021,9029],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":226,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":226,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9564,9580],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":228,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":228,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9677,9693],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":254,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":254,"endColumn":38},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 15.","line":257,"column":74,"nodeType":"Literal","messageId":"noMagic","endLine":257,"endColumn":76},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":258,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":258,"endColumn":47},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.1.","line":258,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":258,"endColumn":52},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":268,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":268,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[11630,11650],"text":"this.patternAnalyzer != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.0.","line":314,"column":27,"nodeType":"Literal","messageId":"noMagic","endLine":314,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.1.","line":316,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":316,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 4.0.","line":317,"column":34,"nodeType":"Literal","messageId":"noMagic","endLine":317,"endColumn":37},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.9.","line":319,"column":14,"nodeType":"Literal","messageId":"noMagic","endLine":319,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":334,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":334,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13570,13578],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[13570,13578],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[13570,13578],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":334,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":334,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[13579,13581],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 121. Maximum allowed is 120.","line":343,"column":1,"nodeType":"Program","messageId":"max","endLine":343,"endColumn":122},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":390,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":390,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15598,15606],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[15598,15606],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15598,15606],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":390,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":390,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[15607,15609],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":392,"column":55,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":392,"endColumn":72,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[15731,15737],"text":"SwingPointType.HIGH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":393,"column":54,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":393,"endColumn":70,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[15812,15817],"text":"SwingPointType.LOW"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":30,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Counter-Trend Strategy (Priority 3)\r\n *\r\n * DANGEROUS STRATEGY - catches extreme reversals at oversold/overbought levels.\r\n *\r\n * Entry conditions:\r\n * 1. LONG: RSI < 20 (extreme oversold)\r\n * 2. SHORT: RSI > 85 (extreme overbought)\r\n * 3. Distance to EMA < 5.5%\r\n * 4. Optional: NOT in opposite trend (avoid catching falling knife / buying blow-off top)\r\n *\r\n * Confidence calculation:\r\n * - Base confidence: 0.50 (LOW - high risk strategy)\r\n * - RSI extremity boost: more extreme = slightly higher confidence\r\n * - Distance penalty: far from EMA = lower confidence\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategyMarketData,\r\n  StrategySignal,\r\n  Signal,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  SessionBasedSLConfig,\r\n  WeightMatrixInput,\r\n  SignalScoreBreakdown,\r\n} from '../types';\r\nimport { VolumeCalculator } from '../analyzers/volume.calculator';\r\nimport { ConfidenceHelper } from '../utils/confidence.helper';\r\nimport { SessionDetector } from '../utils/session-detector';\r\nimport { PatternAnalyzerHelper, PatternAnalyzerConfig } from '../analyzers/pattern-analyzer.helper';\r\nimport { WeightMatrixCalculatorService } from '../services/weight-matrix-calculator.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst STRATEGY_NAME = 'CounterTrend';\r\nconst STRATEGY_PRIORITY = 3; // Third priority (after TrendFollowing, LevelBased)\r\n\r\nconst EXTREME_OVERSOLD_THRESHOLD = PERCENTAGE_THRESHOLDS.LOW_MODERATE; // RSI < 20 for LONG\r\nconst EXTREME_OVERBOUGHT_THRESHOLD = 85; // RSI > 85 for SHORT\r\nconst MAX_DISTANCE_TO_EMA_PERCENT = 5.5; // Distance to EMA must be < 5.5%\r\n\r\nconst BASE_CONFIDENCE = 0.50; // LOW base confidence - risky strategy\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface CounterTrendConfig {\r\n  enabled: boolean;  \r\n  oversoldThreshold: number; // RSI threshold for LONG (default 20)\r\n  overboughtThreshold: number; // RSI threshold for SHORT (default 85)\r\n  maxDistancePercent: number; // Max distance to EMA (default 5.5%)\r\n  blockStrongTrends: boolean; // Block if strong opposite trend (default true)\r\n  stopLossAtrMultiplier: number; // ATR multiplier for stop-loss (e.g., 1.5 - wider for counter-trend)\r\n  takeProfits: Array<{ level: number; percent: number; sizePercent: number }>;\r\n  sessionBasedSL?: SessionBasedSLConfig; // Optional session-based SL widening\r\n  patterns?: PatternAnalyzerConfig; // Pattern detection configuration\r\n}\r\n\r\n// ============================================================================\r\n// COUNTER-TREND STRATEGY\r\n// ============================================================================\r\n\r\nexport class CounterTrendStrategy implements IStrategy {\r\n  readonly name = STRATEGY_NAME;\r\n  readonly priority = STRATEGY_PRIORITY;\r\n\r\n  private volumeCalculator: VolumeCalculator;\r\n  private patternAnalyzer: PatternAnalyzerHelper | null = null;\r\n  private weightMatrix: WeightMatrixCalculatorService | null = null;\r\n\r\n  constructor(\r\n    private config: CounterTrendConfig,\r\n    private logger: LoggerService,\r\n    weightMatrix?: WeightMatrixCalculatorService,\r\n  ) {\r\n    this.volumeCalculator = new VolumeCalculator(logger);\r\n\r\n    // Initialize pattern analyzer if any patterns are configured\r\n    if (config.patterns) {\r\n      this.patternAnalyzer = new PatternAnalyzerHelper(config.patterns, logger, STRATEGY_NAME);\r\n    }\r\n\r\n    // Initialize weight matrix if provided\r\n    if (weightMatrix) {\r\n      this.weightMatrix = weightMatrix;\r\n      this.logger.info(`${STRATEGY_NAME} Strategy: Weight Matrix enabled`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate market data for counter-trend entry (extreme RSI reversal)\r\n   */\r\n  async evaluate(data: StrategyMarketData): Promise<StrategySignal> {\r\n    this.logger.info(`üîç ${this.name} Strategy Evaluation`, {\r\n      rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      trend: data.trend,\r\n      price: data.currentPrice,\r\n    });\r\n\r\n    // ========================================================================\r\n    // STEP 1: Check for extreme RSI\r\n    // ========================================================================\r\n    let direction: SignalDirection | null = null;\r\n    let reason = '';\r\n\r\n    const longCondition = data.rsi < this.config.oversoldThreshold;\r\n    const shortCondition = data.rsi > this.config.overboughtThreshold;\r\n\r\n    this.logger.info(`üìä ${this.name} RSI Extreme Check`, {\r\n      rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      oversoldThreshold: this.config.oversoldThreshold,\r\n      overboughtThreshold: this.config.overboughtThreshold,\r\n      isExtremeOversold: longCondition,\r\n      isExtremeOverbought: shortCondition,\r\n    });\r\n\r\n    // LONG: Extreme oversold\r\n    if (longCondition) {\r\n      direction = SignalDirection.LONG;\r\n      reason = `Extreme oversold RSI ${data.rsi.toFixed(1)} < ${this.config.oversoldThreshold}`;\r\n      this.logger.info(`‚úÖ ${this.name} LONG extreme found`, { reason });\r\n    }\r\n    // SHORT: Extreme overbought\r\n    else if (shortCondition) {\r\n      direction = SignalDirection.SHORT;\r\n      reason = `Extreme overbought RSI ${data.rsi.toFixed(1)} > ${this.config.overboughtThreshold}`;\r\n      this.logger.info(`‚úÖ ${this.name} SHORT extreme found`, { reason });\r\n    }\r\n\r\n    if (direction == null) {\r\n      this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n        blockedBy: ['RSI_NOT_IN_EXTREME_ZONE'],\r\n        rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n      return this.noSignal('RSI not in extreme zone');\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 2: Distance to EMA check\r\n    // ========================================================================\r\n    const distancePercent = Math.abs((data.currentPrice - data.ema.slow) / data.ema.slow) * PERCENT_MULTIPLIER;\r\n\r\n    this.logger.info(`üìä ${this.name} Distance Check`, {\r\n      distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      maxDistance: this.config.maxDistancePercent + '%',\r\n      tooFar: distancePercent > this.config.maxDistancePercent,\r\n    });\r\n\r\n    if (distancePercent > this.config.maxDistancePercent) {\r\n      this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n        blockedBy: ['DISTANCE_TOO_FAR'],\r\n        distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        max: this.config.maxDistancePercent + '%',\r\n      });\r\n      return this.noSignal(\r\n        `Distance to EMA ${distancePercent.toFixed(DECIMAL_PLACES.PERCENT)}% > ${this.config.maxDistancePercent}%`,\r\n      );\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 3: Block opposite trends (optional safety)\r\n    // ========================================================================\r\n    if (this.config.blockStrongTrends) {\r\n      this.logger.info(`üìä ${this.name} Trend Block Check`, {\r\n        direction,\r\n        trend: data.trend,\r\n        blockEnabled: true,\r\n      });\r\n\r\n      // Block LONG in BEARISH trend (catching falling knife)\r\n      if (direction === SignalDirection.LONG && data.trend === 'BEARISH') {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['BEARISH_TREND_BLOCKS_LONG'],\r\n          direction,\r\n          trend: data.trend,\r\n        });\r\n        return this.noSignal('Cannot LONG in BEARISH trend (falling knife)');\r\n      }\r\n\r\n      // Block SHORT in BULLISH trend (buying blow-off top)\r\n      if (direction === SignalDirection.SHORT && data.trend === 'BULLISH') {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['BULLISH_TREND_BLOCKS_SHORT'],\r\n          direction,\r\n          trend: data.trend,\r\n        });\r\n        return this.noSignal('Cannot SHORT in BULLISH trend (blow-off top)');\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 4: Calculate confidence\r\n    // ========================================================================\r\n    let confidence: number;\r\n    let scoreBreakdown: SignalScoreBreakdown | null = null;\r\n\r\n    // Use Weight Matrix if enabled\r\n    if (this.weightMatrix) {\r\n      // Build WeightMatrixInput\r\n      const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n      const currentCandle = data.candles[data.candles.length - 1];\r\n\r\n      const input: WeightMatrixInput = {\r\n        rsi: data.rsi,\r\n        stochastic: data.stochastic ? { k: data.stochastic.k, d: data.stochastic.d } : undefined,\r\n        ema: { fast: data.ema.fast, slow: data.ema.slow, price: data.currentPrice },\r\n        bollingerBands: data.bollingerBands ? { position: data.bollingerBands.percentB } : undefined,\r\n        atr: data.atr ? { current: data.atr, average: data.atr } : undefined,\r\n        volume: {\r\n          current: currentCandle.volume,\r\n          average: volumeAnalysis.avgVolume,\r\n        },\r\n        levelDistance: { percent: distancePercent }, // Distance to EMA\r\n        seniorTFAlignment: {\r\n          aligned: !this.config.blockStrongTrends || data.trend !== (direction === SignalDirection.LONG ? 'BEARISH' : 'BULLISH'),\r\n          strength: MULTIPLIERS.HALF, // Counter-trend = weaker alignment\r\n        },\r\n        tfAlignmentScore:\r\n          data.tfAlignment && direction === SignalDirection.LONG\r\n            ? data.tfAlignment.long.score\r\n            : data.tfAlignment\r\n              ? data.tfAlignment.short.score\r\n              : undefined, // PHASE 6: Multi-timeframe alignment\r\n      };\r\n\r\n      scoreBreakdown = this.weightMatrix.calculateScore(input, direction);\r\n      confidence = scoreBreakdown.confidence;\r\n\r\n      // Log contributions for transparency\r\n      this.logger.info(`üìä ${this.name} Weight Matrix Score`, {\r\n        confidence: confidence.toFixed(1) + '%',\r\n        totalScore: `${scoreBreakdown.totalScore.toFixed(1)}/${scoreBreakdown.maxPossibleScore}`,\r\n        rsi: scoreBreakdown.contributions.rsi?.reason,\r\n        volume: scoreBreakdown.contributions.volume?.reason,\r\n        levelDistance: scoreBreakdown.contributions.levelDistance?.reason,\r\n        ema: scoreBreakdown.contributions.ema?.reason,\r\n        stochastic: scoreBreakdown.contributions.stochastic?.reason,\r\n      });\r\n    } else {\r\n      // Legacy confidence calculation\r\n      confidence = BASE_CONFIDENCE;\r\n\r\n      // RSI extremity boost: more extreme = slightly higher confidence\r\n      if (direction === SignalDirection.LONG) {\r\n        // RSI 15 is more extreme than RSI 19\r\n        const extremity = (this.config.oversoldThreshold - data.rsi) / this.config.oversoldThreshold;\r\n        confidence += extremity * 0.1; // Up to +10% boost\r\n      } else {\r\n        // RSI 90 is more extreme than RSI 86\r\n        const extremity = (data.rsi - this.config.overboughtThreshold) / 15; // Normalize by ~15 point range\r\n        confidence += Math.min(extremity * 0.1, 0.1); // Up to +10% boost\r\n      }\r\n\r\n      // Distance penalty: closer to EMA = better\r\n      const distanceModifier = this.calculateDistanceModifier(distancePercent);\r\n      confidence *= distanceModifier;\r\n\r\n      // ========================================================================\r\n      // STEP 4.5: Pattern Analysis (all patterns via helper)\r\n      // ========================================================================\r\n      if (this.patternAnalyzer) {\r\n        const patternResult = this.patternAnalyzer.analyzePatterns({\r\n          candles: data.candles,\r\n          swingPoints: data.swingPoints,\r\n          direction,\r\n          trend: data.trend,\r\n          strategyName: this.name,\r\n        });\r\n\r\n        confidence += patternResult.confidenceBoost;\r\n        reason += patternResult.reasonAdditions;\r\n      }\r\n\r\n      // Normalize confidence to 0-100 range\r\n      confidence = ConfidenceHelper.normalize(confidence);\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 5: Build signal\r\n    // ========================================================================\r\n    const signal = this.buildSignal(direction, confidence, data, reason);\r\n\r\n    this.logger.info(`‚úÖ ${this.name} SIGNAL GENERATED!`, {\r\n      direction,\r\n      reason,\r\n      rsi: data.rsi.toFixed(1),\r\n      distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      confidence: confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      entry: data.currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      sl: signal.stopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    return {\r\n      valid: true,\r\n      signal,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate distance modifier\r\n   * Closer to EMA = higher confidence\r\n   */\r\n  private calculateDistanceModifier(distancePercent: number): number {\r\n    if (distancePercent < 2.0) {\r\n      // Very close (< 2%)\r\n      return 1.1; // +10%\r\n    } else if (distancePercent > 4.0) {\r\n      // Far (> 4%)\r\n      return 0.9; // -10%\r\n    }\r\n    return 1.0; // Normal\r\n  }\r\n\r\n  /**\r\n   * Build a trading signal\r\n   */\r\n  private buildSignal(\r\n    direction: SignalDirection,\r\n    confidence: number,\r\n    data: StrategyMarketData,\r\n    reason: string,\r\n  ): Signal {\r\n    const price = data.currentPrice;\r\n    const atrPercent = data.atr || 1.0; // ATR in percent (e.g., 1.5%)\r\n\r\n    // Convert ATR from percent to absolute value\r\n    const atrAbsolute = price * (atrPercent / PERCENT_MULTIPLIER);\r\n\r\n    // Stop loss: configurable multiplier (wider for counter-trend)\r\n    let stopLossDistance = atrAbsolute * this.config.stopLossAtrMultiplier;\r\n\r\n    // Enforce minimum SL distance to avoid too tight stops (critical fix for low ATR markets)\r\n    const MIN_SL_DISTANCE_PERCENT = MULTIPLIERS.NEUTRAL; // 1% minimum (prevents 0.2-0.7% stops that get hit immediately)\r\n    const minSlDistance = price * (MIN_SL_DISTANCE_PERCENT / PERCENT_MULTIPLIER);\r\n    stopLossDistance = Math.max(stopLossDistance, minSlDistance);\r\n\r\n    // Apply session-based SL widening if enabled\r\n    stopLossDistance = SessionDetector.applySessionBasedSL(\r\n      stopLossDistance,\r\n      this.config.sessionBasedSL,\r\n      this.logger,\r\n      this.name,\r\n    );\r\n\r\n    const stopLoss =\r\n      direction === SignalDirection.LONG\r\n        ? price - stopLossDistance\r\n        : price + stopLossDistance;\r\n\r\n    // Take profits: from config (tighter targets for quick exits)\r\n    const takeProfits = this.config.takeProfits.map(tp => ({\r\n      level: tp.level,\r\n      percent: tp.percent,\r\n      sizePercent: tp.sizePercent,\r\n      price:\r\n        direction === SignalDirection.LONG\r\n          ? price * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n          : price * (1 - tp.percent / PERCENT_MULTIPLIER),\r\n      hit: false,\r\n    }));\r\n\r\n    // Calculate metrics for journal\r\n    const distanceToEma = Math.abs((price - data.ema.slow) / price) * PERCENT_MULTIPLIER;\r\n    const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n\r\n    return {\r\n      direction,\r\n      type: SignalType.COUNTER_TREND,\r\n      confidence,\r\n      price,\r\n      stopLoss,\r\n      takeProfits,\r\n      reason,\r\n      timestamp: data.timestamp,\r\n      marketData: {\r\n        rsi: data.rsi,\r\n        rsiTrend1: data.rsiTrend1,\r\n        ema20: data.ema.fast,\r\n        ema50: data.ema.slow,\r\n        atr: data.atr || 1.0,\r\n        volumeRatio: volumeAnalysis.volumeRatio,\r\n        swingHighsCount: data.swingPoints.filter(s => s.type === 'HIGH').length,\r\n        swingLowsCount: data.swingPoints.filter(s => s.type === 'LOW').length,\r\n        trend: data.trend,\r\n        distanceToEma,\r\n        stochastic: data.stochastic,\r\n        bollingerBands: data.bollingerBands,\r\n        breakoutPrediction: data.breakoutPrediction,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Return no signal result\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\level-based.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Candle' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SwingPointType' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":17},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":126,"column":61,"nodeType":"Literal","messageId":"noMagic","endLine":126,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":130,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":130,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5140,5155],"text":"config.patterns != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":135,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":135,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5319,5331],"text":"weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":144,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":144,"endColumn":17},{"ruleId":"complexity","severity":1,"message":"Async method 'evaluate' has a complexity of 48. Maximum allowed is 10.","line":144,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":568,"endColumn":4},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":162,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":30},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 2.","line":162,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":54},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":208,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":208,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8210,8224],"text":"(nearestSupport != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":208,"column":27,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":208,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8228,8245],"text":"(nearestResistance != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 127. Maximum allowed is 120.","line":210,"column":1,"nodeType":"Program","messageId":"max","endLine":210,"endColumn":128},{"ruleId":"max-len","severity":1,"message":"This line has a length of 136. Maximum allowed is 120.","line":211,"column":1,"nodeType":"Program","messageId":"max","endLine":211,"endColumn":137},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":224,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":224,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9178,9192],"text":"nearestSupport != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":229,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":229,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9454,9471],"text":"nearestResistance != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":238,"column":23,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":238,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9900,9914],"text":"(nearestSupport != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":239,"column":26,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":239,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10038,10055],"text":"(nearestResistance != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":243,"column":20,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":243,"endColumn":22},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":243,"column":33,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":243,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10260,10266],"text":"(level == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":262,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":262,"endColumn":41,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[11024,11056],"text":"(this.config.blockLongInDowntrend ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[11024,11056],"text":"(this.config.blockLongInDowntrend === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":271,"column":37,"nodeType":"Literal","messageId":"noMagic","endLine":271,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":292,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":292,"endColumn":40,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[12441,12472],"text":"(this.config.rsiFilters?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[12441,12472],"text":"(this.config.rsiFilters?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":359,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":359,"endColumn":40,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[15525,15556],"text":"(this.config.emaFilters?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[15525,15556],"text":"(this.config.emaFilters?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 3.","line":374,"column":36,"nodeType":"Literal","messageId":"noMagic","endLine":374,"endColumn":37},{"ruleId":"eqeqeq","severity":2,"message":"Expected '!==' and instead saw '!='.","line":385,"column":27,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":385,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":387,"column":51,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":387,"endColumn":75,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[17107,17111],"text":"MarketStructure.LOWER_HIGH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":397,"column":52,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":397,"endColumn":76,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[17630,17634],"text":"MarketStructure.HIGHER_LOW"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (619). Maximum allowed is 300.","line":417,"column":1,"nodeType":null,"messageId":"exceed","endLine":875,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":439,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":439,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19259,19276],"text":"this.weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":446,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":446,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19548,19563],"text":"(data.stochastic != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":448,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":448,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19737,19756],"text":"(data.bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":449,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":449,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19829,19837],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19829,19837],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19829,19837],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":454,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":454,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20029,20047],"text":"(data.deltaAnalysis != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":465,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":465,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20662,20678],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":467,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":467,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20775,20791],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":488,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":488,"endColumn":53,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[21836,21863],"text":"(this.config.levelClustering != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":488,"column":54,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":488,"endColumn":56,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[21864,21866],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":514,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":514,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[22935,22955],"text":"this.patternAnalyzer != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":584,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":584,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[25508,25535],"text":"(this.config.levelClustering != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":584,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":584,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[25536,25538],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 132. Maximum allowed is 120.","line":588,"column":1,"nodeType":"Program","messageId":"max","endLine":588,"endColumn":133},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentTime' is defined but never used. Allowed unused args must match /^_/u.","line":625,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":625,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 5.","line":637,"column":85,"nodeType":"Literal","messageId":"noMagic","endLine":637,"endColumn":86},{"ruleId":"complexity","severity":1,"message":"Method 'findNearestLevel' has a complexity of 13. Maximum allowed is 10.","line":654,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":717,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":706,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":706,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[29645,29653],"text":"(nearest == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 55.","line":742,"column":32,"nodeType":"Literal","messageId":"noMagic","endLine":742,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":757,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":757,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[31422,31450],"text":"(this.config.distanceModifier != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":757,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":757,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[31451,31453],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":785,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":785,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32151,32159],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[32151,32159],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[32151,32159],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":785,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":785,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[32160,32162],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":793,"column":45,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":793,"endColumn":82,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[32555,32592],"text":"(this.config.stopLossAtrMultiplierLong != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[32555,32592],"text":"(this.config.stopLossAtrMultiplierLong ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[32555,32592],"text":"(Boolean(this.config.stopLossAtrMultiplierLong))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 121. Maximum allowed is 120.","line":800,"column":1,"nodeType":"Program","messageId":"max","endLine":800,"endColumn":122},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":848,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":848,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[34583,34591],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[34583,34591],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[34583,34591],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":848,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":848,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[34592,34594],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":850,"column":55,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":850,"endColumn":72,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[34716,34722],"text":"SwingPointType.HIGH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":851,"column":54,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":851,"endColumn":70,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[34797,34802],"text":"SwingPointType.LOW"},"desc":"Replace with an enum value comparison."}]}],"suppressedMessages":[],"errorCount":49,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, MULTIPLIERS, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Level-Based Strategy (Priority 2)\r\n *\r\n * Entry conditions:\r\n * 1. Price near support/resistance level (swing points from ZigZag)\r\n * 2. Distance to level < 1.5%\r\n * 3. Level has minimum touches (default: 2+ touches required)\r\n * 4. Level strength based on touches (more touches = stronger level)\r\n * 5. Trend alignment (prefer LONG near support in uptrend, SHORT near resistance in downtrend)\r\n *\r\n * Confidence calculation:\r\n * - Base confidence: 0.70\r\n * - Level strength boost: 0 to +40% (based on touches)\r\n * - Trend alignment boost: +15%\r\n * - Distance penalty: closer = higher confidence\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategyMarketData,\r\n  StrategySignal,\r\n  Signal,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  Candle,\r\n  SwingPoint,\r\n  SwingPointType,\r\n  SessionBasedSLConfig,\r\n  WeightMatrixInput,\r\n  SignalScoreBreakdown,\r\n} from '../types';\r\nimport { ZigZagIndicator } from '../indicators/zigzag.indicator';\r\nimport { ConfidenceHelper } from '../utils/confidence.helper';\r\nimport { VolumeCalculator } from '../analyzers/volume.calculator';\r\nimport { SessionDetector } from '../utils/session-detector';\r\nimport { PatternAnalyzerHelper, PatternAnalyzerConfig } from '../analyzers/pattern-analyzer.helper';\r\nimport { WeightMatrixCalculatorService } from '../services/weight-matrix-calculator.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS (Strategy Metadata Only)\r\n// ============================================================================\r\n\r\nconst STRATEGY_NAME = 'LevelBased';\r\nconst STRATEGY_PRIORITY = 2; // Second priority (after TrendFollowing)\r\n\r\n// All other constants are now configured in LevelBasedConfig\r\n// They are read from config.json and applied during strategy execution\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface LevelBasedConfig {\r\n  enabled: boolean;\r\n  maxDistancePercent: number;\r\n  minTouchesRequired: number;\r\n  minTouchesRequiredShort?: number;\r\n  minTouchesRequiredLong?: number;\r\n  minTouchesForStrong: number;\r\n  requireTrendAlignment: boolean;\r\n  blockLongInDowntrend?: boolean;\r\n  stopLossAtrMultiplier: number;\r\n  stopLossAtrMultiplierLong?: number;\r\n  minConfidenceThreshold?: number; // Minimum confidence to generate signal (0.0-1.0)\r\n  takeProfits: Array<{ level: number; percent: number; sizePercent: number }>;\r\n  zigzagDepth?: number;\r\n  sessionBasedSL?: SessionBasedSLConfig;\r\n  patterns?: PatternAnalyzerConfig;\r\n  rsiFilters?: {\r\n    enabled: boolean;\r\n    longMinThreshold: number;    // Min RSI for LONG (e.g., 45)\r\n    longMaxThreshold: number;    // Max RSI for LONG (e.g., 70)\r\n    shortMinThreshold: number;   // Min RSI for SHORT (e.g., 30)\r\n    shortMaxThreshold: number;   // Max RSI for SHORT (e.g., 55)\r\n  };\r\n  emaFilters?: {\r\n    enabled: boolean;\r\n    downtrend: {\r\n      rsiThreshold: number;      // RSI threshold for downtrend detection (e.g., 55)\r\n      emaDiffThreshold: number;  // EMA difference threshold % (e.g., 0.5)\r\n    };\r\n  };\r\n  distanceModifier?: {\r\n    veryClosePercent: number;    // Distance threshold for very close levels (e.g., 0.5%)\r\n    veryClosePenalty: number;    // Confidence boost for very close (e.g., 1.1)\r\n    farPercent: number;          // Distance threshold for far levels (e.g., 1.2%)\r\n    farPenalty: number;          // Confidence penalty for far (e.g., 0.9)\r\n  };\r\n  levelClustering?: {\r\n    clusterThresholdPercent: number;  // Group levels within this % (e.g., 0.3%)\r\n    minTouchesForStrong: number;      // Min touches for strong level (e.g., 5)\r\n    strengthBoost: number;            // Max strength boost (e.g., 0.4)\r\n    baseConfidence: number;           // Base confidence for signals (e.g., 0.7)\r\n    trendAlignmentBoost: number;      // Bonus for trend alignment (e.g., 0.15)\r\n  };\r\n}\r\n\r\ninterface Level {\r\n  price: number;\r\n  type: 'SUPPORT' | 'RESISTANCE';\r\n  strength: number; // 0-1 based on touches\r\n  touches: number;\r\n  lastTouch: number; // Timestamp\r\n}\r\n\r\n// ============================================================================\r\n// LEVEL-BASED STRATEGY\r\n// ============================================================================\r\n\r\nexport class LevelBasedStrategy implements IStrategy {\r\n  readonly name = STRATEGY_NAME;\r\n  readonly priority = STRATEGY_PRIORITY;\r\n\r\n  private zigzag: ZigZagIndicator;\r\n  private volumeCalculator: VolumeCalculator;\r\n  private patternAnalyzer: PatternAnalyzerHelper | null = null;\r\n  private weightMatrix: WeightMatrixCalculatorService | null = null;\r\n\r\n  constructor(\r\n    private config: LevelBasedConfig,\r\n    private logger: LoggerService,\r\n    weightMatrix?: WeightMatrixCalculatorService,\r\n  ) {\r\n    this.zigzag = new ZigZagIndicator(config.zigzagDepth ?? 2);\r\n    this.volumeCalculator = new VolumeCalculator(logger);\r\n\r\n    // Initialize pattern analyzer if any patterns are configured\r\n    if (config.patterns) {\r\n      this.patternAnalyzer = new PatternAnalyzerHelper(config.patterns, logger, STRATEGY_NAME);\r\n    }\r\n\r\n    // Initialize weight matrix if provided\r\n    if (weightMatrix) {\r\n      this.weightMatrix = weightMatrix;\r\n      this.logger.info(`${STRATEGY_NAME} Strategy: Weight Matrix enabled`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate market data for level-based entry\r\n   */\r\n  async evaluate(data: StrategyMarketData): Promise<StrategySignal> {\r\n    this.logger.info(`üîç ${this.name} Strategy Evaluation`, {\r\n      price: data.currentPrice,\r\n      trend: data.trend,\r\n      candles: data.candles.length,\r\n    });\r\n\r\n    // ========================================================================\r\n    // STEP 1: Extract swing points (levels)\r\n    // ========================================================================\r\n    const { swingHighs, swingLows } = this.zigzag.findSwingPoints(data.candles);\r\n\r\n    this.logger.info(`üìä ${this.name} Swing Points`, {\r\n      highs: swingHighs.length,\r\n      lows: swingLows.length,\r\n      candles: data.candles.length,\r\n    });\r\n\r\n    if (swingHighs.length < 2 && swingLows.length < 2) {\r\n      this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n        blockedBy: ['NOT_ENOUGH_SWING_POINTS'],\r\n        highs: swingHighs.length,\r\n        lows: swingLows.length,\r\n      });\r\n      return this.noSignal('Not enough swing points for level detection');\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 2: Build levels from swing points\r\n    // ========================================================================\r\n    const supportLevels = this.buildLevels(swingLows, 'SUPPORT', data.timestamp);\r\n    const resistanceLevels = this.buildLevels(swingHighs, 'RESISTANCE', data.timestamp);\r\n\r\n    this.logger.info(`üìä ${this.name} Levels Detected`, {\r\n      support: supportLevels.length,\r\n      resistance: resistanceLevels.length,\r\n      supportPrices: supportLevels.map(l => l.price.toFixed(DECIMAL_PLACES.PRICE)),\r\n      resistancePrices: resistanceLevels.map(l => l.price.toFixed(DECIMAL_PLACES.PRICE)),\r\n    });\r\n\r\n    // ========================================================================\r\n    // STEP 3: Find nearest level\r\n    // ========================================================================\r\n    const nearestSupport = this.findNearestLevel(\r\n      data.currentPrice,\r\n      supportLevels,\r\n      this.config.maxDistancePercent,\r\n      'SUPPORT',\r\n    );\r\n    const nearestResistance = this.findNearestLevel(\r\n      data.currentPrice,\r\n      resistanceLevels,\r\n      this.config.maxDistancePercent,\r\n      'RESISTANCE',\r\n    );\r\n\r\n    // ========================================================================\r\n    // STEP 4: Determine entry direction\r\n    // ========================================================================\r\n    let direction: SignalDirection | null = null;\r\n    let level: Level | null = null;\r\n    let reason = '';\r\n\r\n    // Choose the NEAREST level (by distance) - don't prioritize LONG over SHORT!\r\n    if (nearestSupport && nearestResistance) {\r\n      // Both levels exist - choose the closer one\r\n      const supportDistance = Math.abs((data.currentPrice - nearestSupport.price) / nearestSupport.price) * PERCENT_MULTIPLIER;\r\n      const resistanceDistance = Math.abs((data.currentPrice - nearestResistance.price) / nearestResistance.price) * PERCENT_MULTIPLIER;\r\n\r\n      if (supportDistance <= resistanceDistance) {\r\n        // Support is closer ‚Üí LONG\r\n        direction = SignalDirection.LONG;\r\n        level = nearestSupport;\r\n        reason = `Price near support level ${nearestSupport.price.toFixed(DECIMAL_PLACES.PRICE)} (${nearestSupport.touches} touches)`;\r\n      } else {\r\n        // Resistance is closer ‚Üí SHORT\r\n        direction = SignalDirection.SHORT;\r\n        level = nearestResistance;\r\n        reason = `Price near resistance level ${nearestResistance.price.toFixed(DECIMAL_PLACES.PRICE)} (${nearestResistance.touches} touches)`;\r\n      }\r\n    } else if (nearestSupport) {\r\n      // Only support found ‚Üí LONG\r\n      direction = SignalDirection.LONG;\r\n      level = nearestSupport;\r\n      reason = `Price near support level ${nearestSupport.price.toFixed(DECIMAL_PLACES.PRICE)} (${nearestSupport.touches} touches)`;\r\n    } else if (nearestResistance) {\r\n      // Only resistance found ‚Üí SHORT\r\n      direction = SignalDirection.SHORT;\r\n      level = nearestResistance;\r\n      reason = `Price near resistance level ${nearestResistance.price.toFixed(DECIMAL_PLACES.PRICE)} (${nearestResistance.touches} touches)`;\r\n    }\r\n\r\n    this.logger.info(`üìä ${this.name} Nearest Levels Check`, {\r\n      currentPrice: data.currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      nearestSupport: nearestSupport ? `${nearestSupport.price.toFixed(DECIMAL_PLACES.PRICE)} (${nearestSupport.touches}T)` : 'none',\r\n      nearestResistance: nearestResistance ? `${nearestResistance.price.toFixed(DECIMAL_PLACES.PRICE)} (${nearestResistance.touches}T)` : 'none',\r\n      maxDistance: this.config.maxDistancePercent + '%',\r\n    });\r\n\r\n    if ((direction == null) || !level) {\r\n      this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n        blockedBy: ['NO_LEVELS_WITHIN_DISTANCE'],\r\n        maxDistance: this.config.maxDistancePercent + '%',\r\n      });\r\n      return this.noSignal('No levels within distance threshold');\r\n    }\r\n\r\n    this.logger.info(`‚úÖ ${this.name} Level Pattern Found`, {\r\n      direction,\r\n      levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n      levelType: level.type,\r\n      touches: level.touches,\r\n      strength: level.strength.toFixed(DECIMAL_PLACES.PERCENT),\r\n    });\r\n\r\n    // ========================================================================\r\n    // STEP 4.5: LONG Downtrend Filter (if enabled)\r\n    // ========================================================================\r\n    if (this.config.blockLongInDowntrend && direction === SignalDirection.LONG) {\r\n      const isDowntrend = this.isDowntrend(data);\r\n\r\n      this.logger.info(`üìä ${this.name} LONG Downtrend Filter`, {\r\n        blockLongInDowntrend: this.config.blockLongInDowntrend,\r\n        emaFast: data.ema.fast.toFixed(DECIMAL_PLACES.PRICE),\r\n        emaSlow: data.ema.slow.toFixed(DECIMAL_PLACES.PRICE),\r\n        emaFastBelowSlow: data.ema.fast < data.ema.slow,\r\n        rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n        rsiBelowNeutral: data.rsi < 50,\r\n        isDowntrend,\r\n      });\r\n\r\n      if (isDowntrend) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['LONG_IN_DOWNTREND'],\r\n          reason: 'LONG blocked: market in downtrend (EMA20 < EMA50 AND RSI < 50)',\r\n          emaFast: data.ema.fast.toFixed(DECIMAL_PLACES.PRICE),\r\n          emaSlow: data.ema.slow.toFixed(DECIMAL_PLACES.PRICE),\r\n          rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n        return this.noSignal(\r\n          `LONG blocked in downtrend (EMA ${data.ema.fast.toFixed(DECIMAL_PLACES.PRICE)} < ${data.ema.slow.toFixed(DECIMAL_PLACES.PRICE)}, RSI ${data.rsi.toFixed(1)})`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 4.6: RSI Filter\r\n    // ========================================================================\r\n    if (this.config.rsiFilters?.enabled) {\r\n      const rsiConfig = this.config.rsiFilters;\r\n\r\n      // LONG RSI Filter\r\n      if (direction === SignalDirection.LONG) {\r\n        if (data.rsi < rsiConfig.longMinThreshold) {\r\n          this.logger.info(`‚ùå ${this.name} BLOCKED - RSI too low for LONG`, {\r\n            blockedBy: ['LONG_RSI_TOO_LOW'],\r\n            rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n            threshold: rsiConfig.longMinThreshold,\r\n            levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return this.noSignal(\r\n            `LONG blocked: RSI ${data.rsi.toFixed(1)} < ${rsiConfig.longMinThreshold} (insufficient bullish momentum)`,\r\n          );\r\n        }\r\n\r\n        if (data.rsi > rsiConfig.longMaxThreshold) {\r\n          this.logger.info(`‚ùå ${this.name} BLOCKED - RSI too high for LONG`, {\r\n            blockedBy: ['LONG_RSI_TOO_HIGH'],\r\n            rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n            threshold: rsiConfig.longMaxThreshold,\r\n            levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return this.noSignal(\r\n            `LONG blocked: RSI ${data.rsi.toFixed(1)} > ${rsiConfig.longMaxThreshold} (overextended, risk of pullback)`,\r\n          );\r\n        }\r\n      }\r\n\r\n      // SHORT RSI Filter\r\n      if (direction === SignalDirection.SHORT) {\r\n        if (data.rsi < rsiConfig.shortMinThreshold) {\r\n          this.logger.info(`‚ùå ${this.name} BLOCKED - RSI too low for SHORT`, {\r\n            blockedBy: ['SHORT_RSI_TOO_LOW'],\r\n            rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n            threshold: rsiConfig.shortMinThreshold,\r\n            levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return this.noSignal(\r\n            `SHORT blocked: RSI ${data.rsi.toFixed(1)} < ${rsiConfig.shortMinThreshold} (trend might be reversing)`,\r\n          );\r\n        }\r\n\r\n        if (data.rsi > rsiConfig.shortMaxThreshold) {\r\n          this.logger.info(`‚ùå ${this.name} BLOCKED - RSI too high for SHORT`, {\r\n            blockedBy: ['SHORT_RSI_TOO_HIGH'],\r\n            rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n            threshold: rsiConfig.shortMaxThreshold,\r\n            levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return this.noSignal(\r\n            `SHORT blocked: RSI ${data.rsi.toFixed(1)} > ${rsiConfig.shortMaxThreshold} (insufficient bearish momentum)`,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // NOTE: LONG Entry Confirmation\r\n    // ========================================================================\r\n    // LONG entries will be sent to LongEntryConfirmationManager in PositionManager\r\n    // to wait for next 1m candle close confirmation (avoids falling knife entries)\r\n\r\n    // ========================================================================\r\n    // STEP 4.7: EMA/Market Structure Filter\r\n    // ========================================================================\r\n    if (this.config.emaFilters?.enabled) {\r\n      const emaConfig = this.config.emaFilters;\r\n\r\n      // Check for strong downtrend conditions\r\n      const emaDowntrend = data.ema.fast < data.ema.slow;\r\n      const rsiWeak = data.rsi < emaConfig.downtrend.rsiThreshold;\r\n      const emaDiff = ((data.ema.slow - data.ema.fast) / data.ema.fast) * PERCENT_MULTIPLIER;\r\n      const strongDowntrend = emaDiff > emaConfig.downtrend.emaDiffThreshold;\r\n\r\n      // Block LONG entries in strong downtrend\r\n      if (direction === SignalDirection.LONG && emaDowntrend && rsiWeak && strongDowntrend) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED - Strong downtrend detected for LONG`, {\r\n          blockedBy: ['STRONG_DOWNTREND'],\r\n          emaFast: data.ema.fast.toFixed(DECIMAL_PLACES.PRICE),\r\n          emaSlow: data.ema.slow.toFixed(DECIMAL_PLACES.PRICE),\r\n          emaDiff: emaDiff.toFixed(3),\r\n          rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n          levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n        });\r\n        return this.noSignal(\r\n          `LONG blocked: Strong downtrend (EMA diff ${emaDiff.toFixed(DECIMAL_PLACES.PERCENT)}% > ${emaConfig.downtrend.emaDiffThreshold}%, RSI ${data.rsi.toFixed(1)} < ${emaConfig.downtrend.rsiThreshold})`,\r\n        );\r\n      }\r\n\r\n      // Also check market structure if available\r\n      const marketStructure = data.context?.marketStructure;\r\n      if (marketStructure != null) {\r\n        // Block LONG when market structure is bearish (LH = Lower High)\r\n        if (direction === SignalDirection.LONG && marketStructure === 'LH') {\r\n          this.logger.info(`‚ùå ${this.name} BLOCKED - Bearish market structure for LONG`, {\r\n            blockedBy: ['BEARISH_MARKET_STRUCTURE'],\r\n            marketStructure,\r\n            levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return this.noSignal('LONG blocked: Bearish market structure (Lower High pattern)');\r\n        }\r\n\r\n        // Block SHORT when market structure is bullish (HL = Higher Low)\r\n        if (direction === SignalDirection.SHORT && marketStructure === 'HL') {\r\n          this.logger.info(`‚ùå ${this.name} BLOCKED - Bullish market structure for SHORT`, {\r\n            blockedBy: ['BULLISH_MARKET_STRUCTURE'],\r\n            marketStructure,\r\n            levelPrice: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n          });\r\n          return this.noSignal('SHORT blocked: Bullish market structure (Higher Low pattern)');\r\n        }\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 5: Trend alignment check\r\n    // ========================================================================\r\n    if (this.config.requireTrendAlignment) {\r\n      const isAligned = this.isTrendAligned(direction, data.trend);\r\n\r\n      this.logger.info(`üìä ${this.name} Trend Alignment Check`, {\r\n        signalDirection: direction,\r\n        contextTrend: data.trend,\r\n        isAligned,\r\n      });\r\n\r\n      if (!isAligned) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['TREND_NOT_ALIGNED'],\r\n          direction,\r\n          trend: data.trend,\r\n        });\r\n        return this.noSignal(`Trend ${data.trend} not aligned with ${direction} signal`);\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 6: Calculate confidence\r\n    // ========================================================================\r\n    const distancePercent = Math.abs((data.currentPrice - level.price) / level.price) * PERCENT_MULTIPLIER;\r\n\r\n    let confidence: number;\r\n    let scoreBreakdown: SignalScoreBreakdown | null = null;\r\n\r\n    // Use Weight Matrix if enabled\r\n    if (this.weightMatrix) {\r\n      // Build WeightMatrixInput\r\n      const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n      const currentCandle = data.candles[data.candles.length - 1];\r\n\r\n      const input: WeightMatrixInput = {\r\n        rsi: data.rsi,\r\n        stochastic: data.stochastic ? { k: data.stochastic.k, d: data.stochastic.d } : undefined,\r\n        ema: { fast: data.ema.fast, slow: data.ema.slow, price: data.currentPrice },\r\n        bollingerBands: data.bollingerBands ? { position: data.bollingerBands.percentB } : undefined,\r\n        atr: data.atr ? { current: data.atr, average: data.atr } : undefined,\r\n        volume: {\r\n          current: currentCandle.volume,\r\n          average: volumeAnalysis.avgVolume,\r\n        },\r\n        delta: data.deltaAnalysis\r\n          ? { buyPressure: data.deltaAnalysis.buyVolume, sellPressure: data.deltaAnalysis.sellVolume }\r\n          : undefined, // PHASE 4: Delta analysis\r\n        levelStrength: { touches: level.touches, strength: level.strength },\r\n        levelDistance: { percent: distancePercent },\r\n        swingPoints: { quality: level.strength }, // Use level strength as swing quality\r\n        seniorTFAlignment: {\r\n          aligned: this.isTrendAligned(direction, data.trend),\r\n          strength: this.isTrendAligned(direction, data.trend) ? MULTIPLIERS.NEUTRAL : 0.0,\r\n        },\r\n        tfAlignmentScore:\r\n          data.tfAlignment && direction === SignalDirection.LONG\r\n            ? data.tfAlignment.long.score\r\n            : data.tfAlignment\r\n              ? data.tfAlignment.short.score\r\n              : undefined, // PHASE 6: Multi-timeframe alignment\r\n      };\r\n\r\n      scoreBreakdown = this.weightMatrix.calculateScore(input, direction);\r\n      confidence = scoreBreakdown.confidence;\r\n\r\n      // Log contributions for transparency\r\n      this.logger.info(`üìä ${this.name} Weight Matrix Score`, {\r\n        confidence: (confidence * PERCENT_MULTIPLIER).toFixed(1) + '%',\r\n        totalScore: `${scoreBreakdown.totalScore.toFixed(1)}/${scoreBreakdown.maxPossibleScore}`,\r\n        rsi: scoreBreakdown.contributions.rsi?.reason,\r\n        volume: scoreBreakdown.contributions.volume?.reason,\r\n        levelStrength: scoreBreakdown.contributions.levelStrength?.reason,\r\n        levelDistance: scoreBreakdown.contributions.levelDistance?.reason,\r\n        ema: scoreBreakdown.contributions.ema?.reason,\r\n        stochastic: scoreBreakdown.contributions.stochastic?.reason,\r\n      });\r\n    } else {\r\n      // Legacy confidence calculation (using config parameters)\r\n      const clustering = this.config.levelClustering || {\r\n        clusterThresholdPercent: PERCENTAGE_THRESHOLDS.MODERATE,\r\n        minTouchesForStrong: 5,\r\n        strengthBoost: PERCENTAGE_THRESHOLDS.MODERATE_HIGH,\r\n        baseConfidence: CONFIDENCE_THRESHOLDS.MODERATE,\r\n        trendAlignmentBoost: PERCENTAGE_THRESHOLDS.VERY_LOW,\r\n      };\r\n\r\n      confidence = clustering.baseConfidence;\r\n\r\n      // Level strength boost (0 to +strengthBoost)\r\n      const strengthBoost = level.strength * clustering.strengthBoost;\r\n      confidence += strengthBoost;\r\n\r\n      // Trend alignment boost\r\n      if (this.isTrendAligned(direction, data.trend)) {\r\n        confidence += clustering.trendAlignmentBoost;\r\n      }\r\n\r\n      // Distance modifier (closer = better)\r\n      const distanceModifier = this.calculateDistanceModifier(distancePercent);\r\n      confidence *= distanceModifier;\r\n\r\n      // ========================================================================\r\n      // STEP 6.5: Pattern Analysis (all patterns via helper)\r\n      // ========================================================================\r\n      if (this.patternAnalyzer) {\r\n        const patternResult = this.patternAnalyzer.analyzePatterns({\r\n          candles: data.candles,\r\n          swingPoints: data.swingPoints,\r\n          direction,\r\n          trend: data.trend,\r\n          strategyName: this.name,\r\n        });\r\n\r\n        confidence += patternResult.confidenceBoost;\r\n        reason += patternResult.reasonAdditions;\r\n      }\r\n\r\n      // Normalize confidence to 0-100 range\r\n      confidence = ConfidenceHelper.normalize(confidence);\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 6.9: Confidence threshold check\r\n    // ========================================================================\r\n    const minConfidence = this.config.minConfidenceThreshold ?? CONFIDENCE_THRESHOLDS.LOW;\r\n    if (confidence < minConfidence) {\r\n      this.logger.debug(`${this.name} Signal blocked by confidence threshold`, {\r\n        confidence: (confidence * PERCENT_MULTIPLIER).toFixed(1) + '%',\r\n        threshold: (minConfidence * PERCENT_MULTIPLIER).toFixed(1) + '%',\r\n        reason,\r\n      });\r\n      return this.noSignal(`Confidence ${(confidence * PERCENT_MULTIPLIER).toFixed(1)}% below minimum ${(minConfidence * PERCENT_MULTIPLIER).toFixed(1)}%`);\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 7: Build signal\r\n    // ========================================================================\r\n    const signal = this.buildSignal(direction, confidence, data, reason, level);\r\n\r\n    this.logger.info(`‚úÖ ${this.name} SIGNAL GENERATED!`, {\r\n      direction,\r\n      reason,\r\n      level: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n      levelStrength: level.strength.toFixed(DECIMAL_PLACES.PERCENT),\r\n      touches: level.touches,\r\n      distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      confidence: confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      entry: data.currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      sl: signal.stopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    return {\r\n      valid: true,\r\n      signal,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build levels from swing points\r\n   * Groups swing points that are close together (within 0.3%)\r\n   */\r\n  private buildLevels(\r\n    swingPoints: SwingPoint[],\r\n    type: 'SUPPORT' | 'RESISTANCE',\r\n    currentTime: number,\r\n  ): Level[] {\r\n    if (swingPoints.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const levels: Level[] = [];\r\n    const clustering = this.config.levelClustering || {\r\n      clusterThresholdPercent: PERCENTAGE_THRESHOLDS.MODERATE,\r\n      minTouchesForStrong: 5,\r\n    };\r\n    const clusterThreshold = clustering.clusterThresholdPercent / PERCENT_MULTIPLIER; // Convert percent to decimal (0.003 for 0.3%)\r\n\r\n    // Sort by price\r\n    const sorted = [...swingPoints].sort((a, b) => a.price - b.price);\r\n\r\n    let currentCluster: SwingPoint[] = [sorted[0]];\r\n\r\n    for (let i = 1; i < sorted.length; i++) {\r\n      const point = sorted[i];\r\n      const prevPoint = currentCluster[currentCluster.length - 1];\r\n      const priceDiff = Math.abs(point.price - prevPoint.price) / prevPoint.price;\r\n\r\n      if (priceDiff <= clusterThreshold) {\r\n        // Add to current cluster\r\n        currentCluster.push(point);\r\n      } else {\r\n        // Create level from current cluster\r\n        levels.push(this.createLevelFromCluster(currentCluster, type, currentTime));\r\n        // Start new cluster\r\n        currentCluster = [point];\r\n      }\r\n    }\r\n\r\n    // Don't forget last cluster\r\n    if (currentCluster.length > 0) {\r\n      levels.push(this.createLevelFromCluster(currentCluster, type, currentTime));\r\n    }\r\n\r\n    return levels;\r\n  }\r\n\r\n  /**\r\n   * Create a level from a cluster of swing points\r\n   */\r\n  private createLevelFromCluster(\r\n    cluster: SwingPoint[],\r\n    type: 'SUPPORT' | 'RESISTANCE',\r\n    currentTime: number,\r\n  ): Level {\r\n    // Average price of cluster\r\n    const avgPrice = cluster.reduce((sum, p) => sum + p.price, 0) / cluster.length;\r\n\r\n    // Touches = number of points in cluster\r\n    const touches = cluster.length;\r\n\r\n    // Last touch timestamp\r\n    const lastTouch = Math.max(...cluster.map((p) => p.timestamp));\r\n\r\n    // Strength: 0-1 based on touches (from config minTouchesForStrong = MULTIPLIERS.NEUTRAL)\r\n    const minTouchesForStrong = this.config.levelClustering?.minTouchesForStrong ?? 5;\r\n    const strength = Math.min(touches / minTouchesForStrong, 1.0);\r\n\r\n    return {\r\n      price: avgPrice,\r\n      type,\r\n      strength,\r\n      touches,\r\n      lastTouch,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find nearest level within distance threshold\r\n   * For SUPPORT: only accept if price >= level (not below)\r\n   * For RESISTANCE: only accept if price <= level (not above)\r\n   */\r\n  private findNearestLevel(\r\n    price: number,\r\n    levels: Level[],\r\n    maxDistancePercent: number,\r\n    levelType: 'SUPPORT' | 'RESISTANCE',\r\n  ): Level | null {\r\n    if (levels.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    let nearest: Level | null = null;\r\n    let minDistance = Infinity;\r\n\r\n    // Determine minTouches based on level type (SUPPORT=LONG, RESISTANCE=SHORT)\r\n    const minTouches =\r\n      levelType === 'SUPPORT'\r\n        ? this.config.minTouchesRequiredLong ?? this.config.minTouchesRequired\r\n        : this.config.minTouchesRequiredShort ?? this.config.minTouchesRequired;\r\n\r\n    const debugCandidates = [];\r\n\r\n    for (const level of levels) {\r\n      const distancePercent = Math.abs((price - level.price) / level.price) * PERCENT_MULTIPLIER;\r\n      const isValidDirection =\r\n        levelType === 'SUPPORT' ? price >= level.price : price <= level.price;\r\n\r\n      // Debug info\r\n      debugCandidates.push({\r\n        price: level.price.toFixed(DECIMAL_PLACES.PRICE),\r\n        touches: level.touches,\r\n        distance: distancePercent.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        validDirection: isValidDirection,\r\n        enoughTouches: level.touches >= minTouches,\r\n        withinDistance: distancePercent <= maxDistancePercent,\r\n      });\r\n\r\n      // Filter out weak levels (< minTouches for direction)\r\n      if (level.touches < minTouches) {\r\n        continue; // Skip this level - not enough touches\r\n      }\r\n\r\n      // Direction-aware filtering:\r\n      // - SUPPORT: price should be >= level (bounce from support)\r\n      // - RESISTANCE: price should be <= level (bounce from resistance)\r\n\r\n      if (isValidDirection && distancePercent <= maxDistancePercent && distancePercent < minDistance) {\r\n        nearest = level;\r\n        minDistance = distancePercent;\r\n      }\r\n    }\r\n\r\n    // Log debug info if no nearest found\r\n    if (!nearest && debugCandidates.length > 0) {\r\n      this.logger.debug(`üîç ${this.name} findNearestLevel DEBUG`, {\r\n        levelType,\r\n        currentPrice: price.toFixed(DECIMAL_PLACES.PRICE),\r\n        minTouches,\r\n        maxDistance: maxDistancePercent + '%',\r\n        candidates: debugCandidates,\r\n      });\r\n    }\r\n\r\n    return nearest;\r\n  }\r\n\r\n  /**\r\n   * Check if trend aligns with signal direction\r\n   */\r\n  private isTrendAligned(direction: SignalDirection, trend: string): boolean {\r\n    if (direction === SignalDirection.LONG && trend === 'BULLISH') {\r\n      return true;\r\n    }\r\n    if (direction === SignalDirection.SHORT && trend === 'BEARISH') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if market is in downtrend\r\n   * Criteria: EMA20 < EMA50 AND (RSI < 55 OR strong EMA divergence)\r\n   *\r\n   * Strengthened in Session 36:\r\n   * - RSI threshold increased from 50 to 55\r\n   * - Added EMA divergence check (>0.5% = strong downtrend)\r\n   */\r\n  private isDowntrend(data: StrategyMarketData): boolean {\r\n    const emaDowntrend = data.ema.fast < data.ema.slow; // EMA20 < EMA50\r\n    const rsiWeak = data.rsi < 55; // Increased from 50 to 55 (more conservative)\r\n\r\n    // Calculate EMA divergence percentage\r\n    const emaDiff = ((data.ema.slow - data.ema.fast) / data.ema.fast) * PERCENT_MULTIPLIER;\r\n    const strongDowntrend = emaDiff > MULTIPLIERS.HALF; // EMA difference > MULTIPLIERS.HALF% = strong downtrend\r\n\r\n    // Block LONG if: downtrend AND (weak RSI OR strong EMA divergence)\r\n    return emaDowntrend && (rsiWeak || strongDowntrend);\r\n  }\r\n\r\n  /**\r\n   * Calculate distance modifier\r\n   * Closer to level = higher confidence\r\n   */\r\n  private calculateDistanceModifier(distancePercent: number): number {\r\n    const distConfig = this.config.distanceModifier || {\r\n      veryClosePercent: MULTIPLIERS.HALF,\r\n      veryClosePenalty: 1.1,\r\n      farPercent: 1.2,\r\n      farPenalty: MULTIPLIERS.ZERO_NINE,\r\n    };\r\n\r\n    if (distancePercent < distConfig.veryClosePercent) {\r\n      // Very close\r\n      return distConfig.veryClosePenalty;\r\n    } else if (distancePercent > distConfig.farPercent) {\r\n      // Far\r\n      return distConfig.farPenalty;\r\n    }\r\n    return 1.0; // Normal\r\n  }\r\n\r\n  /**\r\n   * Build a trading signal\r\n   */\r\n  private buildSignal(\r\n    direction: SignalDirection,\r\n    confidence: number,\r\n    data: StrategyMarketData,\r\n    reason: string,\r\n    level: Level,\r\n  ): Signal {\r\n    const price = data.currentPrice;\r\n    const atrPercent = data.atr || 1.0; // ATR in percent (e.g., 1.5%)\r\n\r\n    // Convert ATR from percent to absolute value\r\n    const atrAbsolute = price * (atrPercent / PERCENT_MULTIPLIER);\r\n\r\n    // Stop loss: below/above the level (using configurable ATR multiplier)\r\n    // For LONG, use stopLossAtrMultiplierLong if configured, otherwise use default\r\n    const slMultiplier =\r\n      direction === SignalDirection.LONG && this.config.stopLossAtrMultiplierLong\r\n        ? this.config.stopLossAtrMultiplierLong\r\n        : this.config.stopLossAtrMultiplier;\r\n\r\n    let stopLossDistance = atrAbsolute * slMultiplier;\r\n\r\n    // Enforce minimum SL distance to avoid too tight stops (critical fix for low ATR markets)\r\n    const MIN_SL_DISTANCE_PERCENT = MULTIPLIERS.NEUTRAL; // 1% minimum (prevents 0.2-0.7% stops that get hit immediately)\r\n    const minSlDistance = price * (MIN_SL_DISTANCE_PERCENT / PERCENT_MULTIPLIER);\r\n    stopLossDistance = Math.max(stopLossDistance, minSlDistance);\r\n\r\n    // Apply session-based SL widening if enabled\r\n    stopLossDistance = SessionDetector.applySessionBasedSL(\r\n      stopLossDistance,\r\n      this.config.sessionBasedSL,\r\n      this.logger,\r\n      this.name,\r\n    );\r\n\r\n    const stopLoss =\r\n      direction === SignalDirection.LONG\r\n        ? level.price - stopLossDistance // Below support (correct!)\r\n        : level.price + stopLossDistance; // Above resistance (correct!)\r\n\r\n    // Take profits: from config\r\n    const takeProfits = this.config.takeProfits.map(tp => ({\r\n      level: tp.level,\r\n      percent: tp.percent,\r\n      sizePercent: tp.sizePercent,\r\n      price:\r\n        direction === SignalDirection.LONG\r\n          ? price * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n          : price * (1 - tp.percent / PERCENT_MULTIPLIER),\r\n      hit: false,\r\n    }));\r\n\r\n    // Calculate metrics for journal\r\n    const distanceToLevel = Math.abs((price - level.price) / price) * PERCENT_MULTIPLIER;\r\n    const distanceToEma = Math.abs((price - data.ema.slow) / price) * PERCENT_MULTIPLIER;\r\n    const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n\r\n    return {\r\n      direction,\r\n      type: SignalType.LEVEL_BASED,\r\n      confidence,\r\n      price,\r\n      stopLoss,\r\n      takeProfits,\r\n      reason,\r\n      timestamp: data.timestamp,\r\n      marketData: {\r\n        rsi: data.rsi,\r\n        rsiTrend1: data.rsiTrend1,\r\n        ema20: data.ema.fast,\r\n        ema50: data.ema.slow,\r\n        atr: data.atr || 1.0,\r\n        volumeRatio: volumeAnalysis.volumeRatio,\r\n        swingHighsCount: data.swingPoints.filter(s => s.type === 'HIGH').length,\r\n        swingLowsCount: data.swingPoints.filter(s => s.type === 'LOW').length,\r\n        trend: data.trend,\r\n        nearestLevel: level.price,\r\n        distanceToLevel,\r\n        distanceToEma,\r\n        stochastic: data.stochastic,\r\n        bollingerBands: data.bollingerBands,\r\n        breakoutPrediction: data.breakoutPrediction,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Return no signal result\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\price-action.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MULTIPLIERS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":37},{"ruleId":"complexity","severity":1,"message":"Method 'evaluateLong' has a complexity of 23. Maximum allowed is 10.","line":157,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":252,"endColumn":4},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentTrend' is defined but never used. Allowed unused args must match /^_/u.","line":161,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":161,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":168,"column":22,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":168,"endColumn":53,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[5558,5589],"text":"((liquidity.recentSweep?.detected) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[5558,5589],"text":"((liquidity.recentSweep?.detected) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":170,"column":22,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":170,"endColumn":64,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[5708,5714],"text":"SweepDirection.DOWN"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":190,"column":47,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":190,"endColumn":55,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[6503,6511],"text":"(hasSweep ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[6502,6511],"text":"(hasSweep === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":203,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":203,"endColumn":20,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7092,7100],"text":"(hasSweep ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[7091,7100],"text":"(hasSweep === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":217,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":217,"endColumn":17,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7630,7638],"text":"hasSweep ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7630,7638],"text":"hasSweep === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":228,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":228,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8067,8081],"text":"(structureEvent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'evaluateShort' has a complexity of 23. Maximum allowed is 10.","line":258,"column":24,"nodeType":"FunctionExpression","messageId":"complex","endLine":353,"endColumn":4},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentTrend' is defined but never used. Allowed unused args must match /^_/u.","line":262,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":262,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":269,"column":22,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":269,"endColumn":53,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[9499,9530],"text":"((liquidity.recentSweep?.detected) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[9499,9530],"text":"((liquidity.recentSweep?.detected) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":271,"column":22,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":271,"endColumn":62,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[9649,9653],"text":"SweepDirection.UP"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":292,"column":47,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":292,"endColumn":55,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[10534,10542],"text":"(hasSweep ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[10533,10542],"text":"(hasSweep === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":304,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":304,"endColumn":20,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[11033,11041],"text":"(hasSweep ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[11032,11041],"text":"(hasSweep === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":318,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":318,"endColumn":17,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[11573,11581],"text":"hasSweep ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[11573,11581],"text":"hasSweep === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":329,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":329,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12008,12022],"text":"(structureEvent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS } from '../constants';\r\n/**\r\n * Price Action Strategy\r\n *\r\n * Advanced strategy based on Smart Money Concepts (SMC):\r\n * - CHoCH/BoS (Change of Character / Break of Structure)\r\n * - Liquidity Sweeps (false breakouts)\r\n * - Divergences (RSI vs Price)\r\n *\r\n * Priority: MULTIPLIERS.HALF (higher than Trend-Following)\r\n * Best for: Reversal entries after liquidity grabs\r\n */\r\n\r\nimport {\r\n  SignalDirection,\r\n  SwingPoint,\r\n  Candle,\r\n  LoggerService,\r\n  StructureEventType,\r\n  StructureDirection,\r\n  StructureEvent,\r\n} from '../types';\r\nimport { IStrategy, StrategyEvaluation } from './strategy.interface';\r\nimport { MarketStructureAnalyzer } from '../analyzers/market-structure.analyzer';\r\nimport { LiquidityDetector, LiquidityAnalysis } from '../analyzers/liquidity.detector';\r\nimport { DivergenceDetector, Divergence, DivergenceType } from '../analyzers/divergence.detector';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface PriceActionConfig {\r\n  enabled: boolean;\r\n  minConfidence: number;          // Minimum confidence to enter (0.75-0.85)\r\n  requireLiquiditySweep: boolean; // Require liquidity sweep for entry\r\n  requireDivergence: boolean;     // Require divergence for entry\r\n  requireCHoCH: boolean;          // Require CHoCH for entry\r\n}\r\n\r\nexport interface PriceActionData {\r\n  swingPoints: SwingPoint[];\r\n  candles: Candle[];\r\n  currentPrice: number;\r\n  rsi: number;\r\n  rsiHistory: Map<number, number>; // timestamp -> RSI value\r\n}\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst BASE_CONFIDENCE = 0.75;           // High base confidence for PA signals\r\nconst LIQUIDITY_SWEEP_BOOST = 0.15;     // +15% for fakeout\r\nconst DIVERGENCE_BOOST = 0.10;          // +10% for divergence\r\nconst CHOCH_BOOST = 0.10;               // +10% for CHoCH in our direction\r\nconst BOS_BOOST = 0.05;                 // +5% for BoS\r\nconst CONFLICT_PENALTY = 0.25;          // -25% penalty for opposite divergence\r\n\r\n// ============================================================================\r\n// PRICE ACTION STRATEGY\r\n// ============================================================================\r\n\r\nexport class PriceActionStrategy implements IStrategy<PriceActionData> {\r\n  constructor(\r\n    private config: PriceActionConfig,\r\n    private structureAnalyzer: MarketStructureAnalyzer,\r\n    private liquidityDetector: LiquidityDetector,\r\n    private divergenceDetector: DivergenceDetector,\r\n    private logger: LoggerService,\r\n  ) {}\r\n\r\n  /**\r\n   * Get strategy name\r\n   */\r\n  getName(): string {\r\n    return 'PriceAction';\r\n  }\r\n\r\n  /**\r\n   * Get strategy description\r\n   */\r\n  getDescription(): string {\r\n    return 'Advanced price action strategy based on Smart Money Concepts (CHoCH/BoS, Liquidity Sweeps, Divergences)';\r\n  }\r\n\r\n  /**\r\n   * Evaluate price action signals with fully typed data\r\n   *\r\n   * @param data - Properly typed PriceActionData (no casting needed)\r\n   * @returns Strategy evaluation result\r\n   */\r\n  evaluate(data: PriceActionData): StrategyEvaluation {\r\n    if (!this.config.enabled) {\r\n      return this.noSignal('Strategy disabled');\r\n    }\r\n\r\n    // Step 1: Analyze liquidity (zones + sweeps)\r\n    const liquidityAnalysis = this.liquidityDetector.analyze(\r\n      data.swingPoints,\r\n      data.candles,\r\n    );\r\n\r\n    // Step 2: Detect divergence\r\n    const divergence = this.divergenceDetector.detect(\r\n      data.swingPoints,\r\n      data.rsiHistory,\r\n    );\r\n\r\n    // Step 3: Get structure events (CHoCH/BoS)\r\n    const structureEvent = this.structureAnalyzer.getLastStructureEvent();\r\n    const currentTrend = this.structureAnalyzer.getCurrentTrend();\r\n\r\n    this.logger.debug('Price Action Analysis', {\r\n      liquiditySweep: liquidityAnalysis.recentSweep?.detected ?? false,\r\n      isFakeout: liquidityAnalysis.recentSweep?.isFakeout ?? false,\r\n      divergenceType: divergence.type,\r\n      structureEvent: structureEvent?.type ?? 'NONE',\r\n      currentTrend,\r\n    });\r\n\r\n    // Step 4: Evaluate LONG signals\r\n    const longSignal = this.evaluateLong(\r\n      liquidityAnalysis,\r\n      divergence,\r\n      structureEvent,\r\n      currentTrend,\r\n    );\r\n\r\n    if (longSignal.shouldEnter) {\r\n      return longSignal;\r\n    }\r\n\r\n    // Step 5: Evaluate SHORT signals\r\n    const shortSignal = this.evaluateShort(\r\n      liquidityAnalysis,\r\n      divergence,\r\n      structureEvent,\r\n      currentTrend,\r\n    );\r\n\r\n    if (shortSignal.shouldEnter) {\r\n      return shortSignal;\r\n    }\r\n\r\n    // Combine blocked reasons from both directions\r\n    const allBlockedReasons = [\r\n      ...new Set([...longSignal.blockedBy, ...shortSignal.blockedBy]),\r\n    ];\r\n\r\n    return this.noSignal('No price action setup found', allBlockedReasons);\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE: LONG EVALUATION\r\n  // ============================================================================\r\n\r\n  private evaluateLong(\r\n    liquidity: LiquidityAnalysis,\r\n    divergence: Divergence,\r\n    structureEvent: StructureEvent | null,\r\n    currentTrend: string,\r\n  ): StrategyEvaluation {\r\n    const reasons: string[] = [];\r\n    const blockedBy: string[] = [];\r\n    let confidence = BASE_CONFIDENCE;\r\n\r\n    // Scenario 1: Liquidity Sweep + Bullish Divergence\r\n    const hasSweep = liquidity.recentSweep?.detected &&\r\n                     liquidity.recentSweep.isFakeout &&\r\n                     liquidity.recentSweep.direction === 'DOWN';\r\n\r\n    const hasBullishDiv = divergence.type === DivergenceType.BULLISH;\r\n    const hasBearishStructure = structureEvent?.direction === StructureDirection.BEARISH;\r\n\r\n    // üõ°Ô∏è SAFETY CHECK: Divergence-Structure conflict\r\n    // Bullish divergence (expecting reversal UP) vs Bearish structure (trend DOWN)\r\n    if (hasBullishDiv && hasBearishStructure) {\r\n      this.logger.warn('Conflicting signals detected', {\r\n        direction: 'LONG',\r\n        conflict: 'Bullish divergence vs Bearish structure',\r\n        confidencePenalty: -CONFLICT_PENALTY,\r\n      });\r\n\r\n      // Apply penalty for conflicting signals\r\n      confidence -= CONFLICT_PENALTY;\r\n      reasons.push('‚ö†Ô∏è Structure conflict');\r\n    }\r\n\r\n    // Check required conditions\r\n    if (this.config.requireLiquiditySweep && !hasSweep) {\r\n      blockedBy.push('NO_LIQUIDITY_SWEEP');\r\n      return this.noSignal('No liquidity sweep for LONG', blockedBy);\r\n    }\r\n\r\n    if (this.config.requireDivergence && !hasBullishDiv) {\r\n      blockedBy.push('NO_DIVERGENCE');\r\n      return this.noSignal('No bullish divergence', blockedBy);\r\n    }\r\n\r\n    // If no requirements set, need AT LEAST ONE signal present\r\n    const hasBullishStructure = structureEvent?.direction === StructureDirection.BULLISH;\r\n    if (!this.config.requireLiquiditySweep && !this.config.requireDivergence && !this.config.requireCHoCH) {\r\n      if (!hasSweep && !hasBullishDiv && !hasBullishStructure) {\r\n        blockedBy.push('NO_SIGNALS');\r\n        return this.noSignal('No price action signals detected', blockedBy);\r\n      }\r\n    }\r\n\r\n    // üõ°Ô∏è FINAL SAFETY: Don't enter LONG with bearish structure (hard block)\r\n    if (hasBearishStructure) {\r\n      this.logger.warn('Bearish structure blocks LONG entry');\r\n      blockedBy.push('BEARISH_STRUCTURE');\r\n      return this.noSignal('Bearish structure detected', blockedBy);\r\n    }\r\n\r\n    // Boost confidence based on signals\r\n    if (hasSweep) {\r\n      confidence += LIQUIDITY_SWEEP_BOOST * (liquidity.recentSweep!.strength);\r\n      reasons.push('Liquidity sweep (fakeout down)');\r\n    }\r\n\r\n    if (hasBullishDiv) {\r\n      confidence += DIVERGENCE_BOOST * divergence.strength;\r\n      reasons.push(`Bullish divergence (strength: ${divergence.strength.toFixed(DECIMAL_PLACES.PERCENT)})`);\r\n    }\r\n\r\n    // CHoCH/BoS boost (bearish structure already blocked above)\r\n    if (structureEvent && structureEvent.direction === StructureDirection.BULLISH) {\r\n      if (structureEvent.type === StructureEventType.CHoCH) {\r\n        confidence += CHOCH_BOOST;\r\n        reasons.push('Bullish CHoCH');\r\n      } else if (structureEvent.type === StructureEventType.BoS) {\r\n        confidence += BOS_BOOST;\r\n        reasons.push('Bullish BoS');\r\n      }\r\n    }\r\n\r\n    // Check minimum confidence\r\n    if (confidence < this.config.minConfidence) {\r\n      blockedBy.push('LOW_CONFIDENCE');\r\n      return this.noSignal(`Confidence too low: ${confidence.toFixed(DECIMAL_PLACES.PERCENT)}`, blockedBy);\r\n    }\r\n\r\n    // Entry signal!\r\n    return {\r\n      shouldEnter: true,\r\n      direction: SignalDirection.LONG,\r\n      confidence: Math.min(confidence, 1.0), // Cap at 1.0\r\n      reason: reasons.join(' + '),\r\n      blockedBy: [],\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PRIVATE: SHORT EVALUATION\r\n  // ============================================================================\r\n\r\n  private evaluateShort(\r\n    liquidity: LiquidityAnalysis,\r\n    divergence: Divergence,\r\n    structureEvent: StructureEvent | null,\r\n    currentTrend: string,\r\n  ): StrategyEvaluation {\r\n    const reasons: string[] = [];\r\n    const blockedBy: string[] = [];\r\n    let confidence = BASE_CONFIDENCE;\r\n\r\n    // Scenario 2: Liquidity Sweep + Bearish Divergence\r\n    const hasSweep = liquidity.recentSweep?.detected &&\r\n                     liquidity.recentSweep.isFakeout &&\r\n                     liquidity.recentSweep.direction === 'UP';\r\n\r\n    const hasBearishDiv = divergence.type === DivergenceType.BEARISH;\r\n    const hasBullishStructure = structureEvent?.direction === StructureDirection.BULLISH;\r\n    const hasBearishStructure = structureEvent?.direction === StructureDirection.BEARISH;\r\n\r\n    // üõ°Ô∏è SAFETY CHECK: Divergence-Structure conflict\r\n    // Bearish divergence (expecting reversal DOWN) vs Bullish structure (trend UP)\r\n    if (hasBearishDiv && hasBullishStructure) {\r\n      this.logger.warn('Conflicting signals detected', {\r\n        direction: 'SHORT',\r\n        conflict: 'Bearish divergence vs Bullish structure',\r\n        confidencePenalty: -CONFLICT_PENALTY,\r\n      });\r\n\r\n      // Apply penalty for conflicting signals\r\n      confidence -= CONFLICT_PENALTY;\r\n      reasons.push('‚ö†Ô∏è Structure conflict');\r\n    }\r\n\r\n    // Check required conditions\r\n    if (this.config.requireLiquiditySweep && !hasSweep) {\r\n      blockedBy.push('NO_LIQUIDITY_SWEEP');\r\n      return this.noSignal('No liquidity sweep for SHORT', blockedBy);\r\n    }\r\n\r\n    if (this.config.requireDivergence && !hasBearishDiv) {\r\n      blockedBy.push('NO_DIVERGENCE');\r\n      return this.noSignal('No bearish divergence', blockedBy);\r\n    }\r\n\r\n    // If no requirements set, need AT LEAST ONE signal present\r\n    if (!this.config.requireLiquiditySweep && !this.config.requireDivergence && !this.config.requireCHoCH) {\r\n      if (!hasSweep && !hasBearishDiv && !hasBearishStructure) {\r\n        blockedBy.push('NO_SIGNALS');\r\n        return this.noSignal('No price action signals detected', blockedBy);\r\n      }\r\n    }\r\n\r\n    // üõ°Ô∏è FINAL SAFETY: Don't enter SHORT with bullish structure (hard block)\r\n    if (hasBullishStructure) {\r\n      this.logger.warn('Bullish structure blocks SHORT entry');\r\n      blockedBy.push('BULLISH_STRUCTURE');\r\n      return this.noSignal('Bullish structure detected', blockedBy);\r\n    }\r\n\r\n    // Boost confidence based on signals\r\n    if (hasSweep) {\r\n      confidence += LIQUIDITY_SWEEP_BOOST * (liquidity.recentSweep!.strength);\r\n      reasons.push('Liquidity sweep (fakeout up)');\r\n    }\r\n\r\n    if (hasBearishDiv) {\r\n      confidence += DIVERGENCE_BOOST * divergence.strength;\r\n      reasons.push(`Bearish divergence (strength: ${divergence.strength.toFixed(DECIMAL_PLACES.PERCENT)})`);\r\n    }\r\n\r\n    // CHoCH/BoS boost (bullish structure already blocked above)\r\n    if (structureEvent && structureEvent.direction === StructureDirection.BEARISH) {\r\n      if (structureEvent.type === StructureEventType.CHoCH) {\r\n        confidence += CHOCH_BOOST;\r\n        reasons.push('Bearish CHoCH');\r\n      } else if (structureEvent.type === StructureEventType.BoS) {\r\n        confidence += BOS_BOOST;\r\n        reasons.push('Bearish BoS');\r\n      }\r\n    }\r\n\r\n    // Check minimum confidence\r\n    if (confidence < this.config.minConfidence) {\r\n      blockedBy.push('LOW_CONFIDENCE');\r\n      return this.noSignal(`Confidence too low: ${confidence.toFixed(DECIMAL_PLACES.PERCENT)}`, blockedBy);\r\n    }\r\n\r\n    // Entry signal!\r\n    return {\r\n      shouldEnter: true,\r\n      direction: SignalDirection.SHORT,\r\n      confidence: Math.min(confidence, 1.0), // Cap at 1.0\r\n      reason: reasons.join(' + '),\r\n      blockedBy: [],\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // HELPER\r\n  // ============================================================================\r\n\r\n  private noSignal(reason: string, blockedBy: string[] = []): StrategyEvaluation {\r\n    return {\r\n      shouldEnter: false,\r\n      direction: SignalDirection.HOLD,\r\n      confidence: 0,\r\n      reason,\r\n      blockedBy,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\scalping-ladder-tp.strategy.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":90,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":90,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2898,2915],"text":"this.activeLadder != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'setupLadderTps' has no 'await' expression.","line":109,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":109,"endColumn":23},{"ruleId":"complexity","severity":1,"message":"Async method 'monitorLadderExecution' has a complexity of 11. Maximum allowed is 10.","line":157,"column":39,"nodeType":"FunctionExpression","messageId":"complex","endLine":196,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":158,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":158,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5042,5060],"text":"this.activeLadder == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":204,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":204,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6455,6473],"text":"this.activeLadder == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":229,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":229,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7204,7222],"text":"this.activeLadder == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":251,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":251,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7834,7852],"text":"this.activeLadder == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":272,"column":12,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":272,"endColumn":36,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[8504,8510],"text":"PositionSide.LONG"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":279,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":279,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8679,8697],"text":"(this.activeLadder == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Scalping Ladder TP Strategy (Phase 3)\r\n *\r\n * Wrapper strategy that enhances exits with multi-level take profits:\r\n * - 3 TP levels (e.g., 0.08%, 0.15%, 0.25%)\r\n * - Partial closes (e.g., 33%, 33%, 34%)\r\n * - Move SL to breakeven after TP1\r\n * - Trailing SL after TP2\r\n *\r\n * This strategy does NOT generate its own signals.\r\n * Instead, it wraps base signal sources and enhances exit logic.\r\n *\r\n * R/R Ratio: ~1.26:1 (weighted average)\r\n *\r\n * Example flow:\r\n * 1. Base strategy (levelBased) generates LONG signal\r\n * 2. ScalpingLadderTpStrategy returns NO_SIGNAL (wrapper pattern)\r\n * 3. After position opens, ladder TPs are set up\r\n * 4. Monitor execution: TP1 ‚Üí breakeven, TP2 ‚Üí trailing, TP3 ‚Üí full exit\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  SignalDirection,\r\n  StrategySignal,\r\n  SignalType,\r\n  StrategyMarketData,\r\n  ScalpingLadderTpConfig,\r\n  LoggerService,\r\n  Position,\r\n  LadderTpLevel,\r\n} from '../types';\r\nimport { LadderTpManagerService } from '../services/ladder-tp-manager.service';\r\nimport { BybitService } from '../services/bybit/bybit.service';\r\n\r\n// ============================================================================\r\n// SCALPING LADDER TP STRATEGY\r\n// ============================================================================\r\n\r\nexport class ScalpingLadderTpStrategy implements IStrategy {\r\n  readonly name = 'ScalpingLadderTp';\r\n  readonly type = SignalType.SCALPING_LADDER_TP;\r\n  readonly priority: number;\r\n\r\n  private ladderManager: LadderTpManagerService;\r\n\r\n  // Active ladder tracking\r\n  private activeLadder: {\r\n    position: Position;\r\n    levels: LadderTpLevel[];\r\n    tp1Hit: boolean;\r\n    tp2Hit: boolean;\r\n    tp3Hit: boolean;\r\n  } | null = null;\r\n\r\n  constructor(\r\n    private config: ScalpingLadderTpConfig,\r\n    private bybitService: BybitService,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n\r\n    // Initialize ladder manager\r\n    this.ladderManager = new LadderTpManagerService(config.ladderManager, bybitService, logger);\r\n\r\n    this.logger.info('‚úÖ ScalpingLadderTpStrategy initialized', {\r\n      enabled: config.enabled,\r\n      priority: config.priority,\r\n      levels: config.ladderManager.levels.length,\r\n      baseSource: config.baseSignalSource,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // STRATEGY INTERFACE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Evaluate strategy - wrapper pattern\r\n   *\r\n   * This strategy does NOT generate signals.\r\n   * It only monitors existing positions for ladder TP execution.\r\n   *\r\n   * @param data - Market data\r\n   * @returns Always NO_SIGNAL (wrapper strategy)\r\n   */\r\n  async evaluate(data: StrategyMarketData): Promise<StrategySignal> {\r\n    // Monitor active ladder execution if exists\r\n    if (this.activeLadder) {\r\n      await this.monitorLadderExecution(data.candles[0].close);\r\n    }\r\n\r\n    // Wrapper strategy: always return NO_SIGNAL\r\n    return this.noSignal('Wrapper strategy - does not generate signals');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // LADDER SETUP (called externally after position open)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Setup ladder TPs for new position\r\n   *\r\n   * Called by orchestrator after position is opened\r\n   *\r\n   * @param position - Newly opened position\r\n   */\r\n  async setupLadderTps(position: Position): Promise<void> {\r\n    try {\r\n      this.logger.info('üéØ Setting up ladder TPs', {\r\n        side: position.side,\r\n        entry: position.entryPrice,\r\n        quantity: position.quantity,\r\n      });\r\n\r\n      // Determine direction from position side\r\n      const direction = this.getDirectionFromPosition(position);\r\n\r\n      // Create ladder levels\r\n      const levels = this.ladderManager.createLadderLevels(position.entryPrice, direction);\r\n\r\n      // Store active ladder\r\n      this.activeLadder = {\r\n        position,\r\n        levels,\r\n        tp1Hit: false,\r\n        tp2Hit: false,\r\n        tp3Hit: false,\r\n      };\r\n\r\n      this.logger.info('‚úÖ Ladder TPs setup complete', {\r\n        levels: levels.map((l) => ({\r\n          level: l.level,\r\n          targetPrice: l.targetPrice,\r\n          closePercent: l.closePercent,\r\n        })),\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('Failed to setup ladder TPs', {\r\n        error: error instanceof Error ? error.message : String(error),\r\n      });\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // LADDER MONITORING\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Monitor ladder TP execution\r\n   *\r\n   * Checks if TPs are hit and executes partial closes + SL adjustments\r\n   *\r\n   * @param currentPrice - Current market price\r\n   */\r\n  private async monitorLadderExecution(currentPrice: number): Promise<void> {\r\n    if (!this.activeLadder) {\r\n      return;\r\n    }\r\n\r\n    const { position, levels, tp1Hit, tp2Hit, tp3Hit } = this.activeLadder;\r\n    const direction = this.getDirectionFromPosition(position);\r\n\r\n    // Check TP1\r\n    if (!tp1Hit && this.ladderManager.checkTpHit(levels[0], currentPrice, direction)) {\r\n      await this.handleTp1Hit(levels[0]);\r\n      this.activeLadder.tp1Hit = true;\r\n      levels[0].hit = true;\r\n    }\r\n\r\n    // Check TP2\r\n    if (tp1Hit && !tp2Hit && this.ladderManager.checkTpHit(levels[1], currentPrice, direction)) {\r\n      await this.handleTp2Hit(levels[1]);\r\n      this.activeLadder.tp2Hit = true;\r\n      levels[1].hit = true;\r\n    }\r\n\r\n    // Check TP3\r\n    if (tp2Hit && !tp3Hit && this.ladderManager.checkTpHit(levels[2], currentPrice, direction)) {\r\n      await this.handleTp3Hit(levels[2]);\r\n      this.activeLadder.tp3Hit = true;\r\n      levels[2].hit = true;\r\n\r\n      // All TPs hit - clear active ladder\r\n      this.clearActiveLadder();\r\n    }\r\n\r\n    // Check max holding time\r\n    if (this.isMaxHoldingTimeExceeded()) {\r\n      this.logger.warn('Max holding time exceeded, closing position', {\r\n        maxHoldingTimeMs: this.config.maxHoldingTimeMs,\r\n      });\r\n      this.clearActiveLadder();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle TP1 hit\r\n   * - Execute partial close (33%)\r\n   * - Move SL to breakeven\r\n   */\r\n  private async handleTp1Hit(level: LadderTpLevel): Promise<void> {\r\n    if (!this.activeLadder) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('üéØ TP1 HIT - Executing partial close + move to breakeven', {\r\n      targetPrice: level.targetPrice,\r\n      closePercent: level.closePercent,\r\n    });\r\n\r\n    // Execute partial close\r\n    await this.ladderManager.executePartialClose(level, this.activeLadder.position);\r\n\r\n    // Move SL to breakeven\r\n    await this.ladderManager.moveToBreakeven(this.activeLadder.position);\r\n\r\n    // Update position quantity\r\n    this.activeLadder.position.quantity *= 1 - level.closePercent / PERCENT_MULTIPLIER;\r\n  }\r\n\r\n  /**\r\n   * Handle TP2 hit\r\n   * - Execute partial close (33%)\r\n   * - Start trailing SL\r\n   */\r\n  private async handleTp2Hit(level: LadderTpLevel): Promise<void> {\r\n    if (!this.activeLadder) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('üéØ TP2 HIT - Executing partial close + trailing SL', {\r\n      targetPrice: level.targetPrice,\r\n      closePercent: level.closePercent,\r\n    });\r\n\r\n    // Execute partial close\r\n    await this.ladderManager.executePartialClose(level, this.activeLadder.position);\r\n\r\n    // Update position quantity\r\n    this.activeLadder.position.quantity *= 1 - level.closePercent / PERCENT_MULTIPLIER;\r\n  }\r\n\r\n  /**\r\n   * Handle TP3 hit\r\n   * - Execute final close (34%)\r\n   * - Clear ladder\r\n   */\r\n  private async handleTp3Hit(level: LadderTpLevel): Promise<void> {\r\n    if (!this.activeLadder) {\r\n      return;\r\n    }\r\n\r\n    this.logger.info('üéØ TP3 HIT - Executing final close', {\r\n      targetPrice: level.targetPrice,\r\n      closePercent: level.closePercent,\r\n    });\r\n\r\n    // Execute final close\r\n    await this.ladderManager.executePartialClose(level, this.activeLadder.position);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get signal direction from position side\r\n   */\r\n  private getDirectionFromPosition(position: Position): SignalDirection {\r\n    return position.side === 'LONG' ? SignalDirection.LONG : SignalDirection.SHORT;\r\n  }\r\n\r\n  /**\r\n   * Check if max holding time exceeded\r\n   */\r\n  private isMaxHoldingTimeExceeded(): boolean {\r\n    if (!this.activeLadder || this.config.maxHoldingTimeMs === 0) {\r\n      return false;\r\n    }\r\n\r\n    const holdingTime = Date.now() - this.activeLadder.position.openedAt;\r\n    return holdingTime >= this.config.maxHoldingTimeMs;\r\n  }\r\n\r\n  /**\r\n   * Clear active ladder tracking\r\n   */\r\n  private clearActiveLadder(): void {\r\n    this.logger.debug('Clearing active ladder', {\r\n      tp1Hit: this.activeLadder?.tp1Hit,\r\n      tp2Hit: this.activeLadder?.tp2Hit,\r\n      tp3Hit: this.activeLadder?.tp3Hit,\r\n    });\r\n\r\n    this.activeLadder = null;\r\n  }\r\n\r\n  /**\r\n   * Return no signal\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if strategy is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get ladder manager (for testing)\r\n   */\r\n  getLadderManager(): LadderTpManagerService {\r\n    return this.ladderManager;\r\n  }\r\n\r\n  /**\r\n   * Get active ladder (for testing)\r\n   */\r\n  getActiveLadder(): typeof this.activeLadder {\r\n    return this.activeLadder;\r\n  }\r\n\r\n  /**\r\n   * Force clear active ladder (for testing)\r\n   */\r\n  forceClearLadder(): void {\r\n    this.activeLadder = null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\scalping-limit-order.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SignalDirection' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":18},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":78,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":78,"endColumn":17},{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":103,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":103,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":103,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":103,"endColumn":20}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Scalping Limit Order Strategy (Phase 2)\r\n *\r\n * This is a SPECIAL wrapper strategy that doesn't generate its own signals.\r\n * Instead, it modifies the ORDER EXECUTION for ALL strategies when enabled.\r\n *\r\n * Purpose:\r\n * - Intercept position opening and use limit orders instead of market orders\r\n * - Save 0.05% in fees per trade (0.06% taker ‚Üí 0.01% maker)\r\n * - Fallback to market order if limit not filled within timeout\r\n *\r\n * Design:\r\n * - Returns NO_SIGNAL from evaluate() (doesn't compete with other strategies)\r\n * - Actual execution logic handled by LimitOrderExecutorService in PositionService\r\n * - Enabled/disabled via config.scalpingLimitOrder.enabled\r\n *\r\n * Note: This strategy serves as a GLOBAL SETTING for limit order execution,\r\n * not as a traditional signal-generating strategy.\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategySignal,\r\n  StrategyMarketData,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  ScalpingLimitOrderConfig,\r\n} from '../types';\r\n\r\n// ============================================================================\r\n// SCALPING LIMIT ORDER STRATEGY\r\n// ============================================================================\r\n\r\nexport class ScalpingLimitOrderStrategy implements IStrategy {\r\n  readonly name = 'ScalpingLimitOrder';\r\n  readonly type = SignalType.SCALPING_LIMIT_ORDER;\r\n  readonly priority: number;\r\n\r\n  constructor(\r\n    private config: ScalpingLimitOrderConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n    this.logger.info('ScalpingLimitOrderStrategy initialized (execution wrapper)', {\r\n      enabled: config.enabled,\r\n      priority: config.priority,\r\n      timeoutMs: config.executor.timeoutMs,\r\n      slippage: config.executor.slippagePercent,\r\n      fallbackToMarket: config.executor.fallbackToMarket,\r\n      baseSignalSource: config.baseSignalSource,\r\n    });\r\n\r\n    if (config.enabled) {\r\n      this.logger.info(\r\n        'üí∞ Limit Order Execution ENABLED - All entries will use limit orders (maker fees)',\r\n      );\r\n      this.logger.info('üìä Fee savings: 0.05% per trade (0.06% taker ‚Üí 0.01% maker)');\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // STRATEGY INTERFACE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Evaluate market data for signals\r\n   *\r\n   * IMPORTANT: This strategy NEVER generates its own signals!\r\n   * It always returns NO_SIGNAL because it's a wrapper/modifier for execution.\r\n   *\r\n   * The actual limit order logic is handled by:\r\n   * - LimitOrderExecutorService in PositionService.openPosition()\r\n   * - Enabled/disabled via config.scalpingLimitOrder.enabled\r\n   *\r\n   * @returns NO_SIGNAL always\r\n   */\r\n  async evaluate(_data: StrategyMarketData): Promise<StrategySignal> {\r\n    // This strategy doesn't generate signals - it modifies execution\r\n    return this.noSignal('Wrapper strategy - does not generate signals');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Return NO_SIGNAL result\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get executor configuration\r\n   * Used by PositionService to access limit order settings\r\n   */\r\n  getExecutorConfig() {\r\n    return this.config.executor;\r\n  }\r\n\r\n  /**\r\n   * Check if limit order execution is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled && this.config.executor.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get base signal source\r\n   * Indicates which strategy this wrapper applies to\r\n   */\r\n  getBaseSignalSource(): string {\r\n    return this.config.baseSignalSource;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\scalping-micro-wall.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PERCENTAGE_THRESHOLDS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":71},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":69,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":69,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":84,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":84,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2644,2665],"text":"marketData.orderbook == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":108,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":108,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3369,3380],"text":"brokenWall == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1000.","line":244,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":244,"endColumn":42}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Scalping Micro Wall Strategy\r\n *\r\n * High-frequency scalping strategy that trades small orderbook wall breaks.\r\n * Unlike WhaleHunter (15-20% walls), this targets smaller 5-10% walls.\r\n *\r\n * Strategy:\r\n * - Detect micro walls (5-10% of orderbook volume)\r\n * - Wait for price to break through wall (with confirmation)\r\n * - Enter immediately with tight TP/SL\r\n * - Exit within 1-2 minutes (fast scalping)\r\n *\r\n * Risk Management:\r\n * - Very tight stop-loss (0.08%)\r\n * - Quick take-profit (0.15%)\r\n * - Max holding time: 2 minutes\r\n * - Cooldown: 1 minute between trades\r\n *\r\n * R/R Ratio: PERCENTAGE_THRESHOLDS.VERY_LOW% / 0.08% = 1.87:1\r\n *\r\n * IMPORTANT: Requires real-time WebSocket orderbook feed!\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategySignal,\r\n  StrategyMarketData,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  ScalpingMicroWallConfig,\r\n  TakeProfit,\r\n} from '../types';\r\nimport { MicroWallDetectorService } from '../services/micro-wall-detector.service';\r\n\r\n// ============================================================================\r\n// SCALPING MICRO WALL STRATEGY\r\n// ============================================================================\r\n\r\nexport class ScalpingMicroWallStrategy implements IStrategy {\r\n  readonly name = 'SCALPING_MICRO_WALL';\r\n  readonly priority: number;\r\n\r\n  private lastTradeTime: number = 0;\r\n\r\n  constructor(\r\n    private config: ScalpingMicroWallConfig,\r\n    private microWallDetector: MicroWallDetectorService,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n\r\n    this.logger.info('üìä ScalpingMicroWallStrategy initialized', {\r\n      priority: this.priority,\r\n      minConfidence: config.minConfidence,\r\n      takeProfitPercent: config.takeProfitPercent,\r\n      stopLossPercent: config.stopLossPercent,\r\n      maxHoldingTimeMs: config.maxHoldingTimeMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Evaluate scalping micro wall strategy\r\n   *\r\n   * @param marketData - Market data (must include orderbook)\r\n   * @returns Strategy signal\r\n   */\r\n  async evaluate(marketData: StrategyMarketData): Promise<StrategySignal> {\r\n    // Cleanup expired walls to prevent memory leak\r\n    this.microWallDetector.cleanupExpiredWalls();\r\n\r\n    // Check if strategy is enabled\r\n    if (!this.config.enabled) {\r\n      return this.noSignal('Strategy disabled');\r\n    }\r\n\r\n    // Check cooldown (avoid over-trading)\r\n    if (this.isInCooldown()) {\r\n      return this.noSignal('In cooldown period');\r\n    }\r\n\r\n    // Check if we have orderbook data\r\n    if (!marketData.orderbook) {\r\n      this.logger.warn('ScalpingMicroWall: No orderbook data available');\r\n      return this.noSignal('No orderbook data');\r\n    }\r\n\r\n    // Get current price\r\n    const currentPrice = marketData.candles[marketData.candles.length - 1].close;\r\n\r\n    // Detect micro walls\r\n    const microWalls = this.microWallDetector.detectMicroWalls(marketData.orderbook);\r\n\r\n    if (microWalls.length === 0) {\r\n      return this.noSignal('No micro walls detected');\r\n    }\r\n\r\n    // Check for broken walls\r\n    let brokenWall = null;\r\n    for (const wall of microWalls) {\r\n      if (this.microWallDetector.isWallBroken(wall, currentPrice)) {\r\n        brokenWall = wall;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!brokenWall) {\r\n      return this.noSignal('No broken walls (waiting for break)');\r\n    }\r\n\r\n    // Calculate confidence\r\n    const confidence = this.microWallDetector.calculateWallConfidence(brokenWall);\r\n\r\n    // Check confidence threshold\r\n    if (confidence < this.config.minConfidence) {\r\n      return this.noSignal(\r\n        `Confidence too low: ${confidence.toFixed(1)} < ${this.config.minConfidence}`,\r\n      );\r\n    }\r\n\r\n    // Get signal direction\r\n    const direction = this.microWallDetector.getSignalDirection(brokenWall);\r\n\r\n    // Check if this wall was recently broken (prevent duplicate trades)\r\n    if (this.microWallDetector.wasRecentlyBroken(brokenWall.side, brokenWall.price)) {\r\n      return this.noSignal('Wall was recently broken (cooldown)');\r\n    }\r\n\r\n    // MICRO WALL SIGNAL CONFIRMED - Generate strategy signal\r\n    this.logger.info('‚úÖ ScalpingMicroWall signal generated', {\r\n      direction,\r\n      confidence: confidence.toFixed(1),\r\n      wallSide: brokenWall.side,\r\n      wallPrice: brokenWall.price,\r\n      wallSize: brokenWall.size.toFixed(DECIMAL_PLACES.PERCENT),\r\n      wallPercent: brokenWall.percentOfTotal.toFixed(DECIMAL_PLACES.PERCENT),\r\n      currentPrice,\r\n    });\r\n\r\n    // Update last trade time\r\n    this.lastTradeTime = Date.now();\r\n\r\n    // Calculate TP/SL levels\r\n    const { stopLossPrice, takeProfits } = this.calculateTpSlLevels(\r\n      currentPrice,\r\n      direction,\r\n    );\r\n\r\n    return {\r\n      valid: true,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      signal: {\r\n        direction,\r\n        type: SignalType.SCALPING_MICRO_WALL,\r\n        confidence: confidence / PERCENT_MULTIPLIER, // ‚Üê FIX: Convert to 0-1 range\r\n        price: currentPrice,\r\n        stopLoss: stopLossPrice,\r\n        takeProfits,\r\n        reason: `Micro wall broken: ${brokenWall.side} at ${brokenWall.price} (${brokenWall.percentOfTotal.toFixed(1)}%)`,\r\n        timestamp: Date.now(),\r\n        marketData: {\r\n          rsi: 50, // Not used in micro wall strategy\r\n          atr: 0, // Not used in micro wall strategy\r\n          trend: 'NEUTRAL',\r\n          whaleMode: 'MICRO_WALL_BREAK',\r\n          wallSize: brokenWall.size,\r\n        },\r\n      },\r\n      reason: `Micro wall broken: ${brokenWall.side} at ${brokenWall.price} (${brokenWall.percentOfTotal.toFixed(1)}%)`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate TP/SL levels\r\n   * @param entryPrice - Entry price\r\n   * @param direction - Signal direction\r\n   * @returns Stop loss and take profit levels\r\n   */\r\n  private calculateTpSlLevels(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n  ): {\r\n    stopLossPrice: number;\r\n    takeProfits: TakeProfit[];\r\n  } {\r\n    const tpPercent = this.config.takeProfitPercent;\r\n    const slPercent = this.config.stopLossPercent;\r\n\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: TP above entry, SL below entry\r\n      const stopLossPrice = entryPrice * (1 - slPercent / PERCENT_MULTIPLIER);\r\n      const tp1Price = entryPrice * (1 + tpPercent / PERCENT_MULTIPLIER);\r\n\r\n      return {\r\n        stopLossPrice,\r\n        takeProfits: [\r\n          {\r\n            level: 1,\r\n            percent: tpPercent,\r\n            sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Close 100% at TP1 (single TP for scalping)\r\n            price: tp1Price,\r\n            hit: false,\r\n          },\r\n        ],\r\n      };\r\n    } else {\r\n      // SHORT: TP below entry, SL above entry\r\n      const stopLossPrice = entryPrice * (1 + slPercent / PERCENT_MULTIPLIER);\r\n      const tp1Price = entryPrice * (1 - tpPercent / PERCENT_MULTIPLIER);\r\n\r\n      return {\r\n        stopLossPrice,\r\n        takeProfits: [\r\n          {\r\n            level: 1,\r\n            percent: tpPercent,\r\n            sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Close 100% at TP1\r\n            price: tp1Price,\r\n            hit: false,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if strategy is in cooldown period\r\n   * @returns True if in cooldown\r\n   */\r\n  private isInCooldown(): boolean {\r\n    if (this.lastTradeTime === 0) {\r\n      return false;\r\n    }\r\n\r\n    const timeSinceLastTrade = Date.now() - this.lastTradeTime;\r\n    const inCooldown = timeSinceLastTrade < this.config.cooldownMs;\r\n\r\n    if (inCooldown) {\r\n      const remainingMs = this.config.cooldownMs - timeSinceLastTrade;\r\n      this.logger.debug('‚è≥ ScalpingMicroWall in cooldown', {\r\n        remainingMs,\r\n        remainingSec: (remainingMs / 1000).toFixed(1),\r\n      });\r\n    }\r\n\r\n    return inCooldown;\r\n  }\r\n\r\n  /**\r\n   * Helper: Create no-signal response\r\n   * @param reason - Reason for no signal\r\n   * @returns No-signal strategy signal\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset strategy state (for testing)\r\n   */\r\n  reset(): void {\r\n    this.lastTradeTime = 0;\r\n    this.logger.debug('üîÑ ScalpingMicroWallStrategy reset');\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\scalping-order-flow.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FlowImbalance' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":16},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":71,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":71,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":77,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":77,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2505,2519],"text":"data.orderbook != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":89,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":89,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2860,2870],"text":"imbalance == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Scalping Order Flow Strategy (Phase 5)\r\n *\r\n * Scalping strategy based on order flow imbalance analysis.\r\n *\r\n * Features:\r\n * - Analyzes aggressive buy/sell flow from orderbook changes\r\n * - Detects flow imbalance (e.g., 3x more buy flow than sell)\r\n * - Fast scalping with ultra-tight TP/SL\r\n * - R/R Ratio: 2:1 (0.10% TP / 0.05% SL)\r\n *\r\n * Example:\r\n * - Aggressive buy flow: 9000 USDT, sell flow: 3000 USDT ‚Üí 3x ratio ‚Üí LONG signal\r\n * - Entry: 1.0000, TP: 1.0010 (+0.10%), SL: 0.9995 (-0.05%)\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  SignalDirection,\r\n  StrategySignal,\r\n  SignalType,\r\n  StrategyMarketData,\r\n  ScalpingOrderFlowConfig,\r\n  LoggerService,\r\n  OrderBook,\r\n  FlowImbalance,\r\n  TakeProfit,\r\n} from '../types';\r\nimport { OrderFlowAnalyzerService } from '../services/order-flow-analyzer.service';\r\n\r\n// ============================================================================\r\n// SCALPING ORDER FLOW STRATEGY\r\n// ============================================================================\r\n\r\nexport class ScalpingOrderFlowStrategy implements IStrategy {\r\n  readonly name = 'ScalpingOrderFlow';\r\n  readonly type = SignalType.SCALPING_ORDER_FLOW;\r\n  readonly priority: number;\r\n\r\n  private analyzer: OrderFlowAnalyzerService;\r\n\r\n  constructor(\r\n    private config: ScalpingOrderFlowConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n\r\n    // Initialize order flow analyzer\r\n    this.analyzer = new OrderFlowAnalyzerService(config.analyzer, logger);\r\n\r\n    this.logger.info('‚úÖ ScalpingOrderFlowStrategy initialized', {\r\n      enabled: config.enabled,\r\n      priority: config.priority,\r\n      aggressiveBuyThreshold: config.analyzer.aggressiveBuyThreshold,\r\n      takeProfitPercent: config.takeProfitPercent,\r\n      stopLossPercent: config.stopLossPercent,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // STRATEGY INTERFACE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Evaluate strategy - detect flow imbalance\r\n   *\r\n   * @param data - Market data\r\n   * @returns Signal if flow imbalance detected\r\n   */\r\n  async evaluate(data: StrategyMarketData): Promise<StrategySignal> {\r\n    if (!this.config.enabled) {\r\n      return this.noSignal('Strategy disabled');\r\n    }\r\n\r\n    // CRITICAL FIX: Process orderbook update before detecting imbalance\r\n    if (data.orderbook) {\r\n      this.analyzer.processOrderbookUpdate(data.orderbook);\r\n    } else {\r\n      return this.noSignal('No orderbook data available');\r\n    }\r\n\r\n    // Cleanup old flow data to prevent memory leak\r\n    this.analyzer.cleanupOldFlow();\r\n\r\n    // Detect flow imbalance\r\n    const imbalance = this.analyzer.detectFlowImbalance();\r\n\r\n    if (!imbalance) {\r\n      return this.noSignal('No flow imbalance detected');\r\n    }\r\n\r\n    // Check minimum confidence\r\n    if (imbalance.confidence < this.config.minConfidence) {\r\n      return this.noSignal(\r\n        `Flow imbalance confidence too low (${imbalance.confidence.toFixed(1)} < ${this.config.minConfidence})`,\r\n      );\r\n    }\r\n\r\n    // Generate signal\r\n    const currentPrice = data.currentPrice;\r\n\r\n    this.logger.info('üìä Order flow imbalance signal generated!', {\r\n      direction: imbalance.direction,\r\n      flowRatio: imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      confidence: imbalance.confidence.toFixed(1),\r\n      volumeUSDT: imbalance.totalVolumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n    });\r\n\r\n    return {\r\n      valid: true,\r\n      signal: {\r\n        direction: imbalance.direction,\r\n        price: currentPrice,\r\n        stopLoss: this.calculateStopLoss(currentPrice, imbalance.direction),\r\n        takeProfits: this.calculateTakeProfits(currentPrice, imbalance.direction),\r\n        confidence: imbalance.confidence / PERCENT_MULTIPLIER, // ‚Üê FIX: Convert to 0-1 range\r\n        type: this.type,\r\n        reason: `Order flow imbalance: ${imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT)}x | Volume: ${imbalance.totalVolumeUSDT.toFixed(0)} USDT | ${imbalance.direction === SignalDirection.LONG ? 'Aggressive BUY' : 'Aggressive SELL'}`,\r\n        timestamp: Date.now(),\r\n      },\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason: `Flow imbalance detected: ${imbalance.ratio.toFixed(DECIMAL_PLACES.PERCENT)}x ratio`,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS (for external orderbook feeding)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Feed orderbook updates to analyzer (from websocket/external source)\r\n   *\r\n   * @param orderbook - Orderbook snapshot\r\n   */\r\n  feedOrderbookUpdate(orderbook: OrderBook): void {\r\n    this.analyzer.processOrderbookUpdate(orderbook);\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate stop loss price\r\n   *\r\n   * @param entryPrice - Entry price\r\n   * @param direction - Signal direction\r\n   * @returns Stop loss price\r\n   */\r\n  private calculateStopLoss(entryPrice: number, direction: SignalDirection): number {\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: SL below entry\r\n      return entryPrice * (1 - this.config.stopLossPercent / PERCENT_MULTIPLIER);\r\n    } else {\r\n      // SHORT: SL above entry\r\n      return entryPrice * (1 + this.config.stopLossPercent / PERCENT_MULTIPLIER);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate take profit levels\r\n   *\r\n   * @param entryPrice - Entry price\r\n   * @param direction - Signal direction\r\n   * @returns Array of TP levels\r\n   */\r\n  private calculateTakeProfits(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n  ): TakeProfit[] {\r\n    const tpPrice =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice * (1 + this.config.takeProfitPercent / PERCENT_MULTIPLIER) // LONG: TP above entry\r\n        : entryPrice * (1 - this.config.takeProfitPercent / PERCENT_MULTIPLIER); // SHORT: TP below entry\r\n\r\n    return [\r\n      {\r\n        level: 1,\r\n        percent: this.config.takeProfitPercent,\r\n        sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Single TP (100% close)\r\n        price: tpPrice,\r\n        hit: false,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Return no signal\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if strategy is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get analyzer instance (for testing)\r\n   */\r\n  getAnalyzer(): OrderFlowAnalyzerService {\r\n    return this.analyzer;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\scalping-tick-delta.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MomentumSpike' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":16},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":71,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":71,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2438,2444],"text":"spike == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Scalping Tick Delta Strategy (Phase 4)\r\n *\r\n * Scalping strategy based on tick delta momentum analysis.\r\n *\r\n * Features:\r\n * - Analyzes buy/sell tick delta\r\n * - Detects momentum spikes (e.g., 2x more buys than sells)\r\n * - Fast scalping with tight TP/SL\r\n * - R/R Ratio: 2:1 (0.20% TP / 0.10% SL)\r\n *\r\n * Example:\r\n * - 40 buy ticks, 15 sell ticks ‚Üí 2.67x ratio ‚Üí LONG signal\r\n * - Entry: 1.0000, TP: 1.0020 (+0.20%), SL: 0.9990 (-0.10%)\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  SignalDirection,\r\n  StrategySignal,\r\n  SignalType,\r\n  StrategyMarketData,\r\n  ScalpingTickDeltaConfig,\r\n  LoggerService,\r\n  Tick,\r\n  MomentumSpike,\r\n  TakeProfit,\r\n} from '../types';\r\nimport { TickDeltaAnalyzerService } from '../services/tick-delta-analyzer.service';\r\n\r\n// ============================================================================\r\n// SCALPING TICK DELTA STRATEGY\r\n// ============================================================================\r\n\r\nexport class ScalpingTickDeltaStrategy implements IStrategy {\r\n  readonly name = 'ScalpingTickDelta';\r\n  readonly type = SignalType.SCALPING_TICK_DELTA;\r\n  readonly priority: number;\r\n\r\n  private analyzer: TickDeltaAnalyzerService;\r\n\r\n  constructor(\r\n    private config: ScalpingTickDeltaConfig,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n\r\n    // Initialize tick delta analyzer\r\n    this.analyzer = new TickDeltaAnalyzerService(config.analyzer, logger);\r\n\r\n    this.logger.info('‚úÖ ScalpingTickDeltaStrategy initialized', {\r\n      enabled: config.enabled,\r\n      priority: config.priority,\r\n      minDeltaRatio: config.analyzer.minDeltaRatio,\r\n      takeProfitPercent: config.takeProfitPercent,\r\n      stopLossPercent: config.stopLossPercent,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // STRATEGY INTERFACE\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Evaluate strategy - detect momentum spikes\r\n   *\r\n   * @param data - Market data\r\n   * @returns Signal if momentum spike detected\r\n   */\r\n  async evaluate(data: StrategyMarketData): Promise<StrategySignal> {\r\n    if (!this.config.enabled) {\r\n      return this.noSignal('Strategy disabled');\r\n    }\r\n\r\n    // Detect momentum spike\r\n    const spike = this.analyzer.detectMomentumSpike();\r\n\r\n    if (!spike) {\r\n      return this.noSignal('No momentum spike detected');\r\n    }\r\n\r\n    // Check minimum confidence\r\n    if (spike.confidence < this.config.minConfidence) {\r\n      return this.noSignal(\r\n        `Momentum spike confidence too low (${spike.confidence.toFixed(1)} < ${this.config.minConfidence})`,\r\n      );\r\n    }\r\n\r\n    // Generate signal\r\n    const currentPrice = data.currentPrice;\r\n\r\n    this.logger.info('üìà Tick delta momentum signal generated!', {\r\n      direction: spike.direction,\r\n      deltaRatio: spike.deltaRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n      confidence: spike.confidence.toFixed(1),\r\n      tickCount: spike.tickCount,\r\n      volumeUSDT: spike.volumeUSDT.toFixed(DECIMAL_PLACES.PERCENT),\r\n    });\r\n\r\n    return {\r\n      valid: true,\r\n      signal: {\r\n        direction: spike.direction,\r\n        price: currentPrice,\r\n        stopLoss: this.calculateStopLoss(currentPrice, spike.direction),\r\n        takeProfits: this.calculateTakeProfits(currentPrice, spike.direction),\r\n        confidence: spike.confidence / PERCENT_MULTIPLIER, // ‚Üê FIX: Convert to 0-1 range\r\n        type: this.type,\r\n        reason: `Tick delta momentum: ${spike.deltaRatio.toFixed(DECIMAL_PLACES.PERCENT)}x | Volume: ${spike.volumeUSDT.toFixed(0)} USDT | Ticks: ${spike.tickCount}`,\r\n        timestamp: Date.now(),\r\n      },\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason: `Momentum spike detected: ${spike.deltaRatio.toFixed(DECIMAL_PLACES.PERCENT)}x ratio`,\r\n    };\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PUBLIC METHODS (for external tick feeding)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Feed ticks to analyzer (from websocket/external source)\r\n   *\r\n   * @param ticks - Array of ticks to process\r\n   */\r\n  feedTicks(ticks: Tick[]): void {\r\n    for (const tick of ticks) {\r\n      this.analyzer.addTick(tick);\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // HELPER METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Calculate stop loss price\r\n   *\r\n   * @param entryPrice - Entry price\r\n   * @param direction - Signal direction\r\n   * @returns Stop loss price\r\n   */\r\n  private calculateStopLoss(entryPrice: number, direction: SignalDirection): number {\r\n    if (direction === SignalDirection.LONG) {\r\n      // LONG: SL below entry\r\n      return entryPrice * (1 - this.config.stopLossPercent / PERCENT_MULTIPLIER);\r\n    } else {\r\n      // SHORT: SL above entry\r\n      return entryPrice * (1 + this.config.stopLossPercent / PERCENT_MULTIPLIER);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate take profit levels\r\n   *\r\n   * @param entryPrice - Entry price\r\n   * @param direction - Signal direction\r\n   * @returns Array of TP levels\r\n   */\r\n  private calculateTakeProfits(\r\n    entryPrice: number,\r\n    direction: SignalDirection,\r\n  ): TakeProfit[] {\r\n    const tpPrice =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice * (1 + this.config.takeProfitPercent / PERCENT_MULTIPLIER) // LONG: TP above entry\r\n        : entryPrice * (1 - this.config.takeProfitPercent / PERCENT_MULTIPLIER); // SHORT: TP below entry\r\n\r\n    return [\r\n      {\r\n        level: 1,\r\n        percent: this.config.takeProfitPercent,\r\n        sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Single TP (100% close)\r\n        price: tpPrice,\r\n        hit: false,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Return no signal\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if strategy is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled;\r\n  }\r\n\r\n  /**\r\n   * Get analyzer instance (for testing)\r\n   */\r\n  getAnalyzer(): TickDeltaAnalyzerService {\r\n    return this.analyzer;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\smart-trend.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SignalScoreBreakdown' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":23},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":91,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":91,"endColumn":33,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2762,2786],"text":"(atrFilterConfig?.enabled) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2762,2786],"text":"(atrFilterConfig?.enabled) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":102,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":102,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3178,3190],"text":"weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":174,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":174,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5209,5231],"text":"(strategyData.rsi.entry != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5209,5231],"text":"(strategyData.rsi.entry ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5209,5231],"text":"(Boolean(strategyData.rsi.entry))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":174,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":174,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5232,5234],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":211,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":211,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6203,6237],"text":"(this.config.minConfidenceThreshold != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6203,6237],"text":"(this.config.minConfidenceThreshold ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6203,6237],"text":"(Boolean(this.config.minConfidenceThreshold))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":211,"column":61,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":211,"endColumn":63,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[6238,6240],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.6.","line":211,"column":64,"nodeType":"Literal","messageId":"noMagic","endLine":211,"endColumn":67},{"ruleId":"complexity","severity":1,"message":"Method 'applyHardFilters' has a complexity of 17. Maximum allowed is 10.","line":249,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":326,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":261,"column":16,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":261,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7780,7802],"text":"((data.ema.primary?.fast) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[7780,7802],"text":"((data.ema.primary?.fast) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7780,7802],"text":"(Boolean((data.ema.primary?.fast)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":261,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":261,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7803,7805],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":262,"column":16,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":262,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7825,7847],"text":"((data.ema.primary?.slow) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[7825,7847],"text":"((data.ema.primary?.slow) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7825,7847],"text":"(Boolean((data.ema.primary?.slow)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":262,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":262,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7848,7850],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":272,"column":16,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":272,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8092,8112],"text":"((data.ema.entry?.fast) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8092,8112],"text":"((data.ema.entry?.fast) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8092,8112],"text":"(Boolean((data.ema.entry?.fast)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":272,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":272,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8113,8115],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":273,"column":16,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":273,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8135,8155],"text":"((data.ema.entry?.slow) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8135,8155],"text":"((data.ema.entry?.slow) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8135,8155],"text":"(Boolean((data.ema.entry?.slow)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":273,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":273,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8156,8158],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":282,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":282,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8368,8382],"text":"(data.rsi.entry != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8368,8382],"text":"(data.rsi.entry ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8368,8382],"text":"(Boolean(data.rsi.entry))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":282,"column":27,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":282,"endColumn":29,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8383,8385],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":290,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":290,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8555,8571],"text":"(data.ema.primary != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":296,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":296,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8789,8805],"text":"(data.rsi.primary != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8789,8805],"text":"(data.rsi.primary ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8789,8805],"text":"(Boolean(data.rsi.primary))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":303,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":303,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9053,9075],"text":"((data.ema.primary?.slow) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9053,9075],"text":"((data.ema.primary?.slow) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9053,9075],"text":"(Boolean((data.ema.primary?.slow)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":311,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":311,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9375,9392],"text":"(this.atrIndicator != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":311,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":311,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9396,9416],"text":"(this.atrFilterConfig != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":311,"column":54,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":311,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9420,9432],"text":"(data.candles != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'determineTrend5m' has a complexity of 17. Maximum allowed is 10.","line":335,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":403,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":342,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":342,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10316,10326],"text":"((ema?.fast) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10317,10326],"text":"((ema?.fast) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10316,10326],"text":"(!Boolean((ema?.fast)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":342,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":342,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10330,10339],"text":"(ema.slow == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10331,10339],"text":"(ema.slow ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10330,10339],"text":"(!Boolean(ema.slow))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bias' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":358,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":358,"endColumn":15},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (497). Maximum allowed is 300.","line":400,"column":1,"nodeType":null,"messageId":"exceed","endLine":688,"endColumn":1},{"ruleId":"complexity","severity":1,"message":"Method 'detectPullback1m' has a complexity of 11. Maximum allowed is 10.","line":412,"column":27,"nodeType":"FunctionExpression","messageId":"complex","endLine":463,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":419,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":419,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12716,12726],"text":"((ema?.fast) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12717,12726],"text":"((ema?.fast) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12716,12726],"text":"(!Boolean((ema?.fast)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":419,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":419,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12730,12739],"text":"(ema.slow == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12731,12739],"text":"(ema.slow ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12730,12739],"text":"(!Boolean(ema.slow))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'confirmEntry' has a complexity of 19. Maximum allowed is 10.","line":472,"column":23,"nodeType":"FunctionExpression","messageId":"complex","endLine":521,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":480,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":480,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14467,14477],"text":"((ema?.fast) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14468,14477],"text":"((ema?.fast) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14467,14477],"text":"(!Boolean((ema?.fast)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":480,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":480,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14481,14490],"text":"(ema.slow == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14482,14490],"text":"(ema.slow ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14481,14490],"text":"(!Boolean(ema.slow))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":483,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":483,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14572,14575],"text":"(rsi != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14572,14575],"text":"(rsi ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14572,14575],"text":"(Boolean(rsi))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":483,"column":18,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":483,"endColumn":20,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14576,14578],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":557,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":557,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17045,17063],"text":"(this.atrIndicator == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":557,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":557,"endColumn":52,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[17067,17088],"text":"(this.atrFilterConfig == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"unknown\" of template literal expression.","line":590,"column":51,"nodeType":"Identifier","messageId":"invalidType","endLine":590,"endColumn":56},{"ruleId":"complexity","severity":1,"message":"Method 'calculateConfidence' has a complexity of 21. Maximum allowed is 10.","line":606,"column":30,"nodeType":"FunctionExpression","messageId":"complex","endLine":686,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":613,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":613,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18854,18871],"text":"(this.weightMatrix != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":613,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":613,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18875,18879],"text":"(data != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":620,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":620,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19120,19134],"text":"(data.ema.entry != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":622,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":622,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19169,19188],"text":"(data.ema.entry.fast != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19169,19188],"text":"(data.ema.entry.fast ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19169,19188],"text":"(Boolean(data.ema.entry.fast))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":622,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":622,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19189,19191],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":623,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":623,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19214,19233],"text":"(data.ema.entry.slow != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[19214,19233],"text":"(data.ema.entry.slow ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[19214,19233],"text":"(Boolean(data.ema.entry.slow))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":623,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":623,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19234,19236],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":633,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":633,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19630,19646],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":635,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":635,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[19743,19759],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.3.","line":666,"column":43,"nodeType":"Literal","messageId":"noMagic","endLine":666,"endColumn":46},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.2.","line":671,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":671,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.07.","line":675,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":675,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.07.","line":678,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":678,"endColumn":27},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.06.","line":681,"column":23,"nodeType":"Literal","messageId":"noMagic","endLine":681,"endColumn":27}],"suppressedMessages":[],"errorCount":50,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MULTIPLIERS, PERCENTAGE_THRESHOLDS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Smart Trend Strategy\r\n *\r\n * Implements the trading algorithm from –ê–õ–ì–û–†–ò–¢–ú.md:\r\n * 1. Determine trend on 5m (PRIMARY): EMA20 > EMA50 + ZigZag HH/HL\r\n * 2. Find pullback on 1m (ENTRY): Price retraces to EMA20, ZigZag forms HL\r\n * 3. Confirm entry: Candle closes above EMA, RSI crosses 50, ZigZag confirms wave\r\n *\r\n * Uses hybrid logic: hard filters + optional weights\r\n */\r\n\r\nimport {\r\n  SignalDirection,\r\n  TrendState,\r\n  PullbackState,\r\n  EntryConfirmation,\r\n  TrendBias,\r\n  EMACrossover,\r\n  MarketStructure,\r\n  StrategyConfig,\r\n  SwingPoint,\r\n  Candle,\r\n  ATRFilterConfig,\r\n  LoggerService,\r\n  WeightMatrixInput,\r\n  SignalScoreBreakdown,\r\n} from '../types';\r\nimport { IStrategy, StrategyEvaluation } from './strategy.interface';\r\nimport { MarketStructureAnalyzer } from '../analyzers/market-structure.analyzer';\r\nimport { ATRIndicator } from '../indicators/atr.indicator';\r\nimport { WeightMatrixCalculatorService } from '../services/weight-matrix-calculator.service';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\ninterface MultiTimeframeRSI {\r\n  primary?: number;\r\n  entry?: number;\r\n  trend1?: number;\r\n}\r\n\r\ninterface TimeframeEMA {\r\n  fast?: number;\r\n  slow?: number;\r\n  crossover?: EMACrossover;\r\n}\r\n\r\ninterface MultiTimeframeEMA {\r\n  primary?: TimeframeEMA;\r\n  entry?: TimeframeEMA;\r\n  trend1?: TimeframeEMA;\r\n}\r\n\r\ninterface SmartTrendData {\r\n  rsi: MultiTimeframeRSI;\r\n  ema: MultiTimeframeEMA;\r\n  zigzagHighs: SwingPoint[];\r\n  zigzagLows: SwingPoint[];\r\n  currentPrice: number;\r\n  candles?: Candle[]; // Candles for ATR calculation (PRIMARY timeframe)\r\n  tfAlignment?: {\r\n    long: { score: number };\r\n    short: { score: number };\r\n  };\r\n}\r\n\r\ninterface SmartTrendEvaluation extends StrategyEvaluation {\r\n  trendState: TrendState;\r\n  pullbackState: PullbackState;\r\n  entryConfirmation: EntryConfirmation;\r\n}\r\n\r\n// ============================================================================\r\n// SMART TREND STRATEGY\r\n// ============================================================================\r\n\r\nexport class SmartTrendStrategy implements IStrategy<SmartTrendData> {\r\n  private atrIndicator: ATRIndicator | null = null;\r\n  private atrFilterConfig: ATRFilterConfig | null = null;\r\n  private weightMatrix: WeightMatrixCalculatorService | null = null;\r\n\r\n  constructor(\r\n    private config: StrategyConfig,\r\n    private structureAnalyzer: MarketStructureAnalyzer,\r\n    private logger: LoggerService,\r\n    atrFilterConfig?: ATRFilterConfig,\r\n    weightMatrix?: WeightMatrixCalculatorService,\r\n  ) {\r\n    if (atrFilterConfig?.enabled) {\r\n      this.atrFilterConfig = atrFilterConfig;\r\n      this.atrIndicator = new ATRIndicator(atrFilterConfig.period);\r\n      this.logger.info('ATR volatility filter enabled', {\r\n        period: atrFilterConfig.period,\r\n        minimumATR: atrFilterConfig.minimumATR,\r\n        maximumATR: atrFilterConfig.maximumATR,\r\n      });\r\n    }\r\n\r\n    // Initialize weight matrix if provided\r\n    if (weightMatrix) {\r\n      this.weightMatrix = weightMatrix;\r\n      this.logger.info('SmartTrend Strategy: Weight Matrix enabled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get strategy name\r\n   */\r\n  getName(): string {\r\n    return 'SmartTrend';\r\n  }\r\n\r\n  /**\r\n   * Get strategy description\r\n   */\r\n  getDescription(): string {\r\n    return 'Multi-timeframe trend following with pullback entries';\r\n  }\r\n\r\n  /**\r\n   * Evaluate market conditions with fully typed data\r\n   *\r\n   * @param data - Properly typed SmartTrendData (no casting needed)\r\n   * @returns Strategy evaluation result\r\n   */\r\n  evaluate(data: SmartTrendData): SmartTrendEvaluation {\r\n    const strategyData = data;\r\n\r\n    // STEP 1: Hard filters (must pass all)\r\n    const filterResult = this.applyHardFilters(strategyData);\r\n    if (filterResult.blockedBy.length > 0) {\r\n      return {\r\n        shouldEnter: false,\r\n        direction: SignalDirection.HOLD,\r\n        reason: filterResult.reason,\r\n        blockedBy: filterResult.blockedBy,\r\n        confidence: 0,\r\n        trendState: filterResult.trendState,\r\n        pullbackState: filterResult.pullbackState,\r\n        entryConfirmation: filterResult.entryConfirmation,\r\n      };\r\n    }\r\n\r\n    // STEP 2: Determine trend on 5m (PRIMARY)\r\n    const trendState = this.determineTrend5m(\r\n      strategyData.ema.primary,\r\n      strategyData.rsi.primary,\r\n      strategyData.zigzagHighs,\r\n      strategyData.zigzagLows,\r\n      strategyData.currentPrice,\r\n    );\r\n\r\n    if (!trendState.isValid) {\r\n      return {\r\n        shouldEnter: false,\r\n        direction: SignalDirection.HOLD,\r\n        reason: trendState.reason,\r\n        blockedBy: ['NO_VALID_TREND_5M'],\r\n        confidence: 0,\r\n        trendState,\r\n        pullbackState: {\r\n          detected: false,\r\n          emaFast: 0,\r\n          emaSlow: 0,\r\n          price: strategyData.currentPrice,\r\n          structure: null,\r\n          isComplete: false,\r\n          reason: 'Trend not valid',\r\n        },\r\n        entryConfirmation: {\r\n          confirmed: false,\r\n          rsi: strategyData.rsi.entry || 0,\r\n          rsiCrossed: false,\r\n          candleClosed: false,\r\n          zigzagConfirmed: false,\r\n          reason: 'Trend not valid',\r\n        },\r\n      };\r\n    }\r\n\r\n    // STEP 3: Detect pullback on 1m (ENTRY)\r\n    const pullbackState = this.detectPullback1m(\r\n      strategyData.ema.entry,\r\n      strategyData.currentPrice,\r\n      strategyData.zigzagHighs,\r\n      strategyData.zigzagLows,\r\n      trendState.bias,\r\n    );\r\n\r\n    // STEP 4: Confirm entry\r\n    const entryConfirmation = this.confirmEntry(\r\n      strategyData.ema.entry,\r\n      strategyData.rsi.entry,\r\n      strategyData.zigzagHighs,\r\n      strategyData.zigzagLows,\r\n      strategyData.currentPrice,\r\n      trendState.bias,\r\n    );\r\n\r\n    // STEP 5: Calculate confidence (weighted)\r\n    const confidence = this.calculateConfidence(\r\n      trendState,\r\n      pullbackState,\r\n      entryConfirmation,\r\n      strategyData,\r\n    );\r\n\r\n    // STEP 6: Determine if should enter\r\n    const minThreshold = this.config.minConfidenceThreshold || 0.6;\r\n    const shouldEnter = confidence >= minThreshold;\r\n\r\n    // Build reason\r\n    const reason = shouldEnter\r\n      ? `${trendState.bias} trend confirmed, confidence ${(confidence * PERCENT_MULTIPLIER).toFixed(1)}%`\r\n      : `Confidence too low: ${(confidence * PERCENT_MULTIPLIER).toFixed(1)}% < ${(minThreshold * PERCENT_MULTIPLIER).toFixed(1)}%`;\r\n\r\n    const blockedBy: string[] = [];\r\n    if (!trendState.isValid) {\r\n      blockedBy.push('NO_TREND');\r\n    }\r\n    if (!pullbackState.detected) {\r\n      blockedBy.push('NO_PULLBACK');\r\n    }\r\n    if (!entryConfirmation.confirmed) {\r\n      blockedBy.push('NO_ENTRY_CONFIRMATION');\r\n    }\r\n\r\n    return {\r\n      shouldEnter,\r\n      direction: trendState.bias === TrendBias.BULLISH ? SignalDirection.LONG : SignalDirection.SHORT,\r\n      reason,\r\n      blockedBy,\r\n      confidence,\r\n      trendState,\r\n      pullbackState,\r\n      entryConfirmation,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // HARD FILTERS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Apply hard filters (must pass all)\r\n   */\r\n  private applyHardFilters(data: SmartTrendData): {\r\n    blockedBy: string[];\r\n    reason: string;\r\n    trendState: TrendState;\r\n    pullbackState: PullbackState;\r\n    entryConfirmation: EntryConfirmation;\r\n  } {\r\n    const blockedBy: string[] = [];\r\n    const reasons: string[] = [];\r\n\r\n    const emptyTrendState: TrendState = {\r\n      bias: TrendBias.NEUTRAL,\r\n      emaFast: data.ema.primary?.fast || 0,\r\n      emaSlow: data.ema.primary?.slow || 0,\r\n      emaCrossover: EMACrossover.NONE,\r\n      price: data.currentPrice,\r\n      structure: null,\r\n      isValid: false,\r\n      reason: '',\r\n    };\r\n\r\n    const emptyPullbackState: PullbackState = {\r\n      detected: false,\r\n      emaFast: data.ema.entry?.fast || 0,\r\n      emaSlow: data.ema.entry?.slow || 0,\r\n      price: data.currentPrice,\r\n      structure: null,\r\n      isComplete: false,\r\n      reason: '',\r\n    };\r\n\r\n    const emptyEntryConfirmation: EntryConfirmation = {\r\n      confirmed: false,\r\n      rsi: data.rsi.entry || 0,\r\n      rsiCrossed: false,\r\n      candleClosed: false,\r\n      zigzagConfirmed: false,\r\n      reason: '',\r\n    };\r\n\r\n    // Filter 1: EMA flat (EMA20 ‚âà EMA50)\r\n    if (data.ema.primary && this.isEmaFlat(data.ema.primary.fast!, data.ema.primary.slow!)) {\r\n      blockedBy.push('EMA_FLAT');\r\n      reasons.push('EMA20 ‚âà EMA50 (flat market)');\r\n    }\r\n\r\n    // Filter 2: RSI neutral zone (45-55)\r\n    if (data.rsi.primary && this.isRsiNeutral(data.rsi.primary)) {\r\n      blockedBy.push('RSI_NEUTRAL');\r\n      reasons.push(`RSI in neutral zone (${data.rsi.primary.toFixed(DECIMAL_PLACES.PERCENT)})`);\r\n    }\r\n\r\n    // Filter 3: Price too far from EMA50\r\n    if (\r\n      data.ema.primary?.slow &&\r\n      this.isPriceTooFar(data.currentPrice, data.ema.primary.slow)\r\n    ) {\r\n      blockedBy.push('PRICE_TOO_FAR');\r\n      reasons.push(`Price too far from EMA50:${data.ema.primary.slow}  (>${this.config.emaDistanceThreshold}%)`);\r\n    }\r\n\r\n    // Filter 4: ATR volatility (if enabled)\r\n    if (this.atrIndicator && this.atrFilterConfig && data.candles) {\r\n      const atrResult = this.checkATR(data.candles);\r\n      if (!atrResult.isValid) {\r\n        blockedBy.push('ATR_OUT_OF_RANGE');\r\n        reasons.push(atrResult.reason!);\r\n      }\r\n    }\r\n\r\n    return {\r\n      blockedBy,\r\n      reason: blockedBy.length > 0 ? reasons.join(', ') : '',\r\n      trendState: emptyTrendState,\r\n      pullbackState: emptyPullbackState,\r\n      entryConfirmation: emptyEntryConfirmation,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // TREND ANALYSIS (5m / PRIMARY)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Determine trend on 5m timeframe\r\n   */\r\n  private determineTrend5m(\r\n    ema: TimeframeEMA | undefined,\r\n    rsi: number | undefined,\r\n    highs: SwingPoint[],\r\n    lows: SwingPoint[],\r\n    price: number,\r\n  ): TrendState {\r\n    if (!ema?.fast || !ema.slow) {\r\n      return {\r\n        bias: TrendBias.NEUTRAL,\r\n        emaFast: 0,\r\n        emaSlow: 0,\r\n        emaCrossover: EMACrossover.NONE,\r\n        price,\r\n        structure: null,\r\n        isValid: false,\r\n        reason: 'Missing EMA data',\r\n      };\r\n    }\r\n\r\n    // Get structure and pattern\r\n    const structure = this.structureAnalyzer.identifyStructure(highs, lows);\r\n    const pattern = this.structureAnalyzer.getLastPattern(highs, lows);\r\n    const bias = this.structureAnalyzer.getTrendBias(highs, lows);\r\n\r\n    // Determine EMA crossover\r\n    const emaCrossover =\r\n      ema.fast > ema.slow\r\n        ? EMACrossover.BULLISH\r\n        : ema.fast < ema.slow\r\n          ? EMACrossover.BEARISH\r\n          : EMACrossover.NONE;\r\n\r\n    // Check if trend is valid for LONG\r\n    const isValidLong =\r\n      ema.fast > ema.slow && // EMA20 > EMA50\r\n      price > ema.fast && // Price above EMA20\r\n      price > ema.slow && // Price above EMA50\r\n      pattern === 'HH_HL'; // ZigZag confirms HH/HL\r\n\r\n    // Check if trend is valid for SHORT\r\n    const isValidShort =\r\n      ema.fast < ema.slow && // EMA20 < EMA50\r\n      price < ema.fast && // Price below EMA20\r\n      price < ema.slow && // Price below EMA50\r\n      pattern === 'LH_LL'; // ZigZag confirms LH/LL\r\n\r\n    const isValid = isValidLong || isValidShort;\r\n    const finalBias = isValidLong\r\n      ? TrendBias.BULLISH\r\n      : isValidShort\r\n        ? TrendBias.BEARISH\r\n        : TrendBias.NEUTRAL;\r\n\r\n    const reason = isValid\r\n      ? `${finalBias} trend: EMA${ema.fast > ema.slow ? '20>50' : '20<50'}, price ${price > ema.fast ? 'above' : 'below'} EMA, pattern ${pattern}`\r\n      : `No clear trend: EMA crossover=${emaCrossover}, price position unclear, pattern=${pattern}`;\r\n\r\n    return {\r\n      bias: finalBias,\r\n      emaFast: ema.fast,\r\n      emaSlow: ema.slow,\r\n      emaCrossover,\r\n      price,\r\n      structure,\r\n      isValid,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // PULLBACK ANALYSIS (1m / ENTRY)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect pullback on 1m timeframe\r\n   */\r\n  private detectPullback1m(\r\n    ema: TimeframeEMA | undefined,\r\n    price: number,\r\n    highs: SwingPoint[],\r\n    lows: SwingPoint[],\r\n    trendBias: TrendBias,\r\n  ): PullbackState {\r\n    if (!ema?.fast || !ema.slow) {\r\n      return {\r\n        detected: false,\r\n        emaFast: 0,\r\n        emaSlow: 0,\r\n        price,\r\n        structure: null,\r\n        isComplete: false,\r\n        reason: 'Missing EMA data',\r\n      };\r\n    }\r\n\r\n    const structure = this.structureAnalyzer.identifyStructure(highs, lows);\r\n\r\n    // For LONG: pullback = price retraces below EMA20, forms HL\r\n    const isLongPullback =\r\n      trendBias === TrendBias.BULLISH &&\r\n      structure === MarketStructure.HIGHER_LOW;\r\n\r\n    // For SHORT: pullback = price retraces above EMA20, forms LH\r\n    const isShortPullback =\r\n      trendBias === TrendBias.BEARISH &&\r\n      structure === MarketStructure.LOWER_HIGH;\r\n\r\n    const detected = isLongPullback || isShortPullback;\r\n\r\n    // Pullback is complete when price returns to EMA\r\n    const isComplete =\r\n      (isLongPullback && price >= ema.fast) ||\r\n      (isShortPullback && price <= ema.fast);\r\n\r\n    const reason = detected\r\n      ? `Pullback detected: ${structure}, ${isComplete ? 'complete' : 'incomplete'}`\r\n      : `No pullback: structure=${structure}, bias=${trendBias}`;\r\n\r\n    return {\r\n      detected,\r\n      emaFast: ema.fast,\r\n      emaSlow: ema.slow,\r\n      price,\r\n      structure,\r\n      isComplete,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // ENTRY CONFIRMATION (1m / ENTRY)\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Confirm entry conditions\r\n   */\r\n  private confirmEntry(\r\n    ema: TimeframeEMA | undefined,\r\n    rsi: number | undefined,\r\n    highs: SwingPoint[],\r\n    lows: SwingPoint[],\r\n    price: number,\r\n    trendBias: TrendBias,\r\n  ): EntryConfirmation {\r\n    if (!ema?.fast || !ema.slow || rsi === undefined) {\r\n      return {\r\n        confirmed: false,\r\n        rsi: rsi || 0,\r\n        rsiCrossed: false,\r\n        candleClosed: false,\r\n        zigzagConfirmed: false,\r\n        reason: 'Missing data',\r\n      };\r\n    }\r\n\r\n    // RSI crossed threshold\r\n    const rsiCrossed =\r\n      (trendBias === TrendBias.BULLISH && rsi > this.config.rsiLongThreshold) ||\r\n      (trendBias === TrendBias.BEARISH && rsi < this.config.rsiShortThreshold);\r\n\r\n    // Candle closed above/below EMAs\r\n    const candleClosed =\r\n      (trendBias === TrendBias.BULLISH && price > ema.fast && price > ema.slow) ||\r\n      (trendBias === TrendBias.BEARISH && price < ema.fast && price < ema.slow);\r\n\r\n    // ZigZag confirms new wave (HH for LONG, LL for SHORT)\r\n    const structure = this.structureAnalyzer.identifyStructure(highs, lows);\r\n    const zigzagConfirmed =\r\n      (trendBias === TrendBias.BULLISH && structure === MarketStructure.HIGHER_HIGH) ||\r\n      (trendBias === TrendBias.BEARISH && structure === MarketStructure.LOWER_LOW);\r\n\r\n    const confirmed = rsiCrossed && candleClosed && zigzagConfirmed;\r\n\r\n    const reason = confirmed\r\n      ? 'Entry confirmed: RSI crossed, candle closed, ZigZag confirms'\r\n      : `Entry not confirmed: RSI=${rsiCrossed}, candle=${candleClosed}, ZigZag=${zigzagConfirmed}`;\r\n\r\n    return {\r\n      confirmed,\r\n      rsi,\r\n      rsiCrossed,\r\n      candleClosed,\r\n      zigzagConfirmed,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // FILTERS\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if EMA20 ‚âà EMA50 (flat market)\r\n   */\r\n  private isEmaFlat(fast: number, slow: number): boolean {\r\n    const diff = Math.abs(fast - slow) / slow;\r\n    return diff < this.config.emaFlatThreshold;\r\n  }\r\n\r\n  /**\r\n   * Check if RSI is in neutral zone (45-55)\r\n   */\r\n  private isRsiNeutral(rsi: number): boolean {\r\n    return rsi >= this.config.rsiNeutralZone.min && rsi <= this.config.rsiNeutralZone.max;\r\n  }\r\n\r\n  /**\r\n   * Check if price is too far from EMA50\r\n   */\r\n  private isPriceTooFar(price: number, ema50: number): boolean {\r\n    const distance = Math.abs(price - ema50) / ema50;\r\n    return distance > this.config.emaDistanceThreshold / PERCENT_MULTIPLIER;\r\n  }\r\n\r\n  /**\r\n   * Check ATR volatility\r\n   *\r\n   * @param candles - PRIMARY timeframe candles\r\n   * @returns ATRAnalysis result\r\n   */\r\n  private checkATR(candles: Candle[]): { isValid: boolean; value?: number; reason?: string } {\r\n    if (!this.atrIndicator || !this.atrFilterConfig) {\r\n      return { isValid: true }; // If not enabled, always valid\r\n    }\r\n\r\n    try {\r\n      const atr = this.atrIndicator.calculate(candles);\r\n      const { minimumATR, maximumATR } = this.atrFilterConfig;\r\n\r\n      // Check if ATR is within valid range\r\n      if (atr < minimumATR) {\r\n        return {\r\n          isValid: false,\r\n          value: atr,\r\n          reason: `ATR too low (${atr.toFixed(DECIMAL_PLACES.PERCENT)}% < ${minimumATR}%) - low volatility/flat market`,\r\n        };\r\n      }\r\n\r\n      if (atr > maximumATR) {\r\n        return {\r\n          isValid: false,\r\n          value: atr,\r\n          reason: `ATR too high (${atr.toFixed(DECIMAL_PLACES.PERCENT)}% > ${maximumATR}%) - extreme volatility/risk`,\r\n        };\r\n      }\r\n\r\n      // ATR is valid\r\n      this.logger.debug(`ATR valid: ${atr.toFixed(DECIMAL_PLACES.PERCENT)}% (range: ${minimumATR}%-${maximumATR}%)`);\r\n      return {\r\n        isValid: true,\r\n        value: atr,\r\n      };\r\n    } catch (error) {\r\n      // If ATR calculation fails (e.g., not enough candles), treat as invalid\r\n      this.logger.warn(`ATR calculation failed: ${error}`);\r\n      return {\r\n        isValid: false,\r\n        reason: 'ATR calculation failed (not enough candles)',\r\n      };\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // CONFIDENCE CALCULATION\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate confidence score (0-1)\r\n   * Uses weights from config or defaults\r\n   */\r\n  private calculateConfidence(\r\n    trend: TrendState,\r\n    pullback: PullbackState,\r\n    entry: EntryConfirmation,\r\n    data?: SmartTrendData,\r\n  ): number {\r\n    // Use Weight Matrix if enabled and data provided\r\n    if (this.weightMatrix && data) {\r\n      const direction =\r\n        trend.bias === TrendBias.BULLISH ? SignalDirection.LONG : SignalDirection.SHORT;\r\n\r\n      // Build WeightMatrixInput\r\n      const input: WeightMatrixInput = {\r\n        rsi: data.rsi.entry,\r\n        ema: data.ema.entry\r\n          ? {\r\n            fast: data.ema.entry.fast || 0,\r\n            slow: data.ema.entry.slow || 0,\r\n            price: data.currentPrice,\r\n          }\r\n          : undefined,\r\n        swingPoints: { quality: trend.isValid ? MULTIPLIERS.NEUTRAL : 0.0 },\r\n        seniorTFAlignment: {\r\n          aligned: trend.isValid && pullback.detected,\r\n          strength: trend.isValid && pullback.isComplete ? MULTIPLIERS.NEUTRAL : MULTIPLIERS.HALF,\r\n        },\r\n        tfAlignmentScore:\r\n          data.tfAlignment && direction === SignalDirection.LONG\r\n            ? data.tfAlignment.long.score\r\n            : data.tfAlignment\r\n              ? data.tfAlignment.short.score\r\n              : undefined, // PHASE 6: Multi-timeframe alignment\r\n      };\r\n\r\n      const scoreBreakdown = this.weightMatrix.calculateScore(input, direction);\r\n      const confidence = scoreBreakdown.confidence / PERCENT_MULTIPLIER; // Convert to 0-1 range\r\n\r\n      // Log contributions for transparency\r\n      this.logger.info('üìä SmartTrend Weight Matrix Score', {\r\n        confidence: (confidence * PERCENT_MULTIPLIER).toFixed(1) + '%',\r\n        totalScore: `${scoreBreakdown.totalScore.toFixed(1)}/${scoreBreakdown.maxPossibleScore}`,\r\n        rsi: scoreBreakdown.contributions.rsi?.reason,\r\n        ema: scoreBreakdown.contributions.ema?.reason,\r\n        swingPoints: scoreBreakdown.contributions.swingPoints?.reason,\r\n        seniorTF: scoreBreakdown.contributions.seniorTFAlignment?.reason,\r\n      });\r\n\r\n      return confidence;\r\n    }\r\n\r\n    // Legacy confidence calculation\r\n    let confidence = 0;\r\n\r\n    // Trend on 5m (critical - 50%)\r\n    if (trend.isValid) {\r\n      confidence += MULTIPLIERS.HALF;\r\n    }\r\n\r\n    // Pullback on 1m (important - 30%)\r\n    if (pullback.detected) {\r\n      confidence += pullback.isComplete ? 0.3 : PERCENTAGE_THRESHOLDS.VERY_LOW;\r\n    }\r\n\r\n    // Entry confirmation (desirable - 20%)\r\n    if (entry.confirmed) {\r\n      confidence += 0.2;\r\n    } else {\r\n      // Partial credit for individual confirmations\r\n      if (entry.rsiCrossed) {\r\n        confidence += 0.07;\r\n      }\r\n      if (entry.candleClosed) {\r\n        confidence += 0.07;\r\n      }\r\n      if (entry.zigzagConfirmed) {\r\n        confidence += 0.06;\r\n      }\r\n    }\r\n\r\n    return Math.min(confidence, 1.0);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\strategy.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\trend-following.strategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Candle' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'WickDirection' is defined but never used. Allowed unused vars must match /^_/u.","line":33,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'VOLUME_MIN_RATIO' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":49,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ATH_DROP_THRESHOLD' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":50,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'BASE_CONFIDENCE_SWEEP' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":54,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":28},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":97,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":97,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3902,3917],"text":"config.patterns != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":102,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":102,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4081,4093],"text":"weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":111,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":111,"endColumn":17},{"ruleId":"complexity","severity":1,"message":"Async method 'evaluate' has a complexity of 36. Maximum allowed is 10.","line":111,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":398,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":188,"column":57,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":188,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7426,7440],"text":"(data.emaTrend1 != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"eqeqeq","severity":2,"message":"Expected '===' and instead saw '=='.","line":207,"column":19,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":207,"endColumn":21},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 288.","line":261,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":261,"endColumn":33},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: -288.","line":264,"column":54,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":264,"endColumn":58},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":296,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":296,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12279,12296],"text":"this.weightMatrix != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":303,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":303,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12568,12583],"text":"(data.stochastic != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":305,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":305,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12757,12776],"text":"(data.bollingerBands != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":306,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":306,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12849,12857],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[12849,12857],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[12849,12857],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":317,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":317,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13340,13356],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":319,"column":15,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":319,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[13453,13469],"text":"(data.tfAlignment != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 0.8.","line":341,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":341,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 1.1.","line":344,"column":28,"nodeType":"Literal","messageId":"noMagic","endLine":344,"endColumn":31},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":358,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":358,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15120,15140],"text":"this.patternAnalyzer != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":410,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":410,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16795,16803],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16795,16803],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16795,16803],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":410,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":410,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[16804,16806],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (350). Maximum allowed is 300.","line":437,"column":1,"nodeType":null,"messageId":"exceed","endLine":501,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":468,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":468,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18808,18816],"text":"(data.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[18808,18816],"text":"(data.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[18808,18816],"text":"(Boolean(data.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":468,"column":23,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":468,"endColumn":25,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[18817,18819],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":470,"column":55,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":470,"endColumn":72,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[18941,18947],"text":"SwingPointType.HIGH"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"@typescript-eslint/no-unsafe-enum-comparison","severity":2,"message":"The two values in this comparison do not have a shared enum type.","line":471,"column":54,"nodeType":"BinaryExpression","messageId":"mismatchedCondition","endLine":471,"endColumn":70,"suggestions":[{"messageId":"replaceValueWithEnum","fix":{"range":[19022,19027],"text":"SwingPointType.LOW"},"desc":"Replace with an enum value comparison."}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 50.","line":489,"column":35,"nodeType":"Literal","messageId":"noMagic","endLine":489,"endColumn":37}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_THRESHOLDS, DECIMAL_PLACES, MULTIPLIERS, PERCENT_MULTIPLIER, PERCENTAGE_THRESHOLDS } from '../constants';\r\n/**\r\n * Trend-Following Strategy (Priority 1 - Highest)\r\n *\r\n * Entry conditions:\r\n * 1. Price in established trend (EMA alignment)\r\n * 2. RSI pullback in trend direction (oversold for LONG, overbought for SHORT)\r\n * 3. Volume confirmation (> 0.5x avg)\r\n * 4. No large opposing wicks (> 2x body)\r\n * 5. Not at ATH for LONG (< 0.2% drop from 24h high)\r\n * 6. Price Action confirmation (liquidity sweep, divergence, CHoCH)\r\n *\r\n * Confidence modifiers:\r\n * - Distance from EMA: closer = higher confidence\r\n * - Volume: high volume (+10%), low volume (-10%)\r\n * - Price Action boosts: divergence, CHoCH, liquidity sweep\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategyMarketData,\r\n  StrategySignal,\r\n  Signal,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  Candle,\r\n  SessionBasedSLConfig,\r\n  WeightMatrixInput,\r\n  SignalScoreBreakdown,\r\n} from '../types';\r\nimport { VolumeCalculator } from '../analyzers/volume.calculator';\r\nimport { WickAnalyzer, WickDirection } from '../analyzers/wick.analyzer';\r\nimport { ConfidenceHelper } from '../utils/confidence.helper';\r\nimport { SessionDetector } from '../utils/session-detector';\r\nimport { PatternAnalyzerHelper, PatternAnalyzerConfig } from '../analyzers/pattern-analyzer.helper';\r\nimport { WeightMatrixCalculatorService } from '../services/weight-matrix-calculator.service';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst STRATEGY_NAME = 'TrendFollowing';\r\nconst STRATEGY_PRIORITY = 1; // Highest priority\r\n\r\nconst RSI_OVERSOLD = PERCENTAGE_THRESHOLDS.MODERATE; // RSI < 30 for LONG\r\nconst RSI_OVERBOUGHT = CONFIDENCE_THRESHOLDS.MODERATE; // RSI > 70 for SHORT\r\n\r\nconst VOLUME_MIN_RATIO = 0.5; // Volume must be > 0.5x avg\r\nconst ATH_DROP_THRESHOLD = 0.2; // < 0.2% drop from high = at ATH\r\nconst EMA_DISTANCE_MAX = 5.5; // Max distance from EMA (%)\r\n\r\nconst BASE_CONFIDENCE_REVERSAL = 0.75;\r\nconst BASE_CONFIDENCE_SWEEP = 0.80;\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface TrendFollowingConfig {\r\n  enabled: boolean;\r\n  volumeEnabled: boolean;\r\n  wickDetectionEnabled: boolean;\r\n  athProtectionEnabled: boolean;\r\n  blockLongInDowntrend: boolean; // Block LONG if EMA20 < EMA50 AND RSI < 50\r\n  useHigherTimeframeConfirmation: boolean; // Use TREND1 (30m) for confirmation\r\n  minVolumeRatio: number;\r\n  athDropThreshold: number;\r\n  stopLossAtrMultiplier: number; // ATR multiplier for stop-loss (e.g., 1.0)\r\n  takeProfits: Array<{ level: number; percent: number; sizePercent: number }>;\r\n  sessionBasedSL?: SessionBasedSLConfig; // Optional session-based SL widening\r\n  patterns?: PatternAnalyzerConfig; // Pattern detection configuration\r\n}\r\n\r\n// ============================================================================\r\n// TREND-FOLLOWING STRATEGY\r\n// ============================================================================\r\n\r\nexport class TrendFollowingStrategy implements IStrategy {\r\n  readonly name = STRATEGY_NAME;\r\n  readonly priority = STRATEGY_PRIORITY;\r\n\r\n  private volumeCalculator: VolumeCalculator;\r\n  private wickAnalyzer: WickAnalyzer;\r\n  private patternAnalyzer: PatternAnalyzerHelper | null = null;\r\n  private weightMatrix: WeightMatrixCalculatorService | null = null;\r\n\r\n  constructor(\r\n    private config: TrendFollowingConfig,\r\n    private logger: LoggerService,\r\n    weightMatrix?: WeightMatrixCalculatorService,\r\n  ) {\r\n    this.volumeCalculator = new VolumeCalculator(logger);\r\n    this.wickAnalyzer = new WickAnalyzer(logger);\r\n\r\n    // Initialize pattern analyzer if any patterns are configured\r\n    if (config.patterns) {\r\n      this.patternAnalyzer = new PatternAnalyzerHelper(config.patterns, logger, STRATEGY_NAME);\r\n    }\r\n\r\n    // Initialize weight matrix if provided\r\n    if (weightMatrix) {\r\n      this.weightMatrix = weightMatrix;\r\n      this.logger.info(`${STRATEGY_NAME} Strategy: Weight Matrix enabled`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate market data for trend-following entry\r\n   */\r\n  async evaluate(data: StrategyMarketData): Promise<StrategySignal> {\r\n    this.logger.info(`üîç ${this.name} Strategy Evaluation`, {\r\n      price: data.currentPrice,\r\n      rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      trend: data.trend,\r\n      swingPoints: data.swingPoints.length,\r\n      liquidityZones: data.liquidity?.zones?.length ?? 0,\r\n    });\r\n\r\n    // ========================================================================\r\n    // STEP 1: Volume Check\r\n    // ========================================================================\r\n    if (this.config.volumeEnabled) {\r\n      const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n\r\n      this.logger.info(`üìä ${this.name} Volume Check`, {\r\n        volumeRatio: volumeAnalysis.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        isLowVolume: volumeAnalysis.isLowVolume,\r\n        isHighVolume: volumeAnalysis.isHighVolume,\r\n        threshold: this.config.minVolumeRatio,\r\n      });\r\n\r\n      if (volumeAnalysis.isLowVolume) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['LOW_VOLUME'],\r\n          volumeRatio: volumeAnalysis.volumeRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n          threshold: this.config.minVolumeRatio,\r\n        });\r\n        return this.noSignal('Low volume - insufficient liquidity');\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 2: Entry Pattern Detection\r\n    // ========================================================================\r\n    const currentCandle = data.candles[data.candles.length - 1];\r\n\r\n    // Pattern 1: RSI Reversal (classic)\r\n    let direction: SignalDirection | null = null;\r\n    let confidence = BASE_CONFIDENCE_REVERSAL;\r\n    let reason = '';\r\n\r\n    const longConditions = {\r\n      rsiOversold: data.rsi < RSI_OVERSOLD,\r\n      trendBullish: data.trend === 'BULLISH',\r\n    };\r\n\r\n    const shortConditions = {\r\n      rsiOverbought: data.rsi > RSI_OVERBOUGHT,\r\n      trendBearish: data.trend === 'BEARISH',\r\n    };\r\n\r\n    this.logger.info(`üìä ${this.name} RSI Pattern Check`, {\r\n      rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n      trend: data.trend,\r\n      longConditions,\r\n      shortConditions,\r\n    });\r\n\r\n    if (longConditions.rsiOversold && longConditions.trendBullish) {\r\n      direction = SignalDirection.LONG;\r\n      reason = `RSI oversold (${data.rsi.toFixed(1)}) in BULLISH trend`;\r\n      this.logger.info(`‚úÖ ${this.name} LONG pattern found`, { reason });\r\n\r\n      // Check downtrend filter for LONG\r\n      if (this.config.blockLongInDowntrend) {\r\n        if (this.isDowntrend(data.rsi, data.ema.fast, data.ema.slow)) {\r\n          this.logger.info('‚ùå LONG blocked in downtrend (PRIMARY)', {\r\n            ema20: data.ema.fast,\r\n            ema50: data.ema.slow,\r\n            rsi: data.rsi.toFixed(DECIMAL_PLACES.PERCENT),\r\n          });\r\n          return this.noSignal('LONG blocked: downtrend on PRIMARY (EMA20 < EMA50 AND RSI < 50)');\r\n        }\r\n      }\r\n\r\n      // Check higher timeframe (TREND1 30m) confirmation for LONG\r\n      if (this.config.useHigherTimeframeConfirmation && data.emaTrend1 && data.rsiTrend1 !== undefined) {\r\n        if (this.isDowntrend(data.rsiTrend1, data.emaTrend1.fast, data.emaTrend1.slow)) {\r\n          this.logger.info('‚ùå LONG blocked in downtrend (TREND1 30m)', {\r\n            ema20: data.emaTrend1.fast,\r\n            ema50: data.emaTrend1.slow,\r\n            rsi: data.rsiTrend1.toFixed(DECIMAL_PLACES.PERCENT),\r\n          });\r\n          return this.noSignal('LONG blocked: downtrend on TREND1 30m (EMA20 < EMA50 AND RSI < 50)');\r\n        }\r\n      }\r\n    } else if (shortConditions.rsiOverbought && shortConditions.trendBearish) {\r\n      direction = SignalDirection.SHORT;\r\n      reason = `RSI overbought (${data.rsi.toFixed(1)}) in BEARISH trend`;\r\n      this.logger.info(`‚úÖ ${this.name} SHORT pattern found`, { reason });\r\n    }\r\n\r\n    // No entry pattern found\r\n    // NOTE: RSI filter DISABLED - Weight System handles RSI now as MODIFIER, not blocker\r\n    // TrendFollowing still requires clear trend, but RSI becomes optional (Weight System penalty)\r\n    if (direction == null) {\r\n      const blockedBy = [];\r\n      // RSI check removed - Weight System will apply penalty if RSI not ideal\r\n      // if (!longConditions.rsiOversold && !shortConditions.rsiOverbought) {\r\n      //   blockedBy.push('RSI_NOT_IN_REVERSAL_ZONE');\r\n      // }\r\n      if (!longConditions.trendBullish && !shortConditions.trendBearish) {\r\n        blockedBy.push('NO_CLEAR_TREND');\r\n      }\r\n\r\n      if (blockedBy.length > 0) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy,\r\n          reason: blockedBy.join(', '),\r\n        });\r\n        return this.noSignal(`Blocked: ${blockedBy.join(', ')}`);\r\n      }\r\n\r\n      // If no blocks but still no direction - return (should not happen in normal flow)\r\n      return this.noSignal('No entry pattern found');\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 3: Wick Check (blocks opposite direction)\r\n    // ========================================================================\r\n    if (this.config.wickDetectionEnabled) {\r\n      const wickAnalysis = this.wickAnalyzer.analyze(currentCandle);\r\n\r\n      this.logger.info(`üìä ${this.name} Wick Check`, {\r\n        wickDirection: wickAnalysis.wickDirection,\r\n        wickToBodyRatio: wickAnalysis.wickToBodyRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        signalDirection: direction,\r\n        blocks: this.wickAnalyzer.blocksSignal(wickAnalysis, direction),\r\n      });\r\n\r\n      if (this.wickAnalyzer.blocksSignal(wickAnalysis, direction)) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['LARGE_OPPOSING_WICK'],\r\n          wickDirection: wickAnalysis.wickDirection,\r\n          signalDirection: direction,\r\n          ratio: wickAnalysis.wickToBodyRatio.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n        return this.noSignal(\r\n          `Large ${wickAnalysis.wickDirection} wick blocks ${direction} entry`,\r\n        );\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 4: ATH Protection (only for LONG)\r\n    // ========================================================================\r\n    if (\r\n      this.config.athProtectionEnabled &&\r\n      direction === SignalDirection.LONG &&\r\n      data.candles.length >= 288\r\n    ) {\r\n      // 288 x 5m = 24h\r\n      const high24h = Math.max(...data.candles.slice(-288).map((c) => c.high));\r\n      const dropFromHigh = ((high24h - data.currentPrice) / high24h) * PERCENT_MULTIPLIER;\r\n\r\n      this.logger.info(`üìä ${this.name} ATH Check`, {\r\n        high24h: high24h.toFixed(DECIMAL_PLACES.PRICE),\r\n        currentPrice: data.currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        dropFromHigh: dropFromHigh.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n        threshold: this.config.athDropThreshold + '%',\r\n        atATH: dropFromHigh < this.config.athDropThreshold,\r\n      });\r\n\r\n      if (dropFromHigh < this.config.athDropThreshold) {\r\n        this.logger.info(`‚ùå ${this.name} BLOCKED`, {\r\n          blockedBy: ['AT_ATH'],\r\n          dropFromHigh: dropFromHigh.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n          threshold: this.config.athDropThreshold + '%',\r\n        });\r\n        return this.noSignal('At ATH - avoid buying tops');\r\n      }\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 5: Calculate Confidence (Weight Matrix or Legacy)\r\n    // ========================================================================\r\n    let scoreBreakdown: SignalScoreBreakdown | null = null;\r\n\r\n    // Calculate EMA distance (used by both Weight Matrix and legacy)\r\n    const ema50 = data.ema.slow;\r\n    const emaDistance = Math.abs(((data.currentPrice - ema50) / ema50) * PERCENT_MULTIPLIER);\r\n    let distanceModifier = 1.0;\r\n\r\n    // Use Weight Matrix if enabled\r\n    if (this.weightMatrix) {\r\n      // Build WeightMatrixInput\r\n      const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n      const currentCandle = data.candles[data.candles.length - 1];\r\n\r\n      const input: WeightMatrixInput = {\r\n        rsi: data.rsi,\r\n        stochastic: data.stochastic ? { k: data.stochastic.k, d: data.stochastic.d } : undefined,\r\n        ema: { fast: data.ema.fast, slow: data.ema.slow, price: data.currentPrice },\r\n        bollingerBands: data.bollingerBands ? { position: data.bollingerBands.percentB } : undefined,\r\n        atr: data.atr ? { current: data.atr, average: data.atr } : undefined,\r\n        volume: {\r\n          current: currentCandle.volume,\r\n          average: volumeAnalysis.avgVolume,\r\n        },\r\n        levelDistance: { percent: emaDistance },\r\n        seniorTFAlignment: {\r\n          aligned: data.trend === (direction === SignalDirection.LONG ? 'BULLISH' : 'BEARISH'),\r\n          strength: MULTIPLIERS.NEUTRAL, // Trend-following = strong alignment\r\n        },\r\n        tfAlignmentScore:\r\n          data.tfAlignment && direction === SignalDirection.LONG\r\n            ? data.tfAlignment.long.score\r\n            : data.tfAlignment\r\n              ? data.tfAlignment.short.score\r\n              : undefined, // PHASE 6: Multi-timeframe alignment\r\n      };\r\n\r\n      scoreBreakdown = this.weightMatrix.calculateScore(input, direction);\r\n      confidence = scoreBreakdown.confidence;\r\n\r\n      // Log contributions for transparency\r\n      this.logger.info(`üìä ${this.name} Weight Matrix Score`, {\r\n        confidence: confidence.toFixed(1) + '%',\r\n        totalScore: `${scoreBreakdown.totalScore.toFixed(1)}/${scoreBreakdown.maxPossibleScore}`,\r\n        rsi: scoreBreakdown.contributions.rsi?.reason,\r\n        volume: scoreBreakdown.contributions.volume?.reason,\r\n        ema: scoreBreakdown.contributions.ema?.reason,\r\n        stochastic: scoreBreakdown.contributions.stochastic?.reason,\r\n        seniorTFAlignment: scoreBreakdown.contributions.seniorTFAlignment?.reason,\r\n      });\r\n    } else {\r\n      // Legacy confidence calculation\r\n      if (emaDistance > EMA_DISTANCE_MAX) {\r\n        // Too far from EMA\r\n        distanceModifier = 0.8; // -20% confidence\r\n      } else if (emaDistance < 1.0) {\r\n        // Very close to EMA\r\n        distanceModifier = 1.1; // +10% confidence\r\n      }\r\n\r\n      confidence *= distanceModifier;\r\n\r\n      // Volume modifier\r\n      if (this.config.volumeEnabled) {\r\n        const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n        confidence *= volumeAnalysis.volumeModifier;\r\n      }\r\n\r\n      // ========================================================================\r\n      // STEP 5.5: Pattern Analysis (all patterns via helper)\r\n      // ========================================================================\r\n      if (this.patternAnalyzer) {\r\n        const patternResult = this.patternAnalyzer.analyzePatterns({\r\n          candles: data.candles,\r\n          swingPoints: data.swingPoints,\r\n          direction,\r\n          trend: data.trend,\r\n          strategyName: this.name,\r\n        });\r\n\r\n        confidence += patternResult.confidenceBoost;\r\n        reason += patternResult.reasonAdditions;\r\n      }\r\n\r\n      // Normalize confidence to 0-100 range\r\n      confidence = ConfidenceHelper.normalize(confidence);\r\n    }\r\n\r\n    // ========================================================================\r\n    // STEP 7: Build Signal\r\n    // ========================================================================\r\n    const signal = this.buildSignal(direction, confidence, data, reason);\r\n\r\n    this.logger.info(`‚úÖ ${this.name} SIGNAL GENERATED!`, {\r\n      direction,\r\n      confidence: confidence.toFixed(DECIMAL_PLACES.PERCENT),\r\n      reason,\r\n      emaDistance: emaDistance.toFixed(DECIMAL_PLACES.PERCENT) + '%',\r\n      distanceModifier: distanceModifier.toFixed(DECIMAL_PLACES.PERCENT),\r\n      entry: data.currentPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n      sl: signal.stopLoss.toFixed(DECIMAL_PLACES.PRICE),\r\n      tp1: signal.takeProfits[0]?.price?.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    return {\r\n      valid: true,\r\n      signal,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build a trading signal\r\n   */\r\n  private buildSignal(\r\n    direction: SignalDirection,\r\n    confidence: number,\r\n    data: StrategyMarketData,\r\n    reason: string,\r\n  ): Signal {\r\n    const price = data.currentPrice;\r\n    const atrPercent = data.atr || 1.0; // ATR in percent (e.g., 1.5%)\r\n\r\n    // Convert ATR from percent to absolute value\r\n    const atrAbsolute = price * (atrPercent / PERCENT_MULTIPLIER);\r\n\r\n    // Stop loss: configurable ATR multiplier\r\n    let stopLossDistance = atrAbsolute * this.config.stopLossAtrMultiplier;\r\n\r\n    // Enforce minimum SL distance to avoid too tight stops (critical fix for low ATR markets)\r\n    const MIN_SL_DISTANCE_PERCENT = 1.0; // 1% minimum (prevents 0.2-0.7% stops that get hit immediately)\r\n    const minSlDistance = price * (MIN_SL_DISTANCE_PERCENT / PERCENT_MULTIPLIER);\r\n    stopLossDistance = Math.max(stopLossDistance, minSlDistance);\r\n\r\n    // Apply session-based SL widening if enabled\r\n    stopLossDistance = SessionDetector.applySessionBasedSL(\r\n      stopLossDistance,\r\n      this.config.sessionBasedSL,\r\n      this.logger,\r\n      this.name,\r\n    );\r\n\r\n    const stopLoss =\r\n      direction === SignalDirection.LONG\r\n        ? price - stopLossDistance\r\n        : price + stopLossDistance;\r\n\r\n    // Take profits: from config\r\n    const takeProfits = this.config.takeProfits.map(tp => ({\r\n      level: tp.level,\r\n      percent: tp.percent,\r\n      sizePercent: tp.sizePercent,\r\n      price:\r\n        direction === SignalDirection.LONG\r\n          ? price * (1 + tp.percent / PERCENT_MULTIPLIER)\r\n          : price * (1 - tp.percent / PERCENT_MULTIPLIER),\r\n      hit: false,\r\n    }));\r\n\r\n    // Calculate volume ratio\r\n    const volumeAnalysis = this.volumeCalculator.calculate(data.candles);\r\n\r\n    // Calculate distance to EMA (use slow EMA as primary)\r\n    const distanceToEma = Math.abs((price - data.ema.slow) / price) * PERCENT_MULTIPLIER;\r\n\r\n    return {\r\n      direction,\r\n      type: SignalType.TREND_FOLLOWING,\r\n      confidence,\r\n      price,\r\n      stopLoss,\r\n      takeProfits,\r\n      reason,\r\n      timestamp: data.timestamp,\r\n      marketData: {\r\n        rsi: data.rsi,\r\n        rsiTrend1: data.rsiTrend1,\r\n        ema20: data.ema.fast,\r\n        ema50: data.ema.slow,\r\n        atr: data.atr || 1.0,\r\n        volumeRatio: volumeAnalysis.volumeRatio,\r\n        swingHighsCount: data.swingPoints.filter(s => s.type === 'HIGH').length,\r\n        swingLowsCount: data.swingPoints.filter(s => s.type === 'LOW').length,\r\n        trend: data.trend,\r\n        distanceToEma,\r\n        stochastic: data.stochastic,\r\n        bollingerBands: data.bollingerBands,\r\n        breakoutPrediction: data.breakoutPrediction,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Return no signal result\r\n   */\r\n  /**\r\n   * Check if market is in downtrend\r\n   * Downtrend = EMA20 < EMA50 AND RSI < 50\r\n   */\r\n  private isDowntrend(rsi: number, ema20: number, ema50: number): boolean {\r\n    return ema20 < ema50 && rsi < 50;\r\n  }\r\n\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\whale-hunter-follow.strategy.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":65,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":65,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":77,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":77,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2514,2535],"text":"marketData.orderbook == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":251,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":251,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8732,8746],"text":"(marketData.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8732,8746],"text":"(marketData.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8732,8746],"text":"(Boolean(marketData.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":251,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":251,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8747,8749],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":285,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":285,"endColumn":48,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[9816,9854],"text":"((this.config.dynamicTakeProfit?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[9815,9854],"text":"(this.config.dynamicTakeProfit?.enabled) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":312,"column":59,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":312,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[10808,10822],"text":"(marketData.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[10808,10822],"text":"(marketData.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[10808,10822],"text":"(Boolean(marketData.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (301). Maximum allowed is 300.","line":458,"column":1,"nodeType":null,"messageId":"exceed","endLine":459,"endColumn":1}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, MULTIPLIERS, PERCENT_MULTIPLIER, SIGNAL_CONSTANTS } from '../constants';\r\n/**\r\n * Whale Hunter FOLLOW Strategy\r\n *\r\n * Philosophy: Trade WITH the whale (not against momentum)\r\n *\r\n * Uses WhaleDetectorFollowService with inverted WALL_BREAK logic:\r\n * - BID wall broken ‚Üí SHORT (whale sold = distribution)\r\n * - ASK wall broken ‚Üí LONG (whale bought = accumulation)\r\n *\r\n * Risk Management:\r\n * - Small position size (high risk)\r\n * - Tight stop-loss (whales can deceive)\r\n * - Quick take-profit (exit before whale changes mind)\r\n * - Time-based exit (if no movement in 30s)\r\n *\r\n * IMPORTANT: Requires frequent order book updates!\r\n * - WebSocket orderbook stream recommended\r\n * - REST API polling should be < 5 seconds\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategySignal,\r\n  StrategyMarketData,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  WhaleHunterConfig,\r\n  TakeProfit,\r\n  OrderBookAnalysis,\r\n  OrderbookLevel,\r\n} from '../types';\r\nimport { WhaleDetectorFollowService, WhaleSignal, WhaleDetectionMode } from '../services/whale-detector-follow.service';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { SessionDetector } from '../utils/session-detector';\r\n\r\n// ============================================================================\r\n// WHALE HUNTER STRATEGY\r\n// ============================================================================\r\n\r\nexport class WhaleHunterFollowStrategy implements IStrategy {\r\n  readonly name = 'WHALE_HUNTER_FOLLOW';\r\n  readonly priority: number;\r\n\r\n  private lastTradeTime: number = 0;\r\n  private consecutiveSignals: number = 0;\r\n  private lastSignalMode: WhaleDetectionMode | null = null;\r\n\r\n  constructor(\r\n    private config: WhaleHunterConfig,\r\n    private whaleDetector: WhaleDetectorFollowService,\r\n    private orderbookAnalyzer: OrderBookAnalyzer,\r\n    private logger: LoggerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n  }\r\n\r\n  /**\r\n   * Evaluate whale hunter strategy\r\n   *\r\n   * @param marketData - Market data (must include orderbook)\r\n   * @returns Strategy signal\r\n   */\r\n  async evaluate(marketData: StrategyMarketData): Promise<StrategySignal> {\r\n    // Check if strategy is enabled\r\n    if (!this.config.enabled) {\r\n      return this.noSignal('Strategy disabled');\r\n    }\r\n\r\n    // Check cooldown (avoid over-trading)\r\n    if (this.isInCooldown()) {\r\n      return this.noSignal('In cooldown period');\r\n    }\r\n\r\n    // Check if we have order book data\r\n    if (!marketData.orderbook) {\r\n      this.logger.warn('WhaleHunterStrategy: No orderbook data available');\r\n      return this.noSignal('No orderbook data');\r\n    }\r\n\r\n    // Analyze order book\r\n    const currentPrice = marketData.candles[marketData.candles.length - 1].close;\r\n\r\n    // Convert OrderBook to OrderBookData format\r\n    // Handle both tuple format [price, size] and object format {price, size}\r\n    const getPrice = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n    };\r\n    const getSize = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n    };\r\n\r\n    const bids = marketData.orderbook.bids.map((b: OrderbookLevel) => ({\r\n      price: getPrice(b),\r\n      size: getSize(b),\r\n    }));\r\n\r\n    const asks = marketData.orderbook.asks.map((a: OrderbookLevel) => ({\r\n      price: getPrice(a),\r\n      size: getSize(a),\r\n    }));\r\n\r\n    const orderbookData = {\r\n      bids,\r\n      asks,\r\n      timestamp: marketData.orderbook.timestamp,\r\n    };\r\n\r\n    const orderbookAnalysis = this.orderbookAnalyzer.analyze(orderbookData, currentPrice);\r\n\r\n    // Detect whale activity\r\n    const whaleSignal = this.whaleDetector.detectWhale(orderbookAnalysis, currentPrice);\r\n\r\n    // Check if whale detected\r\n    if (!whaleSignal.detected) {\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal('No whale detected');\r\n    }\r\n\r\n    // Check confidence threshold\r\n    if (whaleSignal.confidence < this.config.minConfidence) {\r\n      this.logger.debug('WhaleHunterStrategy: Confidence too low', {\r\n        confidence: whaleSignal.confidence,\r\n        threshold: this.config.minConfidence,\r\n      });\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal(`Confidence too low: ${whaleSignal.confidence}`);\r\n    }\r\n\r\n    // Track consecutive signals\r\n    this.trackConsecutiveSignals(whaleSignal);\r\n\r\n    // Check if we need multiple signals\r\n    if (this.config.requireMultipleSignals && this.consecutiveSignals < SIGNAL_CONSTANTS.MIN_CONSECUTIVE_SIGNALS) {\r\n      this.logger.debug('WhaleHunterStrategy: Waiting for consecutive signal', {\r\n        current: this.consecutiveSignals,\r\n        required: SIGNAL_CONSTANTS.MIN_CONSECUTIVE_SIGNALS,\r\n      });\r\n      return this.noSignal('Waiting for consecutive signal');\r\n    }\r\n\r\n    // WHALE SIGNAL CONFIRMED - Generate strategy signal\r\n    const strategySignal = this.generateStrategySignal(whaleSignal, marketData, orderbookAnalysis);\r\n\r\n    // Mark trade time for cooldown\r\n    this.lastTradeTime = Date.now();\r\n    this.resetConsecutiveSignals();\r\n\r\n    return strategySignal;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Signal Generation\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Generate strategy signal from whale signal\r\n   */\r\n  private generateStrategySignal(\r\n    whaleSignal: WhaleSignal,\r\n    marketData: StrategyMarketData,\r\n    orderbookAnalysis: OrderBookAnalysis,\r\n  ): StrategySignal {\r\n    const currentCandle = marketData.candles[marketData.candles.length - 1];\r\n    const currentPrice = currentCandle.close;\r\n\r\n    // Calculate risk/reward based on whale mode\r\n    const { stopLossPercent, takeProfitPercent } = this.calculateRiskReward(whaleSignal.mode!);\r\n\r\n    // Calculate entry, SL prices\r\n    const direction = whaleSignal.direction!;\r\n    const entryPrice = currentPrice;\r\n\r\n    // Calculate base SL distance\r\n    let stopLossDistance = entryPrice * (stopLossPercent / PERCENT_MULTIPLIER);\r\n\r\n    // Apply session-based SL widening if enabled\r\n    stopLossDistance = SessionDetector.applySessionBasedSL(\r\n      stopLossDistance,\r\n      this.config.sessionBasedSL,\r\n      this.logger,\r\n      this.name,\r\n    );\r\n\r\n    const stopLoss =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice - stopLossDistance\r\n        : entryPrice + stopLossDistance;\r\n\r\n    // Single TP for whale scalping (100% exit)\r\n    const takeProfit =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice * (1 + takeProfitPercent / PERCENT_MULTIPLIER)\r\n        : entryPrice * (1 - takeProfitPercent / PERCENT_MULTIPLIER);\r\n\r\n    let takeProfits: TakeProfit[] = [\r\n      {\r\n        level: 1,\r\n        percent: takeProfitPercent,\r\n        sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Exit full position at TP1\r\n        price: takeProfit,\r\n        hit: false,\r\n      },\r\n    ];\r\n\r\n    this.logger.debug('üéØ Whale Hunter Follow: Single TP mode', {\r\n      mode: whaleSignal.mode,\r\n      tpPercent: `${takeProfitPercent.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n      tpPrice: takeProfit.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    // Apply dynamic TP multiplier based on market conditions\r\n    const dynamicMultiplier = this.calculateDynamicTPMultiplier(orderbookAnalysis, marketData);\r\n    if (dynamicMultiplier > 1.0) {\r\n      takeProfits = takeProfits.map((tp) => {\r\n        const adjustedPercent = tp.percent * dynamicMultiplier;\r\n        const adjustedPrice =\r\n          direction === SignalDirection.LONG\r\n            ? entryPrice * (1 + adjustedPercent / PERCENT_MULTIPLIER)\r\n            : entryPrice * (1 - adjustedPercent / PERCENT_MULTIPLIER);\r\n\r\n        return {\r\n          ...tp,\r\n          percent: adjustedPercent,\r\n          price: adjustedPrice,\r\n        };\r\n      });\r\n\r\n      this.logger.info('üéØ Dynamic TP applied', {\r\n        multiplier: dynamicMultiplier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        adjustedLevels: takeProfits.map(tp => `${tp.percent.toFixed(DECIMAL_PLACES.PERCENT)}%`),\r\n      });\r\n    }\r\n\r\n    const signal = {\r\n      type: SignalType.WHALE_HUNTER_FOLLOW,\r\n      direction,\r\n      price: entryPrice,\r\n      confidence: whaleSignal.confidence / PERCENT_MULTIPLIER, // Convert to 0-1 range\r\n      reason: `üêã WHALE FOLLOW [${whaleSignal.mode}]: ${whaleSignal.reason}`,\r\n      timestamp: Date.now(),\r\n      entryPrice,\r\n      stopLoss,\r\n      takeProfits,\r\n      marketData: {\r\n        rsi: marketData.rsi,\r\n        rsiTrend1: marketData.rsiTrend1,\r\n        ema20: marketData.ema.fast,\r\n        ema50: marketData.ema.slow,\r\n        atr: marketData.atr || 1.0,\r\n        trend: marketData.trend,\r\n        whaleMode: whaleSignal.mode ?? undefined,\r\n        wallSize: orderbookAnalysis.walls.length > 0\r\n          ? Math.max(...orderbookAnalysis.walls.map(w => w.quantity))\r\n          : undefined,\r\n        imbalance: orderbookAnalysis.imbalance.ratio,\r\n        stochastic: marketData.stochastic,\r\n        bollingerBands: marketData.bollingerBands,\r\n        breakoutPrediction: marketData.breakoutPrediction,\r\n      },\r\n    };\r\n\r\n    return {\r\n      valid: true,\r\n      signal,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason: signal.reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate dynamic TP multiplier based on market conditions\r\n   *\r\n   * @param orderbookAnalysis - Current orderbook analysis\r\n   * @param marketData - Market data (for ATR)\r\n   * @returns Combined TP multiplier (1.0 = no adjustment)\r\n   */\r\n  private calculateDynamicTPMultiplier(\r\n    orderbookAnalysis: OrderBookAnalysis,\r\n    marketData: StrategyMarketData,\r\n  ): number {\r\n    // Check if dynamic TP is enabled\r\n    if (!this.config.dynamicTakeProfit?.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    let multiplier = MULTIPLIERS.NEUTRAL;\r\n\r\n    // 1. Wall size-based adjustment\r\n    if (this.config.dynamicTakeProfit.wallSizeBased.enabled) {\r\n      const wallThreshold = this.config.dynamicTakeProfit.wallSizeBased.threshold;\r\n      const wallMultiplier = this.config.dynamicTakeProfit.wallSizeBased.multiplier;\r\n\r\n      // Find largest wall (bid or ask) by percentOfTotal\r\n      const maxWallSize = orderbookAnalysis.walls.length > 0\r\n        ? Math.max(...orderbookAnalysis.walls.map(w => w.percentOfTotal))\r\n        : 0;\r\n\r\n      if (maxWallSize > wallThreshold) {\r\n        multiplier *= wallMultiplier;\r\n        this.logger.debug('üìä Dynamic TP: Wall size triggered', {\r\n          wallSize: maxWallSize.toFixed(1),\r\n          threshold: wallThreshold,\r\n          multiplier: wallMultiplier,\r\n        });\r\n      }\r\n    }\r\n\r\n    // 2. ATR-based adjustment\r\n    if (this.config.dynamicTakeProfit.atrBased.enabled && marketData.atr) {\r\n      const atrThreshold = this.config.dynamicTakeProfit.atrBased.threshold;\r\n      const atrMultiplier = this.config.dynamicTakeProfit.atrBased.multiplier;\r\n\r\n      // Calculate ATR as percentage of current price\r\n      const currentPrice = marketData.candles[marketData.candles.length - 1].close;\r\n      const atrPercent = (marketData.atr / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n      if (atrPercent > atrThreshold) {\r\n        multiplier *= atrMultiplier;\r\n        this.logger.debug('üìä Dynamic TP: ATR volatility triggered', {\r\n          atrPercent: atrPercent.toFixed(DECIMAL_PLACES.PERCENT),\r\n          threshold: atrThreshold,\r\n          multiplier: atrMultiplier,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (multiplier > 1.0) {\r\n      this.logger.info('üéØ Dynamic TP multiplier activated', {\r\n        totalMultiplier: multiplier.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n    }\r\n\r\n    return multiplier;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk/reward ratios based on whale detection mode\r\n   *\r\n   * Different modes have different reliability:\r\n   * - IMBALANCE_SPIKE: Tight SL/TP (quick momentum play)\r\n   * - WALL_BREAK: Medium SL/TP (breakout play)\r\n   * - WALL_DISAPPEARANCE: Wider SL/TP (reversal play)\r\n   */\r\n  private calculateRiskReward(mode: WhaleDetectionMode): {\r\n    stopLossPercent: number;\r\n    takeProfitPercent: number;\r\n  } {\r\n    switch (mode) {\r\n    case WhaleDetectionMode.IMBALANCE_SPIKE:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.HALF, // 0.5% SL (very tight)\r\n        takeProfitPercent: MULTIPLIERS.THREE_QUARTER, // 0.75% TP (quick profit)\r\n      };\r\n\r\n    case WhaleDetectionMode.WALL_BREAK:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.HALF, // 0.8% SL (medium)\r\n        takeProfitPercent: MULTIPLIERS.THREE_QUARTER, // 1.2% TP (medium profit)\r\n      };\r\n\r\n    case WhaleDetectionMode.WALL_DISAPPEARANCE:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.NEUTRAL, // 1.0% SL (wider)\r\n        takeProfitPercent: MULTIPLIERS.ONE_AND_HALF, // 1.5% TP (larger profit)\r\n      };\r\n\r\n    default:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.ZERO_EIGHT,\r\n        takeProfitPercent: MULTIPLIERS.THREE_QUARTER,\r\n      };\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Signal Tracking\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Track consecutive whale signals (same mode)\r\n   */\r\n  private trackConsecutiveSignals(whaleSignal: WhaleSignal): void {\r\n    if (this.lastSignalMode === whaleSignal.mode) {\r\n      this.consecutiveSignals++;\r\n    } else {\r\n      this.consecutiveSignals = 1;\r\n      this.lastSignalMode = whaleSignal.mode;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset consecutive signals counter\r\n   */\r\n  private resetConsecutiveSignals(): void {\r\n    this.consecutiveSignals = 0;\r\n    this.lastSignalMode = null;\r\n  }\r\n\r\n  /**\r\n   * Check if strategy is in cooldown period\r\n   */\r\n  private isInCooldown(): boolean {\r\n    if (this.lastTradeTime === 0) {\r\n      return false;\r\n    }\r\n\r\n    const timeSinceLastTrade = Date.now() - this.lastTradeTime;\r\n    return timeSinceLastTrade < this.config.cooldownMs;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get strategy statistics\r\n   */\r\n  getStats(): {\r\n    name: string;\r\n    enabled: boolean;\r\n    priority: number;\r\n    inCooldown: boolean;\r\n    whaleDetectorStats: ReturnType<WhaleDetectorFollowService['getStats']>;\r\n    } {\r\n    return {\r\n      name: this.name,\r\n      enabled: this.config.enabled,\r\n      priority: this.priority,\r\n      inCooldown: this.isInCooldown(),\r\n      whaleDetectorStats: this.whaleDetector.getStats(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset strategy state (useful for testing)\r\n   */\r\n  reset(): void {\r\n    this.lastTradeTime = 0;\r\n    this.resetConsecutiveSignals();\r\n    this.whaleDetector.clear();\r\n    this.logger.debug('WhaleHunterStrategy reset');\r\n  }\r\n\r\n  /**\r\n   * Return no signal result\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\strategies\\whale-hunter.strategy.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'evaluate' has no 'await' expression.","line":68,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":68,"endColumn":17},{"ruleId":"complexity","severity":1,"message":"Async method 'evaluate' has a complexity of 21. Maximum allowed is 10.","line":68,"column":17,"nodeType":"FunctionExpression","messageId":"complex","endLine":225,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":80,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":80,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2702,2723],"text":"marketData.orderbook == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":173,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":173,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6134,6159],"text":"(this.config.maxAtrPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6134,6159],"text":"(this.config.maxAtrPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6134,6159],"text":"(Boolean(this.config.maxAtrPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":173,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":173,"endColumn":68,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[6163,6193],"text":"((marketData.context?.atrPercent) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[6163,6193],"text":"(!Number.isNaN((marketData.context?.atrPercent)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6163,6193],"text":"(Boolean((marketData.context?.atrPercent)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":202,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":202,"endColumn":39,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7448,7480],"text":"(this.config.blockLongInDowntrend ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7448,7480],"text":"(this.config.blockLongInDowntrend === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"complexity","severity":1,"message":"Method 'generateStrategySignal' has a complexity of 15. Maximum allowed is 10.","line":234,"column":33,"nodeType":"FunctionExpression","messageId":"complex","endLine":400,"endColumn":4},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":261,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":261,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9735,9764],"text":"(this.config.takeProfitPercent != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9735,9764],"text":"(this.config.takeProfitPercent ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9735,9764],"text":"(Boolean(this.config.takeProfitPercent))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":261,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":261,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9765,9767],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":348,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":348,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[12820,12836],"text":"(this.wallTracker != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"max-len","severity":1,"message":"This line has a length of 144. Maximum allowed is 120.","line":354,"column":1,"nodeType":"Program","messageId":"max","endLine":354,"endColumn":145},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":380,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":380,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[14023,14037],"text":"(marketData.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[14023,14037],"text":"(marketData.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[14023,14037],"text":"(Boolean(marketData.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":380,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":380,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[14038,14040],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":414,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":414,"endColumn":48,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[15107,15145],"text":"((this.config.dynamicTakeProfit?.enabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[15106,15145],"text":"(this.config.dynamicTakeProfit?.enabled) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"max-lines","severity":1,"message":"File has too many lines (458). Maximum allowed is 300.","line":428,"column":1,"nodeType":null,"messageId":"exceed","endLine":659,"endColumn":1},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":441,"column":59,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":441,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[16099,16113],"text":"(marketData.atr != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[16099,16113],"text":"(marketData.atr ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[16099,16113],"text":"(Boolean(marketData.atr))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentPrice' is defined but never used. Allowed unused args must match /^_/u.","line":514,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":514,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":516,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":516,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[18702,18719],"text":"this.wallTracker == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":564,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":564,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[20566,20573],"text":"(cluster != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_BOUNDS, DECIMAL_PLACES, FIXED_EXIT_PERCENTAGES, MATH_OPS, MULTIPLIERS, PERCENT_MULTIPLIER, RISK_THRESHOLDS, SIGNAL_CONSTANTS } from '../constants';\r\n/**\r\n * Whale Hunter Strategy\r\n *\r\n * Aggressive strategy that rides with whale movements detected in order book.\r\n *\r\n * Uses WhaleDetectorService with 3 detection modes:\r\n * - IMBALANCE_SPIKE: Highest priority (immediate momentum)\r\n * - WALL_BREAK: Medium priority (breakout momentum)\r\n * - WALL_DISAPPEARANCE: Lowest priority (reversal play)\r\n *\r\n * Risk Management:\r\n * - Small position size (high risk)\r\n * - Tight stop-loss (whales can deceive)\r\n * - Quick take-profit (exit before whale changes mind)\r\n * - Time-based exit (if no movement in 30s)\r\n *\r\n * IMPORTANT: Requires frequent order book updates!\r\n * - WebSocket orderbook stream recommended\r\n * - REST API polling should be < 5 seconds\r\n */\r\n\r\nimport {\r\n  IStrategy,\r\n  StrategySignal,\r\n  StrategyMarketData,\r\n  SignalDirection,\r\n  SignalType,\r\n  LoggerService,\r\n  WhaleHunterConfig,\r\n  TakeProfit,\r\n  OrderBookAnalysis,\r\n  OrderbookLevel,\r\n} from '../types';\r\nimport { WhaleDetectorService, WhaleSignal, WhaleDetectionMode } from '../services/whale-detector.service';\r\nimport { OrderBookAnalyzer } from '../analyzers/orderbook.analyzer';\r\nimport { SessionDetector } from '../utils/session-detector';\r\nimport { WallTrackerService } from '../services/wall-tracker.service';\r\n\r\n// ============================================================================\r\n// WHALE HUNTER STRATEGY\r\n// ============================================================================\r\n\r\nexport class WhaleHunterStrategy implements IStrategy {\r\n  readonly name = 'WHALE_HUNTER';\r\n  readonly priority: number;\r\n\r\n  private lastTradeTime: number = 0;\r\n  private consecutiveSignals: number = 0;\r\n  private lastSignalMode: WhaleDetectionMode | null = null;\r\n\r\n  constructor(\r\n    private config: WhaleHunterConfig,\r\n    private whaleDetector: WhaleDetectorService,\r\n    private orderbookAnalyzer: OrderBookAnalyzer,\r\n    private logger: LoggerService,\r\n    private wallTracker?: WallTrackerService,\r\n  ) {\r\n    this.priority = config.priority;\r\n  }\r\n\r\n  /**\r\n   * Evaluate whale hunter strategy\r\n   *\r\n   * @param marketData - Market data (must include orderbook)\r\n   * @returns Strategy signal\r\n   */\r\n  async evaluate(marketData: StrategyMarketData): Promise<StrategySignal> {\r\n    // Check if strategy is enabled\r\n    if (!this.config.enabled) {\r\n      return this.noSignal('Strategy disabled');\r\n    }\r\n\r\n    // Check cooldown (avoid over-trading)\r\n    if (this.isInCooldown()) {\r\n      return this.noSignal('In cooldown period');\r\n    }\r\n\r\n    // Check if we have order book data\r\n    if (!marketData.orderbook) {\r\n      this.logger.warn('WhaleHunterStrategy: No orderbook data available');\r\n      return this.noSignal('No orderbook data');\r\n    }\r\n\r\n    // Analyze order book\r\n    const currentPrice = marketData.candles[marketData.candles.length - 1].close;\r\n\r\n    // Convert OrderBook to OrderBookData format\r\n    // Handle both tuple format [price, size] and object format {price, size}\r\n    const getPrice = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'price' in level ? level.price : level[0];\r\n    };\r\n    const getSize = (level: OrderbookLevel): number => {\r\n      return typeof level === 'object' && 'size' in level ? level.size : level[1];\r\n    };\r\n\r\n    const bids = marketData.orderbook.bids.map((b: OrderbookLevel) => ({\r\n      price: getPrice(b),\r\n      size: getSize(b),\r\n    }));\r\n\r\n    const asks = marketData.orderbook.asks.map((a: OrderbookLevel) => ({\r\n      price: getPrice(a),\r\n      size: getSize(a),\r\n    }));\r\n\r\n    const orderbookData = {\r\n      bids,\r\n      asks,\r\n      timestamp: marketData.orderbook.timestamp,\r\n    };\r\n\r\n    const orderbookAnalysis = this.orderbookAnalyzer.analyze(orderbookData, currentPrice);\r\n\r\n    // Extract BTC data for trend-aware filtering (if available)\r\n    const btcMomentum = marketData.context?.btcAnalysis?.momentum;\r\n    const btcDirection = marketData.context?.btcAnalysis?.direction;\r\n\r\n    // Detect whale activity (pass BTC data for trend-aware logic)\r\n    const whaleSignal = this.whaleDetector.detectWhale(\r\n      orderbookAnalysis,\r\n      currentPrice,\r\n      btcMomentum,\r\n      btcDirection,\r\n    );\r\n\r\n    // Check if whale detected\r\n    if (!whaleSignal.detected) {\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal('No whale detected');\r\n    }\r\n\r\n    // Check if LONG/SHORT enabled\r\n    if (whaleSignal.direction === SignalDirection.LONG && this.config.enableLong === false) {\r\n      this.logger.info('‚ùå WhaleHunter BLOCKED', {\r\n        blockedBy: ['LONG_DISABLED'],\r\n        reason: 'LONG trades disabled in config',\r\n        direction: 'LONG',\r\n      });\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal('LONG trades disabled');\r\n    }\r\n\r\n    if (whaleSignal.direction === SignalDirection.SHORT && this.config.enableShort === false) {\r\n      this.logger.info('‚ùå WhaleHunter BLOCKED', {\r\n        blockedBy: ['SHORT_DISABLED'],\r\n        reason: 'SHORT trades disabled in config',\r\n        direction: 'SHORT',\r\n      });\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal('SHORT trades disabled');\r\n    }\r\n\r\n    // Check confidence threshold (direction-specific)\r\n    const minConfidenceThreshold =\r\n      whaleSignal.direction === SignalDirection.LONG\r\n        ? this.config.minConfidenceLong ?? this.config.minConfidence\r\n        : this.config.minConfidenceShort ?? this.config.minConfidence;\r\n\r\n    if (whaleSignal.confidence < minConfidenceThreshold) {\r\n      this.logger.debug('WhaleHunterStrategy: Confidence too low', {\r\n        confidence: whaleSignal.confidence,\r\n        threshold: minConfidenceThreshold,\r\n        direction: whaleSignal.direction,\r\n      });\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal(\r\n        `Confidence too low: ${whaleSignal.confidence} < ${minConfidenceThreshold} (${whaleSignal.direction})`,\r\n      );\r\n    }\r\n\r\n    // Check ATR volatility threshold (block signals during extreme volatility)\r\n    if (this.config.maxAtrPercent && marketData.context?.atrPercent) {\r\n      const atrPercent = marketData.context.atrPercent;\r\n      if (atrPercent > this.config.maxAtrPercent) {\r\n        this.logger.info('‚ùå WhaleHunter BLOCKED', {\r\n          blockedBy: ['HIGH_ATR_VOLATILITY'],\r\n          reason: `ATR volatility too high: ${atrPercent.toFixed(DECIMAL_PLACES.PERCENT)}% > ${this.config.maxAtrPercent}%`,\r\n          atrPercent: atrPercent.toFixed(DECIMAL_PLACES.PERCENT),\r\n          threshold: this.config.maxAtrPercent,\r\n          whaleMode: whaleSignal.mode,\r\n        });\r\n        this.resetConsecutiveSignals();\r\n        return this.noSignal(`ATR volatility too high: ${atrPercent.toFixed(DECIMAL_PLACES.PERCENT)}%`);\r\n      }\r\n    }\r\n\r\n    // Track consecutive signals\r\n    this.trackConsecutiveSignals(whaleSignal);\r\n\r\n    // Check if we need multiple signals\r\n    if (this.config.requireMultipleSignals && this.consecutiveSignals < SIGNAL_CONSTANTS.MIN_CONSECUTIVE_SIGNALS) {\r\n      this.logger.debug('WhaleHunterStrategy: Waiting for consecutive signal', {\r\n        current: this.consecutiveSignals,\r\n        required: SIGNAL_CONSTANTS.MIN_CONSECUTIVE_SIGNALS,\r\n      });\r\n      return this.noSignal('Waiting for consecutive signal');\r\n    }\r\n\r\n    // Block LONG trades in downtrend (if enabled)\r\n    if (\r\n      this.config.blockLongInDowntrend &&\r\n      whaleSignal.direction === SignalDirection.LONG &&\r\n      marketData.trend === 'BEARISH'\r\n    ) {\r\n      this.logger.info('‚ùå WhaleHunter BLOCKED', {\r\n        blockedBy: ['LONG_IN_DOWNTREND'],\r\n        reason: 'LONG signal blocked due to downtrend',\r\n        direction: 'LONG',\r\n        trend: marketData.trend,\r\n        whaleMode: whaleSignal.mode,\r\n      });\r\n      this.resetConsecutiveSignals();\r\n      return this.noSignal('LONG blocked in downtrend');\r\n    }\r\n\r\n    // WHALE SIGNAL CONFIRMED - Generate strategy signal\r\n    const strategySignal = this.generateStrategySignal(whaleSignal, marketData, orderbookAnalysis);\r\n\r\n    // Mark trade time for cooldown\r\n    this.lastTradeTime = Date.now();\r\n    this.resetConsecutiveSignals();\r\n\r\n    return strategySignal;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Signal Generation\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Generate strategy signal from whale signal\r\n   */\r\n  private generateStrategySignal(\r\n    whaleSignal: WhaleSignal,\r\n    marketData: StrategyMarketData,\r\n    orderbookAnalysis: OrderBookAnalysis,\r\n  ): StrategySignal {\r\n    const currentCandle = marketData.candles[marketData.candles.length - 1];\r\n    const currentPrice = currentCandle.close;\r\n\r\n    // Calculate risk/reward based on whale mode\r\n    const { stopLossPercent, takeProfitPercent: baseTakeProfitPercent } = this.calculateRiskReward(whaleSignal.mode!);\r\n\r\n    // Determine final TP percent based on config and trend\r\n    let takeProfitPercent = baseTakeProfitPercent;\r\n\r\n    // Use config.takeProfitPercent if set (overrides mode-based values)\r\n    if (this.config.takeProfitPercent !== undefined) {\r\n      takeProfitPercent = this.config.takeProfitPercent;\r\n    }\r\n\r\n    // Use conservative TP for LONG trades in downtrend (if configured)\r\n    if (\r\n      this.config.takeProfitPercentLongDowntrend !== undefined &&\r\n      whaleSignal.direction === SignalDirection.LONG &&\r\n      marketData.trend === 'BEARISH'\r\n    ) {\r\n      takeProfitPercent = this.config.takeProfitPercentLongDowntrend;\r\n      this.logger.info('üéØ Using conservative TP for LONG in downtrend', {\r\n        normalTP: this.config.takeProfitPercent || baseTakeProfitPercent,\r\n        conservativeTP: takeProfitPercent,\r\n        trend: marketData.trend,\r\n      });\r\n    }\r\n\r\n    // Calculate entry, SL prices\r\n    const direction = whaleSignal.direction!;\r\n    const entryPrice = currentPrice;\r\n\r\n    // Calculate base SL distance\r\n    let stopLossDistance = entryPrice * (stopLossPercent / PERCENT_MULTIPLIER);\r\n\r\n    // Apply session-based SL widening if enabled\r\n    stopLossDistance = SessionDetector.applySessionBasedSL(\r\n      stopLossDistance,\r\n      this.config.sessionBasedSL,\r\n      this.logger,\r\n      this.name,\r\n    );\r\n\r\n    const stopLoss =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice - stopLossDistance\r\n        : entryPrice + stopLossDistance;\r\n\r\n    // Single TP for whale scalping (100% exit)\r\n    const takeProfit =\r\n      direction === SignalDirection.LONG\r\n        ? entryPrice * (1 + takeProfitPercent / PERCENT_MULTIPLIER)\r\n        : entryPrice * (1 - takeProfitPercent / PERCENT_MULTIPLIER);\r\n\r\n    let takeProfits: TakeProfit[] = [\r\n      {\r\n        level: 1,\r\n        percent: takeProfitPercent,\r\n        sizePercent: FIXED_EXIT_PERCENTAGES.FULL, // Exit full position at TP1\r\n        price: takeProfit,\r\n        hit: false,\r\n      },\r\n    ];\r\n\r\n    this.logger.debug('üéØ Whale Hunter: Single TP mode', {\r\n      mode: whaleSignal.mode,\r\n      tpPercent: `${takeProfitPercent.toFixed(DECIMAL_PLACES.PERCENT)}%`,\r\n      tpPrice: takeProfit.toFixed(DECIMAL_PLACES.PRICE),\r\n    });\r\n\r\n    // Apply dynamic TP multiplier based on market conditions\r\n    const dynamicMultiplier = this.calculateDynamicTPMultiplier(orderbookAnalysis, marketData);\r\n    if (dynamicMultiplier > 1.0) {\r\n      takeProfits = takeProfits.map((tp) => {\r\n        let adjustedPercent = tp.percent * dynamicMultiplier;\r\n\r\n        // Apply maxTPPercent cap if configured\r\n        if (this.config.dynamicTakeProfit?.maxTPPercent !== undefined) {\r\n          const maxTP = this.config.dynamicTakeProfit.maxTPPercent;\r\n          if (adjustedPercent > maxTP) {\r\n            this.logger.info('‚ö†Ô∏è TP capped by maxTPPercent', {\r\n              originalTP: adjustedPercent.toFixed(DECIMAL_PLACES.PERCENT),\r\n              cappedTP: maxTP.toFixed(DECIMAL_PLACES.PERCENT),\r\n              cap: `${maxTP}%`,\r\n            });\r\n            adjustedPercent = maxTP;\r\n          }\r\n        }\r\n\r\n        const adjustedPrice =\r\n          direction === SignalDirection.LONG\r\n            ? entryPrice * (1 + adjustedPercent / PERCENT_MULTIPLIER)\r\n            : entryPrice * (1 - adjustedPercent / PERCENT_MULTIPLIER);\r\n\r\n        return {\r\n          ...tp,\r\n          percent: adjustedPercent,\r\n          price: adjustedPrice,\r\n        };\r\n      });\r\n\r\n      this.logger.info('üéØ Dynamic TP applied', {\r\n        multiplier: dynamicMultiplier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        adjustedLevels: takeProfits.map(tp => `${tp.percent.toFixed(DECIMAL_PLACES.PERCENT)}%`),\r\n      });\r\n    }\r\n\r\n    // Apply WallTracker confidence adjustments (if available)\r\n    let finalConfidence = whaleSignal.confidence;\r\n    if (this.wallTracker && orderbookAnalysis.walls.length > 0) {\r\n      const confidenceAdjustment = this.applyWallTrackingAdjustment(\r\n        orderbookAnalysis,\r\n        direction,\r\n        currentPrice,\r\n      );\r\n      finalConfidence = Math.max(CONFIDENCE_BOUNDS.MINIMUM, Math.min(CONFIDENCE_BOUNDS.MAXIMUM, whaleSignal.confidence * confidenceAdjustment));\r\n\r\n      if (confidenceAdjustment !== MATH_OPS.ONE) {\r\n        this.logger.info('üß± WallTracker confidence adjustment', {\r\n          original: whaleSignal.confidence,\r\n          adjusted: finalConfidence.toFixed(1),\r\n          multiplier: confidenceAdjustment.toFixed(DECIMAL_PLACES.PERCENT),\r\n        });\r\n      }\r\n    }\r\n\r\n    const signal = {\r\n      type: SignalType.WHALE_HUNTER,\r\n      direction,\r\n      price: entryPrice,\r\n      confidence: finalConfidence / PERCENT_MULTIPLIER, // Convert to 0-1 range\r\n      reason: `üêã WHALE [${whaleSignal.mode}]: ${whaleSignal.reason}`,\r\n      timestamp: Date.now(),\r\n      entryPrice,\r\n      stopLoss,\r\n      takeProfits,\r\n      marketData: {\r\n        rsi: marketData.rsi,\r\n        rsiTrend1: marketData.rsiTrend1,\r\n        ema20: marketData.ema.fast,\r\n        ema50: marketData.ema.slow,\r\n        atr: marketData.atr || 1.0,\r\n        trend: marketData.trend,\r\n        whaleMode: whaleSignal.mode ?? undefined,\r\n        wallSize: orderbookAnalysis.walls.length > 0\r\n          ? Math.max(...orderbookAnalysis.walls.map(w => w.quantity))\r\n          : undefined,\r\n        imbalance: orderbookAnalysis.imbalance.ratio,\r\n        stochastic: marketData.stochastic,\r\n        bollingerBands: marketData.bollingerBands,\r\n        breakoutPrediction: marketData.breakoutPrediction,\r\n      },\r\n    };\r\n\r\n    return {\r\n      valid: true,\r\n      signal,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason: signal.reason,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate dynamic TP multiplier based on market conditions\r\n   *\r\n   * @param orderbookAnalysis - Current orderbook analysis\r\n   * @param marketData - Market data (for ATR)\r\n   * @returns Combined TP multiplier (1.0 = no adjustment)\r\n   */\r\n  private calculateDynamicTPMultiplier(\r\n    orderbookAnalysis: OrderBookAnalysis,\r\n    marketData: StrategyMarketData,\r\n  ): number {\r\n    // Check if dynamic TP is enabled\r\n    if (!this.config.dynamicTakeProfit?.enabled) {\r\n      return 1.0;\r\n    }\r\n\r\n    let multiplier = MULTIPLIERS.NEUTRAL;\r\n\r\n    // 1. Wall size-based adjustment\r\n    if (this.config.dynamicTakeProfit.wallSizeBased.enabled) {\r\n      const wallThreshold = this.config.dynamicTakeProfit.wallSizeBased.threshold;\r\n      const wallMultiplier = this.config.dynamicTakeProfit.wallSizeBased.multiplier;\r\n\r\n      // Find largest wall (bid or ask) by percentOfTotal\r\n      const maxWallSize = orderbookAnalysis.walls.length > 0\r\n        ? Math.max(...orderbookAnalysis.walls.map(w => w.percentOfTotal))\r\n        : 0;\r\n\r\n      if (maxWallSize > wallThreshold) {\r\n        multiplier *= wallMultiplier;\r\n        this.logger.debug('üìä Dynamic TP: Wall size triggered', {\r\n          wallSize: maxWallSize.toFixed(1),\r\n          threshold: wallThreshold,\r\n          multiplier: wallMultiplier,\r\n        });\r\n      }\r\n    }\r\n\r\n    // 2. ATR-based adjustment\r\n    if (this.config.dynamicTakeProfit.atrBased.enabled && marketData.atr) {\r\n      const atrThreshold = this.config.dynamicTakeProfit.atrBased.threshold;\r\n      const atrMultiplier = this.config.dynamicTakeProfit.atrBased.multiplier;\r\n\r\n      // Calculate ATR as percentage of current price\r\n      const currentPrice = marketData.candles[marketData.candles.length - 1].close;\r\n      const atrPercent = (marketData.atr / currentPrice) * PERCENT_MULTIPLIER;\r\n\r\n      if (atrPercent > atrThreshold) {\r\n        multiplier *= atrMultiplier;\r\n        this.logger.debug('üìä Dynamic TP: ATR volatility triggered', {\r\n          atrPercent: atrPercent.toFixed(DECIMAL_PLACES.PERCENT),\r\n          threshold: atrThreshold,\r\n          multiplier: atrMultiplier,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (multiplier > 1.0) {\r\n      this.logger.info('üéØ Dynamic TP multiplier activated', {\r\n        totalMultiplier: multiplier.toFixed(DECIMAL_PLACES.PERCENT),\r\n      });\r\n    }\r\n\r\n    return multiplier;\r\n  }\r\n\r\n  /**\r\n   * Calculate risk/reward ratios based on whale detection mode\r\n   *\r\n   * Different modes have different reliability:\r\n   * - IMBALANCE_SPIKE: Tight SL/TP (quick momentum play)\r\n   * - WALL_BREAK: Medium SL/TP (breakout play)\r\n   * - WALL_DISAPPEARANCE: Wider SL/TP (reversal play)\r\n   */\r\n  private calculateRiskReward(mode: WhaleDetectionMode): {\r\n    stopLossPercent: number;\r\n    takeProfitPercent: number;\r\n  } {\r\n    switch (mode) {\r\n    case WhaleDetectionMode.IMBALANCE_SPIKE:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.HALF, // 0.5% SL (very tight)\r\n        takeProfitPercent: MULTIPLIERS.THREE_QUARTER, // 0.75% TP (quick profit)\r\n      };\r\n\r\n    case WhaleDetectionMode.WALL_BREAK:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.HALF, // 0.8% SL (medium)\r\n        takeProfitPercent: MULTIPLIERS.THREE_QUARTER, // RISK_THRESHOLDS.SL_MODERATE% TP (medium profit)\r\n      };\r\n\r\n    case WhaleDetectionMode.WALL_DISAPPEARANCE:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.NEUTRAL, // 1.0% SL (wider)\r\n        takeProfitPercent: RISK_THRESHOLDS.SL_CONSERVATIVE, // RISK_THRESHOLDS.SL_CONSERVATIVE% TP (larger profit)\r\n      };\r\n\r\n    default:\r\n      return {\r\n        stopLossPercent: MULTIPLIERS.ZERO_EIGHT,\r\n        takeProfitPercent: MULTIPLIERS.THREE_QUARTER,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply WallTracker confidence adjustments\r\n   * Returns multiplier for confidence (e.g., RISK_THRESHOLDS.TP_SCALP = reduce by 70%, 1.3 = boost by 30%)\r\n   */\r\n  private applyWallTrackingAdjustment(\r\n    orderbookAnalysis: OrderBookAnalysis,\r\n    direction: SignalDirection,\r\n    currentPrice: number,\r\n  ): number {\r\n    if (!this.wallTracker) {\r\n      return 1.0;\r\n    }\r\n\r\n    let multiplier = MULTIPLIERS.NEUTRAL;\r\n\r\n    // Find the largest wall in the direction of the trade\r\n    // LONG = look for BID walls (support), SHORT = look for ASK walls (resistance)\r\n    const relevantWalls = orderbookAnalysis.walls.filter((w) =>\r\n      direction === SignalDirection.LONG ? w.side === 'BID' : w.side === 'ASK',\r\n    );\r\n\r\n    if (relevantWalls.length === 0) {\r\n      return 1.0;\r\n    }\r\n\r\n    // Get the largest wall\r\n    const largestWall = relevantWalls.reduce((max, wall) =>\r\n      wall.percentOfTotal > max.percentOfTotal ? wall : max,\r\n    );\r\n\r\n    const side = largestWall.side; // Already 'BID' or 'ASK'\r\n    const wallPrice = largestWall.price;\r\n\r\n    // 1. Filter spoofing - heavily penalize\r\n    if (!this.wallTracker.isWallReal(wallPrice, side)) {\r\n      this.logger.debug('üö´ WallTracker: Spoofing detected', {\r\n        price: wallPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        side,\r\n        adjustment: 'confidence √ó RISK_THRESHOLDS.TP_SCALP',\r\n      });\r\n      return RISK_THRESHOLDS.TP_SCALP; // Reduce confidence by 70%\r\n    }\r\n\r\n    // 2. Boost for strong walls (iceberg, long lifetime)\r\n    const wallStrength = this.wallTracker.getWallStrength(wallPrice, side);\r\n    if (wallStrength > RISK_THRESHOLDS.TP_CONSERVATIVE) {\r\n      multiplier *= MULTIPLIERS.NEUTRAL + wallStrength * RISK_THRESHOLDS.TP_SCALP; // Up to +30% boost\r\n      this.logger.debug('üí™ WallTracker: Strong wall detected', {\r\n        price: wallPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        side,\r\n        strength: wallStrength.toFixed(DECIMAL_PLACES.PERCENT),\r\n        boost: `+${((multiplier - 1.0) * PERCENT_MULTIPLIER).toFixed(0)}%`,\r\n      });\r\n    }\r\n\r\n    // 3. Boost for wall clusters (multiple walls at same level)\r\n    const cluster = this.wallTracker.getClusterAt(wallPrice, side);\r\n    if (cluster && cluster.totalSize > largestWall.quantity * RISK_THRESHOLDS.SL_CONSERVATIVE) {\r\n      multiplier *= RISK_THRESHOLDS.SL_MODERATE; // +20% boost for clusters\r\n      this.logger.debug('üèîÔ∏è WallTracker: Wall cluster detected', {\r\n        price: wallPrice.toFixed(DECIMAL_PLACES.PRICE),\r\n        side,\r\n        clusterSize: cluster.totalSize.toFixed(DECIMAL_PLACES.PERCENT),\r\n        wallCount: cluster.wallCount,\r\n        boost: '+20%',\r\n      });\r\n    }\r\n\r\n    return multiplier;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - Signal Tracking\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Track consecutive whale signals (same mode)\r\n   */\r\n  private trackConsecutiveSignals(whaleSignal: WhaleSignal): void {\r\n    if (this.lastSignalMode === whaleSignal.mode) {\r\n      this.consecutiveSignals++;\r\n    } else {\r\n      this.consecutiveSignals = 1;\r\n      this.lastSignalMode = whaleSignal.mode;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset consecutive signals counter\r\n   */\r\n  private resetConsecutiveSignals(): void {\r\n    this.consecutiveSignals = 0;\r\n    this.lastSignalMode = null;\r\n  }\r\n\r\n  /**\r\n   * Check if strategy is in cooldown period\r\n   */\r\n  private isInCooldown(): boolean {\r\n    if (this.lastTradeTime === 0) {\r\n      return false;\r\n    }\r\n\r\n    const timeSinceLastTrade = Date.now() - this.lastTradeTime;\r\n    return timeSinceLastTrade < this.config.cooldownMs;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // UTILITY METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get strategy statistics\r\n   */\r\n  getStats(): {\r\n    name: string;\r\n    enabled: boolean;\r\n    priority: number;\r\n    inCooldown: boolean;\r\n    whaleDetectorStats: ReturnType<WhaleDetectorService['getStats']>;\r\n    } {\r\n    return {\r\n      name: this.name,\r\n      enabled: this.config.enabled,\r\n      priority: this.priority,\r\n      inCooldown: this.isInCooldown(),\r\n      whaleDetectorStats: this.whaleDetector.getStats(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset strategy state (useful for testing)\r\n   */\r\n  reset(): void {\r\n    this.lastTradeTime = 0;\r\n    this.resetConsecutiveSignals();\r\n    this.whaleDetector.clear();\r\n    this.logger.debug('WhaleHunterStrategy reset');\r\n  }\r\n\r\n  /**\r\n   * Return no signal result\r\n   */\r\n  private noSignal(reason: string): StrategySignal {\r\n    return {\r\n      valid: false,\r\n      strategyName: this.name,\r\n      priority: this.priority,\r\n      reason,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\types\\events.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\compound-interest.helpers.ts","messages":[{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":141,"column":21,"nodeType":"Literal","messageId":"noMagic","endLine":141,"endColumn":24},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":162,"column":25,"nodeType":"Literal","messageId":"noMagic","endLine":162,"endColumn":28},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":183,"column":24,"nodeType":"Literal","messageId":"noMagic","endLine":183,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":218,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":218,"endColumn":33},{"ruleId":"complexity","severity":1,"message":"Function 'validateCompoundConfig' has a complexity of 11. Maximum allowed is 10.","line":254,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":284,"endColumn":2},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":259,"column":70,"nodeType":"Literal","messageId":"noMagic","endLine":259,"endColumn":73},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":263,"column":62,"nodeType":"Literal","messageId":"noMagic","endLine":263,"endColumn":65},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":267,"column":66,"nodeType":"Literal","messageId":"noMagic","endLine":267,"endColumn":69},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 100.","line":279,"column":63,"nodeType":"Literal","messageId":"noMagic","endLine":279,"endColumn":66}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Compound Interest Calculation Helpers\r\n *\r\n * Pure functions for compound interest position sizing calculations.\r\n * No side effects, easy to test.\r\n */\r\n\r\nimport { CompoundInterestConfig } from '../types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface CompoundCalculationResult {\r\n  positionSize: number; // Calculated position size in USDT\r\n  currentBalance: number; // Current account balance\r\n  totalProfit: number; // Total profit (balance - base deposit)\r\n  lockedProfit: number; // Profit that is locked/protected\r\n  availableProfit: number; // Profit available for reinvestment\r\n  reinvestedAmount: number; // Amount being reinvested\r\n  protectionActive: boolean; // True if deposit protection kicked in\r\n  limitApplied: 'none' | 'min' | 'max' | 'risk'; // Which limit was applied\r\n}\r\n\r\n// ============================================================================\r\n// CORE CALCULATIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate compound interest position size\r\n *\r\n * @param currentBalance - Current account balance in USDT\r\n * @param config - Compound interest configuration\r\n * @returns Calculation result with position size and breakdown\r\n */\r\nexport function calculateCompoundPositionSize(\r\n  currentBalance: number,\r\n  config: CompoundInterestConfig,\r\n): CompoundCalculationResult {\r\n  // Validate inputs\r\n  if (currentBalance < 0) {\r\n    throw new Error('Current balance cannot be negative');\r\n  }\r\n\r\n  if (!config.enabled) {\r\n    // If disabled, return min position size\r\n    return {\r\n      positionSize: config.minPositionSize,\r\n      currentBalance,\r\n      totalProfit: 0,\r\n      lockedProfit: 0,\r\n      availableProfit: 0,\r\n      reinvestedAmount: 0,\r\n      protectionActive: false,\r\n      limitApplied: 'none',\r\n    };\r\n  }\r\n\r\n  // Calculate total profit\r\n  const totalProfit = currentBalance - config.baseDeposit;\r\n\r\n  // If no profit or loss, use base position size\r\n  if (totalProfit <= 0) {\r\n    return {\r\n      positionSize: config.minPositionSize,\r\n      currentBalance,\r\n      totalProfit,\r\n      lockedProfit: 0,\r\n      availableProfit: 0,\r\n      reinvestedAmount: 0,\r\n      protectionActive: true, // Protection active (at or below base)\r\n      limitApplied: 'min',\r\n    };\r\n  }\r\n\r\n  // Calculate locked profit (protected)\r\n  const lockedProfit = calculateLockedProfit(totalProfit, config.profitLockPercent);\r\n\r\n  // Calculate available profit for reinvestment\r\n  const availableProfit = totalProfit - lockedProfit;\r\n\r\n  // Calculate reinvestment amount\r\n  const reinvestedAmount = calculateReinvestment(availableProfit, config.reinvestmentPercent);\r\n\r\n  // Calculate base position size with reinvestment\r\n  let positionSize = config.minPositionSize + reinvestedAmount;\r\n\r\n  // Track which limit was applied\r\n  let limitApplied: 'none' | 'min' | 'max' | 'risk' = 'none';\r\n\r\n  // Apply minimum limit\r\n  if (positionSize < config.minPositionSize) {\r\n    positionSize = config.minPositionSize;\r\n    limitApplied = 'min';\r\n  }\r\n\r\n  // Apply maximum limit\r\n  if (positionSize > config.maxPositionSize) {\r\n    positionSize = config.maxPositionSize;\r\n    limitApplied = 'max';\r\n  }\r\n\r\n  // Apply max risk per trade limit\r\n  const maxRiskSize = calculateMaxRiskSize(currentBalance, config.maxRiskPerTrade);\r\n  if (positionSize > maxRiskSize) {\r\n    positionSize = maxRiskSize;\r\n    limitApplied = 'risk';\r\n  }\r\n\r\n  return {\r\n    positionSize,\r\n    currentBalance,\r\n    totalProfit,\r\n    lockedProfit,\r\n    availableProfit,\r\n    reinvestedAmount,\r\n    protectionActive: false,\r\n    limitApplied,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate locked profit amount\r\n *\r\n * @param totalProfit - Total profit in USDT\r\n * @param lockPercent - Percentage to lock (0-100)\r\n * @returns Locked profit amount\r\n */\r\nexport function calculateLockedProfit(totalProfit: number, lockPercent: number): number {\r\n  if (totalProfit <= 0) {\r\n    return 0;\r\n  }\r\n  if (lockPercent < 0) {\r\n    throw new Error('Lock percent cannot be negative');\r\n  }\r\n  if (lockPercent > 100) {\r\n    throw new Error('Lock percent cannot exceed 100');\r\n  }\r\n\r\n  return totalProfit * (lockPercent / PERCENT_MULTIPLIER);\r\n}\r\n\r\n/**\r\n * Calculate reinvestment amount\r\n *\r\n * @param availableProfit - Profit available for reinvestment\r\n * @param reinvestPercent - Percentage to reinvest (0-100)\r\n * @returns Reinvestment amount\r\n */\r\nexport function calculateReinvestment(availableProfit: number, reinvestPercent: number): number {\r\n  if (availableProfit <= 0) {\r\n    return 0;\r\n  }\r\n  if (reinvestPercent < 0) {\r\n    throw new Error('Reinvest percent cannot be negative');\r\n  }\r\n  if (reinvestPercent > 100) {\r\n    throw new Error('Reinvest percent cannot exceed 100');\r\n  }\r\n\r\n  return availableProfit * (reinvestPercent / PERCENT_MULTIPLIER);\r\n}\r\n\r\n/**\r\n * Calculate maximum position size based on risk limit\r\n *\r\n * @param currentBalance - Current balance\r\n * @param maxRiskPercent - Max risk per trade (0-100)\r\n * @returns Maximum allowed position size\r\n */\r\nexport function calculateMaxRiskSize(currentBalance: number, maxRiskPercent: number): number {\r\n  if (currentBalance < 0) {\r\n    throw new Error('Balance cannot be negative');\r\n  }\r\n  if (maxRiskPercent < 0) {\r\n    throw new Error('Max risk percent cannot be negative');\r\n  }\r\n  if (maxRiskPercent > 100) {\r\n    throw new Error('Max risk percent cannot exceed 100');\r\n  }\r\n\r\n  return currentBalance * (maxRiskPercent / PERCENT_MULTIPLIER);\r\n}\r\n\r\n/**\r\n * Check if deposit protection should be active\r\n *\r\n * @param currentBalance - Current balance\r\n * @param baseDeposit - Base deposit (protected amount)\r\n * @param minProfitThreshold - Minimum profit to consider protection inactive (default 0)\r\n * @returns True if protection is active\r\n */\r\nexport function isDepositProtectionActive(\r\n  currentBalance: number,\r\n  baseDeposit: number,\r\n  minProfitThreshold: number = 0,\r\n): boolean {\r\n  const profit = currentBalance - baseDeposit;\r\n  return profit <= minProfitThreshold;\r\n}\r\n\r\n/**\r\n * Calculate compound interest growth over time\r\n *\r\n * @param initialDeposit - Starting deposit\r\n * @param trades - Array of trade PnLs\r\n * @param config - Compound interest config\r\n * @returns Array of balance snapshots after each trade\r\n */\r\nexport function simulateCompoundGrowth(\r\n  initialDeposit: number,\r\n  trades: number[],\r\n  config: CompoundInterestConfig,\r\n): number[] {\r\n  const balances: number[] = [initialDeposit];\r\n  let currentBalance = initialDeposit;\r\n\r\n  for (const tradePnL of trades) {\r\n    currentBalance += tradePnL;\r\n    balances.push(currentBalance);\r\n  }\r\n\r\n  return balances;\r\n}\r\n\r\n/**\r\n * Calculate position size growth factor\r\n *\r\n * @param currentPositionSize - Current position size\r\n * @param minPositionSize - Base/minimum position size\r\n * @returns Growth factor (e.g., 1.5 = CONFIDENCE_THRESHOLDS.MODERATE% larger than base)\r\n */\r\nexport function calculateGrowthFactor(\r\n  currentPositionSize: number,\r\n  minPositionSize: number,\r\n): number {\r\n  if (minPositionSize === 0) {\r\n    return 1;\r\n  }\r\n  return currentPositionSize / minPositionSize;\r\n}\r\n\r\n/**\r\n * Validate compound interest configuration\r\n *\r\n * @param config - Configuration to validate\r\n * @throws Error if configuration is invalid\r\n */\r\nexport function validateCompoundConfig(config: CompoundInterestConfig): void {\r\n  if (config.baseDeposit < 0) {\r\n    throw new Error('Base deposit cannot be negative');\r\n  }\r\n\r\n  if (config.reinvestmentPercent < 0 || config.reinvestmentPercent > 100) {\r\n    throw new Error('Reinvestment percent must be between 0 and 100');\r\n  }\r\n\r\n  if (config.maxRiskPerTrade < 0 || config.maxRiskPerTrade > 100) {\r\n    throw new Error('Max risk per trade must be between 0 and 100');\r\n  }\r\n\r\n  if (config.profitLockPercent < 0 || config.profitLockPercent > 100) {\r\n    throw new Error('Profit lock percent must be between 0 and 100');\r\n  }\r\n\r\n  if (config.minPositionSize < 0) {\r\n    throw new Error('Min position size cannot be negative');\r\n  }\r\n\r\n  if (config.maxPositionSize < config.minPositionSize) {\r\n    throw new Error('Max position size must be >= min position size');\r\n  }\r\n\r\n  if (config.reinvestmentPercent + config.profitLockPercent > 100) {\r\n    throw new Error(\r\n      'Reinvestment + profit lock percentages cannot exceed 100% (some profit must remain unlocked for safety)',\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\confidence.helper.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":111,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":111,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3716,3723],"text":"(weights != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CONFIDENCE_WEIGHTS, MULTIPLIERS, PERCENT_MULTIPLIER } from '../constants';\r\n/**\r\n * Confidence Helper\r\n *\r\n * Centralized utility for confidence calculation and normalization.\r\n * Ensures consistent confidence handling across all strategies.\r\n */\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst MIN_CONFIDENCE = 0.3; // 30%\r\nconst MAX_CONFIDENCE = MULTIPLIERS.NEUTRAL; // PERCENT_MULTIPLIER%\r\n\r\n// ============================================================================\r\n// CONFIDENCE HELPER\r\n// ============================================================================\r\n\r\nexport class ConfidenceHelper {\r\n  /**\r\n   * Normalize confidence to 0.0-1.0 range\r\n   *\r\n   * Takes a raw confidence value (0.0-1.0+) and:\r\n   * 1. Clamps it between MIN_CONFIDENCE and MAX_CONFIDENCE\r\n   * 2. Returns as decimal (0.3 to 1.0)\r\n   *\r\n   * @param rawConfidence - Raw confidence value (0.0 to 1.0+)\r\n   * @returns Normalized confidence (0.3 to 1.0)\r\n   *\r\n   * @example\r\n   * normalize(0.75) // Returns 0.75\r\n   * normalize(0.2)  // Returns 0.3 (clamped to MIN)\r\n   * normalize(1.5)  // Returns 1.0 (clamped to MAX)\r\n   */\r\n  static normalize(rawConfidence: number): number {\r\n    // Clamp to valid range (0.3 to 1.0)\r\n    return Math.max(MIN_CONFIDENCE, Math.min(MAX_CONFIDENCE, rawConfidence));\r\n  }\r\n\r\n  /**\r\n   * Check if confidence meets minimum threshold\r\n   *\r\n   * @param confidence - Confidence value (0.0-1.0)\r\n   * @param threshold - Minimum threshold (0.0-1.0, default CONFIDENCE_WEIGHTS.MODERATE)\r\n   * @returns true if confidence >= threshold\r\n   *\r\n   * @example\r\n   * meetsThreshold(0.75, CONFIDENCE_WEIGHTS.MODERATE) // true\r\n   * meetsThreshold(0.45, CONFIDENCE_WEIGHTS.MODERATE) // false\r\n   */\r\n  static meetsThreshold(confidence: number, threshold: number = CONFIDENCE_WEIGHTS.MODERATE): boolean {\r\n    return confidence >= threshold;\r\n  }\r\n\r\n  /**\r\n   * Get confidence level category\r\n   *\r\n   * @param confidence - Confidence value (0.0-1.0)\r\n   * @returns 'LOW' | 'MEDIUM' | 'HIGH'\r\n   *\r\n   * @example\r\n   * getLevel(0.35) // 'LOW'\r\n   * getLevel(0.65) // 'MEDIUM'\r\n   * getLevel(0.85) // 'HIGH'\r\n   */\r\n  static getLevel(confidence: number): 'LOW' | 'MEDIUM' | 'HIGH' {\r\n    if (confidence < CONFIDENCE_WEIGHTS.MODERATE) {\r\n      return 'LOW';\r\n    }\r\n    if (confidence < CONFIDENCE_WEIGHTS.HIGH) {\r\n      return 'MEDIUM';\r\n    }\r\n    return 'HIGH';\r\n  }\r\n\r\n  /**\r\n   * Format confidence for display\r\n   *\r\n   * @param confidence - Confidence value (0.0-1.0)\r\n   * @param decimals - Number of decimal places (default 1)\r\n   * @returns Formatted string with % sign\r\n   *\r\n   * @example\r\n   * format(0.755) // '75.5%'\r\n   * format(0.75567, 2) // '75.57%'\r\n   */\r\n  static format(confidence: number, decimals: number = 1): string {\r\n    return `${(confidence * PERCENT_MULTIPLIER).toFixed(decimals)}%`;\r\n  }\r\n\r\n  /**\r\n   * Combine multiple confidence scores\r\n   *\r\n   * Useful when a signal has multiple confirmation factors.\r\n   * Uses weighted average if weights provided, otherwise simple average.\r\n   *\r\n   * @param scores - Array of confidence scores (0.0-1.0)\r\n   * @param weights - Optional array of weights (must match scores length)\r\n   * @returns Combined confidence (0.0-1.0)\r\n   *\r\n   * @example\r\n   * combine([CONFIDENCE_WEIGHTS.HIGH, 0.6, 0.7]) // 0.7 (simple average)\r\n   * combine([CONFIDENCE_WEIGHTS.HIGH, 0.6], [2, 1]) // 0.73 (weighted: (CONFIDENCE_WEIGHTS.HIGH*2 + 0.6*1) / 3)\r\n   */\r\n  static combine(scores: number[], weights?: number[]): number {\r\n    if (scores.length === 0) {\r\n      return MIN_CONFIDENCE;\r\n    }\r\n\r\n    if (weights && weights.length === scores.length) {\r\n      // Weighted average\r\n      const totalWeight = weights.reduce((sum, w) => sum + w, 0);\r\n      if (totalWeight === 0) {\r\n        return MIN_CONFIDENCE;\r\n      }\r\n\r\n      const weightedSum = scores.reduce((sum, score, i) => sum + score * weights[i], 0);\r\n      return weightedSum / totalWeight;\r\n    }\r\n\r\n    // Simple average\r\n    const sum = scores.reduce((acc, score) => acc + score, 0);\r\n    return sum / scores.length;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\error-helper.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":37,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":37,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[898,909],"text":"(error.stack != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[898,909],"text":"(error.stack ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[898,909],"text":"(Boolean(error.stack))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Error Helper Utilities\r\n *\r\n * Standardized error handling patterns for unknown error types.\r\n * Replaces repeated boilerplate code across services.\r\n */\r\n\r\nimport { ErrorContext } from '../types';\r\n\r\n/**\r\n * Extract error message from unknown error type\r\n * Handles Error objects, strings, and other types safely\r\n */\r\nexport function extractErrorMessage(error: unknown): string {\r\n  if (error instanceof Error) {\r\n    return error.message;\r\n  }\r\n\r\n  if (typeof error === 'string') {\r\n    return error;\r\n  }\r\n\r\n  if (typeof error === 'object' && error !== null) {\r\n    const err = error as Record<string, unknown>;\r\n    if (typeof err.message === 'string') {\r\n      return err.message;\r\n    }\r\n  }\r\n\r\n  return String(error);\r\n}\r\n\r\n/**\r\n * Extract error stack trace if available\r\n */\r\nexport function extractErrorStack(error: unknown): string | undefined {\r\n  if (error instanceof Error && error.stack) {\r\n    return error.stack;\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Create standardized error context for logging\r\n */\r\nexport function createErrorContext(\r\n  error: unknown,\r\n  context?: Record<string, unknown>,\r\n): ErrorContext {\r\n  return {\r\n    message: extractErrorMessage(error),\r\n    timestamp: Date.now(),\r\n    context,\r\n  };\r\n}\r\n\r\n/**\r\n * Extract error code/name if available\r\n */\r\nexport function extractErrorCode(error: unknown): string | undefined {\r\n  if (error instanceof Error) {\r\n    return error.name;\r\n  }\r\n\r\n  if (typeof error === 'object' && error !== null) {\r\n    const err = error as Record<string, unknown>;\r\n    if (typeof err.code === 'string') {\r\n      return err.code;\r\n    }\r\n    if (typeof err.name === 'string') {\r\n      return err.name;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Type guard: check if value is Error instance\r\n */\r\nexport function isError(value: unknown): value is Error {\r\n  return value instanceof Error;\r\n}\r\n\r\n/**\r\n * Type guard: check if value is ErrorContext\r\n */\r\nexport function isErrorContext(value: unknown): value is ErrorContext {\r\n  if (typeof value !== 'object' || value === null) {\r\n    return false;\r\n  }\r\n\r\n  const ctx = value as Record<string, unknown>;\r\n  return (\r\n    typeof ctx.message === 'string' &&\r\n    typeof ctx.timestamp === 'number'\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\error.utils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":40,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":40,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1150,1161],"text":"(error.stack != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1150,1161],"text":"(error.stack ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1150,1161],"text":"(Boolean(error.stack))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":86,"column":19,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":86,"endColumn":81,"fix":{"range":[2481,2491],"text":""}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\r\n * Error Handling Utilities\r\n *\r\n * Standardized error handling for catch blocks and error logging.\r\n * Converts unknown error types to proper Error objects with type safety.\r\n */\r\n\r\n/**\r\n * Extract error message from unknown error object\r\n * @param error - Unknown error type\r\n * @returns Error message as string\r\n */\r\nexport function getErrorMessage(error: unknown): string {\r\n  if (error instanceof Error) {\r\n    return error.message;\r\n  }\r\n  if (typeof error === 'string') {\r\n    return error;\r\n  }\r\n  if (error === null || error === undefined) {\r\n    return 'Unknown error (null/undefined)';\r\n  }\r\n  // For objects, try to get message property or stringify\r\n  if (typeof error === 'object') {\r\n    const err = error as Record<string, unknown>;\r\n    if (typeof err.message === 'string') {\r\n      return err.message;\r\n    }\r\n    return JSON.stringify(error);\r\n  }\r\n  return String(error);\r\n}\r\n\r\n/**\r\n * Extract stack trace from unknown error object\r\n * @param error - Unknown error type\r\n * @returns Stack trace as string or undefined\r\n */\r\nexport function getErrorStack(error: unknown): string | undefined {\r\n  if (error instanceof Error && error.stack) {\r\n    return error.stack;\r\n  }\r\n  if (typeof error === 'object' && error !== null) {\r\n    const err = error as Record<string, unknown>;\r\n    if (typeof err.stack === 'string') {\r\n      return err.stack;\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Convert unknown error to standard Error object\r\n * @param error - Unknown error type\r\n * @returns Standard Error object\r\n */\r\nexport function normalizeError(error: unknown): Error {\r\n  if (error instanceof Error) {\r\n    return error;\r\n  }\r\n  return new Error(getErrorMessage(error));\r\n}\r\n\r\n/**\r\n * Create standardized error log object for LoggerService\r\n * @param error - Unknown error type\r\n * @returns Object suitable for logger.error()\r\n */\r\nexport function createErrorLogObject(error: unknown): {\r\n  error: unknown;\r\n  errorMessage: string;\r\n  stack?: string;\r\n  errorType?: string;\r\n} {\r\n  const message = getErrorMessage(error);\r\n  const stack = getErrorStack(error);\r\n\r\n  let errorType: string | undefined;\r\n  if (error instanceof Error) {\r\n    errorType = error.constructor.name;\r\n  } else if (typeof error === 'object' && error !== null) {\r\n    const err = error as Record<string, unknown>;\r\n    if (typeof err.code === 'string') {\r\n      errorType = `Error(${err.code})`;\r\n    } else {\r\n      errorType = (error as Record<string, unknown>).constructor?.name as string;\r\n    }\r\n  }\r\n\r\n  return {\r\n    error,\r\n    errorMessage: message,\r\n    stack,\r\n    errorType,\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\lru-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\session-detector.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TIMEZONE_OFFSETS' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":60,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":76},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":39,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":39,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1366,1377],"text":"(currentTime != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1366,1377],"text":"(currentTime ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1366,1377],"text":"(Boolean(currentTime))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 13.","line":43,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":43,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 16.","line":43,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":43,"endColumn":32},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 8.","line":48,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":18},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 16.","line":48,"column":29,"nodeType":"Literal","messageId":"noMagic","endLine":48,"endColumn":31},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 13.","line":53,"column":17,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":19},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 21.","line":53,"column":30,"nodeType":"Literal","messageId":"noMagic","endLine":53,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":130,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":130,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4195,4202],"text":"(config == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":149,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":149,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4718,4724],"text":"logger != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":150,"column":59,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":150,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4787,4799],"text":"(strategyName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4787,4799],"text":"(strategyName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4787,4799],"text":"(Boolean(strategyName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":153,"column":44,"nodeType":"Literal","messageId":"noMagic","endLine":153,"endColumn":45},{"ruleId":"no-magic-numbers","severity":2,"message":"No magic number: 6.","line":154,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":154,"endColumn":53}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DECIMAL_PLACES, MATH_OPS, SESSION_SL_MULTIPLIERS, TIMEZONE_OFFSETS } from '../constants';\r\n/**\r\n * Session Detector Utility\r\n *\r\n * Detects current trading session based on UTC time.\r\n *\r\n * Trading Sessions (UTC):\r\n * - Asian: 00:00-08:00 (Tokyo/Sydney)\r\n * - London: 08:00-16:00 (London open)\r\n * - NY: 13:00-21:00 (New York open)\r\n * - Overlap: 13:00-16:00 (London + NY overlap = highest volatility)\r\n */\r\n\r\nimport { SessionBasedSLConfig, LoggerService } from '../types';\r\n\r\n// ============================================================================\r\n// ENUMS\r\n// ============================================================================\r\n\r\nexport enum TradingSession {\r\n  ASIAN = 'ASIAN',      // 00:00-08:00 UTC\r\n  LONDON = 'LONDON',    // 08:00-16:00 UTC\r\n  NY = 'NY',            // 13:00-21:00 UTC\r\n  OVERLAP = 'OVERLAP',  // 13:00-16:00 UTC (London + NY)\r\n}\r\n\r\n// ============================================================================\r\n// SESSION DETECTOR\r\n// ============================================================================\r\n\r\nexport class SessionDetector {\r\n  /**\r\n   * Get current trading session based on UTC time\r\n   *\r\n   * @param currentTime - Optional timestamp (default: Date.now())\r\n   * @returns Current trading session\r\n   */\r\n  static getCurrentSession(currentTime?: number): TradingSession {\r\n    const now = currentTime ? new Date(currentTime) : new Date();\r\n    const hour = now.getUTCHours();\r\n\r\n    // Overlap: 13:00-16:00 UTC (London + NY = highest volatility)\r\n    if (hour >= 13 && hour < 16) {\r\n      return TradingSession.OVERLAP;\r\n    }\r\n\r\n    // London: 08:00-16:00 UTC\r\n    if (hour >= 8 && hour < 16) {\r\n      return TradingSession.LONDON;\r\n    }\r\n\r\n    // NY: 13:00-21:00 UTC\r\n    if (hour >= 13 && hour < 21) {\r\n      return TradingSession.NY;\r\n    }\r\n\r\n    // Asian: 00:00-08:00 UTC (default for all other hours)\r\n    return TradingSession.ASIAN;\r\n  }\r\n\r\n  /**\r\n   * Get session name (human-readable)\r\n   *\r\n   * @param session - Trading session\r\n   * @returns Session name\r\n   */\r\n  static getSessionName(session: TradingSession): string {\r\n    switch (session) {\r\n    case TradingSession.ASIAN:\r\n      return 'Asian Session (Low Volatility)';\r\n    case TradingSession.LONDON:\r\n      return 'London Session (High Volatility)';\r\n    case TradingSession.NY:\r\n      return 'NY Session (High Volatility)';\r\n    case TradingSession.OVERLAP:\r\n      return 'London/NY Overlap (Very High Volatility)';\r\n    default:\r\n      return 'Unknown Session';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if current time is in a specific session\r\n   *\r\n   * @param session - Session to check\r\n   * @param currentTime - Optional timestamp (default: Date.now())\r\n   * @returns True if in session\r\n   */\r\n  static isInSession(session: TradingSession, currentTime?: number): boolean {\r\n    return this.getCurrentSession(currentTime) === session;\r\n  }\r\n\r\n  /**\r\n   * Get session volatility level (1.0 = normal, >1.0 = high)\r\n   *\r\n   * @param session - Trading session\r\n   * @returns Relative volatility level\r\n   */\r\n  static getSessionVolatility(session: TradingSession): number {\r\n    switch (session) {\r\n    case TradingSession.ASIAN:\r\n      return 1.0; // Normal (low volatility)\r\n    case TradingSession.LONDON:\r\n      return SESSION_SL_MULTIPLIERS.OVERLAP; // High volatility\r\n    case TradingSession.NY:\r\n      return SESSION_SL_MULTIPLIERS.OVERLAP; // High volatility\r\n    case TradingSession.OVERLAP:\r\n      return SESSION_SL_MULTIPLIERS.OVERLAP; // Very high volatility\r\n    default:\r\n      return 1.0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply session-based SL multiplier to stop loss distance\r\n   *\r\n   * @param baseDistance - Base stop loss distance (absolute price distance)\r\n   * @param config - Session-based SL configuration (optional)\r\n   * @param logger - Logger for debug output (optional)\r\n   * @param strategyName - Strategy name for logging (optional)\r\n   * @returns Adjusted stop loss distance\r\n   */\r\n  static applySessionBasedSL(\r\n    baseDistance: number,\r\n    config?: SessionBasedSLConfig,\r\n    logger?: LoggerService,\r\n    strategyName?: string,\r\n  ): number {\r\n    // If config not provided or disabled, return base distance\r\n    if (!config || !config.enabled) {\r\n      return baseDistance;\r\n    }\r\n\r\n    // Get current session\r\n    const currentSession = this.getCurrentSession();\r\n\r\n    // Get multiplier for current session\r\n    const multiplier = this.getSessionMultiplier(currentSession, config);\r\n\r\n    // If multiplier is 1.0, no adjustment needed\r\n    if (multiplier === MATH_OPS.ONE) {\r\n      return baseDistance;\r\n    }\r\n\r\n    // Apply multiplier\r\n    const adjustedDistance = baseDistance * multiplier;\r\n\r\n    // Log if logger provided\r\n    if (logger) {\r\n      logger.debug(`üìç Session-based SL widening applied${strategyName ? ` (${strategyName})` : ''}`, {\r\n        session: currentSession,\r\n        multiplier: multiplier.toFixed(DECIMAL_PLACES.PERCENT),\r\n        baseDistance: baseDistance.toFixed(6),\r\n        adjustedDistance: adjustedDistance.toFixed(6),\r\n      });\r\n    }\r\n\r\n    return adjustedDistance;\r\n  }\r\n\r\n  /**\r\n   * Get session multiplier from config\r\n   *\r\n   * @param session - Trading session\r\n   * @param config - Session-based SL configuration\r\n   * @returns Multiplier for the session\r\n   */\r\n  private static getSessionMultiplier(session: TradingSession, config: SessionBasedSLConfig): number {\r\n    switch (session) {\r\n    case TradingSession.OVERLAP:\r\n      return config.overlapMultiplier;\r\n    case TradingSession.LONDON:\r\n      return config.londonMultiplier;\r\n    case TradingSession.NY:\r\n      return config.nyMultiplier;\r\n    case TradingSession.ASIAN:\r\n      return config.asianMultiplier;\r\n    default:\r\n      return 1.0;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"D:\\src\\Edison\\src\\utils\\timeframe-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"max-len","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
